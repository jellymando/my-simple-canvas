/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./App.jsx":
/*!*****************!*\
  !*** ./App.jsx ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _src__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src */ \"./src/index.tsx\");\n/* harmony import */ var _src__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_src__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction App() {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"App\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_src__WEBPACK_IMPORTED_MODULE_1__.SimpleToolbar, {\n    colors: [\"#000000\", \"red\", \"violet\"]\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_src__WEBPACK_IMPORTED_MODULE_1__.SimpleCanvas, {\n    onDraw: function onDraw(params) {\n      console.log(params);\n    }\n  }));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9BcHAuanN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vQXBwLmpzeD8xODU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFNpbXBsZVRvb2xiYXIsIFNpbXBsZUNhbnZhcyB9IGZyb20gXCIuL3NyY1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwKCkge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJBcHBcIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTaW1wbGVUb29sYmFyLCB7XG4gICAgY29sb3JzOiBbXCIjMDAwMDAwXCIsIFwicmVkXCIsIFwidmlvbGV0XCJdXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTaW1wbGVDYW52YXMsIHtcbiAgICBvbkRyYXc6IGZ1bmN0aW9uIG9uRHJhdyhwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUubG9nKHBhcmFtcyk7XG4gICAgfVxuICB9KSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./App.jsx\n");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./App */ \"./App.jsx\");\n\n\n\nreact_dom__WEBPACK_IMPORTED_MODULE_1__.render( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_App__WEBPACK_IMPORTED_MODULE_2__[\"default\"], null), document.getElementById(\"app\"));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL2luZGV4LmpzPzEyNjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBBcHAgZnJvbSBcIi4vQXBwXCI7XG5SZWFjdERPTS5yZW5kZXIoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFwcCwgbnVsbCksIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYXBwXCIpKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ }),

/***/ "./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/memoize */ \"./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js\");\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\n\nvar isPropValid = /* #__PURE__ */(0,_emotion_memoize__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function (prop) {\n  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111\n  /* o */ && prop.charCodeAt(1) === 110\n  /* n */ && prop.charCodeAt(2) < 91;\n}\n/* Z+1 */);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPropValid);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2Vtb3Rpb24taXMtcHJvcC12YWxpZC5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9pcy1wcm9wLXZhbGlkL2Rpc3QvZW1vdGlvbi1pcy1wcm9wLXZhbGlkLmVzbS5qcz8yYTQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtZW1vaXplIGZyb20gJ0BlbW90aW9uL21lbW9pemUnO1xudmFyIHJlYWN0UHJvcHNSZWdleCA9IC9eKChjaGlsZHJlbnxkYW5nZXJvdXNseVNldElubmVySFRNTHxrZXl8cmVmfGF1dG9Gb2N1c3xkZWZhdWx0VmFsdWV8ZGVmYXVsdENoZWNrZWR8aW5uZXJIVE1MfHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ3xzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmd8dmFsdWVMaW5rfGFiYnJ8YWNjZXB0fGFjY2VwdENoYXJzZXR8YWNjZXNzS2V5fGFjdGlvbnxhbGxvd3xhbGxvd1VzZXJNZWRpYXxhbGxvd1BheW1lbnRSZXF1ZXN0fGFsbG93RnVsbFNjcmVlbnxhbGxvd1RyYW5zcGFyZW5jeXxhbHR8YXN5bmN8YXV0b0NvbXBsZXRlfGF1dG9QbGF5fGNhcHR1cmV8Y2VsbFBhZGRpbmd8Y2VsbFNwYWNpbmd8Y2hhbGxlbmdlfGNoYXJTZXR8Y2hlY2tlZHxjaXRlfGNsYXNzSUR8Y2xhc3NOYW1lfGNvbHN8Y29sU3Bhbnxjb250ZW50fGNvbnRlbnRFZGl0YWJsZXxjb250ZXh0TWVudXxjb250cm9sc3xjb250cm9sc0xpc3R8Y29vcmRzfGNyb3NzT3JpZ2lufGRhdGF8ZGF0ZVRpbWV8ZGVjb2Rpbmd8ZGVmYXVsdHxkZWZlcnxkaXJ8ZGlzYWJsZWR8ZGlzYWJsZVBpY3R1cmVJblBpY3R1cmV8ZG93bmxvYWR8ZHJhZ2dhYmxlfGVuY1R5cGV8ZW50ZXJLZXlIaW50fGZvcm18Zm9ybUFjdGlvbnxmb3JtRW5jVHlwZXxmb3JtTWV0aG9kfGZvcm1Ob1ZhbGlkYXRlfGZvcm1UYXJnZXR8ZnJhbWVCb3JkZXJ8aGVhZGVyc3xoZWlnaHR8aGlkZGVufGhpZ2h8aHJlZnxocmVmTGFuZ3xodG1sRm9yfGh0dHBFcXVpdnxpZHxpbnB1dE1vZGV8aW50ZWdyaXR5fGlzfGtleVBhcmFtc3xrZXlUeXBlfGtpbmR8bGFiZWx8bGFuZ3xsaXN0fGxvYWRpbmd8bG9vcHxsb3d8bWFyZ2luSGVpZ2h0fG1hcmdpbldpZHRofG1heHxtYXhMZW5ndGh8bWVkaWF8bWVkaWFHcm91cHxtZXRob2R8bWlufG1pbkxlbmd0aHxtdWx0aXBsZXxtdXRlZHxuYW1lfG5vbmNlfG5vVmFsaWRhdGV8b3BlbnxvcHRpbXVtfHBhdHRlcm58cGxhY2Vob2xkZXJ8cGxheXNJbmxpbmV8cG9zdGVyfHByZWxvYWR8cHJvZmlsZXxyYWRpb0dyb3VwfHJlYWRPbmx5fHJlZmVycmVyUG9saWN5fHJlbHxyZXF1aXJlZHxyZXZlcnNlZHxyb2xlfHJvd3N8cm93U3BhbnxzYW5kYm94fHNjb3BlfHNjb3BlZHxzY3JvbGxpbmd8c2VhbWxlc3N8c2VsZWN0ZWR8c2hhcGV8c2l6ZXxzaXplc3xzbG90fHNwYW58c3BlbGxDaGVja3xzcmN8c3JjRG9jfHNyY0xhbmd8c3JjU2V0fHN0YXJ0fHN0ZXB8c3R5bGV8c3VtbWFyeXx0YWJJbmRleHx0YXJnZXR8dGl0bGV8dHJhbnNsYXRlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5jcmVtZW50YWx8ZmFsbGJhY2t8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufG9wdGlvbnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3N8YXV0b2ZvY3VzKXwoKFtEZF1bQWFdW1R0XVtBYV18W0FhXVtScl1bSWldW0FhXXx4KS0uKikpJC87IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWJmZWU2OGE0Y2Q3ZTYwMDllZjYxZDIzXG5cbnZhciBpc1Byb3BWYWxpZCA9IC8qICNfX1BVUkVfXyAqL21lbW9pemUoZnVuY3Rpb24gKHByb3ApIHtcbiAgcmV0dXJuIHJlYWN0UHJvcHNSZWdleC50ZXN0KHByb3ApIHx8IHByb3AuY2hhckNvZGVBdCgwKSA9PT0gMTExXG4gIC8qIG8gKi8gJiYgcHJvcC5jaGFyQ29kZUF0KDEpID09PSAxMTBcbiAgLyogbiAqLyAmJiBwcm9wLmNoYXJDb2RlQXQoMikgPCA5MTtcbn1cbi8qIForMSAqLyk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvcFZhbGlkOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js\n");

/***/ }),

/***/ "./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction memoize(fn) {\n  var cache = Object.create(null);\n  return function (arg) {\n    if (cache[arg] === undefined) cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (memoize);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L2Vtb3Rpb24tbWVtb2l6ZS5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9lbW90aW9uLW1lbW9pemUuZXNtLmpzPzY0OGMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChjYWNoZVthcmddID09PSB1bmRlZmluZWQpIGNhY2hlW2FyZ10gPSBmbihhcmcpO1xuICAgIHJldHVybiBjYWNoZVthcmddO1xuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js\n");

/***/ }),

/***/ "./node_modules/@emotion/stylis/dist/stylis.browser.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@emotion/stylis/dist/stylis.browser.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction stylis_min(W) {\n  function M(d, c, e, h, a) {\n    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {\n      g = e.charCodeAt(l);\n      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);\n      if (0 === b + n + v + m) {\n        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {\n          switch (g) {\n            case 32:\n            case 9:\n            case 59:\n            case 13:\n            case 10:\n              break;\n            default:\n              f += e.charAt(l);\n          }\n          g = 59;\n        }\n        switch (g) {\n          case 123:\n            f = f.trim();\n            q = f.charCodeAt(0);\n            k = 1;\n            for (t = ++l; l < B;) {\n              switch (g = e.charCodeAt(l)) {\n                case 123:\n                  k++;\n                  break;\n                case 125:\n                  k--;\n                  break;\n                case 47:\n                  switch (g = e.charCodeAt(l + 1)) {\n                    case 42:\n                    case 47:\n                      a: {\n                        for (u = l + 1; u < J; ++u) {\n                          switch (e.charCodeAt(u)) {\n                            case 47:\n                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {\n                                l = u + 1;\n                                break a;\n                              }\n                              break;\n                            case 10:\n                              if (47 === g) {\n                                l = u + 1;\n                                break a;\n                              }\n                          }\n                        }\n                        l = u;\n                      }\n                  }\n                  break;\n                case 91:\n                  g++;\n                case 40:\n                  g++;\n                case 34:\n                case 39:\n                  for (; l++ < J && e.charCodeAt(l) !== g;) {}\n              }\n              if (0 === k) break;\n              l++;\n            }\n            k = e.substring(t, l);\n            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));\n            switch (q) {\n              case 64:\n                0 < r && (f = f.replace(N, ''));\n                g = f.charCodeAt(1);\n                switch (g) {\n                  case 100:\n                  case 109:\n                  case 115:\n                  case 45:\n                    r = c;\n                    break;\n                  default:\n                    r = O;\n                }\n                k = M(c, r, k, g, a + 1);\n                t = k.length;\n                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));\n                if (0 < t) switch (g) {\n                  case 115:\n                    f = f.replace(da, ea);\n                  case 100:\n                  case 109:\n                  case 45:\n                    k = f + '{' + k + '}';\n                    break;\n                  case 107:\n                    f = f.replace(fa, '$1 $2');\n                    k = f + '{' + k + '}';\n                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;\n                    break;\n                  default:\n                    k = f + k, 112 === h && (k = (p += k, ''));\n                } else k = '';\n                break;\n              default:\n                k = M(c, X(c, f, I), k, h, a + 1);\n            }\n            F += k;\n            k = I = r = u = q = 0;\n            f = '';\n            g = e.charCodeAt(++l);\n            break;\n          case 125:\n          case 59:\n            f = (0 < r ? f.replace(N, '') : f).trim();\n            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\\x00\\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {\n              case 0:\n                break;\n              case 64:\n                if (105 === g || 99 === g) {\n                  G += f + e.charAt(l);\n                  break;\n                }\n              default:\n                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));\n            }\n            I = r = u = q = 0;\n            f = '';\n            g = e.charCodeAt(++l);\n        }\n      }\n      switch (g) {\n        case 13:\n        case 10:\n          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\\x00');\n          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);\n          z = 1;\n          D++;\n          break;\n        case 59:\n        case 125:\n          if (0 === b + n + v + m) {\n            z++;\n            break;\n          }\n        default:\n          z++;\n          y = e.charAt(l);\n          switch (g) {\n            case 9:\n            case 32:\n              if (0 === n + m + b) switch (x) {\n                case 44:\n                case 58:\n                case 9:\n                case 32:\n                  y = '';\n                  break;\n                default:\n                  32 !== g && (y = ' ');\n              }\n              break;\n            case 0:\n              y = '\\\\0';\n              break;\n            case 12:\n              y = '\\\\f';\n              break;\n            case 11:\n              y = '\\\\v';\n              break;\n            case 38:\n              0 === n + b + m && (r = I = 1, y = '\\f' + y);\n              break;\n            case 108:\n              if (0 === n + b + m + E && 0 < u) switch (l - u) {\n                case 2:\n                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);\n                case 8:\n                  111 === K && (E = K);\n              }\n              break;\n            case 58:\n              0 === n + b + m && (u = l);\n              break;\n            case 44:\n              0 === b + v + n + m && (r = 1, y += '\\r');\n              break;\n            case 34:\n            case 39:\n              0 === b && (n = n === g ? 0 : 0 === n ? g : n);\n              break;\n            case 91:\n              0 === n + b + v && m++;\n              break;\n            case 93:\n              0 === n + b + v && m--;\n              break;\n            case 41:\n              0 === n + b + m && v--;\n              break;\n            case 40:\n              if (0 === n + b + m) {\n                if (0 === q) switch (2 * x + 3 * K) {\n                  case 533:\n                    break;\n                  default:\n                    q = 1;\n                }\n                v++;\n              }\n              break;\n            case 64:\n              0 === b + v + n + m + u + k && (k = 1);\n              break;\n            case 42:\n            case 47:\n              if (!(0 < n + m + v)) switch (b) {\n                case 0:\n                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {\n                    case 235:\n                      b = 47;\n                      break;\n                    case 220:\n                      t = l, b = 42;\n                  }\n                  break;\n                case 42:\n                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);\n              }\n          }\n          0 === b && (f += y);\n      }\n      K = x;\n      x = g;\n      l++;\n    }\n    t = p.length;\n    if (0 < t) {\n      r = c;\n      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;\n      p = r.join(',') + '{' + p + '}';\n      if (0 !== w * E) {\n        2 !== w || L(p, 2) || (E = 0);\n        switch (E) {\n          case 111:\n            p = p.replace(ha, ':-moz-$1') + p;\n            break;\n          case 112:\n            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;\n        }\n        E = 0;\n      }\n    }\n    return G + p + F;\n  }\n  function X(d, c, e) {\n    var h = c.trim().split(ia);\n    c = h;\n    var a = h.length,\n      m = d.length;\n    switch (m) {\n      case 0:\n      case 1:\n        var b = 0;\n        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {\n          c[b] = Z(d, c[b], e).trim();\n        }\n        break;\n      default:\n        var v = b = 0;\n        for (c = []; b < a; ++b) {\n          for (var n = 0; n < m; ++n) {\n            c[v++] = Z(d[n] + ' ', h[b], e).trim();\n          }\n        }\n    }\n    return c;\n  }\n  function Z(d, c, e) {\n    var h = c.charCodeAt(0);\n    33 > h && (h = (c = c.trim()).charCodeAt(0));\n    switch (h) {\n      case 38:\n        return c.replace(F, '$1' + d.trim());\n      case 58:\n        return d.trim() + c.replace(F, '$1' + d.trim());\n      default:\n        if (0 < 1 * e && 0 < c.indexOf('\\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());\n    }\n    return d + c;\n  }\n  function P(d, c, e, h) {\n    var a = d + ';',\n      m = 2 * c + 3 * e + 4 * h;\n    if (944 === m) {\n      d = a.indexOf(':', 9) + 1;\n      var b = a.substring(d, a.length - 1).trim();\n      b = a.substring(0, d).trim() + b + ';';\n      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;\n    }\n    if (0 === w || 2 === w && !L(a, 1)) return a;\n    switch (m) {\n      case 1015:\n        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;\n      case 951:\n        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;\n      case 963:\n        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;\n      case 1009:\n        if (100 !== a.charCodeAt(4)) break;\n      case 969:\n      case 942:\n        return '-webkit-' + a + a;\n      case 978:\n        return '-webkit-' + a + '-moz-' + a + a;\n      case 1019:\n      case 983:\n        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;\n      case 883:\n        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;\n        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;\n        break;\n      case 932:\n        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {\n          case 103:\n            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;\n          case 115:\n            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;\n          case 98:\n            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;\n        }\n        return '-webkit-' + a + '-ms-' + a + a;\n      case 964:\n        return '-webkit-' + a + '-ms-flex-' + a + a;\n      case 1023:\n        if (99 !== a.charCodeAt(8)) break;\n        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');\n        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;\n      case 1005:\n        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;\n      case 1e3:\n        b = a.substring(13).trim();\n        c = b.indexOf('-') + 1;\n        switch (b.charCodeAt(0) + b.charCodeAt(c)) {\n          case 226:\n            b = a.replace(G, 'tb');\n            break;\n          case 232:\n            b = a.replace(G, 'tb-rl');\n            break;\n          case 220:\n            b = a.replace(G, 'lr');\n            break;\n          default:\n            return a;\n        }\n        return '-webkit-' + a + '-ms-' + b + a;\n      case 1017:\n        if (-1 === a.indexOf('sticky', 9)) break;\n      case 975:\n        c = (a = d).length - 10;\n        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();\n        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {\n          case 203:\n            if (111 > b.charCodeAt(8)) break;\n          case 115:\n            a = a.replace(b, '-webkit-' + b) + ';' + a;\n            break;\n          case 207:\n          case 102:\n            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;\n        }\n        return a + ';';\n      case 938:\n        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {\n          case 105:\n            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;\n          case 115:\n            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;\n          default:\n            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;\n        }\n        break;\n      case 973:\n      case 989:\n        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;\n      case 931:\n      case 953:\n        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;\n        break;\n      case 962:\n        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;\n    }\n    return a;\n  }\n  function L(d, c) {\n    var e = d.indexOf(1 === c ? ':' : '{'),\n      h = d.substring(0, 3 !== c ? e : 10);\n    e = d.substring(e + 1, d.length - 1);\n    return R(2 !== c ? h : h.replace(na, '$1'), e, c);\n  }\n  function ea(d, c) {\n    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));\n    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';\n  }\n  function H(d, c, e, h, a, m, b, v, n, q) {\n    for (var g = 0, x = c, w; g < A; ++g) {\n      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {\n        case void 0:\n        case !1:\n        case !0:\n        case null:\n          break;\n        default:\n          x = w;\n      }\n    }\n    if (x !== c) return x;\n  }\n  function T(d) {\n    switch (d) {\n      case void 0:\n      case null:\n        A = S.length = 0;\n        break;\n      default:\n        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {\n          T(d[c]);\n        } else Y = !!d | 0;\n    }\n    return T;\n  }\n  function U(d) {\n    d = d.prefix;\n    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);\n    return U;\n  }\n  function B(d, c) {\n    var e = d;\n    33 > e.charCodeAt(0) && (e = e.trim());\n    V = e;\n    e = [V];\n    if (0 < A) {\n      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);\n      void 0 !== h && 'string' === typeof h && (c = h);\n    }\n    var a = M(O, e, c, 0, 0);\n    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));\n    V = '';\n    E = 0;\n    z = D = 1;\n    return a;\n  }\n  var ca = /^\\0+/g,\n    N = /[\\0\\r\\f]/g,\n    aa = /: */g,\n    ka = /zoo|gra/,\n    ma = /([,: ])(transform)/g,\n    ia = /,\\r+?/g,\n    F = /([\\t\\r\\n ])*\\f?&/g,\n    fa = /@(k\\w+)\\s*(\\S*)\\s*/,\n    Q = /::(place)/g,\n    ha = /:(read-only)/g,\n    G = /[svh]\\w+-[tblr]{2}/,\n    da = /\\(\\s*(.*)\\s*\\)/g,\n    oa = /([\\s\\S]*?);/g,\n    ba = /-self|flex-/g,\n    na = /[^]*?(:[rp][el]a[\\w-]+)[^]*/,\n    la = /stretch|:\\s*\\w+\\-(?:conte|avail)/,\n    ja = /([^-])(image-set\\()/,\n    z = 1,\n    D = 1,\n    E = 0,\n    w = 1,\n    O = [],\n    S = [],\n    A = 0,\n    R = null,\n    Y = 0,\n    V = '';\n  B.use = T;\n  B.set = U;\n  void 0 !== W && U(W);\n  return B;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stylis_min);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vc3R5bGlzL2Rpc3Qvc3R5bGlzLmJyb3dzZXIuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3N0eWxpcy9kaXN0L3N0eWxpcy5icm93c2VyLmVzbS5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHN0eWxpc19taW4oVykge1xuICBmdW5jdGlvbiBNKGQsIGMsIGUsIGgsIGEpIHtcbiAgICBmb3IgKHZhciBtID0gMCwgYiA9IDAsIHYgPSAwLCBuID0gMCwgcSwgZywgeCA9IDAsIEsgPSAwLCBrLCB1ID0gayA9IHEgPSAwLCBsID0gMCwgciA9IDAsIEkgPSAwLCB0ID0gMCwgQiA9IGUubGVuZ3RoLCBKID0gQiAtIDEsIHksIGYgPSAnJywgcCA9ICcnLCBGID0gJycsIEcgPSAnJywgQzsgbCA8IEI7KSB7XG4gICAgICBnID0gZS5jaGFyQ29kZUF0KGwpO1xuICAgICAgbCA9PT0gSiAmJiAwICE9PSBiICsgbiArIHYgKyBtICYmICgwICE9PSBiICYmIChnID0gNDcgPT09IGIgPyAxMCA6IDQ3KSwgbiA9IHYgPSBtID0gMCwgQisrLCBKKyspO1xuICAgICAgaWYgKDAgPT09IGIgKyBuICsgdiArIG0pIHtcbiAgICAgICAgaWYgKGwgPT09IEogJiYgKDAgPCByICYmIChmID0gZi5yZXBsYWNlKE4sICcnKSksIDAgPCBmLnRyaW0oKS5sZW5ndGgpKSB7XG4gICAgICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGYgKz0gZS5jaGFyQXQobCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGcgPSA1OTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgIGYgPSBmLnRyaW0oKTtcbiAgICAgICAgICAgIHEgPSBmLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBrID0gMTtcbiAgICAgICAgICAgIGZvciAodCA9ICsrbDsgbCA8IEI7KSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZyA9IGUuY2hhckNvZGVBdChsKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChnID0gZS5jaGFyQ29kZUF0KGwgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodSA9IGwgKyAxOyB1IDwgSjsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5jaGFyQ29kZUF0KHUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICg0MiA9PT0gZyAmJiA0MiA9PT0gZS5jaGFyQ29kZUF0KHUgLSAxKSAmJiBsICsgMiAhPT0gdSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gdSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDQ3ID09PSBnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgICAgIGcrKztcbiAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgZysrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBsKysgPCBKICYmIGUuY2hhckNvZGVBdChsKSAhPT0gZzspIHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDAgPT09IGspIGJyZWFrO1xuICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrID0gZS5zdWJzdHJpbmcodCwgbCk7XG4gICAgICAgICAgICAwID09PSBxICYmIChxID0gKGYgPSBmLnJlcGxhY2UoY2EsICcnKS50cmltKCkpLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgc3dpdGNoIChxKSB7XG4gICAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgICAgMCA8IHIgJiYgKGYgPSBmLnJlcGxhY2UoTiwgJycpKTtcbiAgICAgICAgICAgICAgICBnID0gZi5jaGFyQ29kZUF0KDEpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgICAgICAgciA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgciA9IE87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgPSBNKGMsIHIsIGssIGcsIGEgKyAxKTtcbiAgICAgICAgICAgICAgICB0ID0gay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgMCA8IEEgJiYgKHIgPSBYKE8sIGYsIEkpLCBDID0gSCgzLCBrLCByLCBjLCBELCB6LCB0LCBnLCBhLCBoKSwgZiA9IHIuam9pbignJyksIHZvaWQgMCAhPT0gQyAmJiAwID09PSAodCA9IChrID0gQy50cmltKCkpLmxlbmd0aCkgJiYgKGcgPSAwLCBrID0gJycpKTtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IHQpIHN3aXRjaCAoZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLnJlcGxhY2UoZGEsIGVhKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgICAgICBrID0gZiArICd7JyArIGsgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLnJlcGxhY2UoZmEsICckMSAkMicpO1xuICAgICAgICAgICAgICAgICAgICBrID0gZiArICd7JyArIGsgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAxID09PSB3IHx8IDIgPT09IHcgJiYgTCgnQCcgKyBrLCAzKSA/ICdALXdlYmtpdC0nICsgayArICdAJyArIGsgOiAnQCcgKyBrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGsgPSBmICsgaywgMTEyID09PSBoICYmIChrID0gKHAgKz0gaywgJycpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgayA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGsgPSBNKGMsIFgoYywgZiwgSSksIGssIGgsIGEgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEYgKz0gaztcbiAgICAgICAgICAgIGsgPSBJID0gciA9IHUgPSBxID0gMDtcbiAgICAgICAgICAgIGYgPSAnJztcbiAgICAgICAgICAgIGcgPSBlLmNoYXJDb2RlQXQoKytsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICBmID0gKDAgPCByID8gZi5yZXBsYWNlKE4sICcnKSA6IGYpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICgxIDwgKHQgPSBmLmxlbmd0aCkpIHN3aXRjaCAoMCA9PT0gdSAmJiAocSA9IGYuY2hhckNvZGVBdCgwKSwgNDUgPT09IHEgfHwgOTYgPCBxICYmIDEyMyA+IHEpICYmICh0ID0gKGYgPSBmLnJlcGxhY2UoJyAnLCAnOicpKS5sZW5ndGgpLCAwIDwgQSAmJiB2b2lkIDAgIT09IChDID0gSCgxLCBmLCBjLCBkLCBELCB6LCBwLmxlbmd0aCwgaCwgYSwgaCkpICYmIDAgPT09ICh0ID0gKGYgPSBDLnRyaW0oKSkubGVuZ3RoKSAmJiAoZiA9ICdcXHgwMFxceDAwJyksIHEgPSBmLmNoYXJDb2RlQXQoMCksIGcgPSBmLmNoYXJDb2RlQXQoMSksIHEpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAgIGlmICgxMDUgPT09IGcgfHwgOTkgPT09IGcpIHtcbiAgICAgICAgICAgICAgICAgIEcgKz0gZiArIGUuY2hhckF0KGwpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIDU4ICE9PSBmLmNoYXJDb2RlQXQodCAtIDEpICYmIChwICs9IFAoZiwgcSwgZywgZi5jaGFyQ29kZUF0KDIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJID0gciA9IHUgPSBxID0gMDtcbiAgICAgICAgICAgIGYgPSAnJztcbiAgICAgICAgICAgIGcgPSBlLmNoYXJDb2RlQXQoKytsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgNDcgPT09IGIgPyBiID0gMCA6IDAgPT09IDEgKyBxICYmIDEwNyAhPT0gaCAmJiAwIDwgZi5sZW5ndGggJiYgKHIgPSAxLCBmICs9ICdcXHgwMCcpO1xuICAgICAgICAgIDAgPCBBICogWSAmJiBIKDAsIGYsIGMsIGQsIEQsIHosIHAubGVuZ3RoLCBoLCBhLCBoKTtcbiAgICAgICAgICB6ID0gMTtcbiAgICAgICAgICBEKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTk6XG4gICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIGlmICgwID09PSBiICsgbiArIHYgKyBtKSB7XG4gICAgICAgICAgICB6Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeisrO1xuICAgICAgICAgIHkgPSBlLmNoYXJBdChsKTtcbiAgICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIGlmICgwID09PSBuICsgbSArIGIpIHN3aXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgIHkgPSAnJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAzMiAhPT0gZyAmJiAoeSA9ICcgJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHkgPSAnXFxcXDAnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHkgPSAnXFxcXGYnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIHkgPSAnXFxcXHYnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgbSAmJiAociA9IEkgPSAxLCB5ID0gJ1xcZicgKyB5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IG4gKyBiICsgbSArIEUgJiYgMCA8IHUpIHN3aXRjaCAobCAtIHUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAxMTIgPT09IHggJiYgNTggPT09IGUuY2hhckNvZGVBdChsIC0gMykgJiYgKEUgPSB4KTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAxMTEgPT09IEsgJiYgKEUgPSBLKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgbSAmJiAodSA9IGwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgIDAgPT09IGIgKyB2ICsgbiArIG0gJiYgKHIgPSAxLCB5ICs9ICdcXHInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgMCA9PT0gYiAmJiAobiA9IG4gPT09IGcgPyAwIDogMCA9PT0gbiA/IGcgOiBuKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIHYgJiYgbSsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTM6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgdiAmJiBtLS07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyBtICYmIHYtLTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICBpZiAoMCA9PT0gbiArIGIgKyBtKSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHEpIHN3aXRjaCAoMiAqIHggKyAzICogSykge1xuICAgICAgICAgICAgICAgICAgY2FzZSA1MzM6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHYrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgIDAgPT09IGIgKyB2ICsgbiArIG0gKyB1ICsgayAmJiAoayA9IDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICBpZiAoISgwIDwgbiArIG0gKyB2KSkgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgc3dpdGNoICgyICogZyArIDMgKiBlLmNoYXJDb2RlQXQobCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM1OlxuICAgICAgICAgICAgICAgICAgICAgIGIgPSA0NztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjA6XG4gICAgICAgICAgICAgICAgICAgICAgdCA9IGwsIGIgPSA0MjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgICA0NyA9PT0gZyAmJiA0MiA9PT0geCAmJiB0ICsgMiAhPT0gbCAmJiAoMzMgPT09IGUuY2hhckNvZGVBdCh0ICsgMikgJiYgKHAgKz0gZS5zdWJzdHJpbmcodCwgbCArIDEpKSwgeSA9ICcnLCBiID0gMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgMCA9PT0gYiAmJiAoZiArPSB5KTtcbiAgICAgIH1cbiAgICAgIEsgPSB4O1xuICAgICAgeCA9IGc7XG4gICAgICBsKys7XG4gICAgfVxuICAgIHQgPSBwLmxlbmd0aDtcbiAgICBpZiAoMCA8IHQpIHtcbiAgICAgIHIgPSBjO1xuICAgICAgaWYgKDAgPCBBICYmIChDID0gSCgyLCBwLCByLCBkLCBELCB6LCB0LCBoLCBhLCBoKSwgdm9pZCAwICE9PSBDICYmIDAgPT09IChwID0gQykubGVuZ3RoKSkgcmV0dXJuIEcgKyBwICsgRjtcbiAgICAgIHAgPSByLmpvaW4oJywnKSArICd7JyArIHAgKyAnfSc7XG4gICAgICBpZiAoMCAhPT0gdyAqIEUpIHtcbiAgICAgICAgMiAhPT0gdyB8fCBMKHAsIDIpIHx8IChFID0gMCk7XG4gICAgICAgIHN3aXRjaCAoRSkge1xuICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgcCA9IHAucmVwbGFjZShoYSwgJzotbW96LSQxJykgKyBwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgICBwID0gcC5yZXBsYWNlKFEsICc6Oi13ZWJraXQtaW5wdXQtJDEnKSArIHAucmVwbGFjZShRLCAnOjotbW96LSQxJykgKyBwLnJlcGxhY2UoUSwgJzotbXMtaW5wdXQtJDEnKSArIHA7XG4gICAgICAgIH1cbiAgICAgICAgRSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBHICsgcCArIEY7XG4gIH1cbiAgZnVuY3Rpb24gWChkLCBjLCBlKSB7XG4gICAgdmFyIGggPSBjLnRyaW0oKS5zcGxpdChpYSk7XG4gICAgYyA9IGg7XG4gICAgdmFyIGEgPSBoLmxlbmd0aCxcbiAgICAgIG0gPSBkLmxlbmd0aDtcbiAgICBzd2l0Y2ggKG0pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdmFyIGIgPSAwO1xuICAgICAgICBmb3IgKGQgPSAwID09PSBtID8gJycgOiBkWzBdICsgJyAnOyBiIDwgYTsgKytiKSB7XG4gICAgICAgICAgY1tiXSA9IFooZCwgY1tiXSwgZSkudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHYgPSBiID0gMDtcbiAgICAgICAgZm9yIChjID0gW107IGIgPCBhOyArK2IpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG07ICsrbikge1xuICAgICAgICAgICAgY1t2KytdID0gWihkW25dICsgJyAnLCBoW2JdLCBlKS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9XG4gIGZ1bmN0aW9uIFooZCwgYywgZSkge1xuICAgIHZhciBoID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIDMzID4gaCAmJiAoaCA9IChjID0gYy50cmltKCkpLmNoYXJDb2RlQXQoMCkpO1xuICAgIHN3aXRjaCAoaCkge1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgcmV0dXJuIGMucmVwbGFjZShGLCAnJDEnICsgZC50cmltKCkpO1xuICAgICAgY2FzZSA1ODpcbiAgICAgICAgcmV0dXJuIGQudHJpbSgpICsgYy5yZXBsYWNlKEYsICckMScgKyBkLnRyaW0oKSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoMCA8IDEgKiBlICYmIDAgPCBjLmluZGV4T2YoJ1xcZicpKSByZXR1cm4gYy5yZXBsYWNlKEYsICg1OCA9PT0gZC5jaGFyQ29kZUF0KDApID8gJycgOiAnJDEnKSArIGQudHJpbSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGQgKyBjO1xuICB9XG4gIGZ1bmN0aW9uIFAoZCwgYywgZSwgaCkge1xuICAgIHZhciBhID0gZCArICc7JyxcbiAgICAgIG0gPSAyICogYyArIDMgKiBlICsgNCAqIGg7XG4gICAgaWYgKDk0NCA9PT0gbSkge1xuICAgICAgZCA9IGEuaW5kZXhPZignOicsIDkpICsgMTtcbiAgICAgIHZhciBiID0gYS5zdWJzdHJpbmcoZCwgYS5sZW5ndGggLSAxKS50cmltKCk7XG4gICAgICBiID0gYS5zdWJzdHJpbmcoMCwgZCkudHJpbSgpICsgYiArICc7JztcbiAgICAgIHJldHVybiAxID09PSB3IHx8IDIgPT09IHcgJiYgTChiLCAxKSA/ICctd2Via2l0LScgKyBiICsgYiA6IGI7XG4gICAgfVxuICAgIGlmICgwID09PSB3IHx8IDIgPT09IHcgJiYgIUwoYSwgMSkpIHJldHVybiBhO1xuICAgIHN3aXRjaCAobSkge1xuICAgICAgY2FzZSAxMDE1OlxuICAgICAgICByZXR1cm4gOTcgPT09IGEuY2hhckNvZGVBdCgxMCkgPyAnLXdlYmtpdC0nICsgYSArIGEgOiBhO1xuICAgICAgY2FzZSA5NTE6XG4gICAgICAgIHJldHVybiAxMTYgPT09IGEuY2hhckNvZGVBdCgzKSA/ICctd2Via2l0LScgKyBhICsgYSA6IGE7XG4gICAgICBjYXNlIDk2MzpcbiAgICAgICAgcmV0dXJuIDExMCA9PT0gYS5jaGFyQ29kZUF0KDUpID8gJy13ZWJraXQtJyArIGEgKyBhIDogYTtcbiAgICAgIGNhc2UgMTAwOTpcbiAgICAgICAgaWYgKDEwMCAhPT0gYS5jaGFyQ29kZUF0KDQpKSBicmVhaztcbiAgICAgIGNhc2UgOTY5OlxuICAgICAgY2FzZSA5NDI6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArIGE7XG4gICAgICBjYXNlIDk3ODpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tb3otJyArIGEgKyBhO1xuICAgICAgY2FzZSAxMDE5OlxuICAgICAgY2FzZSA5ODM6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbW96LScgKyBhICsgJy1tcy0nICsgYSArIGE7XG4gICAgICBjYXNlIDg4MzpcbiAgICAgICAgaWYgKDQ1ID09PSBhLmNoYXJDb2RlQXQoOCkpIHJldHVybiAnLXdlYmtpdC0nICsgYSArIGE7XG4gICAgICAgIGlmICgwIDwgYS5pbmRleE9mKCdpbWFnZS1zZXQoJywgMTEpKSByZXR1cm4gYS5yZXBsYWNlKGphLCAnJDEtd2Via2l0LSQyJykgKyBhO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTMyOlxuICAgICAgICBpZiAoNDUgPT09IGEuY2hhckNvZGVBdCg0KSkgc3dpdGNoIChhLmNoYXJDb2RlQXQoNSkpIHtcbiAgICAgICAgICBjYXNlIDEwMzpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC1ib3gtJyArIGEucmVwbGFjZSgnLWdyb3cnLCAnJykgKyAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEucmVwbGFjZSgnZ3JvdycsICdwb3NpdGl2ZScpICsgYTtcbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEucmVwbGFjZSgnc2hyaW5rJywgJ25lZ2F0aXZlJykgKyBhO1xuICAgICAgICAgIGNhc2UgOTg6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBhLnJlcGxhY2UoJ2Jhc2lzJywgJ3ByZWZlcnJlZC1zaXplJykgKyBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEgKyBhO1xuICAgICAgY2FzZSA5NjQ6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC0nICsgYSArIGE7XG4gICAgICBjYXNlIDEwMjM6XG4gICAgICAgIGlmICg5OSAhPT0gYS5jaGFyQ29kZUF0KDgpKSBicmVhaztcbiAgICAgICAgYiA9IGEuc3Vic3RyaW5nKGEuaW5kZXhPZignOicsIDE1KSkucmVwbGFjZSgnZmxleC0nLCAnJykucmVwbGFjZSgnc3BhY2UtYmV0d2VlbicsICdqdXN0aWZ5Jyk7XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC1ib3gtcGFjaycgKyBiICsgJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtcGFjaycgKyBiICsgYTtcbiAgICAgIGNhc2UgMTAwNTpcbiAgICAgICAgcmV0dXJuIGthLnRlc3QoYSkgPyBhLnJlcGxhY2UoYWEsICc6LXdlYmtpdC0nKSArIGEucmVwbGFjZShhYSwgJzotbW96LScpICsgYSA6IGE7XG4gICAgICBjYXNlIDFlMzpcbiAgICAgICAgYiA9IGEuc3Vic3RyaW5nKDEzKS50cmltKCk7XG4gICAgICAgIGMgPSBiLmluZGV4T2YoJy0nKSArIDE7XG4gICAgICAgIHN3aXRjaCAoYi5jaGFyQ29kZUF0KDApICsgYi5jaGFyQ29kZUF0KGMpKSB7XG4gICAgICAgICAgY2FzZSAyMjY6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKEcsICd0YicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyMzI6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKEcsICd0Yi1ybCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyMjA6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKEcsICdscicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGIgKyBhO1xuICAgICAgY2FzZSAxMDE3OlxuICAgICAgICBpZiAoLTEgPT09IGEuaW5kZXhPZignc3RpY2t5JywgOSkpIGJyZWFrO1xuICAgICAgY2FzZSA5NzU6XG4gICAgICAgIGMgPSAoYSA9IGQpLmxlbmd0aCAtIDEwO1xuICAgICAgICBiID0gKDMzID09PSBhLmNoYXJDb2RlQXQoYykgPyBhLnN1YnN0cmluZygwLCBjKSA6IGEpLnN1YnN0cmluZyhkLmluZGV4T2YoJzonLCA3KSArIDEpLnRyaW0oKTtcbiAgICAgICAgc3dpdGNoIChtID0gYi5jaGFyQ29kZUF0KDApICsgKGIuY2hhckNvZGVBdCg3KSB8IDApKSB7XG4gICAgICAgICAgY2FzZSAyMDM6XG4gICAgICAgICAgICBpZiAoMTExID4gYi5jaGFyQ29kZUF0KDgpKSBicmVhaztcbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIGEgPSBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgJzsnICsgYTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjA3OlxuICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgICAgYSA9IGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgKDEwMiA8IG0gPyAnaW5saW5lLScgOiAnJykgKyAnYm94JykgKyAnOycgKyBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgJzsnICsgYS5yZXBsYWNlKGIsICctbXMtJyArIGIgKyAnYm94JykgKyAnOycgKyBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhICsgJzsnO1xuICAgICAgY2FzZSA5Mzg6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDUpKSBzd2l0Y2ggKGEuY2hhckNvZGVBdCg2KSkge1xuICAgICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgICAgcmV0dXJuIGIgPSBhLnJlcGxhY2UoJy1pdGVtcycsICcnKSwgJy13ZWJraXQtJyArIGEgKyAnLXdlYmtpdC1ib3gtJyArIGIgKyAnLW1zLWZsZXgtJyArIGIgKyBhO1xuICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy1mbGV4LWl0ZW0tJyArIGEucmVwbGFjZShiYSwgJycpICsgYTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy1mbGV4LWxpbmUtcGFjaycgKyBhLnJlcGxhY2UoJ2FsaWduLWNvbnRlbnQnLCAnJykucmVwbGFjZShiYSwgJycpICsgYTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTczOlxuICAgICAgY2FzZSA5ODk6XG4gICAgICAgIGlmICg0NSAhPT0gYS5jaGFyQ29kZUF0KDMpIHx8IDEyMiA9PT0gYS5jaGFyQ29kZUF0KDQpKSBicmVhaztcbiAgICAgIGNhc2UgOTMxOlxuICAgICAgY2FzZSA5NTM6XG4gICAgICAgIGlmICghMCA9PT0gbGEudGVzdChkKSkgcmV0dXJuIDExNSA9PT0gKGIgPSBkLnN1YnN0cmluZyhkLmluZGV4T2YoJzonKSArIDEpKS5jaGFyQ29kZUF0KDApID8gUChkLnJlcGxhY2UoJ3N0cmV0Y2gnLCAnZmlsbC1hdmFpbGFibGUnKSwgYywgZSwgaCkucmVwbGFjZSgnOmZpbGwtYXZhaWxhYmxlJywgJzpzdHJldGNoJykgOiBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgYS5yZXBsYWNlKGIsICctbW96LScgKyBiLnJlcGxhY2UoJ2ZpbGwtJywgJycpKSArIGE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5NjI6XG4gICAgICAgIGlmIChhID0gJy13ZWJraXQtJyArIGEgKyAoMTAyID09PSBhLmNoYXJDb2RlQXQoNSkgPyAnLW1zLScgKyBhIDogJycpICsgYSwgMjExID09PSBlICsgaCAmJiAxMDUgPT09IGEuY2hhckNvZGVBdCgxMykgJiYgMCA8IGEuaW5kZXhPZigndHJhbnNmb3JtJywgMTApKSByZXR1cm4gYS5zdWJzdHJpbmcoMCwgYS5pbmRleE9mKCc7JywgMjcpICsgMSkucmVwbGFjZShtYSwgJyQxLXdlYmtpdC0kMicpICsgYTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgZnVuY3Rpb24gTChkLCBjKSB7XG4gICAgdmFyIGUgPSBkLmluZGV4T2YoMSA9PT0gYyA/ICc6JyA6ICd7JyksXG4gICAgICBoID0gZC5zdWJzdHJpbmcoMCwgMyAhPT0gYyA/IGUgOiAxMCk7XG4gICAgZSA9IGQuc3Vic3RyaW5nKGUgKyAxLCBkLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBSKDIgIT09IGMgPyBoIDogaC5yZXBsYWNlKG5hLCAnJDEnKSwgZSwgYyk7XG4gIH1cbiAgZnVuY3Rpb24gZWEoZCwgYykge1xuICAgIHZhciBlID0gUChjLCBjLmNoYXJDb2RlQXQoMCksIGMuY2hhckNvZGVBdCgxKSwgYy5jaGFyQ29kZUF0KDIpKTtcbiAgICByZXR1cm4gZSAhPT0gYyArICc7JyA/IGUucmVwbGFjZShvYSwgJyBvciAoJDEpJykuc3Vic3RyaW5nKDQpIDogJygnICsgYyArICcpJztcbiAgfVxuICBmdW5jdGlvbiBIKGQsIGMsIGUsIGgsIGEsIG0sIGIsIHYsIG4sIHEpIHtcbiAgICBmb3IgKHZhciBnID0gMCwgeCA9IGMsIHc7IGcgPCBBOyArK2cpIHtcbiAgICAgIHN3aXRjaCAodyA9IFNbZ10uY2FsbChCLCBkLCB4LCBlLCBoLCBhLCBtLCBiLCB2LCBuLCBxKSkge1xuICAgICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgY2FzZSAhMTpcbiAgICAgICAgY2FzZSAhMDpcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHggPSB3O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoeCAhPT0gYykgcmV0dXJuIHg7XG4gIH1cbiAgZnVuY3Rpb24gVChkKSB7XG4gICAgc3dpdGNoIChkKSB7XG4gICAgICBjYXNlIHZvaWQgMDpcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgQSA9IFMubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGQpIFNbQSsrXSA9IGQ7ZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBkKSBmb3IgKHZhciBjID0gMCwgZSA9IGQubGVuZ3RoOyBjIDwgZTsgKytjKSB7XG4gICAgICAgICAgVChkW2NdKTtcbiAgICAgICAgfSBlbHNlIFkgPSAhIWQgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gVDtcbiAgfVxuICBmdW5jdGlvbiBVKGQpIHtcbiAgICBkID0gZC5wcmVmaXg7XG4gICAgdm9pZCAwICE9PSBkICYmIChSID0gbnVsbCwgZCA/ICdmdW5jdGlvbicgIT09IHR5cGVvZiBkID8gdyA9IDEgOiAodyA9IDIsIFIgPSBkKSA6IHcgPSAwKTtcbiAgICByZXR1cm4gVTtcbiAgfVxuICBmdW5jdGlvbiBCKGQsIGMpIHtcbiAgICB2YXIgZSA9IGQ7XG4gICAgMzMgPiBlLmNoYXJDb2RlQXQoMCkgJiYgKGUgPSBlLnRyaW0oKSk7XG4gICAgViA9IGU7XG4gICAgZSA9IFtWXTtcbiAgICBpZiAoMCA8IEEpIHtcbiAgICAgIHZhciBoID0gSCgtMSwgYywgZSwgZSwgRCwgeiwgMCwgMCwgMCwgMCk7XG4gICAgICB2b2lkIDAgIT09IGggJiYgJ3N0cmluZycgPT09IHR5cGVvZiBoICYmIChjID0gaCk7XG4gICAgfVxuICAgIHZhciBhID0gTShPLCBlLCBjLCAwLCAwKTtcbiAgICAwIDwgQSAmJiAoaCA9IEgoLTIsIGEsIGUsIGUsIEQsIHosIGEubGVuZ3RoLCAwLCAwLCAwKSwgdm9pZCAwICE9PSBoICYmIChhID0gaCkpO1xuICAgIFYgPSAnJztcbiAgICBFID0gMDtcbiAgICB6ID0gRCA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgdmFyIGNhID0gL15cXDArL2csXG4gICAgTiA9IC9bXFwwXFxyXFxmXS9nLFxuICAgIGFhID0gLzogKi9nLFxuICAgIGthID0gL3pvb3xncmEvLFxuICAgIG1hID0gLyhbLDogXSkodHJhbnNmb3JtKS9nLFxuICAgIGlhID0gLyxcXHIrPy9nLFxuICAgIEYgPSAvKFtcXHRcXHJcXG4gXSkqXFxmPyYvZyxcbiAgICBmYSA9IC9AKGtcXHcrKVxccyooXFxTKilcXHMqLyxcbiAgICBRID0gLzo6KHBsYWNlKS9nLFxuICAgIGhhID0gLzoocmVhZC1vbmx5KS9nLFxuICAgIEcgPSAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sXG4gICAgZGEgPSAvXFwoXFxzKiguKilcXHMqXFwpL2csXG4gICAgb2EgPSAvKFtcXHNcXFNdKj8pOy9nLFxuICAgIGJhID0gLy1zZWxmfGZsZXgtL2csXG4gICAgbmEgPSAvW15dKj8oOltycF1bZWxdYVtcXHctXSspW15dKi8sXG4gICAgbGEgPSAvc3RyZXRjaHw6XFxzKlxcdytcXC0oPzpjb250ZXxhdmFpbCkvLFxuICAgIGphID0gLyhbXi1dKShpbWFnZS1zZXRcXCgpLyxcbiAgICB6ID0gMSxcbiAgICBEID0gMSxcbiAgICBFID0gMCxcbiAgICB3ID0gMSxcbiAgICBPID0gW10sXG4gICAgUyA9IFtdLFxuICAgIEEgPSAwLFxuICAgIFIgPSBudWxsLFxuICAgIFkgPSAwLFxuICAgIFYgPSAnJztcbiAgQi51c2UgPSBUO1xuICBCLnNldCA9IFU7XG4gIHZvaWQgMCAhPT0gVyAmJiBVKFcpO1xuICByZXR1cm4gQjtcbn1cbmV4cG9ydCBkZWZhdWx0IHN0eWxpc19taW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@emotion/stylis/dist/stylis.browser.esm.js\n");

/***/ }),

/***/ "./node_modules/@emotion/unitless/dist/unitless.browser.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@emotion/unitless/dist/unitless.browser.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar unitlessKeys = {\n  animationIterationCount: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  msGridRow: 1,\n  msGridRowSpan: 1,\n  msGridColumn: 1,\n  msGridColumnSpan: 1,\n  fontWeight: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  WebkitLineClamp: 1,\n  // SVG-related properties\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unitlessKeys);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vdW5pdGxlc3MvZGlzdC91bml0bGVzcy5icm93c2VyLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3VuaXRsZXNzL2Rpc3QvdW5pdGxlc3MuYnJvd3Nlci5lc20uanM/NDdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdW5pdGxlc3NLZXlzID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogMSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IDEsXG4gIGJvcmRlckltYWdlU2xpY2U6IDEsXG4gIGJvcmRlckltYWdlV2lkdGg6IDEsXG4gIGJveEZsZXg6IDEsXG4gIGJveEZsZXhHcm91cDogMSxcbiAgYm94T3JkaW5hbEdyb3VwOiAxLFxuICBjb2x1bW5Db3VudDogMSxcbiAgY29sdW1uczogMSxcbiAgZmxleDogMSxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhQb3NpdGl2ZTogMSxcbiAgZmxleFNocmluazogMSxcbiAgZmxleE5lZ2F0aXZlOiAxLFxuICBmbGV4T3JkZXI6IDEsXG4gIGdyaWRSb3c6IDEsXG4gIGdyaWRSb3dFbmQ6IDEsXG4gIGdyaWRSb3dTcGFuOiAxLFxuICBncmlkUm93U3RhcnQ6IDEsXG4gIGdyaWRDb2x1bW46IDEsXG4gIGdyaWRDb2x1bW5FbmQ6IDEsXG4gIGdyaWRDb2x1bW5TcGFuOiAxLFxuICBncmlkQ29sdW1uU3RhcnQ6IDEsXG4gIG1zR3JpZFJvdzogMSxcbiAgbXNHcmlkUm93U3BhbjogMSxcbiAgbXNHcmlkQ29sdW1uOiAxLFxuICBtc0dyaWRDb2x1bW5TcGFuOiAxLFxuICBmb250V2VpZ2h0OiAxLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBvcGFjaXR5OiAxLFxuICBvcmRlcjogMSxcbiAgb3JwaGFuczogMSxcbiAgdGFiU2l6ZTogMSxcbiAgd2lkb3dzOiAxLFxuICB6SW5kZXg6IDEsXG4gIHpvb206IDEsXG4gIFdlYmtpdExpbmVDbGFtcDogMSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogMSxcbiAgZmxvb2RPcGFjaXR5OiAxLFxuICBzdG9wT3BhY2l0eTogMSxcbiAgc3Ryb2tlRGFzaGFycmF5OiAxLFxuICBzdHJva2VEYXNob2Zmc2V0OiAxLFxuICBzdHJva2VNaXRlcmxpbWl0OiAxLFxuICBzdHJva2VPcGFjaXR5OiAxLFxuICBzdHJva2VXaWR0aDogMVxufTtcbmV4cG9ydCBkZWZhdWx0IHVuaXRsZXNzS2V5czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@emotion/unitless/dist/unitless.browser.esm.js\n");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners = events[type];\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n  if (events !== undefined) {\n    var evlistener = events[type];\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    ;\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzP2RlYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbDtcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nID8gUi5hcHBseSA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbn07XG52YXIgUmVmbGVjdE93bktleXM7XG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzO1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gdHlwZSA9PT0gJ2Vycm9yJztcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSBkb0Vycm9yID0gZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZDtlbHNlIGlmICghZG9FcnJvcikgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgKyAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgKyAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG59O1xuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0ge1xuICAgIGZpcmVkOiBmYWxzZSxcbiAgICB3cmFwRm46IHVuZGVmaW5lZCxcbiAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2Uge1xuICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwb3NpdGlvbiA9IC0xO1xuICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uIDwgMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHBvc2l0aW9uID09PSAwKSBsaXN0LnNoaWZ0KCk7ZWxzZSB7XG4gICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG4gICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2UgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgdmFyIGtleTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfVxuICAgIDtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n");

/***/ }),

/***/ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar reactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n    var keys = getOwnPropertyNames(sourceComponent);\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n  return targetComponent;\n}\nmodule.exports = hoistNonReactStatics;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzP2M4ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHt9O1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuRm9yd2FyZFJlZl0gPSBGT1JXQVJEX1JFRl9TVEFUSUNTO1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuTWVtb10gPSBNRU1PX1NUQVRJQ1M7XG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICAvLyBSZWFjdCB2MTYuMTEgYW5kIGJlbG93XG4gIGlmIChyZWFjdElzLmlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfSAvLyBSZWFjdCB2MTYuMTIgYW5kIGFib3ZlXG5cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbJyQkdHlwZW9mJ11dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG4gICAgdmFyIHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgdmFyIHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdFtrZXldKSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaG9pc3ROb25SZWFjdFN0YXRpY3M7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/html4-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html4-entities.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ \"./node_modules/html-entities/lib/surrogate-pairs.js\");\nvar HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'AElig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];\nvar HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];\nvar alphaIndex = {};\nvar numIndex = {};\n(function () {\n  var i = 0;\n  var length = HTML_ALPHA.length;\n  while (i < length) {\n    var a = HTML_ALPHA[i];\n    var c = HTML_CODES[i];\n    alphaIndex[a] = String.fromCharCode(c);\n    numIndex[c] = a;\n    i++;\n  }\n})();\nvar Html4Entities = /** @class */function () {\n  function Html4Entities() {}\n  Html4Entities.prototype.decode = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    return str.replace(/&(#?[\\w\\d]+);?/g, function (s, entity) {\n      var chr;\n      if (entity.charAt(0) === \"#\") {\n        var code = entity.charAt(1).toLowerCase() === 'x' ? parseInt(entity.substr(2), 16) : parseInt(entity.substr(1));\n        if (!isNaN(code) || code >= -32768) {\n          if (code <= 65535) {\n            chr = String.fromCharCode(code);\n          } else {\n            chr = surrogate_pairs_1.fromCodePoint(code);\n          }\n        }\n      } else {\n        chr = alphaIndex[entity];\n      }\n      return chr || s;\n    });\n  };\n  Html4Entities.decode = function (str) {\n    return new Html4Entities().decode(str);\n  };\n  Html4Entities.prototype.encode = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n      var alpha = numIndex[str.charCodeAt(i)];\n      result += alpha ? \"&\" + alpha + \";\" : str.charAt(i);\n      i++;\n    }\n    return result;\n  };\n  Html4Entities.encode = function (str) {\n    return new Html4Entities().encode(str);\n  };\n  Html4Entities.prototype.encodeNonUTF = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n      var cc = str.charCodeAt(i);\n      var alpha = numIndex[cc];\n      if (alpha) {\n        result += \"&\" + alpha + \";\";\n      } else if (cc < 32 || cc > 126) {\n        if (cc >= surrogate_pairs_1.highSurrogateFrom && cc <= surrogate_pairs_1.highSurrogateTo) {\n          result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';\n          i++;\n        } else {\n          result += '&#' + cc + ';';\n        }\n      } else {\n        result += str.charAt(i);\n      }\n      i++;\n    }\n    return result;\n  };\n  Html4Entities.encodeNonUTF = function (str) {\n    return new Html4Entities().encodeNonUTF(str);\n  };\n  Html4Entities.prototype.encodeNonASCII = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n      var c = str.charCodeAt(i);\n      if (c <= 255) {\n        result += str[i++];\n        continue;\n      }\n      if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {\n        result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';\n        i++;\n      } else {\n        result += '&#' + c + ';';\n      }\n      i++;\n    }\n    return result;\n  };\n  Html4Entities.encodeNonASCII = function (str) {\n    return new Html4Entities().encodeNonASCII(str);\n  };\n  return Html4Entities;\n}();\nexports.Html4Entities = Html4Entities;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDQtZW50aXRpZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDQtZW50aXRpZXMuanM/Mzc1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBzdXJyb2dhdGVfcGFpcnNfMSA9IHJlcXVpcmUoXCIuL3N1cnJvZ2F0ZS1wYWlyc1wiKTtcbnZhciBIVE1MX0FMUEhBID0gWydhcG9zJywgJ25ic3AnLCAnaWV4Y2wnLCAnY2VudCcsICdwb3VuZCcsICdjdXJyZW4nLCAneWVuJywgJ2JydmJhcicsICdzZWN0JywgJ3VtbCcsICdjb3B5JywgJ29yZGYnLCAnbGFxdW8nLCAnbm90JywgJ3NoeScsICdyZWcnLCAnbWFjcicsICdkZWcnLCAncGx1c21uJywgJ3N1cDInLCAnc3VwMycsICdhY3V0ZScsICdtaWNybycsICdwYXJhJywgJ21pZGRvdCcsICdjZWRpbCcsICdzdXAxJywgJ29yZG0nLCAncmFxdW8nLCAnZnJhYzE0JywgJ2ZyYWMxMicsICdmcmFjMzQnLCAnaXF1ZXN0JywgJ0FncmF2ZScsICdBYWN1dGUnLCAnQWNpcmMnLCAnQXRpbGRlJywgJ0F1bWwnLCAnQXJpbmcnLCAnQUVsaWcnLCAnQ2NlZGlsJywgJ0VncmF2ZScsICdFYWN1dGUnLCAnRWNpcmMnLCAnRXVtbCcsICdJZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjJywgJ0l1bWwnLCAnRVRIJywgJ050aWxkZScsICdPZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjJywgJ090aWxkZScsICdPdW1sJywgJ3RpbWVzJywgJ09zbGFzaCcsICdVZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjJywgJ1V1bWwnLCAnWWFjdXRlJywgJ1RIT1JOJywgJ3N6bGlnJywgJ2FncmF2ZScsICdhYWN1dGUnLCAnYWNpcmMnLCAnYXRpbGRlJywgJ2F1bWwnLCAnYXJpbmcnLCAnYWVsaWcnLCAnY2NlZGlsJywgJ2VncmF2ZScsICdlYWN1dGUnLCAnZWNpcmMnLCAnZXVtbCcsICdpZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjJywgJ2l1bWwnLCAnZXRoJywgJ250aWxkZScsICdvZ3JhdmUnLCAnb2FjdXRlJywgJ29jaXJjJywgJ290aWxkZScsICdvdW1sJywgJ2RpdmlkZScsICdvc2xhc2gnLCAndWdyYXZlJywgJ3VhY3V0ZScsICd1Y2lyYycsICd1dW1sJywgJ3lhY3V0ZScsICd0aG9ybicsICd5dW1sJywgJ3F1b3QnLCAnYW1wJywgJ2x0JywgJ2d0JywgJ09FbGlnJywgJ29lbGlnJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWXVtbCcsICdjaXJjJywgJ3RpbGRlJywgJ2Vuc3AnLCAnZW1zcCcsICd0aGluc3AnLCAnenduaicsICd6d2onLCAnbHJtJywgJ3JsbScsICduZGFzaCcsICdtZGFzaCcsICdsc3F1bycsICdyc3F1bycsICdzYnF1bycsICdsZHF1bycsICdyZHF1bycsICdiZHF1bycsICdkYWdnZXInLCAnRGFnZ2VyJywgJ3Blcm1pbCcsICdsc2FxdW8nLCAncnNhcXVvJywgJ2V1cm8nLCAnZm5vZicsICdBbHBoYScsICdCZXRhJywgJ0dhbW1hJywgJ0RlbHRhJywgJ0Vwc2lsb24nLCAnWmV0YScsICdFdGEnLCAnVGhldGEnLCAnSW90YScsICdLYXBwYScsICdMYW1iZGEnLCAnTXUnLCAnTnUnLCAnWGknLCAnT21pY3JvbicsICdQaScsICdSaG8nLCAnU2lnbWEnLCAnVGF1JywgJ1Vwc2lsb24nLCAnUGhpJywgJ0NoaScsICdQc2knLCAnT21lZ2EnLCAnYWxwaGEnLCAnYmV0YScsICdnYW1tYScsICdkZWx0YScsICdlcHNpbG9uJywgJ3pldGEnLCAnZXRhJywgJ3RoZXRhJywgJ2lvdGEnLCAna2FwcGEnLCAnbGFtYmRhJywgJ211JywgJ251JywgJ3hpJywgJ29taWNyb24nLCAncGknLCAncmhvJywgJ3NpZ21hZicsICdzaWdtYScsICd0YXUnLCAndXBzaWxvbicsICdwaGknLCAnY2hpJywgJ3BzaScsICdvbWVnYScsICd0aGV0YXN5bScsICd1cHNpaCcsICdwaXYnLCAnYnVsbCcsICdoZWxsaXAnLCAncHJpbWUnLCAnUHJpbWUnLCAnb2xpbmUnLCAnZnJhc2wnLCAnd2VpZXJwJywgJ2ltYWdlJywgJ3JlYWwnLCAndHJhZGUnLCAnYWxlZnN5bScsICdsYXJyJywgJ3VhcnInLCAncmFycicsICdkYXJyJywgJ2hhcnInLCAnY3JhcnInLCAnbEFycicsICd1QXJyJywgJ3JBcnInLCAnZEFycicsICdoQXJyJywgJ2ZvcmFsbCcsICdwYXJ0JywgJ2V4aXN0JywgJ2VtcHR5JywgJ25hYmxhJywgJ2lzaW4nLCAnbm90aW4nLCAnbmknLCAncHJvZCcsICdzdW0nLCAnbWludXMnLCAnbG93YXN0JywgJ3JhZGljJywgJ3Byb3AnLCAnaW5maW4nLCAnYW5nJywgJ2FuZCcsICdvcicsICdjYXAnLCAnY3VwJywgJ2ludCcsICd0aGVyZTQnLCAnc2ltJywgJ2NvbmcnLCAnYXN5bXAnLCAnbmUnLCAnZXF1aXYnLCAnbGUnLCAnZ2UnLCAnc3ViJywgJ3N1cCcsICduc3ViJywgJ3N1YmUnLCAnc3VwZScsICdvcGx1cycsICdvdGltZXMnLCAncGVycCcsICdzZG90JywgJ2xjZWlsJywgJ3JjZWlsJywgJ2xmbG9vcicsICdyZmxvb3InLCAnbGFuZycsICdyYW5nJywgJ2xveicsICdzcGFkZXMnLCAnY2x1YnMnLCAnaGVhcnRzJywgJ2RpYW1zJ107XG52YXIgSFRNTF9DT0RFUyA9IFszOSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSwgMTcyLCAxNzMsIDE3NCwgMTc1LCAxNzYsIDE3NywgMTc4LCAxNzksIDE4MCwgMTgxLCAxODIsIDE4MywgMTg0LCAxODUsIDE4NiwgMTg3LCAxODgsIDE4OSwgMTkwLCAxOTEsIDE5MiwgMTkzLCAxOTQsIDE5NSwgMTk2LCAxOTcsIDE5OCwgMTk5LCAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCwgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxMCwgMjExLCAyMTIsIDIxMywgMjE0LCAyMTUsIDIxNiwgMjE3LCAyMTgsIDIxOSwgMjIwLCAyMjEsIDIyMiwgMjIzLCAyMjQsIDIyNSwgMjI2LCAyMjcsIDIyOCwgMjI5LCAyMzAsIDIzMSwgMjMyLCAyMzMsIDIzNCwgMjM1LCAyMzYsIDIzNywgMjM4LCAyMzksIDI0MCwgMjQxLCAyNDIsIDI0MywgMjQ0LCAyNDUsIDI0NiwgMjQ3LCAyNDgsIDI0OSwgMjUwLCAyNTEsIDI1MiwgMjUzLCAyNTQsIDI1NSwgMzQsIDM4LCA2MCwgNjIsIDMzOCwgMzM5LCAzNTIsIDM1MywgMzc2LCA3MTAsIDczMiwgODE5NCwgODE5NSwgODIwMSwgODIwNCwgODIwNSwgODIwNiwgODIwNywgODIxMSwgODIxMiwgODIxNiwgODIxNywgODIxOCwgODIyMCwgODIyMSwgODIyMiwgODIyNCwgODIyNSwgODI0MCwgODI0OSwgODI1MCwgODM2NCwgNDAyLCA5MTMsIDkxNCwgOTE1LCA5MTYsIDkxNywgOTE4LCA5MTksIDkyMCwgOTIxLCA5MjIsIDkyMywgOTI0LCA5MjUsIDkyNiwgOTI3LCA5MjgsIDkyOSwgOTMxLCA5MzIsIDkzMywgOTM0LCA5MzUsIDkzNiwgOTM3LCA5NDUsIDk0NiwgOTQ3LCA5NDgsIDk0OSwgOTUwLCA5NTEsIDk1MiwgOTUzLCA5NTQsIDk1NSwgOTU2LCA5NTcsIDk1OCwgOTU5LCA5NjAsIDk2MSwgOTYyLCA5NjMsIDk2NCwgOTY1LCA5NjYsIDk2NywgOTY4LCA5NjksIDk3NywgOTc4LCA5ODIsIDgyMjYsIDgyMzAsIDgyNDIsIDgyNDMsIDgyNTQsIDgyNjAsIDg0NzIsIDg0NjUsIDg0NzYsIDg0ODIsIDg1MDEsIDg1OTIsIDg1OTMsIDg1OTQsIDg1OTUsIDg1OTYsIDg2MjksIDg2NTYsIDg2NTcsIDg2NTgsIDg2NTksIDg2NjAsIDg3MDQsIDg3MDYsIDg3MDcsIDg3MDksIDg3MTEsIDg3MTIsIDg3MTMsIDg3MTUsIDg3MTksIDg3MjEsIDg3MjIsIDg3MjcsIDg3MzAsIDg3MzMsIDg3MzQsIDg3MzYsIDg3NDMsIDg3NDQsIDg3NDUsIDg3NDYsIDg3NDcsIDg3NTYsIDg3NjQsIDg3NzMsIDg3NzYsIDg4MDAsIDg4MDEsIDg4MDQsIDg4MDUsIDg4MzQsIDg4MzUsIDg4MzYsIDg4MzgsIDg4MzksIDg4NTMsIDg4NTUsIDg4NjksIDg5MDEsIDg5NjgsIDg5NjksIDg5NzAsIDg5NzEsIDkwMDEsIDkwMDIsIDk2NzQsIDk4MjQsIDk4MjcsIDk4MjksIDk4MzBdO1xudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBudW1JbmRleCA9IHt9O1xuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gSFRNTF9BTFBIQS5sZW5ndGg7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGEgPSBIVE1MX0FMUEhBW2ldO1xuICAgIHZhciBjID0gSFRNTF9DT0RFU1tpXTtcbiAgICBhbHBoYUluZGV4W2FdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICBudW1JbmRleFtjXSA9IGE7XG4gICAgaSsrO1xuICB9XG59KSgpO1xudmFyIEh0bWw0RW50aXRpZXMgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIdG1sNEVudGl0aWVzKCkge31cbiAgSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbiAocywgZW50aXR5KSB7XG4gICAgICB2YXIgY2hyO1xuICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSAneCcgPyBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLCAxNikgOiBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcbiAgICAgICAgaWYgKCFpc05hTihjb2RlKSB8fCBjb2RlID49IC0zMjc2OCkge1xuICAgICAgICAgIGlmIChjb2RlIDw9IDY1NTM1KSB7XG4gICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBzdXJyb2dhdGVfcGFpcnNfMS5mcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xuICB9O1xuICBIdG1sNEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiAgfTtcbiAgSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIHJlc3VsdCArPSBhbHBoYSA/IFwiJlwiICsgYWxwaGEgKyBcIjtcIiA6IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIEh0bWw0RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZShzdHIpO1xuICB9O1xuICBIdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgdmFyIGNjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtjY107XG4gICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgIH0gZWxzZSBpZiAoY2MgPCAzMiB8fCBjYyA+IDEyNikge1xuICAgICAgICBpZiAoY2MgPj0gc3Vycm9nYXRlX3BhaXJzXzEuaGlnaFN1cnJvZ2F0ZUZyb20gJiYgY2MgPD0gc3Vycm9nYXRlX3BhaXJzXzEuaGlnaFN1cnJvZ2F0ZVRvKSB7XG4gICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBzdXJyb2dhdGVfcGFpcnNfMS5nZXRDb2RlUG9pbnQoc3RyLCBpKSArICc7JztcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjYyArICc7JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIEh0bWw0RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuICB9O1xuICBIdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYyA+PSBzdXJyb2dhdGVfcGFpcnNfMS5oaWdoU3Vycm9nYXRlRnJvbSAmJiBjIDw9IHN1cnJvZ2F0ZV9wYWlyc18xLmhpZ2hTdXJyb2dhdGVUbykge1xuICAgICAgICByZXN1bHQgKz0gJyYjJyArIHN1cnJvZ2F0ZV9wYWlyc18xLmdldENvZGVQb2ludChzdHIsIGkpICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIEh0bWw0RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiAgfTtcbiAgcmV0dXJuIEh0bWw0RW50aXRpZXM7XG59KCk7XG5leHBvcnRzLkh0bWw0RW50aXRpZXMgPSBIdG1sNEVudGl0aWVzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/html4-entities.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/html5-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html5-entities.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ \"./node_modules/html-entities/lib/surrogate-pairs.js\");\nvar ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];\nvar DECODE_ONLY_ENTITIES = [['NewLine', [10]]];\nvar alphaIndex = {};\nvar charIndex = {};\ncreateIndexes(alphaIndex, charIndex);\nvar Html5Entities = /** @class */function () {\n  function Html5Entities() {}\n  Html5Entities.prototype.decode = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    return str.replace(/&(#?[\\w\\d]+);?/g, function (s, entity) {\n      var chr;\n      if (entity.charAt(0) === \"#\") {\n        var code = entity.charAt(1) === 'x' ? parseInt(entity.substr(2).toLowerCase(), 16) : parseInt(entity.substr(1));\n        if (!isNaN(code) || code >= -32768) {\n          if (code <= 65535) {\n            chr = String.fromCharCode(code);\n          } else {\n            chr = surrogate_pairs_1.fromCodePoint(code);\n          }\n        }\n      } else {\n        chr = alphaIndex[entity];\n      }\n      return chr || s;\n    });\n  };\n  Html5Entities.decode = function (str) {\n    return new Html5Entities().decode(str);\n  };\n  Html5Entities.prototype.encode = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n      var charInfo = charIndex[str.charCodeAt(i)];\n      if (charInfo) {\n        var alpha = charInfo[str.charCodeAt(i + 1)];\n        if (alpha) {\n          i++;\n        } else {\n          alpha = charInfo[''];\n        }\n        if (alpha) {\n          result += \"&\" + alpha + \";\";\n          i++;\n          continue;\n        }\n      }\n      result += str.charAt(i);\n      i++;\n    }\n    return result;\n  };\n  Html5Entities.encode = function (str) {\n    return new Html5Entities().encode(str);\n  };\n  Html5Entities.prototype.encodeNonUTF = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n      var c = str.charCodeAt(i);\n      var charInfo = charIndex[c];\n      if (charInfo) {\n        var alpha = charInfo[str.charCodeAt(i + 1)];\n        if (alpha) {\n          i++;\n        } else {\n          alpha = charInfo[''];\n        }\n        if (alpha) {\n          result += \"&\" + alpha + \";\";\n          i++;\n          continue;\n        }\n      }\n      if (c < 32 || c > 126) {\n        if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {\n          result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';\n          i++;\n        } else {\n          result += '&#' + c + ';';\n        }\n      } else {\n        result += str.charAt(i);\n      }\n      i++;\n    }\n    return result;\n  };\n  Html5Entities.encodeNonUTF = function (str) {\n    return new Html5Entities().encodeNonUTF(str);\n  };\n  Html5Entities.prototype.encodeNonASCII = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n      var c = str.charCodeAt(i);\n      if (c <= 255) {\n        result += str[i++];\n        continue;\n      }\n      if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {\n        result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';\n        i += 2;\n      } else {\n        result += '&#' + c + ';';\n        i++;\n      }\n    }\n    return result;\n  };\n  Html5Entities.encodeNonASCII = function (str) {\n    return new Html5Entities().encodeNonASCII(str);\n  };\n  return Html5Entities;\n}();\nexports.Html5Entities = Html5Entities;\nfunction createIndexes(alphaIndex, charIndex) {\n  var i = ENTITIES.length;\n  while (i--) {\n    var _a = ENTITIES[i],\n      alpha = _a[0],\n      _b = _a[1],\n      chr = _b[0],\n      chr2 = _b[1];\n    var addChar = chr < 32 || chr > 126 || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;\n    var charInfo = void 0;\n    if (addChar) {\n      charInfo = charIndex[chr] = charIndex[chr] || {};\n    }\n    if (chr2) {\n      alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);\n      addChar && (charInfo[chr2] = alpha);\n    } else {\n      alphaIndex[alpha] = String.fromCharCode(chr);\n      addChar && (charInfo[''] = alpha);\n    }\n  }\n  i = DECODE_ONLY_ENTITIES.length;\n  while (i--) {\n    var _c = DECODE_ONLY_ENTITIES[i],\n      alpha = _c[0],\n      _d = _c[1],\n      chr = _d[0],\n      chr2 = _d[1];\n    alphaIndex[alpha] = String.fromCharCode(chr) + (chr2 ? String.fromCharCode(chr2) : '');\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanM/NjIyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBzdXJyb2dhdGVfcGFpcnNfMSA9IHJlcXVpcmUoXCIuL3N1cnJvZ2F0ZS1wYWlyc1wiKTtcbnZhciBFTlRJVElFUyA9IFtbJ0FhY3V0ZScsIFsxOTNdXSwgWydhYWN1dGUnLCBbMjI1XV0sIFsnQWJyZXZlJywgWzI1OF1dLCBbJ2FicmV2ZScsIFsyNTldXSwgWydhYycsIFs4NzY2XV0sIFsnYWNkJywgWzg3NjddXSwgWydhY0UnLCBbODc2NiwgODE5XV0sIFsnQWNpcmMnLCBbMTk0XV0sIFsnYWNpcmMnLCBbMjI2XV0sIFsnYWN1dGUnLCBbMTgwXV0sIFsnQWN5JywgWzEwNDBdXSwgWydhY3knLCBbMTA3Ml1dLCBbJ0FFbGlnJywgWzE5OF1dLCBbJ2FlbGlnJywgWzIzMF1dLCBbJ2FmJywgWzgyODldXSwgWydBZnInLCBbMTIwMDY4XV0sIFsnYWZyJywgWzEyMDA5NF1dLCBbJ0FncmF2ZScsIFsxOTJdXSwgWydhZ3JhdmUnLCBbMjI0XV0sIFsnYWxlZnN5bScsIFs4NTAxXV0sIFsnYWxlcGgnLCBbODUwMV1dLCBbJ0FscGhhJywgWzkxM11dLCBbJ2FscGhhJywgWzk0NV1dLCBbJ0FtYWNyJywgWzI1Nl1dLCBbJ2FtYWNyJywgWzI1N11dLCBbJ2FtYWxnJywgWzEwODE1XV0sIFsnYW1wJywgWzM4XV0sIFsnQU1QJywgWzM4XV0sIFsnYW5kYW5kJywgWzEwODM3XV0sIFsnQW5kJywgWzEwODM1XV0sIFsnYW5kJywgWzg3NDNdXSwgWydhbmRkJywgWzEwODQ0XV0sIFsnYW5kc2xvcGUnLCBbMTA4NDBdXSwgWydhbmR2JywgWzEwODQyXV0sIFsnYW5nJywgWzg3MzZdXSwgWydhbmdlJywgWzEwNjYwXV0sIFsnYW5nbGUnLCBbODczNl1dLCBbJ2FuZ21zZGFhJywgWzEwNjY0XV0sIFsnYW5nbXNkYWInLCBbMTA2NjVdXSwgWydhbmdtc2RhYycsIFsxMDY2Nl1dLCBbJ2FuZ21zZGFkJywgWzEwNjY3XV0sIFsnYW5nbXNkYWUnLCBbMTA2NjhdXSwgWydhbmdtc2RhZicsIFsxMDY2OV1dLCBbJ2FuZ21zZGFnJywgWzEwNjcwXV0sIFsnYW5nbXNkYWgnLCBbMTA2NzFdXSwgWydhbmdtc2QnLCBbODczN11dLCBbJ2FuZ3J0JywgWzg3MzVdXSwgWydhbmdydHZiJywgWzg4OTRdXSwgWydhbmdydHZiZCcsIFsxMDY1M11dLCBbJ2FuZ3NwaCcsIFs4NzM4XV0sIFsnYW5nc3QnLCBbMTk3XV0sIFsnYW5nemFycicsIFs5MDg0XV0sIFsnQW9nb24nLCBbMjYwXV0sIFsnYW9nb24nLCBbMjYxXV0sIFsnQW9wZicsIFsxMjAxMjBdXSwgWydhb3BmJywgWzEyMDE0Nl1dLCBbJ2FwYWNpcicsIFsxMDg2M11dLCBbJ2FwJywgWzg3NzZdXSwgWydhcEUnLCBbMTA4NjRdXSwgWydhcGUnLCBbODc3OF1dLCBbJ2FwaWQnLCBbODc3OV1dLCBbJ2Fwb3MnLCBbMzldXSwgWydBcHBseUZ1bmN0aW9uJywgWzgyODldXSwgWydhcHByb3gnLCBbODc3Nl1dLCBbJ2FwcHJveGVxJywgWzg3NzhdXSwgWydBcmluZycsIFsxOTddXSwgWydhcmluZycsIFsyMjldXSwgWydBc2NyJywgWzExOTk2NF1dLCBbJ2FzY3InLCBbMTE5OTkwXV0sIFsnQXNzaWduJywgWzg3ODhdXSwgWydhc3QnLCBbNDJdXSwgWydhc3ltcCcsIFs4Nzc2XV0sIFsnYXN5bXBlcScsIFs4NzgxXV0sIFsnQXRpbGRlJywgWzE5NV1dLCBbJ2F0aWxkZScsIFsyMjddXSwgWydBdW1sJywgWzE5Nl1dLCBbJ2F1bWwnLCBbMjI4XV0sIFsnYXdjb25pbnQnLCBbODc1NV1dLCBbJ2F3aW50JywgWzEwNzY5XV0sIFsnYmFja2NvbmcnLCBbODc4MF1dLCBbJ2JhY2tlcHNpbG9uJywgWzEwMTRdXSwgWydiYWNrcHJpbWUnLCBbODI0NV1dLCBbJ2JhY2tzaW0nLCBbODc2NV1dLCBbJ2JhY2tzaW1lcScsIFs4OTA5XV0sIFsnQmFja3NsYXNoJywgWzg3MjZdXSwgWydCYXJ2JywgWzEwOTgzXV0sIFsnYmFydmVlJywgWzg4OTNdXSwgWydiYXJ3ZWQnLCBbODk2NV1dLCBbJ0JhcndlZCcsIFs4OTY2XV0sIFsnYmFyd2VkZ2UnLCBbODk2NV1dLCBbJ2JicmsnLCBbOTE0MV1dLCBbJ2Jicmt0YnJrJywgWzkxNDJdXSwgWydiY29uZycsIFs4NzgwXV0sIFsnQmN5JywgWzEwNDFdXSwgWydiY3knLCBbMTA3M11dLCBbJ2JkcXVvJywgWzgyMjJdXSwgWydiZWNhdXMnLCBbODc1N11dLCBbJ2JlY2F1c2UnLCBbODc1N11dLCBbJ0JlY2F1c2UnLCBbODc1N11dLCBbJ2JlbXB0eXYnLCBbMTA2NzJdXSwgWydiZXBzaScsIFsxMDE0XV0sIFsnYmVybm91JywgWzg0OTJdXSwgWydCZXJub3VsbGlzJywgWzg0OTJdXSwgWydCZXRhJywgWzkxNF1dLCBbJ2JldGEnLCBbOTQ2XV0sIFsnYmV0aCcsIFs4NTAyXV0sIFsnYmV0d2VlbicsIFs4ODEyXV0sIFsnQmZyJywgWzEyMDA2OV1dLCBbJ2JmcicsIFsxMjAwOTVdXSwgWydiaWdjYXAnLCBbODg5OF1dLCBbJ2JpZ2NpcmMnLCBbOTcxMV1dLCBbJ2JpZ2N1cCcsIFs4ODk5XV0sIFsnYmlnb2RvdCcsIFsxMDc1Ml1dLCBbJ2JpZ29wbHVzJywgWzEwNzUzXV0sIFsnYmlnb3RpbWVzJywgWzEwNzU0XV0sIFsnYmlnc3FjdXAnLCBbMTA3NThdXSwgWydiaWdzdGFyJywgWzk3MzNdXSwgWydiaWd0cmlhbmdsZWRvd24nLCBbOTY2MV1dLCBbJ2JpZ3RyaWFuZ2xldXAnLCBbOTY1MV1dLCBbJ2JpZ3VwbHVzJywgWzEwNzU2XV0sIFsnYmlndmVlJywgWzg4OTddXSwgWydiaWd3ZWRnZScsIFs4ODk2XV0sIFsnYmthcm93JywgWzEwNTA5XV0sIFsnYmxhY2tsb3plbmdlJywgWzEwNzMxXV0sIFsnYmxhY2tzcXVhcmUnLCBbOTY0Ml1dLCBbJ2JsYWNrdHJpYW5nbGUnLCBbOTY1Ml1dLCBbJ2JsYWNrdHJpYW5nbGVkb3duJywgWzk2NjJdXSwgWydibGFja3RyaWFuZ2xlbGVmdCcsIFs5NjY2XV0sIFsnYmxhY2t0cmlhbmdsZXJpZ2h0JywgWzk2NTZdXSwgWydibGFuaycsIFs5MjUxXV0sIFsnYmxrMTInLCBbOTYxOF1dLCBbJ2JsazE0JywgWzk2MTddXSwgWydibGszNCcsIFs5NjE5XV0sIFsnYmxvY2snLCBbOTYwOF1dLCBbJ2JuZScsIFs2MSwgODQyMV1dLCBbJ2JuZXF1aXYnLCBbODgwMSwgODQyMV1dLCBbJ2JOb3QnLCBbMTA5ODldXSwgWydibm90JywgWzg5NzZdXSwgWydCb3BmJywgWzEyMDEyMV1dLCBbJ2JvcGYnLCBbMTIwMTQ3XV0sIFsnYm90JywgWzg4NjldXSwgWydib3R0b20nLCBbODg2OV1dLCBbJ2Jvd3RpZScsIFs4OTA0XV0sIFsnYm94Ym94JywgWzEwNjk3XV0sIFsnYm94ZGwnLCBbOTQ4OF1dLCBbJ2JveGRMJywgWzk1NTddXSwgWydib3hEbCcsIFs5NTU4XV0sIFsnYm94REwnLCBbOTU1OV1dLCBbJ2JveGRyJywgWzk0ODRdXSwgWydib3hkUicsIFs5NTU0XV0sIFsnYm94RHInLCBbOTU1NV1dLCBbJ2JveERSJywgWzk1NTZdXSwgWydib3hoJywgWzk0NzJdXSwgWydib3hIJywgWzk1NTJdXSwgWydib3hoZCcsIFs5NTE2XV0sIFsnYm94SGQnLCBbOTU3Ml1dLCBbJ2JveGhEJywgWzk1NzNdXSwgWydib3hIRCcsIFs5NTc0XV0sIFsnYm94aHUnLCBbOTUyNF1dLCBbJ2JveEh1JywgWzk1NzVdXSwgWydib3hoVScsIFs5NTc2XV0sIFsnYm94SFUnLCBbOTU3N11dLCBbJ2JveG1pbnVzJywgWzg4NjNdXSwgWydib3hwbHVzJywgWzg4NjJdXSwgWydib3h0aW1lcycsIFs4ODY0XV0sIFsnYm94dWwnLCBbOTQ5Nl1dLCBbJ2JveHVMJywgWzk1NjNdXSwgWydib3hVbCcsIFs5NTY0XV0sIFsnYm94VUwnLCBbOTU2NV1dLCBbJ2JveHVyJywgWzk0OTJdXSwgWydib3h1UicsIFs5NTYwXV0sIFsnYm94VXInLCBbOTU2MV1dLCBbJ2JveFVSJywgWzk1NjJdXSwgWydib3h2JywgWzk0NzRdXSwgWydib3hWJywgWzk1NTNdXSwgWydib3h2aCcsIFs5NTMyXV0sIFsnYm94dkgnLCBbOTU3OF1dLCBbJ2JveFZoJywgWzk1NzldXSwgWydib3hWSCcsIFs5NTgwXV0sIFsnYm94dmwnLCBbOTUwOF1dLCBbJ2JveHZMJywgWzk1NjldXSwgWydib3hWbCcsIFs5NTcwXV0sIFsnYm94VkwnLCBbOTU3MV1dLCBbJ2JveHZyJywgWzk1MDBdXSwgWydib3h2UicsIFs5NTY2XV0sIFsnYm94VnInLCBbOTU2N11dLCBbJ2JveFZSJywgWzk1NjhdXSwgWydicHJpbWUnLCBbODI0NV1dLCBbJ2JyZXZlJywgWzcyOF1dLCBbJ0JyZXZlJywgWzcyOF1dLCBbJ2JydmJhcicsIFsxNjZdXSwgWydic2NyJywgWzExOTk5MV1dLCBbJ0JzY3InLCBbODQ5Ml1dLCBbJ2JzZW1pJywgWzgyNzFdXSwgWydic2ltJywgWzg3NjVdXSwgWydic2ltZScsIFs4OTA5XV0sIFsnYnNvbGInLCBbMTA2OTNdXSwgWydic29sJywgWzkyXV0sIFsnYnNvbGhzdWInLCBbMTAxODRdXSwgWydidWxsJywgWzgyMjZdXSwgWydidWxsZXQnLCBbODIyNl1dLCBbJ2J1bXAnLCBbODc4Ml1dLCBbJ2J1bXBFJywgWzEwOTI2XV0sIFsnYnVtcGUnLCBbODc4M11dLCBbJ0J1bXBlcScsIFs4NzgyXV0sIFsnYnVtcGVxJywgWzg3ODNdXSwgWydDYWN1dGUnLCBbMjYyXV0sIFsnY2FjdXRlJywgWzI2M11dLCBbJ2NhcGFuZCcsIFsxMDgyMF1dLCBbJ2NhcGJyY3VwJywgWzEwODI1XV0sIFsnY2FwY2FwJywgWzEwODI3XV0sIFsnY2FwJywgWzg3NDVdXSwgWydDYXAnLCBbODkxNF1dLCBbJ2NhcGN1cCcsIFsxMDgyM11dLCBbJ2NhcGRvdCcsIFsxMDgxNl1dLCBbJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJywgWzg1MTddXSwgWydjYXBzJywgWzg3NDUsIDY1MDI0XV0sIFsnY2FyZXQnLCBbODI1N11dLCBbJ2Nhcm9uJywgWzcxMV1dLCBbJ0NheWxleXMnLCBbODQ5M11dLCBbJ2NjYXBzJywgWzEwODI5XV0sIFsnQ2Nhcm9uJywgWzI2OF1dLCBbJ2NjYXJvbicsIFsyNjldXSwgWydDY2VkaWwnLCBbMTk5XV0sIFsnY2NlZGlsJywgWzIzMV1dLCBbJ0NjaXJjJywgWzI2NF1dLCBbJ2NjaXJjJywgWzI2NV1dLCBbJ0Njb25pbnQnLCBbODc1Ml1dLCBbJ2NjdXBzJywgWzEwODI4XV0sIFsnY2N1cHNzbScsIFsxMDgzMl1dLCBbJ0Nkb3QnLCBbMjY2XV0sIFsnY2RvdCcsIFsyNjddXSwgWydjZWRpbCcsIFsxODRdXSwgWydDZWRpbGxhJywgWzE4NF1dLCBbJ2NlbXB0eXYnLCBbMTA2NzRdXSwgWydjZW50JywgWzE2Ml1dLCBbJ2NlbnRlcmRvdCcsIFsxODNdXSwgWydDZW50ZXJEb3QnLCBbMTgzXV0sIFsnY2ZyJywgWzEyMDA5Nl1dLCBbJ0NmcicsIFs4NDkzXV0sIFsnQ0hjeScsIFsxMDYzXV0sIFsnY2hjeScsIFsxMDk1XV0sIFsnY2hlY2snLCBbMTAwMDNdXSwgWydjaGVja21hcmsnLCBbMTAwMDNdXSwgWydDaGknLCBbOTM1XV0sIFsnY2hpJywgWzk2N11dLCBbJ2NpcmMnLCBbNzEwXV0sIFsnY2lyY2VxJywgWzg3OTFdXSwgWydjaXJjbGVhcnJvd2xlZnQnLCBbODYzNF1dLCBbJ2NpcmNsZWFycm93cmlnaHQnLCBbODYzNV1dLCBbJ2NpcmNsZWRhc3QnLCBbODg1OV1dLCBbJ2NpcmNsZWRjaXJjJywgWzg4NThdXSwgWydjaXJjbGVkZGFzaCcsIFs4ODYxXV0sIFsnQ2lyY2xlRG90JywgWzg4NTddXSwgWydjaXJjbGVkUicsIFsxNzRdXSwgWydjaXJjbGVkUycsIFs5NDE2XV0sIFsnQ2lyY2xlTWludXMnLCBbODg1NF1dLCBbJ0NpcmNsZVBsdXMnLCBbODg1M11dLCBbJ0NpcmNsZVRpbWVzJywgWzg4NTVdXSwgWydjaXInLCBbOTY3NV1dLCBbJ2NpckUnLCBbMTA2OTFdXSwgWydjaXJlJywgWzg3OTFdXSwgWydjaXJmbmludCcsIFsxMDc2OF1dLCBbJ2Npcm1pZCcsIFsxMDk5MV1dLCBbJ2NpcnNjaXInLCBbMTA2OTBdXSwgWydDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NF1dLCBbJ2NsdWJzJywgWzk4MjddXSwgWydjbHVic3VpdCcsIFs5ODI3XV0sIFsnY29sb24nLCBbNThdXSwgWydDb2xvbicsIFs4NzU5XV0sIFsnQ29sb25lJywgWzEwODY4XV0sIFsnY29sb25lJywgWzg3ODhdXSwgWydjb2xvbmVxJywgWzg3ODhdXSwgWydjb21tYScsIFs0NF1dLCBbJ2NvbW1hdCcsIFs2NF1dLCBbJ2NvbXAnLCBbODcwNV1dLCBbJ2NvbXBmbicsIFs4NzI4XV0sIFsnY29tcGxlbWVudCcsIFs4NzA1XV0sIFsnY29tcGxleGVzJywgWzg0NTBdXSwgWydjb25nJywgWzg3NzNdXSwgWydjb25nZG90JywgWzEwODYxXV0sIFsnQ29uZ3J1ZW50JywgWzg4MDFdXSwgWydjb25pbnQnLCBbODc1MF1dLCBbJ0NvbmludCcsIFs4NzUxXV0sIFsnQ29udG91ckludGVncmFsJywgWzg3NTBdXSwgWydjb3BmJywgWzEyMDE0OF1dLCBbJ0NvcGYnLCBbODQ1MF1dLCBbJ2NvcHJvZCcsIFs4NzIwXV0sIFsnQ29wcm9kdWN0JywgWzg3MjBdXSwgWydjb3B5JywgWzE2OV1dLCBbJ0NPUFknLCBbMTY5XV0sIFsnY29weXNyJywgWzg0NzFdXSwgWydDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTVdXSwgWydjcmFycicsIFs4NjI5XV0sIFsnY3Jvc3MnLCBbMTAwMDddXSwgWydDcm9zcycsIFsxMDc5OV1dLCBbJ0NzY3InLCBbMTE5OTY2XV0sIFsnY3NjcicsIFsxMTk5OTJdXSwgWydjc3ViJywgWzEwOTU5XV0sIFsnY3N1YmUnLCBbMTA5NjFdXSwgWydjc3VwJywgWzEwOTYwXV0sIFsnY3N1cGUnLCBbMTA5NjJdXSwgWydjdGRvdCcsIFs4OTQzXV0sIFsnY3VkYXJybCcsIFsxMDU1Ml1dLCBbJ2N1ZGFycnInLCBbMTA1NDldXSwgWydjdWVwcicsIFs4OTI2XV0sIFsnY3Vlc2MnLCBbODkyN11dLCBbJ2N1bGFycicsIFs4NjMwXV0sIFsnY3VsYXJycCcsIFsxMDU1N11dLCBbJ2N1cGJyY2FwJywgWzEwODI0XV0sIFsnY3VwY2FwJywgWzEwODIyXV0sIFsnQ3VwQ2FwJywgWzg3ODFdXSwgWydjdXAnLCBbODc0Nl1dLCBbJ0N1cCcsIFs4OTE1XV0sIFsnY3VwY3VwJywgWzEwODI2XV0sIFsnY3VwZG90JywgWzg4NDVdXSwgWydjdXBvcicsIFsxMDgyMV1dLCBbJ2N1cHMnLCBbODc0NiwgNjUwMjRdXSwgWydjdXJhcnInLCBbODYzMV1dLCBbJ2N1cmFycm0nLCBbMTA1NTZdXSwgWydjdXJseWVxcHJlYycsIFs4OTI2XV0sIFsnY3VybHllcXN1Y2MnLCBbODkyN11dLCBbJ2N1cmx5dmVlJywgWzg5MTBdXSwgWydjdXJseXdlZGdlJywgWzg5MTFdXSwgWydjdXJyZW4nLCBbMTY0XV0sIFsnY3VydmVhcnJvd2xlZnQnLCBbODYzMF1dLCBbJ2N1cnZlYXJyb3dyaWdodCcsIFs4NjMxXV0sIFsnY3V2ZWUnLCBbODkxMF1dLCBbJ2N1d2VkJywgWzg5MTFdXSwgWydjd2NvbmludCcsIFs4NzU0XV0sIFsnY3dpbnQnLCBbODc1M11dLCBbJ2N5bGN0eScsIFs5MDA1XV0sIFsnZGFnZ2VyJywgWzgyMjRdXSwgWydEYWdnZXInLCBbODIyNV1dLCBbJ2RhbGV0aCcsIFs4NTA0XV0sIFsnZGFycicsIFs4NTk1XV0sIFsnRGFycicsIFs4NjA5XV0sIFsnZEFycicsIFs4NjU5XV0sIFsnZGFzaCcsIFs4MjA4XV0sIFsnRGFzaHYnLCBbMTA5ODBdXSwgWydkYXNodicsIFs4ODY3XV0sIFsnZGJrYXJvdycsIFsxMDUxMV1dLCBbJ2RibGFjJywgWzczM11dLCBbJ0RjYXJvbicsIFsyNzBdXSwgWydkY2Fyb24nLCBbMjcxXV0sIFsnRGN5JywgWzEwNDRdXSwgWydkY3knLCBbMTA3Nl1dLCBbJ2RkYWdnZXInLCBbODIyNV1dLCBbJ2RkYXJyJywgWzg2NTBdXSwgWydERCcsIFs4NTE3XV0sIFsnZGQnLCBbODUxOF1dLCBbJ0REb3RyYWhkJywgWzEwNTEzXV0sIFsnZGRvdHNlcScsIFsxMDg3MV1dLCBbJ2RlZycsIFsxNzZdXSwgWydEZWwnLCBbODcxMV1dLCBbJ0RlbHRhJywgWzkxNl1dLCBbJ2RlbHRhJywgWzk0OF1dLCBbJ2RlbXB0eXYnLCBbMTA2NzNdXSwgWydkZmlzaHQnLCBbMTA2MjNdXSwgWydEZnInLCBbMTIwMDcxXV0sIFsnZGZyJywgWzEyMDA5N11dLCBbJ2RIYXInLCBbMTA1OTddXSwgWydkaGFybCcsIFs4NjQzXV0sIFsnZGhhcnInLCBbODY0Ml1dLCBbJ0RpYWNyaXRpY2FsQWN1dGUnLCBbMTgwXV0sIFsnRGlhY3JpdGljYWxEb3QnLCBbNzI5XV0sIFsnRGlhY3JpdGljYWxEb3VibGVBY3V0ZScsIFs3MzNdXSwgWydEaWFjcml0aWNhbEdyYXZlJywgWzk2XV0sIFsnRGlhY3JpdGljYWxUaWxkZScsIFs3MzJdXSwgWydkaWFtJywgWzg5MDBdXSwgWydkaWFtb25kJywgWzg5MDBdXSwgWydEaWFtb25kJywgWzg5MDBdXSwgWydkaWFtb25kc3VpdCcsIFs5ODMwXV0sIFsnZGlhbXMnLCBbOTgzMF1dLCBbJ2RpZScsIFsxNjhdXSwgWydEaWZmZXJlbnRpYWxEJywgWzg1MThdXSwgWydkaWdhbW1hJywgWzk4OV1dLCBbJ2Rpc2luJywgWzg5NDZdXSwgWydkaXYnLCBbMjQ3XV0sIFsnZGl2aWRlJywgWzI0N11dLCBbJ2RpdmlkZW9udGltZXMnLCBbODkwM11dLCBbJ2Rpdm9ueCcsIFs4OTAzXV0sIFsnREpjeScsIFsxMDI2XV0sIFsnZGpjeScsIFsxMTA2XV0sIFsnZGxjb3JuJywgWzg5OTBdXSwgWydkbGNyb3AnLCBbODk3M11dLCBbJ2RvbGxhcicsIFszNl1dLCBbJ0RvcGYnLCBbMTIwMTIzXV0sIFsnZG9wZicsIFsxMjAxNDldXSwgWydEb3QnLCBbMTY4XV0sIFsnZG90JywgWzcyOV1dLCBbJ0RvdERvdCcsIFs4NDEyXV0sIFsnZG90ZXEnLCBbODc4NF1dLCBbJ2RvdGVxZG90JywgWzg3ODVdXSwgWydEb3RFcXVhbCcsIFs4Nzg0XV0sIFsnZG90bWludXMnLCBbODc2MF1dLCBbJ2RvdHBsdXMnLCBbODcyNF1dLCBbJ2RvdHNxdWFyZScsIFs4ODY1XV0sIFsnZG91YmxlYmFyd2VkZ2UnLCBbODk2Nl1dLCBbJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzUxXV0sIFsnRG91YmxlRG90JywgWzE2OF1dLCBbJ0RvdWJsZURvd25BcnJvdycsIFs4NjU5XV0sIFsnRG91YmxlTGVmdEFycm93JywgWzg2NTZdXSwgWydEb3VibGVMZWZ0UmlnaHRBcnJvdycsIFs4NjYwXV0sIFsnRG91YmxlTGVmdFRlZScsIFsxMDk4MF1dLCBbJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnLCBbMTAyMzJdXSwgWydEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzRdXSwgWydEb3VibGVMb25nUmlnaHRBcnJvdycsIFsxMDIzM11dLCBbJ0RvdWJsZVJpZ2h0QXJyb3cnLCBbODY1OF1dLCBbJ0RvdWJsZVJpZ2h0VGVlJywgWzg4NzJdXSwgWydEb3VibGVVcEFycm93JywgWzg2NTddXSwgWydEb3VibGVVcERvd25BcnJvdycsIFs4NjYxXV0sIFsnRG91YmxlVmVydGljYWxCYXInLCBbODc0MV1dLCBbJ0Rvd25BcnJvd0JhcicsIFsxMDUxNV1dLCBbJ2Rvd25hcnJvdycsIFs4NTk1XV0sIFsnRG93bkFycm93JywgWzg1OTVdXSwgWydEb3duYXJyb3cnLCBbODY1OV1dLCBbJ0Rvd25BcnJvd1VwQXJyb3cnLCBbODY5M11dLCBbJ0Rvd25CcmV2ZScsIFs3ODVdXSwgWydkb3duZG93bmFycm93cycsIFs4NjUwXV0sIFsnZG93bmhhcnBvb25sZWZ0JywgWzg2NDNdXSwgWydkb3duaGFycG9vbnJpZ2h0JywgWzg2NDJdXSwgWydEb3duTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc2XV0sIFsnRG93bkxlZnRUZWVWZWN0b3InLCBbMTA1OTBdXSwgWydEb3duTGVmdFZlY3RvckJhcicsIFsxMDU4Ml1dLCBbJ0Rvd25MZWZ0VmVjdG9yJywgWzg2MzddXSwgWydEb3duUmlnaHRUZWVWZWN0b3InLCBbMTA1OTFdXSwgWydEb3duUmlnaHRWZWN0b3JCYXInLCBbMTA1ODNdXSwgWydEb3duUmlnaHRWZWN0b3InLCBbODY0MV1dLCBbJ0Rvd25UZWVBcnJvdycsIFs4NjE1XV0sIFsnRG93blRlZScsIFs4ODY4XV0sIFsnZHJia2Fyb3cnLCBbMTA1MTJdXSwgWydkcmNvcm4nLCBbODk5MV1dLCBbJ2RyY3JvcCcsIFs4OTcyXV0sIFsnRHNjcicsIFsxMTk5NjddXSwgWydkc2NyJywgWzExOTk5M11dLCBbJ0RTY3knLCBbMTAyOV1dLCBbJ2RzY3knLCBbMTEwOV1dLCBbJ2Rzb2wnLCBbMTA3NDJdXSwgWydEc3Ryb2snLCBbMjcyXV0sIFsnZHN0cm9rJywgWzI3M11dLCBbJ2R0ZG90JywgWzg5NDVdXSwgWydkdHJpJywgWzk2NjNdXSwgWydkdHJpZicsIFs5NjYyXV0sIFsnZHVhcnInLCBbODY5M11dLCBbJ2R1aGFyJywgWzEwNjA3XV0sIFsnZHdhbmdsZScsIFsxMDY2Ml1dLCBbJ0RaY3knLCBbMTAzOV1dLCBbJ2R6Y3knLCBbMTExOV1dLCBbJ2R6aWdyYXJyJywgWzEwMjM5XV0sIFsnRWFjdXRlJywgWzIwMV1dLCBbJ2VhY3V0ZScsIFsyMzNdXSwgWydlYXN0ZXInLCBbMTA4NjJdXSwgWydFY2Fyb24nLCBbMjgyXV0sIFsnZWNhcm9uJywgWzI4M11dLCBbJ0VjaXJjJywgWzIwMl1dLCBbJ2VjaXJjJywgWzIzNF1dLCBbJ2VjaXInLCBbODc5MF1dLCBbJ2Vjb2xvbicsIFs4Nzg5XV0sIFsnRWN5JywgWzEwNjldXSwgWydlY3knLCBbMTEwMV1dLCBbJ2VERG90JywgWzEwODcxXV0sIFsnRWRvdCcsIFsyNzhdXSwgWydlZG90JywgWzI3OV1dLCBbJ2VEb3QnLCBbODc4NV1dLCBbJ2VlJywgWzg1MTldXSwgWydlZkRvdCcsIFs4Nzg2XV0sIFsnRWZyJywgWzEyMDA3Ml1dLCBbJ2VmcicsIFsxMjAwOThdXSwgWydlZycsIFsxMDkwNl1dLCBbJ0VncmF2ZScsIFsyMDBdXSwgWydlZ3JhdmUnLCBbMjMyXV0sIFsnZWdzJywgWzEwOTAyXV0sIFsnZWdzZG90JywgWzEwOTA0XV0sIFsnZWwnLCBbMTA5MDVdXSwgWydFbGVtZW50JywgWzg3MTJdXSwgWydlbGludGVycycsIFs5MTkxXV0sIFsnZWxsJywgWzg0NjddXSwgWydlbHMnLCBbMTA5MDFdXSwgWydlbHNkb3QnLCBbMTA5MDNdXSwgWydFbWFjcicsIFsyNzRdXSwgWydlbWFjcicsIFsyNzVdXSwgWydlbXB0eScsIFs4NzA5XV0sIFsnZW1wdHlzZXQnLCBbODcwOV1dLCBbJ0VtcHR5U21hbGxTcXVhcmUnLCBbOTcyM11dLCBbJ2VtcHR5dicsIFs4NzA5XV0sIFsnRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCBbOTY0M11dLCBbJ2Vtc3AxMycsIFs4MTk2XV0sIFsnZW1zcDE0JywgWzgxOTddXSwgWydlbXNwJywgWzgxOTVdXSwgWydFTkcnLCBbMzMwXV0sIFsnZW5nJywgWzMzMV1dLCBbJ2Vuc3AnLCBbODE5NF1dLCBbJ0VvZ29uJywgWzI4MF1dLCBbJ2VvZ29uJywgWzI4MV1dLCBbJ0VvcGYnLCBbMTIwMTI0XV0sIFsnZW9wZicsIFsxMjAxNTBdXSwgWydlcGFyJywgWzg5MTddXSwgWydlcGFyc2wnLCBbMTA3MjNdXSwgWydlcGx1cycsIFsxMDg2NV1dLCBbJ2Vwc2knLCBbOTQ5XV0sIFsnRXBzaWxvbicsIFs5MTddXSwgWydlcHNpbG9uJywgWzk0OV1dLCBbJ2Vwc2l2JywgWzEwMTNdXSwgWydlcWNpcmMnLCBbODc5MF1dLCBbJ2VxY29sb24nLCBbODc4OV1dLCBbJ2Vxc2ltJywgWzg3NzBdXSwgWydlcXNsYW50Z3RyJywgWzEwOTAyXV0sIFsnZXFzbGFudGxlc3MnLCBbMTA5MDFdXSwgWydFcXVhbCcsIFsxMDg2OV1dLCBbJ2VxdWFscycsIFs2MV1dLCBbJ0VxdWFsVGlsZGUnLCBbODc3MF1dLCBbJ2VxdWVzdCcsIFs4Nzk5XV0sIFsnRXF1aWxpYnJpdW0nLCBbODY1Ml1dLCBbJ2VxdWl2JywgWzg4MDFdXSwgWydlcXVpdkREJywgWzEwODcyXV0sIFsnZXF2cGFyc2wnLCBbMTA3MjVdXSwgWydlcmFycicsIFsxMDYwOV1dLCBbJ2VyRG90JywgWzg3ODddXSwgWydlc2NyJywgWzg0OTVdXSwgWydFc2NyJywgWzg0OTZdXSwgWydlc2RvdCcsIFs4Nzg0XV0sIFsnRXNpbScsIFsxMDg2N11dLCBbJ2VzaW0nLCBbODc3MF1dLCBbJ0V0YScsIFs5MTldXSwgWydldGEnLCBbOTUxXV0sIFsnRVRIJywgWzIwOF1dLCBbJ2V0aCcsIFsyNDBdXSwgWydFdW1sJywgWzIwM11dLCBbJ2V1bWwnLCBbMjM1XV0sIFsnZXVybycsIFs4MzY0XV0sIFsnZXhjbCcsIFszM11dLCBbJ2V4aXN0JywgWzg3MDddXSwgWydFeGlzdHMnLCBbODcwN11dLCBbJ2V4cGVjdGF0aW9uJywgWzg0OTZdXSwgWydleHBvbmVudGlhbGUnLCBbODUxOV1dLCBbJ0V4cG9uZW50aWFsRScsIFs4NTE5XV0sIFsnZmFsbGluZ2RvdHNlcScsIFs4Nzg2XV0sIFsnRmN5JywgWzEwNjBdXSwgWydmY3knLCBbMTA5Ml1dLCBbJ2ZlbWFsZScsIFs5NzkyXV0sIFsnZmZpbGlnJywgWzY0MjU5XV0sIFsnZmZsaWcnLCBbNjQyNTZdXSwgWydmZmxsaWcnLCBbNjQyNjBdXSwgWydGZnInLCBbMTIwMDczXV0sIFsnZmZyJywgWzEyMDA5OV1dLCBbJ2ZpbGlnJywgWzY0MjU3XV0sIFsnRmlsbGVkU21hbGxTcXVhcmUnLCBbOTcyNF1dLCBbJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZScsIFs5NjQyXV0sIFsnZmpsaWcnLCBbMTAyLCAxMDZdXSwgWydmbGF0JywgWzk4MzddXSwgWydmbGxpZycsIFs2NDI1OF1dLCBbJ2ZsdG5zJywgWzk2NDldXSwgWydmbm9mJywgWzQwMl1dLCBbJ0ZvcGYnLCBbMTIwMTI1XV0sIFsnZm9wZicsIFsxMjAxNTFdXSwgWydmb3JhbGwnLCBbODcwNF1dLCBbJ0ZvckFsbCcsIFs4NzA0XV0sIFsnZm9yaycsIFs4OTE2XV0sIFsnZm9ya3YnLCBbMTA5NjldXSwgWydGb3VyaWVydHJmJywgWzg0OTddXSwgWydmcGFydGludCcsIFsxMDc2NV1dLCBbJ2ZyYWMxMicsIFsxODldXSwgWydmcmFjMTMnLCBbODUzMV1dLCBbJ2ZyYWMxNCcsIFsxODhdXSwgWydmcmFjMTUnLCBbODUzM11dLCBbJ2ZyYWMxNicsIFs4NTM3XV0sIFsnZnJhYzE4JywgWzg1MzldXSwgWydmcmFjMjMnLCBbODUzMl1dLCBbJ2ZyYWMyNScsIFs4NTM0XV0sIFsnZnJhYzM0JywgWzE5MF1dLCBbJ2ZyYWMzNScsIFs4NTM1XV0sIFsnZnJhYzM4JywgWzg1NDBdXSwgWydmcmFjNDUnLCBbODUzNl1dLCBbJ2ZyYWM1NicsIFs4NTM4XV0sIFsnZnJhYzU4JywgWzg1NDFdXSwgWydmcmFjNzgnLCBbODU0Ml1dLCBbJ2ZyYXNsJywgWzgyNjBdXSwgWydmcm93bicsIFs4OTk0XV0sIFsnZnNjcicsIFsxMTk5OTVdXSwgWydGc2NyJywgWzg0OTddXSwgWydnYWN1dGUnLCBbNTAxXV0sIFsnR2FtbWEnLCBbOTE1XV0sIFsnZ2FtbWEnLCBbOTQ3XV0sIFsnR2FtbWFkJywgWzk4OF1dLCBbJ2dhbW1hZCcsIFs5ODldXSwgWydnYXAnLCBbMTA4ODZdXSwgWydHYnJldmUnLCBbMjg2XV0sIFsnZ2JyZXZlJywgWzI4N11dLCBbJ0djZWRpbCcsIFsyOTBdXSwgWydHY2lyYycsIFsyODRdXSwgWydnY2lyYycsIFsyODVdXSwgWydHY3knLCBbMTA0M11dLCBbJ2djeScsIFsxMDc1XV0sIFsnR2RvdCcsIFsyODhdXSwgWydnZG90JywgWzI4OV1dLCBbJ2dlJywgWzg4MDVdXSwgWydnRScsIFs4ODA3XV0sIFsnZ0VsJywgWzEwODkyXV0sIFsnZ2VsJywgWzg5MjNdXSwgWydnZXEnLCBbODgwNV1dLCBbJ2dlcXEnLCBbODgwN11dLCBbJ2dlcXNsYW50JywgWzEwODc4XV0sIFsnZ2VzY2MnLCBbMTA5MjFdXSwgWydnZXMnLCBbMTA4NzhdXSwgWydnZXNkb3QnLCBbMTA4ODBdXSwgWydnZXNkb3RvJywgWzEwODgyXV0sIFsnZ2VzZG90b2wnLCBbMTA4ODRdXSwgWydnZXNsJywgWzg5MjMsIDY1MDI0XV0sIFsnZ2VzbGVzJywgWzEwOTAwXV0sIFsnR2ZyJywgWzEyMDA3NF1dLCBbJ2dmcicsIFsxMjAxMDBdXSwgWydnZycsIFs4ODExXV0sIFsnR2cnLCBbODkyMV1dLCBbJ2dnZycsIFs4OTIxXV0sIFsnZ2ltZWwnLCBbODUwM11dLCBbJ0dKY3knLCBbMTAyN11dLCBbJ2dqY3knLCBbMTEwN11dLCBbJ2dsYScsIFsxMDkxN11dLCBbJ2dsJywgWzg4MjNdXSwgWydnbEUnLCBbMTA4OThdXSwgWydnbGonLCBbMTA5MTZdXSwgWydnbmFwJywgWzEwODkwXV0sIFsnZ25hcHByb3gnLCBbMTA4OTBdXSwgWydnbmUnLCBbMTA4ODhdXSwgWydnbkUnLCBbODgwOV1dLCBbJ2duZXEnLCBbMTA4ODhdXSwgWydnbmVxcScsIFs4ODA5XV0sIFsnZ25zaW0nLCBbODkzNV1dLCBbJ0dvcGYnLCBbMTIwMTI2XV0sIFsnZ29wZicsIFsxMjAxNTJdXSwgWydncmF2ZScsIFs5Nl1dLCBbJ0dyZWF0ZXJFcXVhbCcsIFs4ODA1XV0sIFsnR3JlYXRlckVxdWFsTGVzcycsIFs4OTIzXV0sIFsnR3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3XV0sIFsnR3JlYXRlckdyZWF0ZXInLCBbMTA5MTRdXSwgWydHcmVhdGVyTGVzcycsIFs4ODIzXV0sIFsnR3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzhdXSwgWydHcmVhdGVyVGlsZGUnLCBbODgxOV1dLCBbJ0dzY3InLCBbMTE5OTcwXV0sIFsnZ3NjcicsIFs4NDU4XV0sIFsnZ3NpbScsIFs4ODE5XV0sIFsnZ3NpbWUnLCBbMTA4OTRdXSwgWydnc2ltbCcsIFsxMDg5Nl1dLCBbJ2d0Y2MnLCBbMTA5MTldXSwgWydndGNpcicsIFsxMDg3NF1dLCBbJ2d0JywgWzYyXV0sIFsnR1QnLCBbNjJdXSwgWydHdCcsIFs4ODExXV0sIFsnZ3Rkb3QnLCBbODkxOV1dLCBbJ2d0bFBhcicsIFsxMDY0NV1dLCBbJ2d0cXVlc3QnLCBbMTA4NzZdXSwgWydndHJhcHByb3gnLCBbMTA4ODZdXSwgWydndHJhcnInLCBbMTA2MTZdXSwgWydndHJkb3QnLCBbODkxOV1dLCBbJ2d0cmVxbGVzcycsIFs4OTIzXV0sIFsnZ3RyZXFxbGVzcycsIFsxMDg5Ml1dLCBbJ2d0cmxlc3MnLCBbODgyM11dLCBbJ2d0cnNpbScsIFs4ODE5XV0sIFsnZ3ZlcnRuZXFxJywgWzg4MDksIDY1MDI0XV0sIFsnZ3ZuRScsIFs4ODA5LCA2NTAyNF1dLCBbJ0hhY2VrJywgWzcxMV1dLCBbJ2hhaXJzcCcsIFs4MjAyXV0sIFsnaGFsZicsIFsxODldXSwgWydoYW1pbHQnLCBbODQ1OV1dLCBbJ0hBUkRjeScsIFsxMDY2XV0sIFsnaGFyZGN5JywgWzEwOThdXSwgWydoYXJyY2lyJywgWzEwNTY4XV0sIFsnaGFycicsIFs4NTk2XV0sIFsnaEFycicsIFs4NjYwXV0sIFsnaGFycncnLCBbODYyMV1dLCBbJ0hhdCcsIFs5NF1dLCBbJ2hiYXInLCBbODQ2M11dLCBbJ0hjaXJjJywgWzI5Ml1dLCBbJ2hjaXJjJywgWzI5M11dLCBbJ2hlYXJ0cycsIFs5ODI5XV0sIFsnaGVhcnRzdWl0JywgWzk4MjldXSwgWydoZWxsaXAnLCBbODIzMF1dLCBbJ2hlcmNvbicsIFs4ODg5XV0sIFsnaGZyJywgWzEyMDEwMV1dLCBbJ0hmcicsIFs4NDYwXV0sIFsnSGlsYmVydFNwYWNlJywgWzg0NTldXSwgWydoa3NlYXJvdycsIFsxMDUzM11dLCBbJ2hrc3dhcm93JywgWzEwNTM0XV0sIFsnaG9hcnInLCBbODcwM11dLCBbJ2hvbXRodCcsIFs4NzYzXV0sIFsnaG9va2xlZnRhcnJvdycsIFs4NjE3XV0sIFsnaG9va3JpZ2h0YXJyb3cnLCBbODYxOF1dLCBbJ2hvcGYnLCBbMTIwMTUzXV0sIFsnSG9wZicsIFs4NDYxXV0sIFsnaG9yYmFyJywgWzgyMTNdXSwgWydIb3Jpem9udGFsTGluZScsIFs5NDcyXV0sIFsnaHNjcicsIFsxMTk5OTddXSwgWydIc2NyJywgWzg0NTldXSwgWydoc2xhc2gnLCBbODQ2M11dLCBbJ0hzdHJvaycsIFsyOTRdXSwgWydoc3Ryb2snLCBbMjk1XV0sIFsnSHVtcERvd25IdW1wJywgWzg3ODJdXSwgWydIdW1wRXF1YWwnLCBbODc4M11dLCBbJ2h5YnVsbCcsIFs4MjU5XV0sIFsnaHlwaGVuJywgWzgyMDhdXSwgWydJYWN1dGUnLCBbMjA1XV0sIFsnaWFjdXRlJywgWzIzN11dLCBbJ2ljJywgWzgyOTFdXSwgWydJY2lyYycsIFsyMDZdXSwgWydpY2lyYycsIFsyMzhdXSwgWydJY3knLCBbMTA0OF1dLCBbJ2ljeScsIFsxMDgwXV0sIFsnSWRvdCcsIFszMDRdXSwgWydJRWN5JywgWzEwNDVdXSwgWydpZWN5JywgWzEwNzddXSwgWydpZXhjbCcsIFsxNjFdXSwgWydpZmYnLCBbODY2MF1dLCBbJ2lmcicsIFsxMjAxMDJdXSwgWydJZnInLCBbODQ2NV1dLCBbJ0lncmF2ZScsIFsyMDRdXSwgWydpZ3JhdmUnLCBbMjM2XV0sIFsnaWknLCBbODUyMF1dLCBbJ2lpaWludCcsIFsxMDc2NF1dLCBbJ2lpaW50JywgWzg3NDldXSwgWydpaW5maW4nLCBbMTA3MTZdXSwgWydpaW90YScsIFs4NDg5XV0sIFsnSUpsaWcnLCBbMzA2XV0sIFsnaWpsaWcnLCBbMzA3XV0sIFsnSW1hY3InLCBbMjk4XV0sIFsnaW1hY3InLCBbMjk5XV0sIFsnaW1hZ2UnLCBbODQ2NV1dLCBbJ0ltYWdpbmFyeUknLCBbODUyMF1dLCBbJ2ltYWdsaW5lJywgWzg0NjRdXSwgWydpbWFncGFydCcsIFs4NDY1XV0sIFsnaW1hdGgnLCBbMzA1XV0sIFsnSW0nLCBbODQ2NV1dLCBbJ2ltb2YnLCBbODg4N11dLCBbJ2ltcGVkJywgWzQzN11dLCBbJ0ltcGxpZXMnLCBbODY1OF1dLCBbJ2luY2FyZScsIFs4NDUzXV0sIFsnaW4nLCBbODcxMl1dLCBbJ2luZmluJywgWzg3MzRdXSwgWydpbmZpbnRpZScsIFsxMDcxN11dLCBbJ2lub2RvdCcsIFszMDVdXSwgWydpbnRjYWwnLCBbODg5MF1dLCBbJ2ludCcsIFs4NzQ3XV0sIFsnSW50JywgWzg3NDhdXSwgWydpbnRlZ2VycycsIFs4NDg0XV0sIFsnSW50ZWdyYWwnLCBbODc0N11dLCBbJ2ludGVyY2FsJywgWzg4OTBdXSwgWydJbnRlcnNlY3Rpb24nLCBbODg5OF1dLCBbJ2ludGxhcmhrJywgWzEwNzc1XV0sIFsnaW50cHJvZCcsIFsxMDgxMl1dLCBbJ0ludmlzaWJsZUNvbW1hJywgWzgyOTFdXSwgWydJbnZpc2libGVUaW1lcycsIFs4MjkwXV0sIFsnSU9jeScsIFsxMDI1XV0sIFsnaW9jeScsIFsxMTA1XV0sIFsnSW9nb24nLCBbMzAyXV0sIFsnaW9nb24nLCBbMzAzXV0sIFsnSW9wZicsIFsxMjAxMjhdXSwgWydpb3BmJywgWzEyMDE1NF1dLCBbJ0lvdGEnLCBbOTIxXV0sIFsnaW90YScsIFs5NTNdXSwgWydpcHJvZCcsIFsxMDgxMl1dLCBbJ2lxdWVzdCcsIFsxOTFdXSwgWydpc2NyJywgWzExOTk5OF1dLCBbJ0lzY3InLCBbODQ2NF1dLCBbJ2lzaW4nLCBbODcxMl1dLCBbJ2lzaW5kb3QnLCBbODk0OV1dLCBbJ2lzaW5FJywgWzg5NTNdXSwgWydpc2lucycsIFs4OTQ4XV0sIFsnaXNpbnN2JywgWzg5NDddXSwgWydpc2ludicsIFs4NzEyXV0sIFsnaXQnLCBbODI5MF1dLCBbJ0l0aWxkZScsIFsyOTZdXSwgWydpdGlsZGUnLCBbMjk3XV0sIFsnSXVrY3knLCBbMTAzMF1dLCBbJ2l1a2N5JywgWzExMTBdXSwgWydJdW1sJywgWzIwN11dLCBbJ2l1bWwnLCBbMjM5XV0sIFsnSmNpcmMnLCBbMzA4XV0sIFsnamNpcmMnLCBbMzA5XV0sIFsnSmN5JywgWzEwNDldXSwgWydqY3knLCBbMTA4MV1dLCBbJ0pmcicsIFsxMjAwNzddXSwgWydqZnInLCBbMTIwMTAzXV0sIFsnam1hdGgnLCBbNTY3XV0sIFsnSm9wZicsIFsxMjAxMjldXSwgWydqb3BmJywgWzEyMDE1NV1dLCBbJ0pzY3InLCBbMTE5OTczXV0sIFsnanNjcicsIFsxMTk5OTldXSwgWydKc2VyY3knLCBbMTAzMl1dLCBbJ2pzZXJjeScsIFsxMTEyXV0sIFsnSnVrY3knLCBbMTAyOF1dLCBbJ2p1a2N5JywgWzExMDhdXSwgWydLYXBwYScsIFs5MjJdXSwgWydrYXBwYScsIFs5NTRdXSwgWydrYXBwYXYnLCBbMTAwOF1dLCBbJ0tjZWRpbCcsIFszMTBdXSwgWydrY2VkaWwnLCBbMzExXV0sIFsnS2N5JywgWzEwNTBdXSwgWydrY3knLCBbMTA4Ml1dLCBbJ0tmcicsIFsxMjAwNzhdXSwgWydrZnInLCBbMTIwMTA0XV0sIFsna2dyZWVuJywgWzMxMl1dLCBbJ0tIY3knLCBbMTA2MV1dLCBbJ2toY3knLCBbMTA5M11dLCBbJ0tKY3knLCBbMTAzNl1dLCBbJ2tqY3knLCBbMTExNl1dLCBbJ0tvcGYnLCBbMTIwMTMwXV0sIFsna29wZicsIFsxMjAxNTZdXSwgWydLc2NyJywgWzExOTk3NF1dLCBbJ2tzY3InLCBbMTIwMDAwXV0sIFsnbEFhcnInLCBbODY2Nl1dLCBbJ0xhY3V0ZScsIFszMTNdXSwgWydsYWN1dGUnLCBbMzE0XV0sIFsnbGFlbXB0eXYnLCBbMTA2NzZdXSwgWydsYWdyYW4nLCBbODQ2Nl1dLCBbJ0xhbWJkYScsIFs5MjNdXSwgWydsYW1iZGEnLCBbOTU1XV0sIFsnbGFuZycsIFsxMDIxNl1dLCBbJ0xhbmcnLCBbMTAyMThdXSwgWydsYW5nZCcsIFsxMDY0MV1dLCBbJ2xhbmdsZScsIFsxMDIxNl1dLCBbJ2xhcCcsIFsxMDg4NV1dLCBbJ0xhcGxhY2V0cmYnLCBbODQ2Nl1dLCBbJ2xhcXVvJywgWzE3MV1dLCBbJ2xhcnJiJywgWzg2NzZdXSwgWydsYXJyYmZzJywgWzEwNTI3XV0sIFsnbGFycicsIFs4NTkyXV0sIFsnTGFycicsIFs4NjA2XV0sIFsnbEFycicsIFs4NjU2XV0sIFsnbGFycmZzJywgWzEwNTI1XV0sIFsnbGFycmhrJywgWzg2MTddXSwgWydsYXJybHAnLCBbODYxOV1dLCBbJ2xhcnJwbCcsIFsxMDU1M11dLCBbJ2xhcnJzaW0nLCBbMTA2MTFdXSwgWydsYXJydGwnLCBbODYxMF1dLCBbJ2xhdGFpbCcsIFsxMDUyMV1dLCBbJ2xBdGFpbCcsIFsxMDUyM11dLCBbJ2xhdCcsIFsxMDkyM11dLCBbJ2xhdGUnLCBbMTA5MjVdXSwgWydsYXRlcycsIFsxMDkyNSwgNjUwMjRdXSwgWydsYmFycicsIFsxMDUwOF1dLCBbJ2xCYXJyJywgWzEwNTEwXV0sIFsnbGJicmsnLCBbMTAwOThdXSwgWydsYnJhY2UnLCBbMTIzXV0sIFsnbGJyYWNrJywgWzkxXV0sIFsnbGJya2UnLCBbMTA2MzVdXSwgWydsYnJrc2xkJywgWzEwNjM5XV0sIFsnbGJya3NsdScsIFsxMDYzN11dLCBbJ0xjYXJvbicsIFszMTddXSwgWydsY2Fyb24nLCBbMzE4XV0sIFsnTGNlZGlsJywgWzMxNV1dLCBbJ2xjZWRpbCcsIFszMTZdXSwgWydsY2VpbCcsIFs4OTY4XV0sIFsnbGN1YicsIFsxMjNdXSwgWydMY3knLCBbMTA1MV1dLCBbJ2xjeScsIFsxMDgzXV0sIFsnbGRjYScsIFsxMDU1MF1dLCBbJ2xkcXVvJywgWzgyMjBdXSwgWydsZHF1b3InLCBbODIyMl1dLCBbJ2xkcmRoYXInLCBbMTA1OTldXSwgWydsZHJ1c2hhcicsIFsxMDU3MV1dLCBbJ2xkc2gnLCBbODYyNl1dLCBbJ2xlJywgWzg4MDRdXSwgWydsRScsIFs4ODA2XV0sIFsnTGVmdEFuZ2xlQnJhY2tldCcsIFsxMDIxNl1dLCBbJ0xlZnRBcnJvd0JhcicsIFs4Njc2XV0sIFsnbGVmdGFycm93JywgWzg1OTJdXSwgWydMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRhcnJvdycsIFs4NjU2XV0sIFsnTGVmdEFycm93UmlnaHRBcnJvdycsIFs4NjQ2XV0sIFsnbGVmdGFycm93dGFpbCcsIFs4NjEwXV0sIFsnTGVmdENlaWxpbmcnLCBbODk2OF1dLCBbJ0xlZnREb3VibGVCcmFja2V0JywgWzEwMjE0XV0sIFsnTGVmdERvd25UZWVWZWN0b3InLCBbMTA1OTNdXSwgWydMZWZ0RG93blZlY3RvckJhcicsIFsxMDU4NV1dLCBbJ0xlZnREb3duVmVjdG9yJywgWzg2NDNdXSwgWydMZWZ0Rmxvb3InLCBbODk3MF1dLCBbJ2xlZnRoYXJwb29uZG93bicsIFs4NjM3XV0sIFsnbGVmdGhhcnBvb251cCcsIFs4NjM2XV0sIFsnbGVmdGxlZnRhcnJvd3MnLCBbODY0N11dLCBbJ2xlZnRyaWdodGFycm93JywgWzg1OTZdXSwgWydMZWZ0UmlnaHRBcnJvdycsIFs4NTk2XV0sIFsnTGVmdHJpZ2h0YXJyb3cnLCBbODY2MF1dLCBbJ2xlZnRyaWdodGFycm93cycsIFs4NjQ2XV0sIFsnbGVmdHJpZ2h0aGFycG9vbnMnLCBbODY1MV1dLCBbJ2xlZnRyaWdodHNxdWlnYXJyb3cnLCBbODYyMV1dLCBbJ0xlZnRSaWdodFZlY3RvcicsIFsxMDU3NF1dLCBbJ0xlZnRUZWVBcnJvdycsIFs4NjEyXV0sIFsnTGVmdFRlZScsIFs4ODY3XV0sIFsnTGVmdFRlZVZlY3RvcicsIFsxMDU4Nl1dLCBbJ2xlZnR0aHJlZXRpbWVzJywgWzg5MDddXSwgWydMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDNdXSwgWydMZWZ0VHJpYW5nbGUnLCBbODg4Ml1dLCBbJ0xlZnRUcmlhbmdsZUVxdWFsJywgWzg4ODRdXSwgWydMZWZ0VXBEb3duVmVjdG9yJywgWzEwNTc3XV0sIFsnTGVmdFVwVGVlVmVjdG9yJywgWzEwNTkyXV0sIFsnTGVmdFVwVmVjdG9yQmFyJywgWzEwNTg0XV0sIFsnTGVmdFVwVmVjdG9yJywgWzg2MzldXSwgWydMZWZ0VmVjdG9yQmFyJywgWzEwNTc4XV0sIFsnTGVmdFZlY3RvcicsIFs4NjM2XV0sIFsnbEVnJywgWzEwODkxXV0sIFsnbGVnJywgWzg5MjJdXSwgWydsZXEnLCBbODgwNF1dLCBbJ2xlcXEnLCBbODgwNl1dLCBbJ2xlcXNsYW50JywgWzEwODc3XV0sIFsnbGVzY2MnLCBbMTA5MjBdXSwgWydsZXMnLCBbMTA4NzddXSwgWydsZXNkb3QnLCBbMTA4NzldXSwgWydsZXNkb3RvJywgWzEwODgxXV0sIFsnbGVzZG90b3InLCBbMTA4ODNdXSwgWydsZXNnJywgWzg5MjIsIDY1MDI0XV0sIFsnbGVzZ2VzJywgWzEwODk5XV0sIFsnbGVzc2FwcHJveCcsIFsxMDg4NV1dLCBbJ2xlc3Nkb3QnLCBbODkxOF1dLCBbJ2xlc3NlcWd0cicsIFs4OTIyXV0sIFsnbGVzc2VxcWd0cicsIFsxMDg5MV1dLCBbJ0xlc3NFcXVhbEdyZWF0ZXInLCBbODkyMl1dLCBbJ0xlc3NGdWxsRXF1YWwnLCBbODgwNl1dLCBbJ0xlc3NHcmVhdGVyJywgWzg4MjJdXSwgWydsZXNzZ3RyJywgWzg4MjJdXSwgWydMZXNzTGVzcycsIFsxMDkxM11dLCBbJ2xlc3NzaW0nLCBbODgxOF1dLCBbJ0xlc3NTbGFudEVxdWFsJywgWzEwODc3XV0sIFsnTGVzc1RpbGRlJywgWzg4MThdXSwgWydsZmlzaHQnLCBbMTA2MjBdXSwgWydsZmxvb3InLCBbODk3MF1dLCBbJ0xmcicsIFsxMjAwNzldXSwgWydsZnInLCBbMTIwMTA1XV0sIFsnbGcnLCBbODgyMl1dLCBbJ2xnRScsIFsxMDg5N11dLCBbJ2xIYXInLCBbMTA1OTRdXSwgWydsaGFyZCcsIFs4NjM3XV0sIFsnbGhhcnUnLCBbODYzNl1dLCBbJ2xoYXJ1bCcsIFsxMDYwMl1dLCBbJ2xoYmxrJywgWzk2MDRdXSwgWydMSmN5JywgWzEwMzNdXSwgWydsamN5JywgWzExMTNdXSwgWydsbGFycicsIFs4NjQ3XV0sIFsnbGwnLCBbODgxMF1dLCBbJ0xsJywgWzg5MjBdXSwgWydsbGNvcm5lcicsIFs4OTkwXV0sIFsnTGxlZnRhcnJvdycsIFs4NjY2XV0sIFsnbGxoYXJkJywgWzEwNjAzXV0sIFsnbGx0cmknLCBbOTcyMl1dLCBbJ0xtaWRvdCcsIFszMTldXSwgWydsbWlkb3QnLCBbMzIwXV0sIFsnbG1vdXN0YWNoZScsIFs5MTM2XV0sIFsnbG1vdXN0JywgWzkxMzZdXSwgWydsbmFwJywgWzEwODg5XV0sIFsnbG5hcHByb3gnLCBbMTA4ODldXSwgWydsbmUnLCBbMTA4ODddXSwgWydsbkUnLCBbODgwOF1dLCBbJ2xuZXEnLCBbMTA4ODddXSwgWydsbmVxcScsIFs4ODA4XV0sIFsnbG5zaW0nLCBbODkzNF1dLCBbJ2xvYW5nJywgWzEwMjIwXV0sIFsnbG9hcnInLCBbODcwMV1dLCBbJ2xvYnJrJywgWzEwMjE0XV0sIFsnbG9uZ2xlZnRhcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdMZWZ0QXJyb3cnLCBbMTAyMjldXSwgWydMb25nbGVmdGFycm93JywgWzEwMjMyXV0sIFsnbG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjMxXV0sIFsnTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjMxXV0sIFsnTG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjM0XV0sIFsnbG9uZ21hcHN0bycsIFsxMDIzNl1dLCBbJ2xvbmdyaWdodGFycm93JywgWzEwMjMwXV0sIFsnTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzBdXSwgWydMb25ncmlnaHRhcnJvdycsIFsxMDIzM11dLCBbJ2xvb3BhcnJvd2xlZnQnLCBbODYxOV1dLCBbJ2xvb3BhcnJvd3JpZ2h0JywgWzg2MjBdXSwgWydsb3BhcicsIFsxMDYyOV1dLCBbJ0xvcGYnLCBbMTIwMTMxXV0sIFsnbG9wZicsIFsxMjAxNTddXSwgWydsb3BsdXMnLCBbMTA3OTddXSwgWydsb3RpbWVzJywgWzEwODA0XV0sIFsnbG93YXN0JywgWzg3MjddXSwgWydsb3diYXInLCBbOTVdXSwgWydMb3dlckxlZnRBcnJvdycsIFs4NjAxXV0sIFsnTG93ZXJSaWdodEFycm93JywgWzg2MDBdXSwgWydsb3onLCBbOTY3NF1dLCBbJ2xvemVuZ2UnLCBbOTY3NF1dLCBbJ2xvemYnLCBbMTA3MzFdXSwgWydscGFyJywgWzQwXV0sIFsnbHBhcmx0JywgWzEwNjQzXV0sIFsnbHJhcnInLCBbODY0Nl1dLCBbJ2xyY29ybmVyJywgWzg5OTFdXSwgWydscmhhcicsIFs4NjUxXV0sIFsnbHJoYXJkJywgWzEwNjA1XV0sIFsnbHJtJywgWzgyMDZdXSwgWydscnRyaScsIFs4ODk1XV0sIFsnbHNhcXVvJywgWzgyNDldXSwgWydsc2NyJywgWzEyMDAwMV1dLCBbJ0xzY3InLCBbODQ2Nl1dLCBbJ2xzaCcsIFs4NjI0XV0sIFsnTHNoJywgWzg2MjRdXSwgWydsc2ltJywgWzg4MThdXSwgWydsc2ltZScsIFsxMDg5M11dLCBbJ2xzaW1nJywgWzEwODk1XV0sIFsnbHNxYicsIFs5MV1dLCBbJ2xzcXVvJywgWzgyMTZdXSwgWydsc3F1b3InLCBbODIxOF1dLCBbJ0xzdHJvaycsIFszMjFdXSwgWydsc3Ryb2snLCBbMzIyXV0sIFsnbHRjYycsIFsxMDkxOF1dLCBbJ2x0Y2lyJywgWzEwODczXV0sIFsnbHQnLCBbNjBdXSwgWydMVCcsIFs2MF1dLCBbJ0x0JywgWzg4MTBdXSwgWydsdGRvdCcsIFs4OTE4XV0sIFsnbHRocmVlJywgWzg5MDddXSwgWydsdGltZXMnLCBbODkwNV1dLCBbJ2x0bGFycicsIFsxMDYxNF1dLCBbJ2x0cXVlc3QnLCBbMTA4NzVdXSwgWydsdHJpJywgWzk2NjddXSwgWydsdHJpZScsIFs4ODg0XV0sIFsnbHRyaWYnLCBbOTY2Nl1dLCBbJ2x0clBhcicsIFsxMDY0Nl1dLCBbJ2x1cmRzaGFyJywgWzEwNTcwXV0sIFsnbHVydWhhcicsIFsxMDU5OF1dLCBbJ2x2ZXJ0bmVxcScsIFs4ODA4LCA2NTAyNF1dLCBbJ2x2bkUnLCBbODgwOCwgNjUwMjRdXSwgWydtYWNyJywgWzE3NV1dLCBbJ21hbGUnLCBbOTc5NF1dLCBbJ21hbHQnLCBbMTAwMTZdXSwgWydtYWx0ZXNlJywgWzEwMDE2XV0sIFsnTWFwJywgWzEwNTAxXV0sIFsnbWFwJywgWzg2MTRdXSwgWydtYXBzdG8nLCBbODYxNF1dLCBbJ21hcHN0b2Rvd24nLCBbODYxNV1dLCBbJ21hcHN0b2xlZnQnLCBbODYxMl1dLCBbJ21hcHN0b3VwJywgWzg2MTNdXSwgWydtYXJrZXInLCBbOTY0Nl1dLCBbJ21jb21tYScsIFsxMDc5M11dLCBbJ01jeScsIFsxMDUyXV0sIFsnbWN5JywgWzEwODRdXSwgWydtZGFzaCcsIFs4MjEyXV0sIFsnbUREb3QnLCBbODc2Ml1dLCBbJ21lYXN1cmVkYW5nbGUnLCBbODczN11dLCBbJ01lZGl1bVNwYWNlJywgWzgyODddXSwgWydNZWxsaW50cmYnLCBbODQ5OV1dLCBbJ01mcicsIFsxMjAwODBdXSwgWydtZnInLCBbMTIwMTA2XV0sIFsnbWhvJywgWzg0ODddXSwgWydtaWNybycsIFsxODFdXSwgWydtaWRhc3QnLCBbNDJdXSwgWydtaWRjaXInLCBbMTA5OTJdXSwgWydtaWQnLCBbODczOV1dLCBbJ21pZGRvdCcsIFsxODNdXSwgWydtaW51c2InLCBbODg2M11dLCBbJ21pbnVzJywgWzg3MjJdXSwgWydtaW51c2QnLCBbODc2MF1dLCBbJ21pbnVzZHUnLCBbMTA3OTRdXSwgWydNaW51c1BsdXMnLCBbODcyM11dLCBbJ21sY3AnLCBbMTA5NzFdXSwgWydtbGRyJywgWzgyMzBdXSwgWydtbnBsdXMnLCBbODcyM11dLCBbJ21vZGVscycsIFs4ODcxXV0sIFsnTW9wZicsIFsxMjAxMzJdXSwgWydtb3BmJywgWzEyMDE1OF1dLCBbJ21wJywgWzg3MjNdXSwgWydtc2NyJywgWzEyMDAwMl1dLCBbJ01zY3InLCBbODQ5OV1dLCBbJ21zdHBvcycsIFs4NzY2XV0sIFsnTXUnLCBbOTI0XV0sIFsnbXUnLCBbOTU2XV0sIFsnbXVsdGltYXAnLCBbODg4OF1dLCBbJ211bWFwJywgWzg4ODhdXSwgWyduYWJsYScsIFs4NzExXV0sIFsnTmFjdXRlJywgWzMyM11dLCBbJ25hY3V0ZScsIFszMjRdXSwgWyduYW5nJywgWzg3MzYsIDg0MDJdXSwgWyduYXAnLCBbODc3N11dLCBbJ25hcEUnLCBbMTA4NjQsIDgyNF1dLCBbJ25hcGlkJywgWzg3NzksIDgyNF1dLCBbJ25hcG9zJywgWzMyOV1dLCBbJ25hcHByb3gnLCBbODc3N11dLCBbJ25hdHVyYWwnLCBbOTgzOF1dLCBbJ25hdHVyYWxzJywgWzg0NjldXSwgWyduYXR1cicsIFs5ODM4XV0sIFsnbmJzcCcsIFsxNjBdXSwgWyduYnVtcCcsIFs4NzgyLCA4MjRdXSwgWyduYnVtcGUnLCBbODc4MywgODI0XV0sIFsnbmNhcCcsIFsxMDgxOV1dLCBbJ05jYXJvbicsIFszMjddXSwgWyduY2Fyb24nLCBbMzI4XV0sIFsnTmNlZGlsJywgWzMyNV1dLCBbJ25jZWRpbCcsIFszMjZdXSwgWyduY29uZycsIFs4Nzc1XV0sIFsnbmNvbmdkb3QnLCBbMTA4NjEsIDgyNF1dLCBbJ25jdXAnLCBbMTA4MThdXSwgWydOY3knLCBbMTA1M11dLCBbJ25jeScsIFsxMDg1XV0sIFsnbmRhc2gnLCBbODIxMV1dLCBbJ25lYXJoaycsIFsxMDUzMl1dLCBbJ25lYXJyJywgWzg1OTldXSwgWyduZUFycicsIFs4NjYzXV0sIFsnbmVhcnJvdycsIFs4NTk5XV0sIFsnbmUnLCBbODgwMF1dLCBbJ25lZG90JywgWzg3ODQsIDgyNF1dLCBbJ05lZ2F0aXZlTWVkaXVtU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpY2tTcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGluU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnbmVxdWl2JywgWzg4MDJdXSwgWyduZXNlYXInLCBbMTA1MzZdXSwgWyduZXNpbScsIFs4NzcwLCA4MjRdXSwgWydOZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFs4ODExXV0sIFsnTmVzdGVkTGVzc0xlc3MnLCBbODgxMF1dLCBbJ25leGlzdCcsIFs4NzA4XV0sIFsnbmV4aXN0cycsIFs4NzA4XV0sIFsnTmZyJywgWzEyMDA4MV1dLCBbJ25mcicsIFsxMjAxMDddXSwgWyduZ0UnLCBbODgwNywgODI0XV0sIFsnbmdlJywgWzg4MTddXSwgWyduZ2VxJywgWzg4MTddXSwgWyduZ2VxcScsIFs4ODA3LCA4MjRdXSwgWyduZ2Vxc2xhbnQnLCBbMTA4NzgsIDgyNF1dLCBbJ25nZXMnLCBbMTA4NzgsIDgyNF1dLCBbJ25HZycsIFs4OTIxLCA4MjRdXSwgWyduZ3NpbScsIFs4ODIxXV0sIFsnbkd0JywgWzg4MTEsIDg0MDJdXSwgWyduZ3QnLCBbODgxNV1dLCBbJ25ndHInLCBbODgxNV1dLCBbJ25HdHYnLCBbODgxMSwgODI0XV0sIFsnbmhhcnInLCBbODYyMl1dLCBbJ25oQXJyJywgWzg2NTRdXSwgWyduaHBhcicsIFsxMDk5NF1dLCBbJ25pJywgWzg3MTVdXSwgWyduaXMnLCBbODk1Nl1dLCBbJ25pc2QnLCBbODk1NF1dLCBbJ25pdicsIFs4NzE1XV0sIFsnTkpjeScsIFsxMDM0XV0sIFsnbmpjeScsIFsxMTE0XV0sIFsnbmxhcnInLCBbODYwMl1dLCBbJ25sQXJyJywgWzg2NTNdXSwgWydubGRyJywgWzgyMjldXSwgWydubEUnLCBbODgwNiwgODI0XV0sIFsnbmxlJywgWzg4MTZdXSwgWydubGVmdGFycm93JywgWzg2MDJdXSwgWyduTGVmdGFycm93JywgWzg2NTNdXSwgWydubGVmdHJpZ2h0YXJyb3cnLCBbODYyMl1dLCBbJ25MZWZ0cmlnaHRhcnJvdycsIFs4NjU0XV0sIFsnbmxlcScsIFs4ODE2XV0sIFsnbmxlcXEnLCBbODgwNiwgODI0XV0sIFsnbmxlcXNsYW50JywgWzEwODc3LCA4MjRdXSwgWydubGVzJywgWzEwODc3LCA4MjRdXSwgWydubGVzcycsIFs4ODE0XV0sIFsnbkxsJywgWzg5MjAsIDgyNF1dLCBbJ25sc2ltJywgWzg4MjBdXSwgWyduTHQnLCBbODgxMCwgODQwMl1dLCBbJ25sdCcsIFs4ODE0XV0sIFsnbmx0cmknLCBbODkzOF1dLCBbJ25sdHJpZScsIFs4OTQwXV0sIFsnbkx0dicsIFs4ODEwLCA4MjRdXSwgWydubWlkJywgWzg3NDBdXSwgWydOb0JyZWFrJywgWzgyODhdXSwgWydOb25CcmVha2luZ1NwYWNlJywgWzE2MF1dLCBbJ25vcGYnLCBbMTIwMTU5XV0sIFsnTm9wZicsIFs4NDY5XV0sIFsnTm90JywgWzEwOTg4XV0sIFsnbm90JywgWzE3Ml1dLCBbJ05vdENvbmdydWVudCcsIFs4ODAyXV0sIFsnTm90Q3VwQ2FwJywgWzg4MTNdXSwgWydOb3REb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQyXV0sIFsnTm90RWxlbWVudCcsIFs4NzEzXV0sIFsnTm90RXF1YWwnLCBbODgwMF1dLCBbJ05vdEVxdWFsVGlsZGUnLCBbODc3MCwgODI0XV0sIFsnTm90RXhpc3RzJywgWzg3MDhdXSwgWydOb3RHcmVhdGVyJywgWzg4MTVdXSwgWydOb3RHcmVhdGVyRXF1YWwnLCBbODgxN11dLCBbJ05vdEdyZWF0ZXJGdWxsRXF1YWwnLCBbODgwNywgODI0XV0sIFsnTm90R3JlYXRlckdyZWF0ZXInLCBbODgxMSwgODI0XV0sIFsnTm90R3JlYXRlckxlc3MnLCBbODgyNV1dLCBbJ05vdEdyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4LCA4MjRdXSwgWydOb3RHcmVhdGVyVGlsZGUnLCBbODgyMV1dLCBbJ05vdEh1bXBEb3duSHVtcCcsIFs4NzgyLCA4MjRdXSwgWydOb3RIdW1wRXF1YWwnLCBbODc4MywgODI0XV0sIFsnbm90aW4nLCBbODcxM11dLCBbJ25vdGluZG90JywgWzg5NDksIDgyNF1dLCBbJ25vdGluRScsIFs4OTUzLCA4MjRdXSwgWydub3RpbnZhJywgWzg3MTNdXSwgWydub3RpbnZiJywgWzg5NTFdXSwgWydub3RpbnZjJywgWzg5NTBdXSwgWydOb3RMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDMsIDgyNF1dLCBbJ05vdExlZnRUcmlhbmdsZScsIFs4OTM4XV0sIFsnTm90TGVmdFRyaWFuZ2xlRXF1YWwnLCBbODk0MF1dLCBbJ05vdExlc3MnLCBbODgxNF1dLCBbJ05vdExlc3NFcXVhbCcsIFs4ODE2XV0sIFsnTm90TGVzc0dyZWF0ZXInLCBbODgyNF1dLCBbJ05vdExlc3NMZXNzJywgWzg4MTAsIDgyNF1dLCBbJ05vdExlc3NTbGFudEVxdWFsJywgWzEwODc3LCA4MjRdXSwgWydOb3RMZXNzVGlsZGUnLCBbODgyMF1dLCBbJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzEwOTE0LCA4MjRdXSwgWydOb3ROZXN0ZWRMZXNzTGVzcycsIFsxMDkxMywgODI0XV0sIFsnbm90bmknLCBbODcxNl1dLCBbJ25vdG5pdmEnLCBbODcxNl1dLCBbJ25vdG5pdmInLCBbODk1OF1dLCBbJ25vdG5pdmMnLCBbODk1N11dLCBbJ05vdFByZWNlZGVzJywgWzg4MzJdXSwgWydOb3RQcmVjZWRlc0VxdWFsJywgWzEwOTI3LCA4MjRdXSwgWydOb3RQcmVjZWRlc1NsYW50RXF1YWwnLCBbODkyOF1dLCBbJ05vdFJldmVyc2VFbGVtZW50JywgWzg3MTZdXSwgWydOb3RSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0LCA4MjRdXSwgWydOb3RSaWdodFRyaWFuZ2xlJywgWzg5MzldXSwgWydOb3RSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODk0MV1dLCBbJ05vdFNxdWFyZVN1YnNldCcsIFs4ODQ3LCA4MjRdXSwgWydOb3RTcXVhcmVTdWJzZXRFcXVhbCcsIFs4OTMwXV0sIFsnTm90U3F1YXJlU3VwZXJzZXQnLCBbODg0OCwgODI0XV0sIFsnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4OTMxXV0sIFsnTm90U3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWydOb3RTdWJzZXRFcXVhbCcsIFs4ODQwXV0sIFsnTm90U3VjY2VlZHMnLCBbODgzM11dLCBbJ05vdFN1Y2NlZWRzRXF1YWwnLCBbMTA5MjgsIDgyNF1dLCBbJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4OTI5XV0sIFsnTm90U3VjY2VlZHNUaWxkZScsIFs4ODMxLCA4MjRdXSwgWydOb3RTdXBlcnNldCcsIFs4ODM1LCA4NDAyXV0sIFsnTm90U3VwZXJzZXRFcXVhbCcsIFs4ODQxXV0sIFsnTm90VGlsZGUnLCBbODc2OV1dLCBbJ05vdFRpbGRlRXF1YWwnLCBbODc3Ml1dLCBbJ05vdFRpbGRlRnVsbEVxdWFsJywgWzg3NzVdXSwgWydOb3RUaWxkZVRpbGRlJywgWzg3NzddXSwgWydOb3RWZXJ0aWNhbEJhcicsIFs4NzQwXV0sIFsnbnBhcmFsbGVsJywgWzg3NDJdXSwgWyducGFyJywgWzg3NDJdXSwgWyducGFyc2wnLCBbMTEwMDUsIDg0MjFdXSwgWyducGFydCcsIFs4NzA2LCA4MjRdXSwgWyducG9saW50JywgWzEwNzcyXV0sIFsnbnByJywgWzg4MzJdXSwgWyducHJjdWUnLCBbODkyOF1dLCBbJ25wcmVjJywgWzg4MzJdXSwgWyducHJlY2VxJywgWzEwOTI3LCA4MjRdXSwgWyducHJlJywgWzEwOTI3LCA4MjRdXSwgWyducmFycmMnLCBbMTA1NDcsIDgyNF1dLCBbJ25yYXJyJywgWzg2MDNdXSwgWyduckFycicsIFs4NjU1XV0sIFsnbnJhcnJ3JywgWzg2MDUsIDgyNF1dLCBbJ25yaWdodGFycm93JywgWzg2MDNdXSwgWyduUmlnaHRhcnJvdycsIFs4NjU1XV0sIFsnbnJ0cmknLCBbODkzOV1dLCBbJ25ydHJpZScsIFs4OTQxXV0sIFsnbnNjJywgWzg4MzNdXSwgWyduc2NjdWUnLCBbODkyOV1dLCBbJ25zY2UnLCBbMTA5MjgsIDgyNF1dLCBbJ05zY3InLCBbMTE5OTc3XV0sIFsnbnNjcicsIFsxMjAwMDNdXSwgWyduc2hvcnRtaWQnLCBbODc0MF1dLCBbJ25zaG9ydHBhcmFsbGVsJywgWzg3NDJdXSwgWyduc2ltJywgWzg3NjldXSwgWyduc2ltZScsIFs4NzcyXV0sIFsnbnNpbWVxJywgWzg3NzJdXSwgWyduc21pZCcsIFs4NzQwXV0sIFsnbnNwYXInLCBbODc0Ml1dLCBbJ25zcXN1YmUnLCBbODkzMF1dLCBbJ25zcXN1cGUnLCBbODkzMV1dLCBbJ25zdWInLCBbODgzNl1dLCBbJ25zdWJFJywgWzEwOTQ5LCA4MjRdXSwgWyduc3ViZScsIFs4ODQwXV0sIFsnbnN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnbnN1YnNldGVxJywgWzg4NDBdXSwgWyduc3Vic2V0ZXFxJywgWzEwOTQ5LCA4MjRdXSwgWyduc3VjYycsIFs4ODMzXV0sIFsnbnN1Y2NlcScsIFsxMDkyOCwgODI0XV0sIFsnbnN1cCcsIFs4ODM3XV0sIFsnbnN1cEUnLCBbMTA5NTAsIDgyNF1dLCBbJ25zdXBlJywgWzg4NDFdXSwgWyduc3Vwc2V0JywgWzg4MzUsIDg0MDJdXSwgWyduc3Vwc2V0ZXEnLCBbODg0MV1dLCBbJ25zdXBzZXRlcXEnLCBbMTA5NTAsIDgyNF1dLCBbJ250Z2wnLCBbODgyNV1dLCBbJ050aWxkZScsIFsyMDldXSwgWydudGlsZGUnLCBbMjQxXV0sIFsnbnRsZycsIFs4ODI0XV0sIFsnbnRyaWFuZ2xlbGVmdCcsIFs4OTM4XV0sIFsnbnRyaWFuZ2xlbGVmdGVxJywgWzg5NDBdXSwgWydudHJpYW5nbGVyaWdodCcsIFs4OTM5XV0sIFsnbnRyaWFuZ2xlcmlnaHRlcScsIFs4OTQxXV0sIFsnTnUnLCBbOTI1XV0sIFsnbnUnLCBbOTU3XV0sIFsnbnVtJywgWzM1XV0sIFsnbnVtZXJvJywgWzg0NzBdXSwgWydudW1zcCcsIFs4MTk5XV0sIFsnbnZhcCcsIFs4NzgxLCA4NDAyXV0sIFsnbnZkYXNoJywgWzg4NzZdXSwgWydudkRhc2gnLCBbODg3N11dLCBbJ25WZGFzaCcsIFs4ODc4XV0sIFsnblZEYXNoJywgWzg4NzldXSwgWydudmdlJywgWzg4MDUsIDg0MDJdXSwgWydudmd0JywgWzYyLCA4NDAyXV0sIFsnbnZIYXJyJywgWzEwNTAwXV0sIFsnbnZpbmZpbicsIFsxMDcxOF1dLCBbJ252bEFycicsIFsxMDQ5OF1dLCBbJ252bGUnLCBbODgwNCwgODQwMl1dLCBbJ252bHQnLCBbNjAsIDg0MDJdXSwgWydudmx0cmllJywgWzg4ODQsIDg0MDJdXSwgWydudnJBcnInLCBbMTA0OTldXSwgWydudnJ0cmllJywgWzg4ODUsIDg0MDJdXSwgWydudnNpbScsIFs4NzY0LCA4NDAyXV0sIFsnbndhcmhrJywgWzEwNTMxXV0sIFsnbndhcnInLCBbODU5OF1dLCBbJ253QXJyJywgWzg2NjJdXSwgWydud2Fycm93JywgWzg1OThdXSwgWydud25lYXInLCBbMTA1MzVdXSwgWydPYWN1dGUnLCBbMjExXV0sIFsnb2FjdXRlJywgWzI0M11dLCBbJ29hc3QnLCBbODg1OV1dLCBbJ09jaXJjJywgWzIxMl1dLCBbJ29jaXJjJywgWzI0NF1dLCBbJ29jaXInLCBbODg1OF1dLCBbJ09jeScsIFsxMDU0XV0sIFsnb2N5JywgWzEwODZdXSwgWydvZGFzaCcsIFs4ODYxXV0sIFsnT2RibGFjJywgWzMzNl1dLCBbJ29kYmxhYycsIFszMzddXSwgWydvZGl2JywgWzEwODA4XV0sIFsnb2RvdCcsIFs4ODU3XV0sIFsnb2Rzb2xkJywgWzEwNjg0XV0sIFsnT0VsaWcnLCBbMzM4XV0sIFsnb2VsaWcnLCBbMzM5XV0sIFsnb2ZjaXInLCBbMTA2ODddXSwgWydPZnInLCBbMTIwMDgyXV0sIFsnb2ZyJywgWzEyMDEwOF1dLCBbJ29nb24nLCBbNzMxXV0sIFsnT2dyYXZlJywgWzIxMF1dLCBbJ29ncmF2ZScsIFsyNDJdXSwgWydvZ3QnLCBbMTA2ODldXSwgWydvaGJhcicsIFsxMDY3N11dLCBbJ29obScsIFs5MzddXSwgWydvaW50JywgWzg3NTBdXSwgWydvbGFycicsIFs4NjM0XV0sIFsnb2xjaXInLCBbMTA2ODZdXSwgWydvbGNyb3NzJywgWzEwNjgzXV0sIFsnb2xpbmUnLCBbODI1NF1dLCBbJ29sdCcsIFsxMDY4OF1dLCBbJ09tYWNyJywgWzMzMl1dLCBbJ29tYWNyJywgWzMzM11dLCBbJ09tZWdhJywgWzkzN11dLCBbJ29tZWdhJywgWzk2OV1dLCBbJ09taWNyb24nLCBbOTI3XV0sIFsnb21pY3JvbicsIFs5NTldXSwgWydvbWlkJywgWzEwNjc4XV0sIFsnb21pbnVzJywgWzg4NTRdXSwgWydPb3BmJywgWzEyMDEzNF1dLCBbJ29vcGYnLCBbMTIwMTYwXV0sIFsnb3BhcicsIFsxMDY3OV1dLCBbJ09wZW5DdXJseURvdWJsZVF1b3RlJywgWzgyMjBdXSwgWydPcGVuQ3VybHlRdW90ZScsIFs4MjE2XV0sIFsnb3BlcnAnLCBbMTA2ODFdXSwgWydvcGx1cycsIFs4ODUzXV0sIFsnb3JhcnInLCBbODYzNV1dLCBbJ09yJywgWzEwODM2XV0sIFsnb3InLCBbODc0NF1dLCBbJ29yZCcsIFsxMDg0NV1dLCBbJ29yZGVyJywgWzg1MDBdXSwgWydvcmRlcm9mJywgWzg1MDBdXSwgWydvcmRmJywgWzE3MF1dLCBbJ29yZG0nLCBbMTg2XV0sIFsnb3JpZ29mJywgWzg4ODZdXSwgWydvcm9yJywgWzEwODM4XV0sIFsnb3JzbG9wZScsIFsxMDgzOV1dLCBbJ29ydicsIFsxMDg0M11dLCBbJ29TJywgWzk0MTZdXSwgWydPc2NyJywgWzExOTk3OF1dLCBbJ29zY3InLCBbODUwMF1dLCBbJ09zbGFzaCcsIFsyMTZdXSwgWydvc2xhc2gnLCBbMjQ4XV0sIFsnb3NvbCcsIFs4ODU2XV0sIFsnT3RpbGRlJywgWzIxM11dLCBbJ290aWxkZScsIFsyNDVdXSwgWydvdGltZXNhcycsIFsxMDgwNl1dLCBbJ090aW1lcycsIFsxMDgwN11dLCBbJ290aW1lcycsIFs4ODU1XV0sIFsnT3VtbCcsIFsyMTRdXSwgWydvdW1sJywgWzI0Nl1dLCBbJ292YmFyJywgWzkwMjFdXSwgWydPdmVyQmFyJywgWzgyNTRdXSwgWydPdmVyQnJhY2UnLCBbOTE4Ml1dLCBbJ092ZXJCcmFja2V0JywgWzkxNDBdXSwgWydPdmVyUGFyZW50aGVzaXMnLCBbOTE4MF1dLCBbJ3BhcmEnLCBbMTgyXV0sIFsncGFyYWxsZWwnLCBbODc0MV1dLCBbJ3BhcicsIFs4NzQxXV0sIFsncGFyc2ltJywgWzEwOTk1XV0sIFsncGFyc2wnLCBbMTEwMDVdXSwgWydwYXJ0JywgWzg3MDZdXSwgWydQYXJ0aWFsRCcsIFs4NzA2XV0sIFsnUGN5JywgWzEwNTVdXSwgWydwY3knLCBbMTA4N11dLCBbJ3BlcmNudCcsIFszN11dLCBbJ3BlcmlvZCcsIFs0Nl1dLCBbJ3Blcm1pbCcsIFs4MjQwXV0sIFsncGVycCcsIFs4ODY5XV0sIFsncGVydGVuaycsIFs4MjQxXV0sIFsnUGZyJywgWzEyMDA4M11dLCBbJ3BmcicsIFsxMjAxMDldXSwgWydQaGknLCBbOTM0XV0sIFsncGhpJywgWzk2Nl1dLCBbJ3BoaXYnLCBbOTgxXV0sIFsncGhtbWF0JywgWzg0OTldXSwgWydwaG9uZScsIFs5NzQyXV0sIFsnUGknLCBbOTI4XV0sIFsncGknLCBbOTYwXV0sIFsncGl0Y2hmb3JrJywgWzg5MTZdXSwgWydwaXYnLCBbOTgyXV0sIFsncGxhbmNrJywgWzg0NjNdXSwgWydwbGFuY2toJywgWzg0NjJdXSwgWydwbGFua3YnLCBbODQ2M11dLCBbJ3BsdXNhY2lyJywgWzEwNzg3XV0sIFsncGx1c2InLCBbODg2Ml1dLCBbJ3BsdXNjaXInLCBbMTA3ODZdXSwgWydwbHVzJywgWzQzXV0sIFsncGx1c2RvJywgWzg3MjRdXSwgWydwbHVzZHUnLCBbMTA3ODldXSwgWydwbHVzZScsIFsxMDg2Nl1dLCBbJ1BsdXNNaW51cycsIFsxNzddXSwgWydwbHVzbW4nLCBbMTc3XV0sIFsncGx1c3NpbScsIFsxMDc5MF1dLCBbJ3BsdXN0d28nLCBbMTA3OTFdXSwgWydwbScsIFsxNzddXSwgWydQb2luY2FyZXBsYW5lJywgWzg0NjBdXSwgWydwb2ludGludCcsIFsxMDc3M11dLCBbJ3BvcGYnLCBbMTIwMTYxXV0sIFsnUG9wZicsIFs4NDczXV0sIFsncG91bmQnLCBbMTYzXV0sIFsncHJhcCcsIFsxMDkzNV1dLCBbJ1ByJywgWzEwOTM5XV0sIFsncHInLCBbODgyNl1dLCBbJ3ByY3VlJywgWzg4MjhdXSwgWydwcmVjYXBwcm94JywgWzEwOTM1XV0sIFsncHJlYycsIFs4ODI2XV0sIFsncHJlY2N1cmx5ZXEnLCBbODgyOF1dLCBbJ1ByZWNlZGVzJywgWzg4MjZdXSwgWydQcmVjZWRlc0VxdWFsJywgWzEwOTI3XV0sIFsnUHJlY2VkZXNTbGFudEVxdWFsJywgWzg4MjhdXSwgWydQcmVjZWRlc1RpbGRlJywgWzg4MzBdXSwgWydwcmVjZXEnLCBbMTA5MjddXSwgWydwcmVjbmFwcHJveCcsIFsxMDkzN11dLCBbJ3ByZWNuZXFxJywgWzEwOTMzXV0sIFsncHJlY25zaW0nLCBbODkzNl1dLCBbJ3ByZScsIFsxMDkyN11dLCBbJ3ByRScsIFsxMDkzMV1dLCBbJ3ByZWNzaW0nLCBbODgzMF1dLCBbJ3ByaW1lJywgWzgyNDJdXSwgWydQcmltZScsIFs4MjQzXV0sIFsncHJpbWVzJywgWzg0NzNdXSwgWydwcm5hcCcsIFsxMDkzN11dLCBbJ3BybkUnLCBbMTA5MzNdXSwgWydwcm5zaW0nLCBbODkzNl1dLCBbJ3Byb2QnLCBbODcxOV1dLCBbJ1Byb2R1Y3QnLCBbODcxOV1dLCBbJ3Byb2ZhbGFyJywgWzkwMDZdXSwgWydwcm9mbGluZScsIFs4OTc4XV0sIFsncHJvZnN1cmYnLCBbODk3OV1dLCBbJ3Byb3AnLCBbODczM11dLCBbJ1Byb3BvcnRpb25hbCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbicsIFs4NzU5XV0sIFsncHJvcHRvJywgWzg3MzNdXSwgWydwcnNpbScsIFs4ODMwXV0sIFsncHJ1cmVsJywgWzg4ODBdXSwgWydQc2NyJywgWzExOTk3OV1dLCBbJ3BzY3InLCBbMTIwMDA1XV0sIFsnUHNpJywgWzkzNl1dLCBbJ3BzaScsIFs5NjhdXSwgWydwdW5jc3AnLCBbODIwMF1dLCBbJ1FmcicsIFsxMjAwODRdXSwgWydxZnInLCBbMTIwMTEwXV0sIFsncWludCcsIFsxMDc2NF1dLCBbJ3FvcGYnLCBbMTIwMTYyXV0sIFsnUW9wZicsIFs4NDc0XV0sIFsncXByaW1lJywgWzgyNzldXSwgWydRc2NyJywgWzExOTk4MF1dLCBbJ3FzY3InLCBbMTIwMDA2XV0sIFsncXVhdGVybmlvbnMnLCBbODQ2MV1dLCBbJ3F1YXRpbnQnLCBbMTA3NzRdXSwgWydxdWVzdCcsIFs2M11dLCBbJ3F1ZXN0ZXEnLCBbODc5OV1dLCBbJ3F1b3QnLCBbMzRdXSwgWydRVU9UJywgWzM0XV0sIFsnckFhcnInLCBbODY2N11dLCBbJ3JhY2UnLCBbODc2NSwgODE3XV0sIFsnUmFjdXRlJywgWzM0MF1dLCBbJ3JhY3V0ZScsIFszNDFdXSwgWydyYWRpYycsIFs4NzMwXV0sIFsncmFlbXB0eXYnLCBbMTA2NzVdXSwgWydyYW5nJywgWzEwMjE3XV0sIFsnUmFuZycsIFsxMDIxOV1dLCBbJ3JhbmdkJywgWzEwNjQyXV0sIFsncmFuZ2UnLCBbMTA2NjFdXSwgWydyYW5nbGUnLCBbMTAyMTddXSwgWydyYXF1bycsIFsxODddXSwgWydyYXJyYXAnLCBbMTA2MTNdXSwgWydyYXJyYicsIFs4Njc3XV0sIFsncmFycmJmcycsIFsxMDUyOF1dLCBbJ3JhcnJjJywgWzEwNTQ3XV0sIFsncmFycicsIFs4NTk0XV0sIFsnUmFycicsIFs4NjA4XV0sIFsnckFycicsIFs4NjU4XV0sIFsncmFycmZzJywgWzEwNTI2XV0sIFsncmFycmhrJywgWzg2MThdXSwgWydyYXJybHAnLCBbODYyMF1dLCBbJ3JhcnJwbCcsIFsxMDU2NV1dLCBbJ3JhcnJzaW0nLCBbMTA2MTJdXSwgWydSYXJydGwnLCBbMTA1MThdXSwgWydyYXJydGwnLCBbODYxMV1dLCBbJ3JhcnJ3JywgWzg2MDVdXSwgWydyYXRhaWwnLCBbMTA1MjJdXSwgWydyQXRhaWwnLCBbMTA1MjRdXSwgWydyYXRpbycsIFs4NzU4XV0sIFsncmF0aW9uYWxzJywgWzg0NzRdXSwgWydyYmFycicsIFsxMDUwOV1dLCBbJ3JCYXJyJywgWzEwNTExXV0sIFsnUkJhcnInLCBbMTA1MTJdXSwgWydyYmJyaycsIFsxMDA5OV1dLCBbJ3JicmFjZScsIFsxMjVdXSwgWydyYnJhY2snLCBbOTNdXSwgWydyYnJrZScsIFsxMDYzNl1dLCBbJ3JicmtzbGQnLCBbMTA2MzhdXSwgWydyYnJrc2x1JywgWzEwNjQwXV0sIFsnUmNhcm9uJywgWzM0NF1dLCBbJ3JjYXJvbicsIFszNDVdXSwgWydSY2VkaWwnLCBbMzQyXV0sIFsncmNlZGlsJywgWzM0M11dLCBbJ3JjZWlsJywgWzg5NjldXSwgWydyY3ViJywgWzEyNV1dLCBbJ1JjeScsIFsxMDU2XV0sIFsncmN5JywgWzEwODhdXSwgWydyZGNhJywgWzEwNTUxXV0sIFsncmRsZGhhcicsIFsxMDYwMV1dLCBbJ3JkcXVvJywgWzgyMjFdXSwgWydyZHF1b3InLCBbODIyMV1dLCBbJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZScsIFs4MjIxXV0sIFsncmRzaCcsIFs4NjI3XV0sIFsncmVhbCcsIFs4NDc2XV0sIFsncmVhbGluZScsIFs4NDc1XV0sIFsncmVhbHBhcnQnLCBbODQ3Nl1dLCBbJ3JlYWxzJywgWzg0NzddXSwgWydSZScsIFs4NDc2XV0sIFsncmVjdCcsIFs5NjQ1XV0sIFsncmVnJywgWzE3NF1dLCBbJ1JFRycsIFsxNzRdXSwgWydSZXZlcnNlRWxlbWVudCcsIFs4NzE1XV0sIFsnUmV2ZXJzZUVxdWlsaWJyaXVtJywgWzg2NTFdXSwgWydSZXZlcnNlVXBFcXVpbGlicml1bScsIFsxMDYwN11dLCBbJ3JmaXNodCcsIFsxMDYyMV1dLCBbJ3JmbG9vcicsIFs4OTcxXV0sIFsncmZyJywgWzEyMDExMV1dLCBbJ1JmcicsIFs4NDc2XV0sIFsnckhhcicsIFsxMDU5Nl1dLCBbJ3JoYXJkJywgWzg2NDFdXSwgWydyaGFydScsIFs4NjQwXV0sIFsncmhhcnVsJywgWzEwNjA0XV0sIFsnUmhvJywgWzkyOV1dLCBbJ3JobycsIFs5NjFdXSwgWydyaG92JywgWzEwMDldXSwgWydSaWdodEFuZ2xlQnJhY2tldCcsIFsxMDIxN11dLCBbJ1JpZ2h0QXJyb3dCYXInLCBbODY3N11dLCBbJ3JpZ2h0YXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0YXJyb3cnLCBbODY1OF1dLCBbJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnLCBbODY0NF1dLCBbJ3JpZ2h0YXJyb3d0YWlsJywgWzg2MTFdXSwgWydSaWdodENlaWxpbmcnLCBbODk2OV1dLCBbJ1JpZ2h0RG91YmxlQnJhY2tldCcsIFsxMDIxNV1dLCBbJ1JpZ2h0RG93blRlZVZlY3RvcicsIFsxMDU4OV1dLCBbJ1JpZ2h0RG93blZlY3RvckJhcicsIFsxMDU4MV1dLCBbJ1JpZ2h0RG93blZlY3RvcicsIFs4NjQyXV0sIFsnUmlnaHRGbG9vcicsIFs4OTcxXV0sIFsncmlnaHRoYXJwb29uZG93bicsIFs4NjQxXV0sIFsncmlnaHRoYXJwb29udXAnLCBbODY0MF1dLCBbJ3JpZ2h0bGVmdGFycm93cycsIFs4NjQ0XV0sIFsncmlnaHRsZWZ0aGFycG9vbnMnLCBbODY1Ml1dLCBbJ3JpZ2h0cmlnaHRhcnJvd3MnLCBbODY0OV1dLCBbJ3JpZ2h0c3F1aWdhcnJvdycsIFs4NjA1XV0sIFsnUmlnaHRUZWVBcnJvdycsIFs4NjE0XV0sIFsnUmlnaHRUZWUnLCBbODg2Nl1dLCBbJ1JpZ2h0VGVlVmVjdG9yJywgWzEwNTg3XV0sIFsncmlnaHR0aHJlZXRpbWVzJywgWzg5MDhdXSwgWydSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0XV0sIFsnUmlnaHRUcmlhbmdsZScsIFs4ODgzXV0sIFsnUmlnaHRUcmlhbmdsZUVxdWFsJywgWzg4ODVdXSwgWydSaWdodFVwRG93blZlY3RvcicsIFsxMDU3NV1dLCBbJ1JpZ2h0VXBUZWVWZWN0b3InLCBbMTA1ODhdXSwgWydSaWdodFVwVmVjdG9yQmFyJywgWzEwNTgwXV0sIFsnUmlnaHRVcFZlY3RvcicsIFs4NjM4XV0sIFsnUmlnaHRWZWN0b3JCYXInLCBbMTA1NzldXSwgWydSaWdodFZlY3RvcicsIFs4NjQwXV0sIFsncmluZycsIFs3MzBdXSwgWydyaXNpbmdkb3RzZXEnLCBbODc4N11dLCBbJ3JsYXJyJywgWzg2NDRdXSwgWydybGhhcicsIFs4NjUyXV0sIFsncmxtJywgWzgyMDddXSwgWydybW91c3RhY2hlJywgWzkxMzddXSwgWydybW91c3QnLCBbOTEzN11dLCBbJ3JubWlkJywgWzEwOTkwXV0sIFsncm9hbmcnLCBbMTAyMjFdXSwgWydyb2FycicsIFs4NzAyXV0sIFsncm9icmsnLCBbMTAyMTVdXSwgWydyb3BhcicsIFsxMDYzMF1dLCBbJ3JvcGYnLCBbMTIwMTYzXV0sIFsnUm9wZicsIFs4NDc3XV0sIFsncm9wbHVzJywgWzEwNzk4XV0sIFsncm90aW1lcycsIFsxMDgwNV1dLCBbJ1JvdW5kSW1wbGllcycsIFsxMDYwOF1dLCBbJ3JwYXInLCBbNDFdXSwgWydycGFyZ3QnLCBbMTA2NDRdXSwgWydycHBvbGludCcsIFsxMDc3MF1dLCBbJ3JyYXJyJywgWzg2NDldXSwgWydScmlnaHRhcnJvdycsIFs4NjY3XV0sIFsncnNhcXVvJywgWzgyNTBdXSwgWydyc2NyJywgWzEyMDAwN11dLCBbJ1JzY3InLCBbODQ3NV1dLCBbJ3JzaCcsIFs4NjI1XV0sIFsnUnNoJywgWzg2MjVdXSwgWydyc3FiJywgWzkzXV0sIFsncnNxdW8nLCBbODIxN11dLCBbJ3JzcXVvcicsIFs4MjE3XV0sIFsnQ2xvc2VDdXJseVF1b3RlJywgWzgyMTddXSwgWydydGhyZWUnLCBbODkwOF1dLCBbJ3J0aW1lcycsIFs4OTA2XV0sIFsncnRyaScsIFs5NjU3XV0sIFsncnRyaWUnLCBbODg4NV1dLCBbJ3J0cmlmJywgWzk2NTZdXSwgWydydHJpbHRyaScsIFsxMDcwMl1dLCBbJ1J1bGVEZWxheWVkJywgWzEwNzQwXV0sIFsncnVsdWhhcicsIFsxMDYwMF1dLCBbJ3J4JywgWzg0NzhdXSwgWydTYWN1dGUnLCBbMzQ2XV0sIFsnc2FjdXRlJywgWzM0N11dLCBbJ3NicXVvJywgWzgyMThdXSwgWydzY2FwJywgWzEwOTM2XV0sIFsnU2Nhcm9uJywgWzM1Ml1dLCBbJ3NjYXJvbicsIFszNTNdXSwgWydTYycsIFsxMDk0MF1dLCBbJ3NjJywgWzg4MjddXSwgWydzY2N1ZScsIFs4ODI5XV0sIFsnc2NlJywgWzEwOTI4XV0sIFsnc2NFJywgWzEwOTMyXV0sIFsnU2NlZGlsJywgWzM1MF1dLCBbJ3NjZWRpbCcsIFszNTFdXSwgWydTY2lyYycsIFszNDhdXSwgWydzY2lyYycsIFszNDldXSwgWydzY25hcCcsIFsxMDkzOF1dLCBbJ3NjbkUnLCBbMTA5MzRdXSwgWydzY25zaW0nLCBbODkzN11dLCBbJ3NjcG9saW50JywgWzEwNzcxXV0sIFsnc2NzaW0nLCBbODgzMV1dLCBbJ1NjeScsIFsxMDU3XV0sIFsnc2N5JywgWzEwODldXSwgWydzZG90YicsIFs4ODY1XV0sIFsnc2RvdCcsIFs4OTAxXV0sIFsnc2RvdGUnLCBbMTA4NTRdXSwgWydzZWFyaGsnLCBbMTA1MzNdXSwgWydzZWFycicsIFs4NjAwXV0sIFsnc2VBcnInLCBbODY2NF1dLCBbJ3NlYXJyb3cnLCBbODYwMF1dLCBbJ3NlY3QnLCBbMTY3XV0sIFsnc2VtaScsIFs1OV1dLCBbJ3Nlc3dhcicsIFsxMDUzN11dLCBbJ3NldG1pbnVzJywgWzg3MjZdXSwgWydzZXRtbicsIFs4NzI2XV0sIFsnc2V4dCcsIFsxMDAzOF1dLCBbJ1NmcicsIFsxMjAwODZdXSwgWydzZnInLCBbMTIwMTEyXV0sIFsnc2Zyb3duJywgWzg5OTRdXSwgWydzaGFycCcsIFs5ODM5XV0sIFsnU0hDSGN5JywgWzEwNjVdXSwgWydzaGNoY3knLCBbMTA5N11dLCBbJ1NIY3knLCBbMTA2NF1dLCBbJ3NoY3knLCBbMTA5Nl1dLCBbJ1Nob3J0RG93bkFycm93JywgWzg1OTVdXSwgWydTaG9ydExlZnRBcnJvdycsIFs4NTkyXV0sIFsnc2hvcnRtaWQnLCBbODczOV1dLCBbJ3Nob3J0cGFyYWxsZWwnLCBbODc0MV1dLCBbJ1Nob3J0UmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnU2hvcnRVcEFycm93JywgWzg1OTNdXSwgWydzaHknLCBbMTczXV0sIFsnU2lnbWEnLCBbOTMxXV0sIFsnc2lnbWEnLCBbOTYzXV0sIFsnc2lnbWFmJywgWzk2Ml1dLCBbJ3NpZ21hdicsIFs5NjJdXSwgWydzaW0nLCBbODc2NF1dLCBbJ3NpbWRvdCcsIFsxMDg1OF1dLCBbJ3NpbWUnLCBbODc3MV1dLCBbJ3NpbWVxJywgWzg3NzFdXSwgWydzaW1nJywgWzEwOTEwXV0sIFsnc2ltZ0UnLCBbMTA5MTJdXSwgWydzaW1sJywgWzEwOTA5XV0sIFsnc2ltbEUnLCBbMTA5MTFdXSwgWydzaW1uZScsIFs4Nzc0XV0sIFsnc2ltcGx1cycsIFsxMDc4OF1dLCBbJ3NpbXJhcnInLCBbMTA2MTBdXSwgWydzbGFycicsIFs4NTkyXV0sIFsnU21hbGxDaXJjbGUnLCBbODcyOF1dLCBbJ3NtYWxsc2V0bWludXMnLCBbODcyNl1dLCBbJ3NtYXNocCcsIFsxMDgwM11dLCBbJ3NtZXBhcnNsJywgWzEwNzI0XV0sIFsnc21pZCcsIFs4NzM5XV0sIFsnc21pbGUnLCBbODk5NV1dLCBbJ3NtdCcsIFsxMDkyMl1dLCBbJ3NtdGUnLCBbMTA5MjRdXSwgWydzbXRlcycsIFsxMDkyNCwgNjUwMjRdXSwgWydTT0ZUY3knLCBbMTA2OF1dLCBbJ3NvZnRjeScsIFsxMTAwXV0sIFsnc29sYmFyJywgWzkwMjNdXSwgWydzb2xiJywgWzEwNjkyXV0sIFsnc29sJywgWzQ3XV0sIFsnU29wZicsIFsxMjAxMzhdXSwgWydzb3BmJywgWzEyMDE2NF1dLCBbJ3NwYWRlcycsIFs5ODI0XV0sIFsnc3BhZGVzdWl0JywgWzk4MjRdXSwgWydzcGFyJywgWzg3NDFdXSwgWydzcWNhcCcsIFs4ODUxXV0sIFsnc3FjYXBzJywgWzg4NTEsIDY1MDI0XV0sIFsnc3FjdXAnLCBbODg1Ml1dLCBbJ3NxY3VwcycsIFs4ODUyLCA2NTAyNF1dLCBbJ1NxcnQnLCBbODczMF1dLCBbJ3Nxc3ViJywgWzg4NDddXSwgWydzcXN1YmUnLCBbODg0OV1dLCBbJ3Nxc3Vic2V0JywgWzg4NDddXSwgWydzcXN1YnNldGVxJywgWzg4NDldXSwgWydzcXN1cCcsIFs4ODQ4XV0sIFsnc3FzdXBlJywgWzg4NTBdXSwgWydzcXN1cHNldCcsIFs4ODQ4XV0sIFsnc3FzdXBzZXRlcScsIFs4ODUwXV0sIFsnc3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZUludGVyc2VjdGlvbicsIFs4ODUxXV0sIFsnU3F1YXJlU3Vic2V0JywgWzg4NDddXSwgWydTcXVhcmVTdWJzZXRFcXVhbCcsIFs4ODQ5XV0sIFsnU3F1YXJlU3VwZXJzZXQnLCBbODg0OF1dLCBbJ1NxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODg1MF1dLCBbJ1NxdWFyZVVuaW9uJywgWzg4NTJdXSwgWydzcXVhcmYnLCBbOTY0Ml1dLCBbJ3NxdScsIFs5NjMzXV0sIFsnc3F1ZicsIFs5NjQyXV0sIFsnc3JhcnInLCBbODU5NF1dLCBbJ1NzY3InLCBbMTE5OTgyXV0sIFsnc3NjcicsIFsxMjAwMDhdXSwgWydzc2V0bW4nLCBbODcyNl1dLCBbJ3NzbWlsZScsIFs4OTk1XV0sIFsnc3N0YXJmJywgWzg5MDJdXSwgWydTdGFyJywgWzg5MDJdXSwgWydzdGFyJywgWzk3MzRdXSwgWydzdGFyZicsIFs5NzMzXV0sIFsnc3RyYWlnaHRlcHNpbG9uJywgWzEwMTNdXSwgWydzdHJhaWdodHBoaScsIFs5ODFdXSwgWydzdHJucycsIFsxNzVdXSwgWydzdWInLCBbODgzNF1dLCBbJ1N1YicsIFs4OTEyXV0sIFsnc3ViZG90JywgWzEwOTQxXV0sIFsnc3ViRScsIFsxMDk0OV1dLCBbJ3N1YmUnLCBbODgzOF1dLCBbJ3N1YmVkb3QnLCBbMTA5NDddXSwgWydzdWJtdWx0JywgWzEwOTQ1XV0sIFsnc3VibkUnLCBbMTA5NTVdXSwgWydzdWJuZScsIFs4ODQyXV0sIFsnc3VicGx1cycsIFsxMDk0M11dLCBbJ3N1YnJhcnInLCBbMTA2MTddXSwgWydzdWJzZXQnLCBbODgzNF1dLCBbJ1N1YnNldCcsIFs4OTEyXV0sIFsnc3Vic2V0ZXEnLCBbODgzOF1dLCBbJ3N1YnNldGVxcScsIFsxMDk0OV1dLCBbJ1N1YnNldEVxdWFsJywgWzg4MzhdXSwgWydzdWJzZXRuZXEnLCBbODg0Ml1dLCBbJ3N1YnNldG5lcXEnLCBbMTA5NTVdXSwgWydzdWJzaW0nLCBbMTA5NTFdXSwgWydzdWJzdWInLCBbMTA5NjVdXSwgWydzdWJzdXAnLCBbMTA5NjNdXSwgWydzdWNjYXBwcm94JywgWzEwOTM2XV0sIFsnc3VjYycsIFs4ODI3XV0sIFsnc3VjY2N1cmx5ZXEnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzJywgWzg4MjddXSwgWydTdWNjZWVkc0VxdWFsJywgWzEwOTI4XV0sIFsnU3VjY2VlZHNTbGFudEVxdWFsJywgWzg4MjldXSwgWydTdWNjZWVkc1RpbGRlJywgWzg4MzFdXSwgWydzdWNjZXEnLCBbMTA5MjhdXSwgWydzdWNjbmFwcHJveCcsIFsxMDkzOF1dLCBbJ3N1Y2NuZXFxJywgWzEwOTM0XV0sIFsnc3VjY25zaW0nLCBbODkzN11dLCBbJ3N1Y2NzaW0nLCBbODgzMV1dLCBbJ1N1Y2hUaGF0JywgWzg3MTVdXSwgWydzdW0nLCBbODcyMV1dLCBbJ1N1bScsIFs4NzIxXV0sIFsnc3VuZycsIFs5ODM0XV0sIFsnc3VwMScsIFsxODVdXSwgWydzdXAyJywgWzE3OF1dLCBbJ3N1cDMnLCBbMTc5XV0sIFsnc3VwJywgWzg4MzVdXSwgWydTdXAnLCBbODkxM11dLCBbJ3N1cGRvdCcsIFsxMDk0Ml1dLCBbJ3N1cGRzdWInLCBbMTA5NjhdXSwgWydzdXBFJywgWzEwOTUwXV0sIFsnc3VwZScsIFs4ODM5XV0sIFsnc3VwZWRvdCcsIFsxMDk0OF1dLCBbJ1N1cGVyc2V0JywgWzg4MzVdXSwgWydTdXBlcnNldEVxdWFsJywgWzg4MzldXSwgWydzdXBoc29sJywgWzEwMTg1XV0sIFsnc3VwaHN1YicsIFsxMDk2N11dLCBbJ3N1cGxhcnInLCBbMTA2MTldXSwgWydzdXBtdWx0JywgWzEwOTQ2XV0sIFsnc3VwbkUnLCBbMTA5NTZdXSwgWydzdXBuZScsIFs4ODQzXV0sIFsnc3VwcGx1cycsIFsxMDk0NF1dLCBbJ3N1cHNldCcsIFs4ODM1XV0sIFsnU3Vwc2V0JywgWzg5MTNdXSwgWydzdXBzZXRlcScsIFs4ODM5XV0sIFsnc3Vwc2V0ZXFxJywgWzEwOTUwXV0sIFsnc3Vwc2V0bmVxJywgWzg4NDNdXSwgWydzdXBzZXRuZXFxJywgWzEwOTU2XV0sIFsnc3Vwc2ltJywgWzEwOTUyXV0sIFsnc3Vwc3ViJywgWzEwOTY0XV0sIFsnc3Vwc3VwJywgWzEwOTY2XV0sIFsnc3dhcmhrJywgWzEwNTM0XV0sIFsnc3dhcnInLCBbODYwMV1dLCBbJ3N3QXJyJywgWzg2NjVdXSwgWydzd2Fycm93JywgWzg2MDFdXSwgWydzd253YXInLCBbMTA1MzhdXSwgWydzemxpZycsIFsyMjNdXSwgWydUYWInLCBbOV1dLCBbJ3RhcmdldCcsIFs4OTgyXV0sIFsnVGF1JywgWzkzMl1dLCBbJ3RhdScsIFs5NjRdXSwgWyd0YnJrJywgWzkxNDBdXSwgWydUY2Fyb24nLCBbMzU2XV0sIFsndGNhcm9uJywgWzM1N11dLCBbJ1RjZWRpbCcsIFszNTRdXSwgWyd0Y2VkaWwnLCBbMzU1XV0sIFsnVGN5JywgWzEwNThdXSwgWyd0Y3knLCBbMTA5MF1dLCBbJ3Rkb3QnLCBbODQxMV1dLCBbJ3RlbHJlYycsIFs4OTgxXV0sIFsnVGZyJywgWzEyMDA4N11dLCBbJ3RmcicsIFsxMjAxMTNdXSwgWyd0aGVyZTQnLCBbODc1Nl1dLCBbJ3RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGV0YScsIFs5MjBdXSwgWyd0aGV0YScsIFs5NTJdXSwgWyd0aGV0YXN5bScsIFs5NzddXSwgWyd0aGV0YXYnLCBbOTc3XV0sIFsndGhpY2thcHByb3gnLCBbODc3Nl1dLCBbJ3RoaWNrc2ltJywgWzg3NjRdXSwgWydUaGlja1NwYWNlJywgWzgyODcsIDgyMDJdXSwgWydUaGluU3BhY2UnLCBbODIwMV1dLCBbJ3RoaW5zcCcsIFs4MjAxXV0sIFsndGhrYXAnLCBbODc3Nl1dLCBbJ3Roa3NpbScsIFs4NzY0XV0sIFsnVEhPUk4nLCBbMjIyXV0sIFsndGhvcm4nLCBbMjU0XV0sIFsndGlsZGUnLCBbNzMyXV0sIFsnVGlsZGUnLCBbODc2NF1dLCBbJ1RpbGRlRXF1YWwnLCBbODc3MV1dLCBbJ1RpbGRlRnVsbEVxdWFsJywgWzg3NzNdXSwgWydUaWxkZVRpbGRlJywgWzg3NzZdXSwgWyd0aW1lc2JhcicsIFsxMDgwMV1dLCBbJ3RpbWVzYicsIFs4ODY0XV0sIFsndGltZXMnLCBbMjE1XV0sIFsndGltZXNkJywgWzEwODAwXV0sIFsndGludCcsIFs4NzQ5XV0sIFsndG9lYScsIFsxMDUzNl1dLCBbJ3RvcGJvdCcsIFs5MDE0XV0sIFsndG9wY2lyJywgWzEwOTkzXV0sIFsndG9wJywgWzg4NjhdXSwgWydUb3BmJywgWzEyMDEzOV1dLCBbJ3RvcGYnLCBbMTIwMTY1XV0sIFsndG9wZm9yaycsIFsxMDk3MF1dLCBbJ3Rvc2EnLCBbMTA1MzddXSwgWyd0cHJpbWUnLCBbODI0NF1dLCBbJ3RyYWRlJywgWzg0ODJdXSwgWydUUkFERScsIFs4NDgyXV0sIFsndHJpYW5nbGUnLCBbOTY1M11dLCBbJ3RyaWFuZ2xlZG93bicsIFs5NjYzXV0sIFsndHJpYW5nbGVsZWZ0JywgWzk2NjddXSwgWyd0cmlhbmdsZWxlZnRlcScsIFs4ODg0XV0sIFsndHJpYW5nbGVxJywgWzg3OTZdXSwgWyd0cmlhbmdsZXJpZ2h0JywgWzk2NTddXSwgWyd0cmlhbmdsZXJpZ2h0ZXEnLCBbODg4NV1dLCBbJ3RyaWRvdCcsIFs5NzA4XV0sIFsndHJpZScsIFs4Nzk2XV0sIFsndHJpbWludXMnLCBbMTA4MTBdXSwgWydUcmlwbGVEb3QnLCBbODQxMV1dLCBbJ3RyaXBsdXMnLCBbMTA4MDldXSwgWyd0cmlzYicsIFsxMDcwMV1dLCBbJ3RyaXRpbWUnLCBbMTA4MTFdXSwgWyd0cnBleml1bScsIFs5MTg2XV0sIFsnVHNjcicsIFsxMTk5ODNdXSwgWyd0c2NyJywgWzEyMDAwOV1dLCBbJ1RTY3knLCBbMTA2Ml1dLCBbJ3RzY3knLCBbMTA5NF1dLCBbJ1RTSGN5JywgWzEwMzVdXSwgWyd0c2hjeScsIFsxMTE1XV0sIFsnVHN0cm9rJywgWzM1OF1dLCBbJ3RzdHJvaycsIFszNTldXSwgWyd0d2l4dCcsIFs4ODEyXV0sIFsndHdvaGVhZGxlZnRhcnJvdycsIFs4NjA2XV0sIFsndHdvaGVhZHJpZ2h0YXJyb3cnLCBbODYwOF1dLCBbJ1VhY3V0ZScsIFsyMThdXSwgWyd1YWN1dGUnLCBbMjUwXV0sIFsndWFycicsIFs4NTkzXV0sIFsnVWFycicsIFs4NjA3XV0sIFsndUFycicsIFs4NjU3XV0sIFsnVWFycm9jaXInLCBbMTA1NjldXSwgWydVYnJjeScsIFsxMDM4XV0sIFsndWJyY3knLCBbMTExOF1dLCBbJ1VicmV2ZScsIFszNjRdXSwgWyd1YnJldmUnLCBbMzY1XV0sIFsnVWNpcmMnLCBbMjE5XV0sIFsndWNpcmMnLCBbMjUxXV0sIFsnVWN5JywgWzEwNTldXSwgWyd1Y3knLCBbMTA5MV1dLCBbJ3VkYXJyJywgWzg2NDVdXSwgWydVZGJsYWMnLCBbMzY4XV0sIFsndWRibGFjJywgWzM2OV1dLCBbJ3VkaGFyJywgWzEwNjA2XV0sIFsndWZpc2h0JywgWzEwNjIyXV0sIFsnVWZyJywgWzEyMDA4OF1dLCBbJ3VmcicsIFsxMjAxMTRdXSwgWydVZ3JhdmUnLCBbMjE3XV0sIFsndWdyYXZlJywgWzI0OV1dLCBbJ3VIYXInLCBbMTA1OTVdXSwgWyd1aGFybCcsIFs4NjM5XV0sIFsndWhhcnInLCBbODYzOF1dLCBbJ3VoYmxrJywgWzk2MDBdXSwgWyd1bGNvcm4nLCBbODk4OF1dLCBbJ3VsY29ybmVyJywgWzg5ODhdXSwgWyd1bGNyb3AnLCBbODk3NV1dLCBbJ3VsdHJpJywgWzk3MjBdXSwgWydVbWFjcicsIFszNjJdXSwgWyd1bWFjcicsIFszNjNdXSwgWyd1bWwnLCBbMTY4XV0sIFsnVW5kZXJCYXInLCBbOTVdXSwgWydVbmRlckJyYWNlJywgWzkxODNdXSwgWydVbmRlckJyYWNrZXQnLCBbOTE0MV1dLCBbJ1VuZGVyUGFyZW50aGVzaXMnLCBbOTE4MV1dLCBbJ1VuaW9uJywgWzg4OTldXSwgWydVbmlvblBsdXMnLCBbODg0Nl1dLCBbJ1VvZ29uJywgWzM3MF1dLCBbJ3VvZ29uJywgWzM3MV1dLCBbJ1VvcGYnLCBbMTIwMTQwXV0sIFsndW9wZicsIFsxMjAxNjZdXSwgWydVcEFycm93QmFyJywgWzEwNTE0XV0sIFsndXBhcnJvdycsIFs4NTkzXV0sIFsnVXBBcnJvdycsIFs4NTkzXV0sIFsnVXBhcnJvdycsIFs4NjU3XV0sIFsnVXBBcnJvd0Rvd25BcnJvdycsIFs4NjQ1XV0sIFsndXBkb3duYXJyb3cnLCBbODU5N11dLCBbJ1VwRG93bkFycm93JywgWzg1OTddXSwgWydVcGRvd25hcnJvdycsIFs4NjYxXV0sIFsnVXBFcXVpbGlicml1bScsIFsxMDYwNl1dLCBbJ3VwaGFycG9vbmxlZnQnLCBbODYzOV1dLCBbJ3VwaGFycG9vbnJpZ2h0JywgWzg2MzhdXSwgWyd1cGx1cycsIFs4ODQ2XV0sIFsnVXBwZXJMZWZ0QXJyb3cnLCBbODU5OF1dLCBbJ1VwcGVyUmlnaHRBcnJvdycsIFs4NTk5XV0sIFsndXBzaScsIFs5NjVdXSwgWydVcHNpJywgWzk3OF1dLCBbJ3Vwc2loJywgWzk3OF1dLCBbJ1Vwc2lsb24nLCBbOTMzXV0sIFsndXBzaWxvbicsIFs5NjVdXSwgWydVcFRlZUFycm93JywgWzg2MTNdXSwgWydVcFRlZScsIFs4ODY5XV0sIFsndXB1cGFycm93cycsIFs4NjQ4XV0sIFsndXJjb3JuJywgWzg5ODldXSwgWyd1cmNvcm5lcicsIFs4OTg5XV0sIFsndXJjcm9wJywgWzg5NzRdXSwgWydVcmluZycsIFszNjZdXSwgWyd1cmluZycsIFszNjddXSwgWyd1cnRyaScsIFs5NzIxXV0sIFsnVXNjcicsIFsxMTk5ODRdXSwgWyd1c2NyJywgWzEyMDAxMF1dLCBbJ3V0ZG90JywgWzg5NDRdXSwgWydVdGlsZGUnLCBbMzYwXV0sIFsndXRpbGRlJywgWzM2MV1dLCBbJ3V0cmknLCBbOTY1M11dLCBbJ3V0cmlmJywgWzk2NTJdXSwgWyd1dWFycicsIFs4NjQ4XV0sIFsnVXVtbCcsIFsyMjBdXSwgWyd1dW1sJywgWzI1Ml1dLCBbJ3V3YW5nbGUnLCBbMTA2NjNdXSwgWyd2YW5ncnQnLCBbMTA2NTJdXSwgWyd2YXJlcHNpbG9uJywgWzEwMTNdXSwgWyd2YXJrYXBwYScsIFsxMDA4XV0sIFsndmFybm90aGluZycsIFs4NzA5XV0sIFsndmFycGhpJywgWzk4MV1dLCBbJ3ZhcnBpJywgWzk4Ml1dLCBbJ3ZhcnByb3B0bycsIFs4NzMzXV0sIFsndmFycicsIFs4NTk3XV0sIFsndkFycicsIFs4NjYxXV0sIFsndmFycmhvJywgWzEwMDldXSwgWyd2YXJzaWdtYScsIFs5NjJdXSwgWyd2YXJzdWJzZXRuZXEnLCBbODg0MiwgNjUwMjRdXSwgWyd2YXJzdWJzZXRuZXFxJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcScsIFs4ODQzLCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcXEnLCBbMTA5NTYsIDY1MDI0XV0sIFsndmFydGhldGEnLCBbOTc3XV0sIFsndmFydHJpYW5nbGVsZWZ0JywgWzg4ODJdXSwgWyd2YXJ0cmlhbmdsZXJpZ2h0JywgWzg4ODNdXSwgWyd2QmFyJywgWzEwOTg0XV0sIFsnVmJhcicsIFsxMDk4N11dLCBbJ3ZCYXJ2JywgWzEwOTg1XV0sIFsnVmN5JywgWzEwNDJdXSwgWyd2Y3knLCBbMTA3NF1dLCBbJ3ZkYXNoJywgWzg4NjZdXSwgWyd2RGFzaCcsIFs4ODcyXV0sIFsnVmRhc2gnLCBbODg3M11dLCBbJ1ZEYXNoJywgWzg4NzVdXSwgWydWZGFzaGwnLCBbMTA5ODJdXSwgWyd2ZWViYXInLCBbODg5MV1dLCBbJ3ZlZScsIFs4NzQ0XV0sIFsnVmVlJywgWzg4OTddXSwgWyd2ZWVlcScsIFs4Nzk0XV0sIFsndmVsbGlwJywgWzg5NDJdXSwgWyd2ZXJiYXInLCBbMTI0XV0sIFsnVmVyYmFyJywgWzgyMTRdXSwgWyd2ZXJ0JywgWzEyNF1dLCBbJ1ZlcnQnLCBbODIxNF1dLCBbJ1ZlcnRpY2FsQmFyJywgWzg3MzldXSwgWydWZXJ0aWNhbExpbmUnLCBbMTI0XV0sIFsnVmVydGljYWxTZXBhcmF0b3InLCBbMTAwNzJdXSwgWydWZXJ0aWNhbFRpbGRlJywgWzg3NjhdXSwgWydWZXJ5VGhpblNwYWNlJywgWzgyMDJdXSwgWydWZnInLCBbMTIwMDg5XV0sIFsndmZyJywgWzEyMDExNV1dLCBbJ3ZsdHJpJywgWzg4ODJdXSwgWyd2bnN1YicsIFs4ODM0LCA4NDAyXV0sIFsndm5zdXAnLCBbODgzNSwgODQwMl1dLCBbJ1ZvcGYnLCBbMTIwMTQxXV0sIFsndm9wZicsIFsxMjAxNjddXSwgWyd2cHJvcCcsIFs4NzMzXV0sIFsndnJ0cmknLCBbODg4M11dLCBbJ1ZzY3InLCBbMTE5OTg1XV0sIFsndnNjcicsIFsxMjAwMTFdXSwgWyd2c3VibkUnLCBbMTA5NTUsIDY1MDI0XV0sIFsndnN1Ym5lJywgWzg4NDIsIDY1MDI0XV0sIFsndnN1cG5FJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZzdXBuZScsIFs4ODQzLCA2NTAyNF1dLCBbJ1Z2ZGFzaCcsIFs4ODc0XV0sIFsndnppZ3phZycsIFsxMDY1MF1dLCBbJ1djaXJjJywgWzM3Ml1dLCBbJ3djaXJjJywgWzM3M11dLCBbJ3dlZGJhcicsIFsxMDg0N11dLCBbJ3dlZGdlJywgWzg3NDNdXSwgWydXZWRnZScsIFs4ODk2XV0sIFsnd2VkZ2VxJywgWzg3OTNdXSwgWyd3ZWllcnAnLCBbODQ3Ml1dLCBbJ1dmcicsIFsxMjAwOTBdXSwgWyd3ZnInLCBbMTIwMTE2XV0sIFsnV29wZicsIFsxMjAxNDJdXSwgWyd3b3BmJywgWzEyMDE2OF1dLCBbJ3dwJywgWzg0NzJdXSwgWyd3cicsIFs4NzY4XV0sIFsnd3JlYXRoJywgWzg3NjhdXSwgWydXc2NyJywgWzExOTk4Nl1dLCBbJ3dzY3InLCBbMTIwMDEyXV0sIFsneGNhcCcsIFs4ODk4XV0sIFsneGNpcmMnLCBbOTcxMV1dLCBbJ3hjdXAnLCBbODg5OV1dLCBbJ3hkdHJpJywgWzk2NjFdXSwgWydYZnInLCBbMTIwMDkxXV0sIFsneGZyJywgWzEyMDExN11dLCBbJ3hoYXJyJywgWzEwMjMxXV0sIFsneGhBcnInLCBbMTAyMzRdXSwgWydYaScsIFs5MjZdXSwgWyd4aScsIFs5NThdXSwgWyd4bGFycicsIFsxMDIyOV1dLCBbJ3hsQXJyJywgWzEwMjMyXV0sIFsneG1hcCcsIFsxMDIzNl1dLCBbJ3huaXMnLCBbODk1NV1dLCBbJ3hvZG90JywgWzEwNzUyXV0sIFsnWG9wZicsIFsxMjAxNDNdXSwgWyd4b3BmJywgWzEyMDE2OV1dLCBbJ3hvcGx1cycsIFsxMDc1M11dLCBbJ3hvdGltZScsIFsxMDc1NF1dLCBbJ3hyYXJyJywgWzEwMjMwXV0sIFsneHJBcnInLCBbMTAyMzNdXSwgWydYc2NyJywgWzExOTk4N11dLCBbJ3hzY3InLCBbMTIwMDEzXV0sIFsneHNxY3VwJywgWzEwNzU4XV0sIFsneHVwbHVzJywgWzEwNzU2XV0sIFsneHV0cmknLCBbOTY1MV1dLCBbJ3h2ZWUnLCBbODg5N11dLCBbJ3h3ZWRnZScsIFs4ODk2XV0sIFsnWWFjdXRlJywgWzIyMV1dLCBbJ3lhY3V0ZScsIFsyNTNdXSwgWydZQWN5JywgWzEwNzFdXSwgWyd5YWN5JywgWzExMDNdXSwgWydZY2lyYycsIFszNzRdXSwgWyd5Y2lyYycsIFszNzVdXSwgWydZY3knLCBbMTA2N11dLCBbJ3ljeScsIFsxMDk5XV0sIFsneWVuJywgWzE2NV1dLCBbJ1lmcicsIFsxMjAwOTJdXSwgWyd5ZnInLCBbMTIwMTE4XV0sIFsnWUljeScsIFsxMDMxXV0sIFsneWljeScsIFsxMTExXV0sIFsnWW9wZicsIFsxMjAxNDRdXSwgWyd5b3BmJywgWzEyMDE3MF1dLCBbJ1lzY3InLCBbMTE5OTg4XV0sIFsneXNjcicsIFsxMjAwMTRdXSwgWydZVWN5JywgWzEwNzBdXSwgWyd5dWN5JywgWzExMDJdXSwgWyd5dW1sJywgWzI1NV1dLCBbJ1l1bWwnLCBbMzc2XV0sIFsnWmFjdXRlJywgWzM3N11dLCBbJ3phY3V0ZScsIFszNzhdXSwgWydaY2Fyb24nLCBbMzgxXV0sIFsnemNhcm9uJywgWzM4Ml1dLCBbJ1pjeScsIFsxMDQ3XV0sIFsnemN5JywgWzEwNzldXSwgWydaZG90JywgWzM3OV1dLCBbJ3pkb3QnLCBbMzgwXV0sIFsnemVldHJmJywgWzg0ODhdXSwgWydaZXJvV2lkdGhTcGFjZScsIFs4MjAzXV0sIFsnWmV0YScsIFs5MThdXSwgWyd6ZXRhJywgWzk1MF1dLCBbJ3pmcicsIFsxMjAxMTldXSwgWydaZnInLCBbODQ4OF1dLCBbJ1pIY3knLCBbMTA0Nl1dLCBbJ3poY3knLCBbMTA3OF1dLCBbJ3ppZ3JhcnInLCBbODY2OV1dLCBbJ3pvcGYnLCBbMTIwMTcxXV0sIFsnWm9wZicsIFs4NDg0XV0sIFsnWnNjcicsIFsxMTk5ODldXSwgWyd6c2NyJywgWzEyMDAxNV1dLCBbJ3p3aicsIFs4MjA1XV0sIFsnenduaicsIFs4MjA0XV1dO1xudmFyIERFQ09ERV9PTkxZX0VOVElUSUVTID0gW1snTmV3TGluZScsIFsxMF1dXTtcbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgY2hhckluZGV4ID0ge307XG5jcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCk7XG52YXIgSHRtbDVFbnRpdGllcyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEh0bWw1RW50aXRpZXMoKSB7fVxuICBIdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uIChzLCBlbnRpdHkpIHtcbiAgICAgIHZhciBjaHI7XG4gICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpID09PSAneCcgPyBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCksIDE2KSA6IHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuICAgICAgICBpZiAoIWlzTmFOKGNvZGUpIHx8IGNvZGUgPj0gLTMyNzY4KSB7XG4gICAgICAgICAgaWYgKGNvZGUgPD0gNjU1MzUpIHtcbiAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IHN1cnJvZ2F0ZV9wYWlyc18xLmZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG4gIH07XG4gIEh0bWw1RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmRlY29kZShzdHIpO1xuICB9O1xuICBIdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBIdG1sNUVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiAgfTtcbiAgSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbY107XG4gICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgaWYgKGMgPj0gc3Vycm9nYXRlX3BhaXJzXzEuaGlnaFN1cnJvZ2F0ZUZyb20gJiYgYyA8PSBzdXJyb2dhdGVfcGFpcnNfMS5oaWdoU3Vycm9nYXRlVG8pIHtcbiAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIHN1cnJvZ2F0ZV9wYWlyc18xLmdldENvZGVQb2ludChzdHIsIGkpICsgJzsnO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBIdG1sNUVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiAgfTtcbiAgSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPj0gc3Vycm9nYXRlX3BhaXJzXzEuaGlnaFN1cnJvZ2F0ZUZyb20gJiYgYyA8PSBzdXJyb2dhdGVfcGFpcnNfMS5oaWdoU3Vycm9nYXRlVG8pIHtcbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBzdXJyb2dhdGVfcGFpcnNfMS5nZXRDb2RlUG9pbnQoc3RyLCBpKSArICc7JztcbiAgICAgICAgaSArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiAgfTtcbiAgcmV0dXJuIEh0bWw1RW50aXRpZXM7XG59KCk7XG5leHBvcnRzLkh0bWw1RW50aXRpZXMgPSBIdG1sNUVudGl0aWVzO1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpIHtcbiAgdmFyIGkgPSBFTlRJVElFUy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgX2EgPSBFTlRJVElFU1tpXSxcbiAgICAgIGFscGhhID0gX2FbMF0sXG4gICAgICBfYiA9IF9hWzFdLFxuICAgICAgY2hyID0gX2JbMF0sXG4gICAgICBjaHIyID0gX2JbMV07XG4gICAgdmFyIGFkZENoYXIgPSBjaHIgPCAzMiB8fCBjaHIgPiAxMjYgfHwgY2hyID09PSA2MiB8fCBjaHIgPT09IDYwIHx8IGNociA9PT0gMzggfHwgY2hyID09PSAzNCB8fCBjaHIgPT09IDM5O1xuICAgIHZhciBjaGFySW5mbyA9IHZvaWQgMDtcbiAgICBpZiAoYWRkQ2hhcikge1xuICAgICAgY2hhckluZm8gPSBjaGFySW5kZXhbY2hyXSA9IGNoYXJJbmRleFtjaHJdIHx8IHt9O1xuICAgIH1cbiAgICBpZiAoY2hyMikge1xuICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgYWRkQ2hhciAmJiAoY2hhckluZm9bY2hyMl0gPSBhbHBoYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgYWRkQ2hhciAmJiAoY2hhckluZm9bJyddID0gYWxwaGEpO1xuICAgIH1cbiAgfVxuICBpID0gREVDT0RFX09OTFlfRU5USVRJRVMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIF9jID0gREVDT0RFX09OTFlfRU5USVRJRVNbaV0sXG4gICAgICBhbHBoYSA9IF9jWzBdLFxuICAgICAgX2QgPSBfY1sxXSxcbiAgICAgIGNociA9IF9kWzBdLFxuICAgICAgY2hyMiA9IF9kWzFdO1xuICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgKGNocjIgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpIDogJycpO1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/html5-entities.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/html-entities/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar xml_entities_1 = __webpack_require__(/*! ./xml-entities */ \"./node_modules/html-entities/lib/xml-entities.js\");\nexports.XmlEntities = xml_entities_1.XmlEntities;\nvar html4_entities_1 = __webpack_require__(/*! ./html4-entities */ \"./node_modules/html-entities/lib/html4-entities.js\");\nexports.Html4Entities = html4_entities_1.Html4Entities;\nvar html5_entities_1 = __webpack_require__(/*! ./html5-entities */ \"./node_modules/html-entities/lib/html5-entities.js\");\nexports.Html5Entities = html5_entities_1.Html5Entities;\nexports.AllHtmlEntities = html5_entities_1.Html5Entities;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9pbmRleC5qcz9mNzYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIHhtbF9lbnRpdGllc18xID0gcmVxdWlyZShcIi4veG1sLWVudGl0aWVzXCIpO1xuZXhwb3J0cy5YbWxFbnRpdGllcyA9IHhtbF9lbnRpdGllc18xLlhtbEVudGl0aWVzO1xudmFyIGh0bWw0X2VudGl0aWVzXzEgPSByZXF1aXJlKFwiLi9odG1sNC1lbnRpdGllc1wiKTtcbmV4cG9ydHMuSHRtbDRFbnRpdGllcyA9IGh0bWw0X2VudGl0aWVzXzEuSHRtbDRFbnRpdGllcztcbnZhciBodG1sNV9lbnRpdGllc18xID0gcmVxdWlyZShcIi4vaHRtbDUtZW50aXRpZXNcIik7XG5leHBvcnRzLkh0bWw1RW50aXRpZXMgPSBodG1sNV9lbnRpdGllc18xLkh0bWw1RW50aXRpZXM7XG5leHBvcnRzLkFsbEh0bWxFbnRpdGllcyA9IGh0bWw1X2VudGl0aWVzXzEuSHRtbDVFbnRpdGllczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/index.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/surrogate-pairs.js":
/*!***********************************************************!*\
  !*** ./node_modules/html-entities/lib/surrogate-pairs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.fromCodePoint = String.fromCodePoint || function (astralCodePoint) {\n  return String.fromCharCode(Math.floor((astralCodePoint - 0x10000) / 0x400) + 0xD800, (astralCodePoint - 0x10000) % 0x400 + 0xDC00);\n};\nexports.getCodePoint = String.prototype.codePointAt ? function (input, position) {\n  return input.codePointAt(position);\n} : function (input, position) {\n  return (input.charCodeAt(position) - 0xD800) * 0x400 + input.charCodeAt(position + 1) - 0xDC00 + 0x10000;\n};\nexports.highSurrogateFrom = 0xD800;\nexports.highSurrogateTo = 0xDBFF;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvc3Vycm9nYXRlLXBhaXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvc3Vycm9nYXRlLXBhaXJzLmpzP2NmMWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCB8fCBmdW5jdGlvbiAoYXN0cmFsQ29kZVBvaW50KSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGguZmxvb3IoKGFzdHJhbENvZGVQb2ludCAtIDB4MTAwMDApIC8gMHg0MDApICsgMHhEODAwLCAoYXN0cmFsQ29kZVBvaW50IC0gMHgxMDAwMCkgJSAweDQwMCArIDB4REMwMCk7XG59O1xuZXhwb3J0cy5nZXRDb2RlUG9pbnQgPSBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ID8gZnVuY3Rpb24gKGlucHV0LCBwb3NpdGlvbikge1xuICByZXR1cm4gaW5wdXQuY29kZVBvaW50QXQocG9zaXRpb24pO1xufSA6IGZ1bmN0aW9uIChpbnB1dCwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIChpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKSAtIDB4RDgwMCkgKiAweDQwMCArIGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSAtIDB4REMwMCArIDB4MTAwMDA7XG59O1xuZXhwb3J0cy5oaWdoU3Vycm9nYXRlRnJvbSA9IDB4RDgwMDtcbmV4cG9ydHMuaGlnaFN1cnJvZ2F0ZVRvID0gMHhEQkZGOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/surrogate-pairs.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/xml-entities.js":
/*!********************************************************!*\
  !*** ./node_modules/html-entities/lib/xml-entities.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ \"./node_modules/html-entities/lib/surrogate-pairs.js\");\nvar ALPHA_INDEX = {\n  '&lt': '<',\n  '&gt': '>',\n  '&quot': '\"',\n  '&apos': '\\'',\n  '&amp': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&apos;': '\\'',\n  '&amp;': '&'\n};\nvar CHAR_INDEX = {\n  60: 'lt',\n  62: 'gt',\n  34: 'quot',\n  39: 'apos',\n  38: 'amp'\n};\nvar CHAR_S_INDEX = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  '\\'': '&apos;',\n  '&': '&amp;'\n};\nvar XmlEntities = /** @class */function () {\n  function XmlEntities() {}\n  XmlEntities.prototype.encode = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    return str.replace(/[<>\"'&]/g, function (s) {\n      return CHAR_S_INDEX[s];\n    });\n  };\n  XmlEntities.encode = function (str) {\n    return new XmlEntities().encode(str);\n  };\n  XmlEntities.prototype.decode = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function (s) {\n      if (s.charAt(1) === '#') {\n        var code = s.charAt(2).toLowerCase() === 'x' ? parseInt(s.substr(3), 16) : parseInt(s.substr(2));\n        if (!isNaN(code) || code >= -32768) {\n          if (code <= 65535) {\n            return String.fromCharCode(code);\n          } else {\n            return surrogate_pairs_1.fromCodePoint(code);\n          }\n        }\n        return '';\n      }\n      return ALPHA_INDEX[s] || s;\n    });\n  };\n  XmlEntities.decode = function (str) {\n    return new XmlEntities().decode(str);\n  };\n  XmlEntities.prototype.encodeNonUTF = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n      var c = str.charCodeAt(i);\n      var alpha = CHAR_INDEX[c];\n      if (alpha) {\n        result += \"&\" + alpha + \";\";\n        i++;\n        continue;\n      }\n      if (c < 32 || c > 126) {\n        if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {\n          result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';\n          i++;\n        } else {\n          result += '&#' + c + ';';\n        }\n      } else {\n        result += str.charAt(i);\n      }\n      i++;\n    }\n    return result;\n  };\n  XmlEntities.encodeNonUTF = function (str) {\n    return new XmlEntities().encodeNonUTF(str);\n  };\n  XmlEntities.prototype.encodeNonASCII = function (str) {\n    if (!str || !str.length) {\n      return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n      var c = str.charCodeAt(i);\n      if (c <= 255) {\n        result += str[i++];\n        continue;\n      }\n      if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {\n        result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';\n        i++;\n      } else {\n        result += '&#' + c + ';';\n      }\n      i++;\n    }\n    return result;\n  };\n  XmlEntities.encodeNonASCII = function (str) {\n    return new XmlEntities().encodeNonASCII(str);\n  };\n  return XmlEntities;\n}();\nexports.XmlEntities = XmlEntities;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIveG1sLWVudGl0aWVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcz82NjA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIHN1cnJvZ2F0ZV9wYWlyc18xID0gcmVxdWlyZShcIi4vc3Vycm9nYXRlLXBhaXJzXCIpO1xudmFyIEFMUEhBX0lOREVYID0ge1xuICAnJmx0JzogJzwnLFxuICAnJmd0JzogJz4nLFxuICAnJnF1b3QnOiAnXCInLFxuICAnJmFwb3MnOiAnXFwnJyxcbiAgJyZhbXAnOiAnJicsXG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYXBvczsnOiAnXFwnJyxcbiAgJyZhbXA7JzogJyYnXG59O1xudmFyIENIQVJfSU5ERVggPSB7XG4gIDYwOiAnbHQnLFxuICA2MjogJ2d0JyxcbiAgMzQ6ICdxdW90JyxcbiAgMzk6ICdhcG9zJyxcbiAgMzg6ICdhbXAnXG59O1xudmFyIENIQVJfU19JTkRFWCA9IHtcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgJ1xcJyc6ICcmYXBvczsnLFxuICAnJic6ICcmYW1wOydcbn07XG52YXIgWG1sRW50aXRpZXMgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYbWxFbnRpdGllcygpIHt9XG4gIFhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bPD5cIicmXS9nLCBmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIENIQVJfU19JTkRFWFtzXTtcbiAgICB9KTtcbiAgfTtcbiAgWG1sRW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiAgfTtcbiAgWG1sRW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjP1swLTlhLXpBLVpdKzs/L2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICBpZiAocy5jaGFyQXQoMSkgPT09ICcjJykge1xuICAgICAgICB2YXIgY29kZSA9IHMuY2hhckF0KDIpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/IHBhcnNlSW50KHMuc3Vic3RyKDMpLCAxNikgOiBwYXJzZUludChzLnN1YnN0cigyKSk7XG4gICAgICAgIGlmICghaXNOYU4oY29kZSkgfHwgY29kZSA+PSAtMzI3NjgpIHtcbiAgICAgICAgICBpZiAoY29kZSA8PSA2NTUzNSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXJyb2dhdGVfcGFpcnNfMS5mcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gQUxQSEFfSU5ERVhbc10gfHwgcztcbiAgICB9KTtcbiAgfTtcbiAgWG1sRW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiAgfTtcbiAgWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGFscGhhID0gQ0hBUl9JTkRFWFtjXTtcbiAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgIGlmIChjID49IHN1cnJvZ2F0ZV9wYWlyc18xLmhpZ2hTdXJyb2dhdGVGcm9tICYmIGMgPD0gc3Vycm9nYXRlX3BhaXJzXzEuaGlnaFN1cnJvZ2F0ZVRvKSB7XG4gICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBzdXJyb2dhdGVfcGFpcnNfMS5nZXRDb2RlUG9pbnQoc3RyLCBpKSArICc7JztcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgWG1sRW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiAgfTtcbiAgWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID49IHN1cnJvZ2F0ZV9wYWlyc18xLmhpZ2hTdXJyb2dhdGVGcm9tICYmIGMgPD0gc3Vycm9nYXRlX3BhaXJzXzEuaGlnaFN1cnJvZ2F0ZVRvKSB7XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgc3Vycm9nYXRlX3BhaXJzXzEuZ2V0Q29kZVBvaW50KHN0ciwgaSkgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgWG1sRW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gIH07XG4gIHJldHVybiBYbWxFbnRpdGllcztcbn0oKTtcbmV4cG9ydHMuWG1sRW50aXRpZXMgPSBYbWxFbnRpdGllczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/xml-entities.js\n");

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n  \"use strict\";\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  \"use strict\";\n\n  // Slightly dubious tricks to cut down minimized file size\n  var noop = function () {};\n  var undefinedType = \"undefined\";\n  var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n  var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n  // Cross-browser bind equivalent that works at least back to IE6\n  function bindMethod(obj, methodName) {\n    var method = obj[methodName];\n    if (typeof method.bind === 'function') {\n      return method.bind(obj);\n    } else {\n      try {\n        return Function.prototype.bind.call(method, obj);\n      } catch (e) {\n        // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n        return function () {\n          return Function.prototype.apply.apply(method, [obj, arguments]);\n        };\n      }\n    }\n  }\n\n  // Trace() doesn't print the message in IE, so for that case we need to wrap it\n  function traceForIE() {\n    if (console.log) {\n      if (console.log.apply) {\n        console.log.apply(console, arguments);\n      } else {\n        // In old IE, native console methods themselves don't have apply().\n        Function.prototype.apply.apply(console.log, [console, arguments]);\n      }\n    }\n    if (console.trace) console.trace();\n  }\n\n  // Build the best logging method possible for this env\n  // Wherever possible we want to bind, not wrap, to preserve stack traces\n  function realMethod(methodName) {\n    if (methodName === 'debug') {\n      methodName = 'log';\n    }\n    if (typeof console === undefinedType) {\n      return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n    } else if (methodName === 'trace' && isIE) {\n      return traceForIE;\n    } else if (console[methodName] !== undefined) {\n      return bindMethod(console, methodName);\n    } else if (console.log !== undefined) {\n      return bindMethod(console, 'log');\n    } else {\n      return noop;\n    }\n  }\n\n  // These private functions always need `this` to be set properly\n\n  function replaceLoggingMethods(level, loggerName) {\n    /*jshint validthis:true */\n    for (var i = 0; i < logMethods.length; i++) {\n      var methodName = logMethods[i];\n      this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n    }\n\n    // Define log.log as an alias for log.debug\n    this.log = this.debug;\n  }\n\n  // In old IE versions, the console isn't present until you first open it.\n  // We build realMethod() replacements here that regenerate logging methods\n  function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n    return function () {\n      if (typeof console !== undefinedType) {\n        replaceLoggingMethods.call(this, level, loggerName);\n        this[methodName].apply(this, arguments);\n      }\n    };\n  }\n\n  // By default, we use closely bound real methods wherever possible, and\n  // otherwise we wait for a console to appear, and then try again.\n  function defaultMethodFactory(methodName, level, loggerName) {\n    /*jshint validthis:true */\n    return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n  }\n  function Logger(name, defaultLevel, factory) {\n    var self = this;\n    var currentLevel;\n    defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n    var storageKey = \"loglevel\";\n    if (typeof name === \"string\") {\n      storageKey += \":\" + name;\n    } else if (typeof name === \"symbol\") {\n      storageKey = undefined;\n    }\n    function persistLevelIfPossible(levelNum) {\n      var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n      if (typeof window === undefinedType || !storageKey) return;\n\n      // Use localStorage if available\n      try {\n        window.localStorage[storageKey] = levelName;\n        return;\n      } catch (ignore) {}\n\n      // Use session cookie as fallback\n      try {\n        window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n      } catch (ignore) {}\n    }\n    function getPersistedLevel() {\n      var storedLevel;\n      if (typeof window === undefinedType || !storageKey) return;\n      try {\n        storedLevel = window.localStorage[storageKey];\n      } catch (ignore) {}\n\n      // Fallback to cookies if local storage gives us nothing\n      if (typeof storedLevel === undefinedType) {\n        try {\n          var cookie = window.document.cookie;\n          var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n          if (location !== -1) {\n            storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n          }\n        } catch (ignore) {}\n      }\n\n      // If the stored level is not valid, treat it as if nothing was stored.\n      if (self.levels[storedLevel] === undefined) {\n        storedLevel = undefined;\n      }\n      return storedLevel;\n    }\n    function clearPersistedLevel() {\n      if (typeof window === undefinedType || !storageKey) return;\n\n      // Use localStorage if available\n      try {\n        window.localStorage.removeItem(storageKey);\n        return;\n      } catch (ignore) {}\n\n      // Use session cookie as fallback\n      try {\n        window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n      } catch (ignore) {}\n    }\n\n    /*\n     *\n     * Public logger API - see https://github.com/pimterry/loglevel for details\n     *\n     */\n\n    self.name = name;\n    self.levels = {\n      \"TRACE\": 0,\n      \"DEBUG\": 1,\n      \"INFO\": 2,\n      \"WARN\": 3,\n      \"ERROR\": 4,\n      \"SILENT\": 5\n    };\n    self.methodFactory = factory || defaultMethodFactory;\n    self.getLevel = function () {\n      return currentLevel;\n    };\n    self.setLevel = function (level, persist) {\n      if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n        level = self.levels[level.toUpperCase()];\n      }\n      if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n        currentLevel = level;\n        if (persist !== false) {\n          // defaults to true\n          persistLevelIfPossible(level);\n        }\n        replaceLoggingMethods.call(self, level, name);\n        if (typeof console === undefinedType && level < self.levels.SILENT) {\n          return \"No console available for logging\";\n        }\n      } else {\n        throw \"log.setLevel() called with invalid level: \" + level;\n      }\n    };\n    self.setDefaultLevel = function (level) {\n      defaultLevel = level;\n      if (!getPersistedLevel()) {\n        self.setLevel(level, false);\n      }\n    };\n    self.resetLevel = function () {\n      self.setLevel(defaultLevel, false);\n      clearPersistedLevel();\n    };\n    self.enableAll = function (persist) {\n      self.setLevel(self.levels.TRACE, persist);\n    };\n    self.disableAll = function (persist) {\n      self.setLevel(self.levels.SILENT, persist);\n    };\n\n    // Initialize with the right level\n    var initialLevel = getPersistedLevel();\n    if (initialLevel == null) {\n      initialLevel = defaultLevel;\n    }\n    self.setLevel(initialLevel, false);\n  }\n\n  /*\n   *\n   * Top-level API\n   *\n   */\n\n  var defaultLogger = new Logger();\n  var _loggersByName = {};\n  defaultLogger.getLogger = function getLogger(name) {\n    if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n      throw new TypeError(\"You must supply a name when creating a logger.\");\n    }\n    var logger = _loggersByName[name];\n    if (!logger) {\n      logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n    }\n    return logger;\n  };\n\n  // Grab the current global log variable in case of overwrite\n  var _log = typeof window !== undefinedType ? window.log : undefined;\n  defaultLogger.noConflict = function () {\n    if (typeof window !== undefinedType && window.log === defaultLogger) {\n      window.log = _log;\n    }\n    return defaultLogger;\n  };\n  defaultLogger.getLoggers = function getLoggers() {\n    return _loggersByName;\n  };\n\n  // ES6 default export, for compatibility\n  defaultLogger['default'] = defaultLogger;\n  return defaultLogger;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/ZTFkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICB2YXIgaXNJRSA9IHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiYgdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZFR5cGUgJiYgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgbG9nTWV0aG9kcyA9IFtcInRyYWNlXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdO1xuXG4gIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICB9XG5cbiAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IGkgPCBsZXZlbCA/IG5vb3AgOiB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gIH1cblxuICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHwgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICBkZWZhdWx0TGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgdmFyIHN0b3JlZExldmVsO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xuICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgKlxuICAgICAqL1xuXG4gICAgc2VsZi5uYW1lID0gbmFtZTtcbiAgICBzZWxmLmxldmVscyA9IHtcbiAgICAgIFwiVFJBQ0VcIjogMCxcbiAgICAgIFwiREVCVUdcIjogMSxcbiAgICAgIFwiSU5GT1wiOiAyLFxuICAgICAgXCJXQVJOXCI6IDMsXG4gICAgICBcIkVSUk9SXCI6IDQsXG4gICAgICBcIlNJTEVOVFwiOiA1XG4gICAgfTtcbiAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgIH07XG4gICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgZGVmYXVsdExldmVsID0gbGV2ZWw7XG4gICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5zZXRMZXZlbChkZWZhdWx0TGV2ZWwsIGZhbHNlKTtcbiAgICAgIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKTtcbiAgICB9O1xuICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24gKHBlcnNpc3QpIHtcbiAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgIH07XG4gICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24gKHBlcnNpc3QpIHtcbiAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsO1xuICAgIH1cbiAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICB9XG5cbiAgLypcbiAgICpcbiAgICogVG9wLWxldmVsIEFQSVxuICAgKlxuICAgKi9cblxuICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcbiAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgfVxuICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlcjtcbiAgfTtcblxuICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgdmFyIF9sb2cgPSB0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgfTtcbiAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gIH07XG5cbiAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICBkZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xuICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/loglevel/lib/loglevel.js\n");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */if(true){(function(){'use strict';/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=__webpack_require__(/*! react */ \"./node_modules/react/index.js\");var Scheduler=__webpack_require__(/*! scheduler */ \"./node_modules/scheduler/index.js\");var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\nfunction warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also\n// update consoleWithStackDev.www.js as well.\n{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion\nvar argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix\nargsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it\n// breaks IE9: https://github.com/facebook/react/issues/13610\n// eslint-disable-next-line react-internal/no-production-logging\nFunction.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class\nvar HostRoot=3;// Root of a host tree. Could be nested inside another node.\nvar HostPortal=4;// A subtree. Could be an entry point to a different renderer.\nvar HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------\nvar enableClientRenderFallbackOnTextMismatch=true;// TODO: Need to review this code one more time before landing\n// the react-reconciler package.\nvar enableNewReconciler=false;// Support legacy Primer support on internal FB www\nvar enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.\nvar enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber\nvar enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nvar disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.\n// and client rendering, mostly to allow JSX attributes to apply to the custom\n// element's object properties instead of only HTML attributes.\n// https://github.com/facebook/react/issues/11347\nvar enableCustomElementPropertySupport=false;// Disables children for <textarea> elements\nvar warnAboutStringRefs=false;// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nvar enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState\nvar enableProfilerTimer=true;// Record durations for commit and passive effects phases.\nvar enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nvar allNativeEvents=new Set();/**\n * Mapping from registration name to event name\n */var registrationNameDependencies={};/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true\nfunction registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant\nvar hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's\n// happened: you supplied an object or symbol value to React (as a prop, key,\n// DOM attribute, CSS property, string ref, etc.) and when React tried to\n// coerce it to a string using `'' + value`, an exception was thrown.\n//\n// The most common types that will cause this exception are `Symbol` instances\n// and Temporal objects like `Temporal.Instant`. But any object that has a\n// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n// exception. (Library authors do this to prevent users from using built-in\n// numeric operators like `+` or comparison operators like `>=` because custom\n// methods are needed to perform accurate arithmetic or comparison.)\n//\n// To fix the problem, coerce this object or symbol value to a string before\n// passing it to React. The most reliable way is usually `String(value)`.\n//\n// To find which value is throwing, check the browser or debugger console.\n// Before this exception was thrown, there should be `console.error` output\n// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n// problem and how that type was used: key, atrribute, input value prop, etc.\n// In most cases, this console output also shows the component and its\n// ancestor components where the exception happened.\n//\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED=0;// A simple string attribute.\n// Attributes that aren't in the filter are presumed to have this type.\nvar STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING=2;// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=\":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+\"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value){case'function':// $FlowIssue symbol is perfectly valid here\ncase'symbol':// eslint-disable-line\nreturn true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties={};// These props are reserved by React. They shouldn't be written to the DOM.\nvar reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML boolean attributes.\n['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata\n'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture','download'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be positive numbers.\n['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be numbers.\n['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});var CAMELIZE=/[\\-\\:]([a-z])/g;var capitalize=function(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML attribute filter.\n// Some of these attributes can be hard to find. This list was created by\n// scraping the MDN documentation.\n['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,null,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// String SVG attributes with the xlink namespace.\n['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL\nfalse);});// String SVG attributes with the xml namespace.\n['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL\nfalse);});// These attribute exists both in HTML and SVG.\n// The attribute name is case-sensitive in SVG so we can't just use\n// the React name like we do for attributes that exist only in HTML.\n['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These attributes accept URLs. These must not allow javascript: URLS.\n// These will also need to accept Trusted Types object in the future.\nvar xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty\n'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL\nfalse);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\ntrue,// sanitizeURL\ntrue);});// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n/* eslint-disable max-len */var isJavaScriptProtocol=/^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{// This check protects multiple uses of `expected`, which is why the\n// react-internal/safe-string-coercion rule is disabled in several spots\n// below.\n{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if\n// the hydration is successful of a javascript: URL, we\n// still want to warn on the client.\n// eslint-disable-next-line react-internal/safe-string-coercion\nsanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion\nif(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it\n// for the error message.\nreturn node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is\n// the fact that we have it is the same as the expected.\nreturn expected;}// Even if this property uses a namespace we use getAttribute\n// because we assume its namespaced name is the same as our config.\n// To use getAttributeNS we need the local name which we don't have\n// in our config atm.\nstringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion\n}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */function getValueForAttribute(node,name,expected,isCustomComponentTag){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly\n// `toString`ed by IE8/9.\nnode[propertyName]=value;}return;}// The rest are treated as attributes with special cases.\nvar attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink\n// and we won't require Trusted Type here.\nattributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,\n// ('' + value) makes it output the correct toString()-value.\n{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE=Symbol.for('react.element');var REACT_PORTAL_TYPE=Symbol.for('react.portal');var REACT_FRAGMENT_TYPE=Symbol.for('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol.for('react.strict_mode');var REACT_PROFILER_TYPE=Symbol.for('react.profiler');var REACT_PROVIDER_TYPE=Symbol.for('react.provider');var REACT_CONTEXT_TYPE=Symbol.for('react.context');var REACT_FORWARD_REF_TYPE=Symbol.for('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol.for('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol.for('react.suspense_list');var REACT_MEMO_TYPE=Symbol.for('react.memo');var REACT_LAZY_TYPE=Symbol.for('react.lazy');var REACT_SCOPE_TYPE=Symbol.for('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol.for('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol.for('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol.for('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol.for('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol.for('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099\nvar props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.\ntry{throw Error();}catch(x){var match=x.stack.trim().match(/\\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.\nreturn'\\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.\nif(!fn||reentry){return'';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.\nError.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function\n// for warnings.\nReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.\nif(construct){// Something should be setting the props in the constructor.\nvar Fake=function(){throw Error();};// $FlowFixMe\nObject.defineProperty(Fake.prototype,'props',{set:function(){// We use a throwing setter instead of frozen or non-writable props\n// because that won't throw in a non-strict mode function.\nthrow Error();}});if(typeof Reflect==='object'&&Reflect.construct){// We construct a different control for this case to include any extra\n// frames added by the construct call.\ntry{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else{try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else{try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.\nif(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.\n// Skipping one frame that we assume is the frame that calls the two.\nvar sampleLines=sample.stack.split('\\n');var controlLines=control.stack.split('\\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.\n// Typically this will be the root most one. However, stack frames may be\n// cut off due to maximum stack limits. In this case, one maybe cut off\n// earlier than the other. We assume that the sample is longer or the same\n// and there for cut off earlier. So we should find the root most frame in\n// the sample somewhere in the control.\nc--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the\n// frame that called our sample function and the control.\nif(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.\n// If we're about to return the first line, and the control is also on the same\n// line, that's a pretty good indicator that our sample threw at same line as\n// the control. I.e. before we entered the sample frame. So we ignore this result.\n// This can happen if you passed a class to function component, or non-function.\nif(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.\n// The next one that isn't the same should be our match though.\nif(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\nvar _frame='\\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled \"<anonymous>\"\n// but we have a user-provided \"displayName\"\n// splice it in to make the stack more readable.\nif(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.\nreturn _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.\nvar name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return'';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(typeof type==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return'';}function describeFiber(fiber){var owner=fiber._debugOwner?fiber._debugOwner.type:null;var source=fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}catch(x){return'\\nError generating stack: '+x.message+'\\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nfunction getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.\nreturn null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';case REACT_SUSPENSE_LIST_TYPE:return'SuspenseList';}if(typeof type==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough\n}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName);}// Keep in sync with shared/getComponentNameFromType\nfunction getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return'Fragment';case HostComponent:// Host component type is the display name (e.g. \"div\", \"View\")\nreturn type;case HostPortal:return'Portal';case HostRoot:return'Root';case HostText:return'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.\nreturn getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType\nreturn'StrictMode';}return'Mode';case OffscreenComponent:return'Offscreen';case Profiler:return'Profiler';case ScopeComponent:return'Scope';case SuspenseComponent:return'Suspense';case SuspenseListComponent:return'SuspenseList';case TracingMarkerComponent:return'TracingMarker';// The display name for this tags come from the user-provided type:\ncase ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,\n// and it is guaranteed to be the work-in-progress version.\nreturn getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function getCurrentFiber(){{return current;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nfunction toString(value){// The coercion safety check is performed in getToStringValue().\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function getToStringValue(value){switch(typeof value){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings\nreturn'';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail\n// and don't track value will cause over reporting of changes,\n// but it's better then a hard failure\n// (needed for certain tests that spyOn input values and Safari)\nif(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var get=descriptor.get,set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function(){return get.call(this);},set:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;set.call(this,value);}});// We could've passed this the first time\n// but it triggers a bug in IE11 and Edge 14/15.\n// Calling defineProperty() again should be equivalent.\n// https://github.com/facebook/react/issues/11768\nObject.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function(){return currentValue;},setValue:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState\nnode._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely\n// that trying again will succeed\nif(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.\n// eslint-disable-next-line\nnode.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid\n// blank-text buttons.\nnode.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of\n// properties:\n//  1. The value React property\n//  2. The defaultValue React property\n//  3. Otherwise there should be no change\nif(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs\n// to be removed, such as transitioning from a checkbox into a text input\nif(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the\n// default value provided by the browser. See: #12872\nif(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(!isHydrating){{// When syncing the value attribute, the value property should use\n// the wrapperState._initialValue property. This uses:\n//\n//   1. The value React property when present\n//   2. The defaultValue React property when present\n//   3. An empty string\nif(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,\n// so we assign defaultValue to the same thing as the value property\n// assignment step above.\nnode.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n// this is needed to work around a chrome bug where setting defaultChecked\n// will sometimes influence the value of checked (even after detachment).\n// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n// We need to temporarily unset name to avoid disrupting radio button groups.\nvar name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and\n// attribute are assigned at the same time using defaultChecked. This uses:\n//\n//   1. The checked React property when present\n//   2. The defaultChecked React property when present\n//   3. Otherwise, false\nnode.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,\n// but that sometimes behaves strangely in IE8. We could also try using\n// `form.getElementsByName`, but that will only return direct children\n// and won't include inputs that use the HTML5 `form=` attribute. Since\n// the input might not even be in a form. It might not even be in the\n// document. Let's just use the local `querySelectorAll` to ensure we don't\n// miss anything.\n{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type=\"radio\"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React\n// and the same name are rendered into the same form (same as #1939).\n// That's probably okay; we don't support it just as we don't support\n// mixing React radio buttons with non-React ones.\nvar otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value\n// was changed but the input saw no event or value set\nupdateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that\n// was previously checked to update will cause it to be come re-checked\n// as appropriate.\nupdateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js\ntype!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**\n * Implements an <option> host component that warns when `selected` is set.\n */function validateProps(element,props){{// If a value is not provided, then the children must be simple.\nif(props.value==null){if(typeof props.children==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.\nif(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value=\"\" should make a value attribute (#6219)\nif(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare\nfunction isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\\n\\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**\n * Validation function for `value` and `defaultValue`.\n */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.\nselectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all\n// browsers for all cases.\nvar _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.\nif(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.\nupdateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will\n// get reset if `textContent` is mutated.  We could add a check in setTextContent\n// to only set the value if/when the value differs from the node value (which would\n// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n// solution. The value can be a boolean or object so that's why it's forced\n// to be a string.\nvar hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it\nif(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While\n// browsers typically do this as necessary, jsdom doesn't.\nvar newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed\nif(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not\n// available until after the component has mounted.\nvar textContent=node.textContent;// Only set node.value if textContent is equal to the expected\n// initial value. In IE10/IE11 there is a bug where the placeholder attribute\n// will populate textContent as well.\n// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\nif(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update\nupdateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.\nreturn getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.\nreturn HTML_NAMESPACE;}// By default, pass namespace below.\nreturn parentNamespace;}/* globals MSApp */ /**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */var createMicrosoftUnsafeLocalFunction=function(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};var reusableSVGContainer;/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the\n// new markup in a temp node and then move the child nodes across into\n// the target node\nreusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**\n * HTML nodeType values that represent the type of the node\n */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */var setTextContent=function(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:\n// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\nvar shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties\nfillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the\n// whole string will be escaped when the attribute is injected into\n// the markup. If you provide unsafe user data here they can inject\n// arbitrary CSS which may be problematic (I couldn't repro this):\n// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n// This is not an XSS hole but instead a potential CSS injection issue\n// which has lead to a greater discussion about how we're going to\n// trust URLs moving forward. See #2115901\nvar isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers\n}{checkCSSPropertyStringCoercion(value,name);}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function(){};{// 'msTransform' is correct, but the other prefixes should be capitalized\nvar badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon\nvar badStyleValueWithSemicolonPattern=/;\\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests\n// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n// is converted to lowercase `ms`.\ncamelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error(\"Style property values shouldn't contain a semicolon. \"+'Try \"%s: %s\" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**\n * Operations for dealing with CSS properties.\n */ /**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+\"avoid this, don't mix shorthand and non-shorthand properties \"+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for\n// those special-case tags.\nvar omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.\n};// `omittedCloseTags` except that `menuitem` should still have its closing tag.\nvar voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.\nif(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+\" is a void element tag and must neither have `children` nor \"+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(typeof props.dangerouslySetInnerHTML!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&typeof props.style!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+\"not a string. For example, style={{marginRight: spacing + 'em'}} when \"+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.\n// We don't mind this list too much because we expect it to never grow.\n// The alternative is to track the namespace in a few places which is convoluted.\n// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\ncase'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames={// HTML\naccept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG\nabout:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state\n'aria-description':0,'aria-details':0,'aria-disabled':0,// state\n'aria-hidden':0,// state\n'aria-invalid':0,// state\n'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes\n'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes\n'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes\n'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes\n'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.\nif(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.\n// So we can't tell if the event name is correct for sure, but we can filter\n// out known bad ones like `onclick`. We can't suggest a specific replacement though.\nif(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes\nif(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',typeof value);warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.\nif(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they\n// will be cased anyway with server rendering.\nerror('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.',value,name,name,value,name);}else{error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate\n// data types for reserved props\nif(isReserved){return true;}// Warn when a known attribute is a bad type\nif(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop\nif((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string \"false\".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when\n// we call willDeferLaterForLegacyFBSupport, thus not bailing out\n// will result in endless cycles like an infinite loop.\n// We also don't want to defer during event replaying.\nvar SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying\n// and DOMPluginEventSystem.\nvar currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9\n// https://github.com/facebook/react/issues/12506\nvar target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963\nif(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n// @see http://www.quirksmode.org/js/events_properties.html\nreturn target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we\n// always receive the correct fiber here\nvar internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted\nreturn;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.\nif(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\nvar batchedUpdatesImpl=function(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important\n// when using controlled components within layers:\n// https://github.com/facebook/react/issues/1698\n// Then we restore state of any controlled component.\nvar controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of\n// the DOM node back to the controlled value. This is necessary when React\n// bails out of the update without touching the DOM.\n// TODO: Restore state in the microtask, after the discrete updates flush,\n// instead of early flushing them here.\nflushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it\n// fully completes before restoring state.\nreturn fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync\nfunction setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return!!(props.disabled&&isInteractive(type));default:return false;}}/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).\nreturn null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.\nreturn null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error(\"Expected `\"+registrationName+\"` listener to be a function, instead got a value of `\"+typeof listener+\"` type.\");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nif(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value\nObject.defineProperty(options,'passive',{get:function(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version\n// that plays more nicely with the browser's DevTools. The idea is to preserve\n// \"Pause on exceptions\" behavior. Because React wraps all user-provided\n// functions in invokeGuardedCallback, and the production version of\n// invokeGuardedCallback uses a try-catch, all user exceptions are treated\n// like caught exceptions, and the DevTools won't pause unless the developer\n// takes the extra step of enabling pause on caught exceptions. This is\n// unintuitive, though, because even though React has caught the error, from\n// the developer's perspective, the error is uncaught.\n//\n// To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n// DOM node, and call the user-provided callback from inside an event handler\n// for that fake event. If the callback throws, the error is \"captured\" using\n// a global event handler. But because the error happens in a different\n// event loop context, it does not interrupt the normal program flow.\n// Effectively, this gives us try-catch behavior without actually using\n// try-catch. Neat!\n// Check that the browser supports the APIs we need to implement our special\n// DEV version of invokeGuardedCallback\nif(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method\n// when we call document.createEvent(). However this can cause confusing\n// errors: https://github.com/facebook/create-react-app/issues/3482\n// So we preemptively throw with a better message instead.\nif(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We\n// set this to true at the beginning, then set it to false right after\n// calling the function. If the function errors, `didError` will never be\n// set to false. This strategy works even if the browser is flaky and\n// fails to call our global error handler, because it doesn't rely on\n// the error event at all.\nvar didError=true;// Keeps track of the value of window.event so that we can reset it\n// during the callback to let user code access window.event in the\n// browsers that support it.\nvar windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event\n// dispatching: https://github.com/facebook/react/issues/13688\nvar windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that\n// nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n// nested call would trigger the fake event handlers of any call higher\n// in the stack.\nfakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the\n// window.event assignment in both IE <= 10 as they throw an error\n// \"Member not found\" in strict mode, and in Firefox which does not\n// support window.event.\nif(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously\n// dispatch our fake event using `dispatchEvent`. Inside the handler, we\n// call the user-provided callback.\nvar funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value\n// that was thrown. It's possible that this error handler will fire more\n// than once; for example, if non-React code also calls `dispatchEvent`\n// and a handler for that event throws. We should be resilient to most of\n// those cases. Even if our error event handler fires more than once, the\n// last error event is always used. If the callback actually does error,\n// we know that the last error event is the correct one, because it's not\n// possible for anything else to have happened in between our callback\n// erroring and the code that follows the `dispatchEvent` call below. If\n// the callback doesn't error, but the error event was fired, we know to\n// ignore it because `didError` will be false, as described above.\nvar error;// Use this to track whether the error event is ever called.\nvar didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.\n// Browsers silence the error report if this happens.\n// We'll remember this to later decide whether to log it or not.\nif(error!=null&&typeof error==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.\n}}}}// Create a fake event type.\nvar evtType=\"react-\"+(name?name:'invokeguardedcallback');// Attach our event handlers\nwindow.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function\n// errors, it will trigger our global error handler.\nevt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.\n// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error('An error was thrown inside one of your components, but React '+\"doesn't know what it was. This is likely due to browser \"+'flakiness. React does its best to preserve the \"Pause on '+'exceptions\" behavior of the DevTools, which requires some '+\"DEV-mode only tricks. It's possible that these don't work in \"+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(\"A cross-origin error was thrown. React doesn't have access to \"+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners\nwindow.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.\n// https://github.com/facebook/react/issues/16734\n// https://github.com/facebook/react/issues/16585\n// Fall back to the production implementation.\nrestoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.\nvar hasRethrowError=false;var rethrowError=null;var reporter={onError:function(error){hasError=true;caughtError=error;}};/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).\nvar Placement=/*                    */2;var Update=/*                       */4;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)\nvar HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.\nvar Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\nvar RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\nvar MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\nvar BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask\nvar PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\nvar StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted\n// yet. If it is, then it will have a pending insertion effect on it.\nvar nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible\n// mounted fiber is the parent but we need to continue to figure out\n// if that one is still mounted.\nnearestMounted=node.return;}nextNode=node.return;}while(nextNode);}else{while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with\n// renderContainerIntoSubtree.\nreturn nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree\n// that has been unmounted.\nreturn null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.\nvar nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root\n// to see what path the root points to. On the way we may hit one of the\n// special cases and we'll deal with them.\nvar a=fiber;var b=alternate;while(true){var parentA=a.return;if(parentA===null){// We're at the root.\nbreak;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only\n// happens when a Suspense component is hidden. An extra fragment fiber\n// is inserted in between the Suspense fiber and its children. Skip\n// over this extra fragment fiber and proceed to the next parent.\nvar nextParent=parentA.return;if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.\nbreak;}// If both copies of the parent fiber point to the same child, we can\n// assume that the child is current. This happens when we bailout on low\n// priority: the bailed out fiber's child reuses the current child.\nif(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.\nassertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.\nassertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only\n// way this could possibly happen is if this was unmounted, if at all.\nthrow new Error('Unable to find node on an unmounted component.');}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different\n// fibers. We assume that return pointers never criss-cross, so A must\n// belong to the child set of A.return, and B must belong to the child\n// set of B.return.\na=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the\n// default, slow path: scan the child sets of each parent alternate to see\n// which child belongs to which set.\n//\n// Search parent A's child set\nvar didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set\n_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error(\"Return fibers should always be each others' alternates. \"+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.\n// unmounted.\nif(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.\nreturn fiber;}// Otherwise B has to be current branch.\nreturn alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools\nreturn false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out\n// of DevTools integration and associated warnings and logs.\n// https://github.com/facebook/react/issues/3877\nreturn true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.\nreturn true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.\n// This gives DevTools a way to feature detect that isn't tied to version number\n// (since profiling and timeline are controlled by different feature flags).\ninternals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.\ninjectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.\n{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.\nreturn true;}else{// This is likely a hook installed by Fast Refresh runtime.\nreturn false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}else{injectedHook.onCommitFiberRoot(rendererID,root,undefined,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists\n// in SchedulerMock. To reduce the noise in strict mode tests,\n// suppress warnings and disable scheduler yielding during the double render\nunstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks\nfunction injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead\nvar ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\nvar log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.\nvar TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*             */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                     */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                          */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                        */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nfunction getLabelForLane(lane){{if(lane&SyncLane){return'Sync';}if(lane&InputContinuousHydrationLane){return'InputContinuousHydration';}if(lane&InputContinuousLane){return'InputContinuous';}if(lane&DefaultHydrationLane){return'DefaultHydration';}if(lane&DefaultLane){return'Default';}if(lane&TransitionHydrationLane){return'TransitionHydration';}if(lane&TransitionLanes){return'Transition';}if(lane&RetryLanes){return'Retry';}if(lane&SelectiveHydrationLane){return'SelectiveHydration';}if(lane&IdleHydrationLane){return'IdleHydration';}if(lane&IdleLane){return'Idle';}if(lane&OffscreenLane){return'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.\nreturn lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.\nvar pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,\n// even if the work is suspended.\nvar nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else{// The only remaining work is Idle.\nvar unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else{if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended\n// TODO: Consider warning in this path if a fallback timer is not scheduled.\nreturn NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt\n// it and we'll lose our progress. We should only do this if the new lanes are\n// higher priority.\nif(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't\n// bother waiting until the root is complete.\n(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip\n// one. This works because the bits decrease in priority as you go left.\nnextLane>=wipLane||// Default priority updates should not interrupt transition updates. The\n// only difference between default updates and transition updates is that\n// default updates do not support refresh transitions.\nnextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.\nreturn wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates\n// and default updates, so they render in the same batch. The only reason\n// they use separate lanes is because continuous updates should interrupt\n// transitions, but default updates should not.\nnextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.\n//\n// A lane is said to be entangled with another when it's not allowed to render\n// in a batch that does not also include the other lane. Typically we do this\n// when multiple updates have the same source, and we only want to respond to\n// the most recent event from that source.\n//\n// Note that we apply entanglements *after* checking for partial work above.\n// This means that if a lane is entangled during an interleaved event while\n// it's already rendering, we won't interrupt it. This is intentional, since\n// entanglement is usually \"best effort\": we'll try our best to render the\n// lanes in the same batch, but it's not worth throwing out partially\n// completed work in order to do it.\n// TODO: Reconsider this. The counter-argument is that the partial work\n// represents an intermediate state, which we don't want to show to the user.\n// And by spending extra time finishing it, we're increasing the amount of\n// time it takes to show the final state, which is what they are actually\n// waiting for.\n//\n// For those exceptions where entanglement is semantically important, like\n// useMutableSource, we should ensure that there is no partial work at the\n// time we apply the entanglement.\nvar entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.\n//\n// NOTE: This is set to the corresponding constant as in Scheduler.js.\n// When we made it larger, a product metric in www regressed, suggesting\n// there's a user interaction that's being starved by a series of\n// synchronous updates. If that theory is correct, the proper solution is\n// to fix the starvation. However, this scenario supports the idea that\n// expiration times are an important safeguard when starvation\n// does happen.\nreturn currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for\n// too long, but when I made this change it caused a spike in browser\n// crashes. There must be some other underlying bug; not super urgent but\n// ideally should figure out why and fix it. Unfortunately we don't have\n// a repro for the crashes, only detected via production metrics.\nreturn NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.\nreturn NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing\n// the earliest expiration time on the root. Then use that to quickly bail out\n// of this function.\nvar pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their\n// expiration time. If so, we'll assume the update is being starved and mark\n// it as expired to force it to finish.\nvar lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or\n// if it's pinged, assume it's CPU-bound. Compute a new expiration time\n// using the current time.\nif((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.\nexpirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired\nroot.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nfunction getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes;}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return(lanes&UrgentLanes)===NoLanes;}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can\n// expire after a render has already started.\nreturn(lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return(lane&TransitionLanes)!==NoLanes;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.\n// In most cases, this means every transition gets its own lane, until we\n// run out of lanes and cycle back to the beginning.\nvar lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===NoLanes){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===NoLanes){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it\n// doesn't matter which bit is selected; you can pick any bit without\n// affecting the algorithms where its used. Here I'm using\n// getHighestPriorityLane because it requires the fewest operations.\nreturn getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return(a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return(set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nfunction laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.\nreturn a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.\n// https://v8.dev/blog/elements-kinds#avoid-creating-holes\nvar laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update\n// could unblock them. Clear the suspended lanes so that we can try rendering\n// them again.\n//\n// TODO: We really only need to unsuspend only lanes that are in the\n// `subtreeLanes` of the updated fiber, or the update lanes of the return\n// path. This would exclude suspended updates in an unrelated sibling tree,\n// since there's no way for this update to unblock it.\n//\n// We don't do this if the incoming update is idle, because we never process\n// idle updates until after all the regular updates have finished; there's no\n// way it could unblock a transition.\nif(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most\n// recent event, and we assume time is monotonically increasing.\neventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.\nvar expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again\nroot.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work\nvar lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also\n// have to consider _transitive_ entanglements. For each lane that is already\n// entangled with *any* of the given lanes, that lane is now transitively\n// entangled with *all* the given lanes.\n//\n// Translated: If C is entangled with A, then entangling A with B also\n// entangles C with B.\n//\n// If this is hard to grasp, it might help to intentionally break this\n// function and look at the tests that fail in ReactTransition-test.js. Try\n// commenting out one of the conditions below.\nvar rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?\nlane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?\nentanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't\n// be retried at a hydration lane.\nlane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we\n// already attempted and failed to hydrate at that level. Also check if we're\n// already rendering that lane, which is rare but could happen.\nif((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.\nreturn NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}function getTransitionsForLanes(root,lanes){{return null;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\nvar hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.\nvar queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.\n// if the last target was dehydrated.\nvar queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.\nvar queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.\nvar queuedExplicitHydrationTargets=[];var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase\n'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers.delete(pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures.delete(_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.\nattemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because\n// the different event systems have different DOM event listeners.\n// We can accumulate the flags, and the targetContainers, and\n// store a single event to be replayed.\nexistingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we\n// moved from outside the window (no target) onto the target once it hydrates.\n// Instead of mutating we could clone the event.\nswitch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n// Try to unify them. It's a bit tricky since it would require two return\n// values.\nvar targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.\n// Increase its priority.\nqueuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of\n// a root other than sync.\nreturn;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){// TODO: This will read the priority if it's dispatched by the React\n// event system but not native events. Should read window.event.type, like\n// we do for updates (getCurrentEventPriority).\nvar updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than\nif(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){{var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}}else{// We're still blocked. Try again later.\nvar _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.\ntargetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map.delete(key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are\n// now unblocked. This first might not actually be unblocked yet.\n// We could check it early to avoid scheduling an unnecessary callback.\nScheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked\n// and eligible for a replay.\nif(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's\n// worth it because we expect very few discrete events to queue up and once\n// we are actually fully unblocked it will be fast to replay them.\nfor(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.\nbreak;}else{attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.\nqueuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?\nvar _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\nfunction setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}{dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent);}}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because\n// queueing is accumulative.\nclearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,\n// in case the event system needs to trace it.\ndispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\nfunction findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.\nreturn_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.\ntargetInst=null;}else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we\n// don't want this event dispatched twice through the event system.\n// TODO: If this is the first discrete event in the queue. Schedule an increased\n// priority for this boundary.\nreturn instance;}// This shouldn't happen, something went wrong but to avoid blocking\n// the whole system, dispatch the event without a target.\n// TODO: Warn.\ntargetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block\n// the whole system.\nreturn getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that\n// component's mount, ignore it for now (that is, treat it as if it was an\n// event on a non-React tree). We might also consider queueing events and\n// dispatching them after the mount.\ntargetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.\nreturn null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:\ncase'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:\n// eslint-disable-next-line no-fallthrough\ncase'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:\n// eslint-disable-next-line no-fallthrough\ncase'beforeblur':case'afterblur':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.\n// Eventually this mechanism will be replaced by a check\n// of the current priority on the native scheduler.\nvar schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\nreturn DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.\nif(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.\ncharCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n// report Enter as charCode 10 when ctrl is pressed.\nif(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n// Must not discard the (non-)printable Enter-key.\nif(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.\n// If we had a single constructor, it would be megamorphic and engines would deopt.\nfunction createSyntheticEvent(Interface){/**\n   * Synthetic events are dispatched by event plugins, typically in response to a\n   * top-level event delegation handler.\n   *\n   * These systems should generally use pooling to reduce the frequency of garbage\n   * collection. The system should check `isPersistent` to determine whether the\n   * event should be released into the pool after being dispatched. Users that\n   * need a persisted event should invoke `persist`.\n   *\n   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n   * DOM interface; custom application-specific events can also subclass this.\n   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else{this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a \"propertychange\" event for\n// IE. This event does not support bubbling or cancelling, and\n// any references to cancelBubble throw \"Member not found\".  A\n// typeof check of \"unknown\" circumvents this issue (and is also\n// IE specific).\nevent.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won't be added back into the pool.\n     */persist:function(){// Modern event system doesn't use pooling.\n},/**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return {boolean} True if this should not be released, false otherwise.\n     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else{lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here\n// because it's guaranteed to have already run when movementX\n// was copied.\nreturn lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */ // Happens to share the same list for now.\nvar SyntheticInputEvent=SyntheticCompositionEvent;/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to\n// implementations of a working draft specification.\n// FireFox implements `key` but returns `MozPrintableKey` for all\n// printable characters (normalized to `Unidentified`), ignore it.\nvar key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.\nif(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can\n// thus be captured by `keypress`, no other non-printable key should.\nreturn charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each\n// `keyCode` value, almost all function keys have a universal value.\nreturn translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support\n// getModifierState. If getModifierState is not supported, we map it to a set of\n// modifier keys exposed by the event. In this case, Lock-keys are not supported.\nfunction modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface\ncharCode:function(event){// `charCode` is the result of a KeyPress event and represents the value of\n// the actual printable character.\n// KeyPress is deprecated, but its replacement is not yet final and not\n// implemented in any major browser. Only KeyPress has charCode.\nif(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of\n// physical keyboard key.\n// The actual meaning of the value depends on the users' keyboard layout\n// which cannot be detected. Assuming that it is a US keyboard layout\n// provides a surprisingly accurate mapping for US and European users.\n// Due to this, it is left to the user to implement at this time.\nif(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function(event){// `which` is an alias for either `keyCode` or `charCode` depending on the\n// type of the event.\nif(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n// notch on the scroll is always +/- 120, roughly equivalent to pixels.\n// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\ndeltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space\nvar START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress=false;/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.\n!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**\n * Translate native top level events into event types.\n */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return'onCompositionStart';case'compositionend':return'onCompositionEnd';case'compositionupdate':return'onCompositionUpdate';}}/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**\n * Does our fallback mode think that this event is the end of composition?\n */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.\nreturn END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other\n// code we must have exited earlier.\nreturn nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.\nreturn true;default:return false;}}/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(typeof detail==='object'&&'data'in detail){return detail.data;}return null;}/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.\nvar isComposing=false;/**\n * @return {?object} A SyntheticCompositionEvent.\n */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be\n// overwritten while composition continues.\nif(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.\n// This matches the property of native CompositionEventInterface.\nevent.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.\nvar chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled\n// it at the keypress level and bail immediately. Android Chrome\n// doesn't give us keycodes, so we need to ignore it.\nif(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.\nreturn null;}}/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,\n// try to extract the composed characters from the fallback object.\n// If composition event is available, we extract a string only at\n// compositionevent, otherwise extract it at fallback events.\nif(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input\n// chars. Paste events should not lead to BeforeInput events.\nreturn null;case'keypress':/**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via\n// Touch keyboard of Windows.  In such a case, the `char` property\n// holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n// is 2, the property `which` does not represent an emoji correctly.\n// In such a case, we directly return the `char` property instead of\n// using `which`.\nif(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else{chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should\n// be fired.\nif(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=(eventName in document);if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.\nenqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**\n * For IE shims\n */var activeElement=null;var activeElementInst=null;/**\n * SECTION: handle `change` event\n */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the\n// other events and have it go through ReactBrowserEventEmitter. Since it\n// doesn't, we manually listen for the events and so we have to enqueue and\n// process the abstract event manually.\n//\n// Batching is necessary here in order to ensure that all event handlers run\n// before the next rerender (including event handlers attached to ancestor\n// elements instead of directly on the input). Without this, controlled\n// components don't work properly in conjunction with event bubbling because\n// the component is rerendered and the value reverted before all the event\n// handlers can run. See https://github.com/facebook/react/issues/708.\nbatchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**\n * SECTION: handle `input` event\n */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when\n// deleting text, so we ignore its input events.\nisInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and\n// doesn't fire when text is deleted, but conveniently, selectionchange\n// appears to fire in all of the remaining cases so we catch those and\n// forward the event if the value has changed\n// In either case, we don't want to call the event handler if the value\n// is changed from JS so we redefine a setter for `.value` that updates\n// our activeElementValue variable, allowing us to ignore those changes\n//\n// stopWatching() should be a noop here but we call it just in case we\n// missed a blur event somehow.\nstopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't\n// helpful for us so just check activeElement instead.\n//\n// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n// propertychange on the first input event after setting `value` from a\n// script and fires only keydown, keypress, keyup. Catching keyup usually\n// gets it and catching keydown lets us fire an event for the first\n// keystroke if user does a key repeat (it'll be a little delayed: right\n// before the second keystroke). Other input methods (e.g., paste) seem to\n// fire selectionchange normally.\nreturn getInstIfValueChanged(activeElementInst);}}/**\n * SECTION: handle `click` event\n */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.\n// This approach works across all browsers, whereas `change` does not fire\n// until `blur` in IE8.\nvar nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur\nsetDefaultValue(node,'number',node.value);}}/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs\nif(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**\n * For almost every interaction we care about, there will be both a top-level\n * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n * we do not extract duplicate events. However, moving the mouse into the\n * browser from outside will not fire a `mouseout` event. In this case, we use\n * the `mouseover` top-level event.\n */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched\n// the event in the out event of the other target. If this is replayed,\n// then it's because we couldn't dispatch against this target previously\n// so we have to do it now instead.\nvar related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have\n// already dispatched the corresponding events during its mouseout.\nif(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.\nreturn;}var win;// TODO: why is this nullable in the types but we read from it?\nif(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.\nwin=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\nvar doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else{// Moving to a node from outside the window.\nfrom=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.\nreturn;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing\n// the first ancestor. Next time, we will ignore the event.\nvar nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare\n;}var objectIs=typeof Object.is==='function'?Object.is:is;/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(typeof objA!=='object'||objA===null||typeof objB!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.\nfor(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n// up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n// expose properties, triggering a \"Permission denied error\" if any of its\n// properties are accessed. The only seemingly possible way to avoid erroring\n// is to access a property that typically works for non-anonymous divs and\n// catch any error that may otherwise arise. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=208427\ntry{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.\nparentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting\n// it. If it has no children, this is still the first loop, and the only\n// valid selection is anchorNode and focusNode both equal to this node\n// and both offsets 0, in which case we will have handled above.\nbreak outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.\nnode=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't\n// actually inside the passed-in node.)\nreturn null;}return{start:start,end:end};}/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with \"Object expected\" in some scenarios.\n// (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n// fails when pasting 100+ items)\nif(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.\n// Flip backward selections, so we can set with a single range.\nif(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser\n// to throw, e.g. if it has a cross-origin src attribute.\n// Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n// iframe.contentDocument.defaultView;\n// A safety way is to access one of the cross origin properties: Window or Location\n// Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\nreturn typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */ /**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable\nvar ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.\nselection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.\nselection=getOffsets(input);}return selection||{start:0,end:0};}/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**\n * Get document associated with the event target.\n */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a\n// selection (this matches native `select` event behavior). In HTML5, select\n// fires only on input and textarea thus if there's no focused element we\n// won't dispatch.\nvar doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.\nvar currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.\ncase'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the\n// semantics of the native select event.\ncase'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and\n// sometimes when it hasn't). IE's event fires out of order with respect\n// to key and input events on deletion, so we discard it.\n//\n// Firefox doesn't support selectionchange, so check selection status\n// after each key entry. The selection changes after keydown and before\n// keyup, but we check on keydown as well in the case of holding down a\n// key, when multiple keydown events are fired but only one keyup is.\n// This is also our approach for IE handling, for the reason above.\ncase'selectionchange':if(skipSelectionChangeEvent){break;}// falls through\ncase'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**\n * A list of event names to a configurable list of vendor prefixes.\n */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**\n * Event names that have already been detected and prefixed (if applicable).\n */var prefixedEventNames={};/**\n * Element to check for prefixes on.\n */var style={};/**\n * Bootstrap if a DOM exists.\n */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,\n// the un-prefixed \"animation\" and \"transition\" properties are defined on the\n// style object but the events that fire will still be prefixed, so we need\n// to check if the un-prefixed events are usable, and if not remove them from the map.\nif(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above\nif(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!\n//\n// E.g. it needs \"pointerDown\", not \"pointerdown\".\n// This is because we derive both React name (\"onPointerDown\")\n// and DOM name (\"pointerdown\") from the same list.\n//\n// Exceptions that don't match this convention are listed separately.\n//\n// prettier-ignore\nvar simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.\nregisterSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes\n// the unwanted keypress events. Enter is however both printable and\n// non-printable. One would expect Tab to be as well (but it isn't).\nif(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the\n// unwanted click events.\nif(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events\n/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.\n// In the past, React has always bubbled them, but this can be surprising.\n// We're going to try aligning closer to the browser behavior by not bubbling\n// them in React either. We'll start by not bubbling onScroll, and then expand.\nvar accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from\n// nonDelegatedEvents list in DOMPluginEventSystem.\n// Then we can remove this special list.\n// This is a breaking change that can wait until React 18.\ndomEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.\nvar _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.\nregisterSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a \"SimpleEventPlugin\".\n// This is the basic functionality of the event system. All\n// the other plugins are essentially polyfills. So the plugin\n// should probably be inlined somewhere and have its logic\n// be core the to event system. This would potentially allow\n// us to ship builds of React without the polyfilled plugins below.\nextractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the\n// event's native \"bubble\" phase, which means that we're\n// not in the capture phase. That's because we emulate\n// the capture phase here still. This is a trade-off,\n// because in an ideal world we would not emulate and use\n// the phases properly, like we do with the SimpleEvent\n// plugin. However, the plugins below either expect\n// emulation (EnterLeave) or use state localized to that\n// plugin (BeforeInput, Change, Select). The state in\n// these modules complicates things, as you'll essentially\n// get the case where the capture phase event might change\n// state, only for the following bubble event to come in\n// later and not trigger anything as the state now\n// invalidates the heuristics of the event plugin. We\n// could alter all these plugins to work in such ways, but\n// that might cause other unknown side-effects that we\n// can't foresee right now.\nif(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.\nvar mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\nvar nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else{for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.\n}// This would be a good time to rethrow if any of the event handlers threw.\nrethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the\nvar listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it\n// doesn't bubble and needs to be on the document.\nif(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication\n// but it is attached to the document.\nif(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be\n// active and not passive.\nvar isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events\n// passive by default on document. React doesn't bind them\n// to document anymore, but changing this now would undo\n// the performance wins from the change. So we emulate\n// the existing behavior manually on the roots now.\n// https://github.com/facebook/react/issues/19651\nif(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;var unsubscribeListener;// When legacyFBSupport is enabled, it's for when we\nif(isCapturePhaseListener){if(isPassiveListener!==undefined){unsubscribeListener=addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventCaptureListener(targetContainer,domEventName,listener);}}else{if(isPassiveListener!==undefined){unsubscribeListener=addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we\nif(targetInst!==null){// The below logic attempts to work out if we need to change\n// the target fiber to a different ancestor. We had similar logic\n// in the legacy event system, except the big difference between\n// systems is that the modern event system now has an event listener\n// attached to each React Root and React Portal Root. Together,\n// the DOM nodes representing these roots are the \"rootContainer\".\n// To figure out which ancestor instance we should use, we traverse\n// up the fiber tree from the target instance and attempt to find\n// root boundaries that match that of our current \"rootContainer\".\n// If we find that \"rootContainer\", we find the parent fiber\n// sub-tree for that root and make that our ancestor instance.\nvar node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.\n// Normally portals handle their own events all the way down to the root.\n// So we should be able to stop now. However, we don't know if this portal\n// was part of *our* root.\nvar grandNode=node.return;while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as\n// a parent of the Portal. That means we can ignore it because the\n// Portal will bubble through to us.\nreturn;}}grandNode=grandNode.return;}}// Now we need to find it's corresponding host fiber in the other\n// tree. To do this we can use getClosestInstanceFromNode, but we\n// need to validate that the fiber is a host instance, otherwise\n// we need to traverse up through the DOM till we find the correct\n// node that is from the other tree.\nwhile(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node.return;}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return{instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners\nif(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't\n// continue to propagate through the React fiber tree to find other\n// listeners.\nif(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take\ninstance=instance.return;}return listeners;}// We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\nfunction accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance.return;}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.\n// That is depending on if we want nested subtrees (layers) to bubble\n// events to their parent. We could also go through parentNode on the\n// host node but that wouldn't work for React Native and doesn't let us\n// do the portal feature.\n}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.\nwhile(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.\nwhile(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.\nvar depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance.return;}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\nfunction accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+\"__\"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.\ndialog:true,// Electron ships a custom <webview> tag to display external web content in\n// an isolated frame and process.\n// This tag is not present in non Electron environments such as JSDom which\n// is often used for testing purposes.\n// @see https://electronjs.org/docs/api/webview-tag\nwebview:true};validatePropertiesInDevelopment=function(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other\n// browsers. It adds spaces and sorts the properties in some\n// non-alphabetical order. Handling that would require sorting CSS\n// properties in the client & server versions or applying\n// `expectedStyle` to a temporary DOM node to read its `style` attribute\n// normalized. Since it only affects IE, we're skipping style warnings\n// in that browser completely in favor of doing all that work.\n// See https://github.com/facebook/react/issues/11807\ncanDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener);}};// Parse the HTML and read it back to normalize the HTML string so that it\n// can be used for comparison.\nnormalizeHTML=function(parent,html){// We could have created a separate document here to avoid\n// re-initializing custom elements if they exist. But this breaks\n// how <noscript> is being handled. So we use the same document.\n// See the discussion in https://github.com/facebook/react/pull/11157.\nvar testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.\n// It also can turn \\u0000 into \\uFFFD inside attributes.\n// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n// If we have a mismatch, it might be caused by that.\n// We will still patch up in this case but not fire the warning.\nvar NORMALIZE_NEWLINES_REGEX=/\\r\\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\\u0000|\\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: \"%s\" Client: \"%s\"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to\n// client rendering, up to the nearest Suspense boundary.\nthrow new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on\n// non-interactive elements, which means delegated click listeners do not\n// fire. The workaround for this bug involves attaching an empty click\n// listener on the target node.\n// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n// Just set it using the onclick property so that we don't have to manage any\n// bookkeeping for it. Not sure if we need to clear it when the listener is\n// removed.\n// TODO: Only do this for the relevant Safaris maybe?\nnode.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.\nsetValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting\n// textContent on a <textarea> will cause the placeholder to not\n// show within the <textarea> until it has been focused and blurred again.\n// https://github.com/facebook/react/issues/6731#issuecomment-254874553\nvar canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag\nfor(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML\n// tags get no namespace.\nvar ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to\n// allow <SVG> or <mATH>.\nif(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its \"parser-inserted\" flag is\n// set to true and it does not execute\nvar div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line\n// This is guaranteed to yield a script element.\nvar firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components\ndomElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n// See discussion in https://github.com/facebook/react/pull/6896\n// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\ndomElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`\n// attributes on `select`s needs to be added before `option`s are inserted.\n// This prevents:\n// - a bug where the `select` does not scroll to the correct option because singular\n//  `select` elements automatically pick the first item #13222\n// - a bug where the `select` set the first item as selected despite the `size` attribute #14239\n// See https://github.com/facebook/react/issues/13222\n// and https://github.com/facebook/react/issues/14239\nif(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where\n// it is possible that no option is selected.\n//\n// This is only necessary when a select in \"single selection mode\".\nnode.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nvar props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.\nfunction diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" fiber pointer gets updated so we need a commit\n// to update this element.\nif(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use\n// the allowed property list in the commit phase instead.\n(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.\nfor(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.\nfor(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.\nif(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.\nif(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" props pointer gets updated so we need a commit\n// to update this element.\nupdatePayload=[];}}else{// For any other property we always add it to the queue and then we\n// filter it out using the allowed property list during the commit.\n(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.\nfunction updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.\n// In the middle of an update, it is possible to have multiple checked.\n// When a checked radio tries to change name, browser makes another radio's checked false.\nif(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.\nupdateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props\n// changed.\nswitch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to\n// happen after `updateDOMProperties`. Otherwise HTML5 input validations\n// raise warnings and prevent the new value from being assigned.\nupdateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children\n// reconciliation\npostUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nswitch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\ncase'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.\n// See discussion in https://github.com/facebook/react/pull/10676.\nextraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This\n// might match additional HTML that is hidden when we read it using\n// textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n// satisfies our requirement. Our requirement is not to produce perfect\n// HTML and attributes. Ideally we should preserve structure but it's\n// ok not to if the visible content is still enough to indicate what\n// even listeners these nodes might be wired up to.\n// TODO: Warn if there is more than a single textNode as a child.\n// TODO: Should we use domElement.firstChild.nodeValue to compare?\nif(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)\ntypeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.\nvar serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]===true);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\npropKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will\n// be successfully parsed from HTML, but will produce a mismatch\n// (and would be incorrectly rendered on the client).\n// However, we already warn about bad casing elsewhere.\n// So we'll skip the misleading extra mismatch warning in this case.\nisMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){if(// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==true){// $FlowFixMe - Should be inferred as not undefined.\nwarnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at\n// post mount to force it to diverge from attributes. However, for\n// option and select we don't quite do the same thing and select\n// is not resilient to the DOM state changing so we don't do that here.\n// TODO: Consider not doing this for input and textarea.\nbreak;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node \"%s\" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in\n// the HTML.\n// TODO: Remove this special case if we can just avoid inserting empty\n// text nodes.\nreturn;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function(){};var updatedAncestorInfo=function(){};{// This validation code was written based on the HTML5 parsing spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n//\n// Note: this does not catch all invalid nesting, nor does it try to (as it's\n// not clear what practical benefit doing so provides); instead, we warn only\n// for cases where the parser will give a parse tree differing from what React\n// intended. For example, <b><div></div></b> is invalid but we don't warn\n// because it still parses correctly; we do warn for other cases like nested\n// <p> tags where the beginning of the second element implicitly closes the\n// first, causing a confusing mess.\n// https://html.spec.whatwg.org/multipage/syntax.html#special\nvar specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\nvar inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n// TODO: Distinguish by namespace here -- for <title>, including it here\n// errs on the side of fewer warnings\n'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\nvar buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nvar impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nif(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**\n   * Returns whether\n   */var isTagValidWithParent=function(tag,parentTag){// First, let's check if we're in an unusual parsing mode...\nswitch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\ncase'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n// but\ncase'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n// No special behavior since these rules fall back to \"in body\" mode for\n// all except special table nodes which cause bad parsing behavior anyway.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\ncase'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\ncase'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\ncase'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\ncase'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\ncase'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\ncase'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n// where the parsing rules cause implicit opens or closes to be added.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nswitch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child\n// parsing rules -- if we're down here, then none of those matched and\n// so we allow it only if we don't know what the parent is, as all other\n// cases are invalid.\nreturn parentTag==null;}return true;};/**\n   * Returns whether\n   */var findInvalidAncestorForTag=function(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds\n// equivalent to this check.\nreturn ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=\" Make sure you don't have any extra whitespace between tags on \"+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else{error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.\nvar hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(typeof newProps.children!==typeof oldProps.children&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||typeof props.dangerouslySetInnerHTML==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nvar scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------\nvar scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.\nfunction handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------\nfunction commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only\n// fires if there is an `Update` effect scheduled during mounting.\n// This happens if `finalizeInitialChildren` returns `true` (which it\n// does to implement the `autoFocus` attribute on the client). But\n// there are also other cases when this might happen (such as patching\n// up text content during hydration mismatch). So we'll check this again.\nswitch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.\nupdateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with\n// with current event handlers.\nupdateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.\n// If something inside a portal is clicked, that click should bubble\n// through the React tree. However, on Mobile Safari the click would\n// never bubble through the *DOM* tree unless an ancestor with onclick\n// event exists. So we wouldn't see it and dispatch it.\n// This is why we ensure that non React root containers have inline onclick\n// defined.\n// https://github.com/facebook/react/issues/11918\nvar reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);return;}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.\n// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we\n// pass host context to this method?\ninstance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else{style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){if(container.documentElement){container.removeChild(container.documentElement);}}}// -------------------\nfunction canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.\nreturn instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a text node.\nreturn instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a suspense node.\nreturn instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getSuspenseInstanceFallbackErrorDetails(instance){var dataset=instance.nextSibling&&instance.nextSibling.dataset;var digest,message,stack;if(dataset){digest=dataset.dgst;{message=dataset.msg;stack=dataset.stck;}}{return{message:message,digest:digest,stack:stack};}// let value = {message: undefined, hash: undefined};\n// const nextSibling = instance.nextSibling;\n// if (nextSibling) {\n//   const dataset = ((nextSibling: any): HTMLTemplateElement).dataset;\n//   value.message = dataset.msg;\n//   value.hash = dataset.hash;\n//   if (true) {\n//     value.stack = dataset.stack;\n//   }\n// }\n// return value;\n}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.\nfor(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events\n// get attached.\nupdateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.\nreturn null;}// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nfunction getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else{depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentInstance,instance);}}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be\n// able to remove it.\nerror('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of\n// these fields are relevant.\ndelete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nfunction getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.\nreturn targetInst;}// If the direct event target isn't a React owned DOM node, we need to look\n// to see if one of its parents is a React owned DOM node.\nvar parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include\n// React nodes in the future. We need to check this first because\n// if we're a child of a dehydrated container, we need to first\n// find that inner container before moving on to finding the parent\n// instance. Note that we don't check this field on  the targetNode\n// itself because the fibers are conceptually between the container\n// node and the first child. It isn't surrounding the container node.\n// If it's not a container, we check if it's an instance.\ntargetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have\n// stepped past dehydrated DOM nodes to get here. However they could\n// also have been non-React nodes. We need to answer which one.\n// If we the instance doesn't have any children, then there can't be\n// a nested suspense boundary within it. So we can use this as a fast\n// bailout. Most of the time, when people add non-React children to\n// the tree, it is using a ref to a child-less DOM node.\n// Normally we'd only need to check one of the fibers because if it\n// has ever gone from having children to deleting them or vice versa\n// it would have deleted the dehydrated boundary nested inside already.\n// However, since the HostRoot starts out with an alternate it might\n// have one on the alternate so we need to check in case this was a\n// root.\nvar alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is\n// nested within a dehydrated boundary and if so, which one.\nvar suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't\n// hydrated it yet. Even though we leave the comments in the\n// DOM after hydrating, and there are boundaries in the DOM\n// that could already be hydrated, we wouldn't have found them\n// through this pass since if the target is hydrated it would\n// have had an internalInstanceKey on it.\n// Let's get the fiber associated with the SuspenseComponent\n// as the deepest instance.\nvar targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because\n// we haven't gotten to hydrate it yet. There might still be a\n// parent boundary that hasn't above this one so we need to find\n// the outer most that is known.\nsuspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent\n// host component also hasn't hydrated yet. We can return it\n// below since it will bail out on the isMounted check later.\n}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else{return null;}}return null;}/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be\n// a host component or host text.\nreturn inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next\n// invariant for a missing parent, which is super confusing.\nthrow new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else{ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.\nvar has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to\n// fail the render phase where it didn't fail before. So we log it.\n// After these have been cleaned up, we'll let them throw.\ntry{// This is intentionally an invariant that gets caught. It's the same\n// behavior as without this statement except with a better message.\nif(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes\nvar err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+typeof typeSpecs[typeSpecName]+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,typeof error$1);setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the\n// same error.\nloggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.\nvar contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context\n// we may have already pushed its own child context on the stack. A context\n// provider should not \"see\" its own child context. Therefore we read the\n// previous (parent) context instead for a context provider.\nreturn previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.\n// Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n// This may trigger infinite loops if componentWillReceiveProps calls setState.\nvar instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// Context is created before the class component is instantiated so check for instance.\nif(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.\n// It has only been added in Fiber to match the (unintentional) behavior in Stack.\nif(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+\".getChildContext(): key \\\"\"+contextKey+\"\\\" is not defined in childContextTypes.\");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.\n// If the instance does not exist yet, we will push null at first,\n// and replace it on the stack later when invalidating the context.\nvar memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.\n// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\npreviousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.\n// Skip this if we're not updating due to sCU.\n// This avoids unnecessarily recomputing memoized values.\nvar mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.\n// It is important to unwind the context in the reverse order.\npop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.\npush(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it\n// makes sense elsewhere\nif(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in\n// the next tick, or earlier if something calls `flushSyncCallbackQueue`.\nif(syncQueue===null){syncQueue=[callback];}else{// Push onto existing queue. Don't need to schedule a callback because\n// we already scheduled one when we created the queue.\nsyncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.\n// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n// it might make more sense for the queue to be a list of roots instead of a\n// list of generic callbacks. Then we can have two: one for legacy roots, one\n// for concurrent roots. And this method would only flush the legacy ones.\nif(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.\nisFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this\n// queue is in the render or commit phases.\nsetCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.\nif(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick\nscheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return(workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child\n// fibers, because that's the only place where we know how many children in\n// the whole set without doing extra work later, or storing addtional\n// information on the fiber.\n//\n// That's why this function is separate from pushTreeId  it's called during\n// the render phase of the fork parent, not the child, which is where we push\n// the other context values.\n//\n// In the Fizz implementation this is much simpler because the child is\n// rendered in the same callstack as the parent.\n//\n// It might be better to just add a `forks` field to the Fiber type. It would\n// make this module simpler.\nwarnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n// of the id; we use it to account for leading 0s.\nvar baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into\n// consideration the leading 1 we use to mark the end of the sequence.\nif(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.\n// This branch assumes the length of the base id is greater than 5; it won't\n// work for smaller ids, because you need 5 bits per character.\n//\n// We encode the id in multiple steps: first the base id, then the\n// remaining digits.\n//\n// Each 5 bit sequence corresponds to a single base 32 character. So for\n// example, if the current id is 23 bits long, we can convert 20 of those\n// bits into a string of 4 characters, with 3 bits left over.\n//\n// First calculate how many bits in the base id represent a complete\n// sequence of characters.\nvar numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.\nvar newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.\nvar newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.\nvar restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because\n// we made more room, this time it won't overflow.\nvar restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else{// Normal path\nvar newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear\n// in its children.\nvar returnFiber=workInProgress.return;if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.\n// This is a bit more complicated than other context-like modules in Fiber\n// because the same Fiber may appear on the stack multiple times and for\n// different reasons. We have to keep popping until the work-in-progress is\n// no longer at the top of the stack.\nwhile(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return{id:treeContextId,overflow:treeContextOverflow};}else{return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.\nvar hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;// This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\nvar didSuspendOrErrorDEV=false;// Hydration errors that were thrown inside this boundary\nvar hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidThrowWhileHydratingDEV(){{didSuspendOrErrorDEV=true;}}function didSuspendOrErrorWhileHydratingDEV(){{return didSuspendOrErrorDEV;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV){// Inside a boundary that already suspended. We're currently rendering the\n// siblings of a suspended node. The mismatch may be due to the missing\n// data, so it's probably a false positive.\nreturn;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type;var _props=fiber.pendingProps;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostText:{var _text=fiber.pendingProps;var _isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode);break;}}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;var _props2=fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.\nnextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.\n// This simplifies the code for getHostSibling and deleting nodes,\n// since it doesn't have to consider all Suspense boundaries and\n// check if they're dehydrated ones or not.\nvar dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment.return=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into\n// it during the first pass. Instead, we'll reenter it later.\nnextHydratableInstance=null;return true;}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.\n// We use this as a heuristic. It's based on intuition and not data so it\n// might be flawed or unnecessary.\nnextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was\n// superfluous and we'll delete it. Since we can't eagerly delete it\n// we'll have to schedule a deletion. To do that, this node needs a dummy\n// fiber associated with it.\ndeleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspendOrErrorDEV;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.\nfiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update.\nif(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the\n// hydration parent is the parent host component of this host text.\nvar returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;var _isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode2);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted\n// tree.\nreturn false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then\n// we were an insertion and now need to pop up reenter hydration of our\n// siblings.\npopToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.\n// We only do this deeper than head and body since they tend to have random\n// other nodes in them. We also ignore components with pure text content in\n// side of them. We also don't delete anything inside the root container.\nif(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else{while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else{nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspendOrErrorDEV=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred\n// during the hydration attempt are now recovered. We will log them in\n// commit phase, once the entire tree has finished.\nqueueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else{hydrationErrors.push(error);}}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}};{var findStrictRoot=function(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};var setToSortedString=function(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.\nvar didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.\nif(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.\ninstance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names\nvar componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings\n// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\nif(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'\\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, \"+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'\\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'\\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, refactor your \"+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.\nvar didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\nif(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\\n\\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement\nvar props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context\nrendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`\n// cannot be called outside the render phase.\ncurrentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.\nvar node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node.return;}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nfiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.\nvar list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.\nif(dependency.context===context){// Match! Schedule an update on this fiber.\nif(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.\nvar lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the\n// update to the current fiber, too, which means it will persist even if\n// this render is thrown away. Since it's a race condition, not sure it's\n// worth fixing.\n// Inlined `enqueueUpdate` to remove interleaved update check\nvar updateQueue=fiber.updateQueue;if(updateQueue===null);else{var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,workInProgress);// Mark the updated lanes on the list, too.\nlist.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the\n// dependency list.\nbreak;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider\nnextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know\n// if it will have any context consumers in it. The best we can do is\n// mark it as having updates.\nvar parentSuspense=fiber.return;if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent\n// because we want to schedule this fiber as having work\n// on its children. We'll use the childLanes on\n// this fiber to indicate that a context has changed.\nscheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else{// Traverse down.\nnextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nnextFiber.return=fiber;}else{// No child. Traverse to next sibling.\nnextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.\nnextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.\nsibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.\nnextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.\nmarkWorkInProgressReceivedUpdate();}// Reset the work-in-progress list\ndependencies.firstContext=null;}}}}function readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.\n// Unlike the class check below, it's not enforced in production for perf.\nif(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else{var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.\nlastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else{// Append a new context item.\nlastContextDependency=lastContextDependency.next=contextItem;}}return value;}// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nvar concurrentQueues=null;function pushConcurrentUpdateQueue(queue){if(concurrentQueues===null){concurrentQueues=[queue];}else{concurrentQueues.push(queue);}}function finishQueueingConcurrentUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a\n// `pending` field and an `interleaved` field. When they are not null, they\n// point to the last node in a circular linked list. We need to append the\n// interleaved list to the end of the pending list by joining them into a\n// single, circular list.\nif(concurrentQueues!==null){for(var i=0;i<concurrentQueues.length;i++){var queue=concurrentQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}concurrentQueues=null;}}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}function enqueueConcurrentClassUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentRenderForLane(fiber,lane){return markUpdateLaneFromFiberToRoot(fiber,lane);}// Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\nvar unsafe_markUpdateLaneFromFiberToRoot=markUpdateLaneFromFiberToRoot;function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.\nvar node=sourceFiber;var parent=sourceFiber.return;while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else{{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent.return;}if(node.tag===HostRoot){var root=node.stateNode;return root;}else{return null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.\nvar queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn null;}var sharedQueue=updateQueue.shared;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}if(isUnsafeClassRenderPhaseUpdate()){// This is an unsafe render phase update. Add directly to the update\n// queue so we can process it immediately during the current render.\nvar pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;// Update the childLanes even though we're most likely already rendering\n// this fiber. This is for backwards compatibility in the case where you\n// update a different component during render phase than the one that is\n// currently renderings (a pattern that is accompanied by a warning).\nreturn unsafe_markUpdateLaneFromFiberToRoot(fiber,lane);}else{return enqueueConcurrentClassUpdate(fiber,sharedQueue,update,lane);}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must\n// have finished. We can remove them from the shared queue, which represents\n// a superset of the actually pending lanes. In some cases we may entangle\n// more than we need to, but that's OK. In fact it's worse if we *don't*\n// entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render\n// phase. They should be discarded if the render is aborted. Therefore,\n// we should only put them on the work-in-progress queue, not the current one.\nvar queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.\nvar current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when\n// we bail out on a parent fiber that then captures an error thrown by\n// a child. Since we want to append the update only to the work-in\n// -progress queue, we need to clone the updates. We usually clone during\n// processUpdateQueue, but that didn't happen in this case because we\n// skipped over the parent when we bailed out.\nvar newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.\nvar update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else{newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.\nif(newLast===null){newFirst=newLast=capturedUpdate;}else{newLast.next=capturedUpdate;newLast=capturedUpdate;}}else{// There are no base updates.\nnewFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.\nvar lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else{lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object\nreturn payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough\ncase UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else{// Partial state object\npartialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.\nreturn prevState;}// Merge the partial state and the previous state.\nreturn assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot\nvar queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.\nvar pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first\n// and last so that it's non-circular.\nvar lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue\nif(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else{lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then\n// we need to transfer the updates to that queue, too. Because the base\n// queue is a singly-linked list with no cycles, we can append to both\n// lists and take advantage of structural sharing.\n// TODO: Pass `current` as argument\nvar current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot\nvar currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else{currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.\nif(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.\nvar newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n// from the original lanes.\nvar newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else{newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.\nnewLanes=mergeLanes(newLanes,updateLane);}else{// This update does have sufficient priority.\nif(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.\nnewState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its\n// callback again.\nupdate.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else{effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else{// An update was scheduled from inside a reducer. Add the new\n// pending updates to the end of the list and keep processing.\nvar _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we\n// unravel them when transferring them to the base queue.\nvar _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.\n// This should be fine because the only two other things that contribute to\n// expiration time are props and context. We're already in the middle of the\n// begin phase by the time we start processing the queue, so we've already\n// dealt with the props. Context in components that specify\n// shouldComponentUpdate is tricky; but we'll have to account for\n// that regardless.\nmarkSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+(\"received: \"+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects\nvar effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var fakeInternalInstance={};// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nvar emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if\n// it causes problems. This is meant to give a nicer error message for\n// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n// ...)) which otherwise throws a \"_processChildContext is not a function\"\n// exception.\nObject.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+\"unstable_renderSubtreeIntoContainer, which isn't supported. Try \"+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\npartialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.\nvar memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the\n// base state.\nif(workInProgress.lanes===NoLanes){// Queue is always non-null for classes\nvar updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\nshouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+\"up the same props that your component's constructor was passed.\",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(typeof _state!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&typeof ctor.childContextTypes!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates\nset(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration\ncontextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>\nif(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(typeof contextType!=='object'){addendum=' However, it is set to a '+typeof contextType+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>\naddendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(typeof contextType==='object'&&contextType!==null){context=readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.\n{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new\n}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n// Warn about these lifecycles if they are present.\n// Don't warn about react-lifecycles-compat polyfilled methods though.\nif(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n'+'The above lifecycles should be removed. Learn more about this warning here:\\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?\"\\n  \"+foundWillMountName:'',foundWillReceivePropsName!==null?\"\\n  \"+foundWillReceivePropsName:'',foundWillUpdateName!==null?\"\\n  \"+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// ReactFiberContext usually updates this cache but can't for newly-created instances.\nif(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+\"deprecated (except inside a component's \"+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+\"this.state is deprecated (except inside a component's \"+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(typeof contextType==='object'&&contextType!==null){instance.context=readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+\"because updates to props won't be reflected in state. \"+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's\n// process them now.\nprocessUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the\n// memoized state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,\n// both before and after `shouldComponentUpdate` has been called. Not ideal,\n// but I'm loath to refactor this function. This only happens for memoized\n// components so it's not that common.\nenableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the\n// memoized props/state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function(child,returnFiber){if(child===null||typeof child!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(typeof child._store!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'\"key\" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&typeof mixedRef!=='object'){{// TODO: Clean this up once we turn on the string ref warning for\n// everyone, because the strict mode case will no longer be relevant\nif((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs\n// because these cannot be automatically converted to an arrow function\n// using a codemod. Therefore, we don't have to warn about string refs again.\n!(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('A string ref, \"%s\", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error(\"Missing owner for string ref \"+mixedRef+\". This error is likely caused by a \"+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure\nvar resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref\nif(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function(value){var refs=resolvedInst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.\nrefs=resolvedInst.refs={};}if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error(\"Element ref was specified as a string (\"+mixedRef+\") but no owner was set. This could happen for one of\"+' the following reasons:\\n'+'1. You may be adding a ref to a function component\\n'+\"2. You may be adding a ref to a component that was not created inside a component's render method\\n\"+'3. You have multiple copies of React loaded\\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error(\"Objects are not valid as a React child (found: \"+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+\"). \"+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.\nreturn;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.\nreturn null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by\n// assuming that after the first child we've already added everything.\nvar childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by\n// keys quickly. Implicit (null) keys get added to this set with their index\n// instead.\nvar existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy\n// to forget to do before returning it. E.g. for the single child case.\nvar clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are\n// part of a list of children (arrays, iterators).\nnewFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.\nnewFiber.flags|=Placement;return lastPlacedIndex;}else{// This item can stay in place.\nreturn oldIndex;}}else{// This is an insertion.\nnewFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a\n// placement for inserting new children.\nif(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert\nvar created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,textContent);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\ntypeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index\nvar existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert\nvar created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created.return=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert\nvar created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,portal.children||[]);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert\nvar created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,fragment);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nvar created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created.return=returnFiber;return created;}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2.return=returnFiber;return _created2;}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.\nvar key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nif(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor\n// new node for the key. If both are text nodes, they match.\nvar matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**\n   * Warns if there is a duplicate or missing key\n   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(typeof child!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted  the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we\n// don't have backpointers on fibers. I'm trying to see how far we can get\n// with that model. If it ends up not being worth the tradeoffs, we can\n// add it later.\n// Even with a two ended optimization, we'd want to optimize for the case\n// where there are few changes and brute force the comparison instead of\n// going for the Map. It'd like to explore hitting that path first in\n// forward-only mode and only go for the Map once we notice that we need\n// lots of look ahead. This doesn't handle reversal as well as two ended\n// search but that's unusual. Besides, for the two ended optimization to\n// work on Iterables, we'd need to copy the whole set.\n// In this first iteration, we'll just live with hitting the bad case\n// (adding everything to a Map) in for every insert/move.\n// If you change this code, also update reconcileChildrenIterator() which\n// uses the same algorithm.\n{// First, validate keys.\nvar knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),\n// but using the iterator instead.\nvar iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.\n// See https://github.com/facebook/react/issues/12995\nif(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag\nnewChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children\nif(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.\n// We'll get a different iterator later for the main pass.\nvar _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a\n// way to define them.\nif(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete\n// the rest.\ndeleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one\n// and delete the existing ones.\ndeleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else{if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\ntypeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing.return=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.\ndeleteRemainingChildren(returnFiber,child);break;}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created.return=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing.return=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.\n// If the top level item is an array, we treat it as a set of children,\n// not as a fragment. Nested arrays on the other hand will be treated as\n// fragment nodes. Recursion happens at the normal flow.\n// Handle top level unkeyed fragments as if they were arrays.\n// This leads to an ambiguity between <>{[...]}</> and <>...</>.\n// We treat the ambiguous cases above the same.\nvar isUnkeyedTopLevelFragment=typeof newChild==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types\nif(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.\nreturn reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.\nreturn deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild.return=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.\nfunction resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;\n// This allows us to reset root when portals are popped.\npush(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.\n// However, we can't just call getRootHostContext() and push it because\n// we'd have a different number of entries on the stack depending on\n// whether getRootHostContext() throws somewhere in renderer code or not.\n// So we push an empty value first. This lets us safely unwind on errors.\npush(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.\npop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.\nif(context===nextContext){return;}// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.\n// pushHostContext() only pushes Fibers that provide unique contexts.\nif(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\nvar SubtreeSuspenseContextMask=1;// Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\nvar InvisibleParentSuspenseContext=1;// Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\nvar ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the\n// fallback. Otherwise, don't capture and bubble to the next boundary.\nvar nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.\nreturn true;}return false;}var props=workInProgress.memoizedProps;// Regular boundaries always capture.\n{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the\n}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't\n// keep track of whether it suspended or not.\nnode.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node.return===null||node.return===row){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.\nvar HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.\nvar Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\nvar workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\nfunction registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.\n// Retaining it forever may interfere with GC.\nif(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else{root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.\nvar renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nvar currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nvar currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nvar didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\nvar didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.\nvar localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\nvar globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook\nvar currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nvar hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nvar ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.\n// It's unlikely their type would change as usually you define them inline.\nerror('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,typeof deps);}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+\". \"+oldHookName;// Extra space so second column lines up\n// lol @ IE not supporting String#repeat\nwhile(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n'+'   Previous render            Next render\\n'+'   ------------------------------------------------------\\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\\n'+'2. You might be breaking the Rules of Hooks\\n'+'3. You might have more than one copy of React in the same app\\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.\nreturn false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be\n// passed inline.\nif(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\\n\\n'+'Previous: %s\\n'+'Incoming: %s',currentHookNameInDev,\"[\"+prevDeps.join(', ')+\"]\",\"[\"+nextDeps.join(', ')+\"]\");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:\nignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset\n// currentHook = null;\n// workInProgressHook = null;\n// didScheduleRenderPhaseUpdate = false;\n// localIdCounter = 0;\n// TODO Warn if no hooks are used at all during mount, then some are used during update.\n// Currently we will identify the update render as a mount because memoizedState === null.\n// This is tricky because it's valid for certain types of components (e.g. React.lazy)\n// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n// Non-stateful hooks (e.g. context) don't get added to memoizedState,\n// so memoizedState would be null during updates and mounts.\n{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,\n// but no stateful hooks have been used.\n// We want to match the production code behavior (which will use HooksDispatcherOnMount),\n// but with the extra DEV validation to ensure hooks ordering hasn't changed.\n// This dispatcher does that.\nReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update\nif(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to\n// be scheduled. Use a counter to prevent infinite loops.\nvar numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize\n// after first render to prevent infinite render phase updates.\nignorePreviousDependencies=false;}// Start over from the beginning of the list\ncurrentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.\nhookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.\n// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\nvar didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last\n// render. If this fires, it suggests that we incorrectly reset the static\n// flags in some other part of the codebase. This has happened before, for\n// example, in the SuspenseList implementation.\nif(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird\n// and creates false positives. To make this work in legacy mode, we'd\n// need to mark fibers that commit in an incomplete state, somehow. For\n// now I'll disable the warning that most of the bugs that would trigger\n// it are either exclusive to concurrent mode or exist in both.\n(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook\n// localIdCounter = 0;\nif(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.\n// Conceptually, it's part of the return value of renderWithHooks; it's only a\n// separate function to avoid using an array tuple.\nvar didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the\n// complete phase (bubbleProperties).\nif((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else{workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render\n// phase, which we are now aborting. Remove the updates from the queues so\n// they do not persist to the next render. Do not remove updates from hooks\n// that weren't processed.\n//\n// Only reset the updates from the queue if it has a clone. If it does\n// not have a clone, that means it wasn't processed, and the updates were\n// scheduled before we entered the render phase.\nvar hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else{// Append to the end of the list\nworkInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a\n// render phase update. It assumes there is either a current hook we can\n// clone, or a work-in-progress hook from a previous render pass that we can\n// use as a base. When we reach the end of the base list, we must switch to\n// the dispatcher used for mounts.\nvar nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else{nextCurrentHook=null;}}else{nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else{nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.\nworkInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else{// Clone from the current hook.\nif(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else{// Append to the end of the list.\nworkInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types\nreturn typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.\nvar baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.\nvar pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.\n// We'll add them to the base queue.\nif(baseQueue!==null){// Merge the pending queue and the base queue.\nvar baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in\n// the future if we implement resuming, or some form of that.\nerror('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.\nvar first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else{newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.\n// TODO: Don't need to accumulate this. Instead, we can remove\n// renderLanes from the original lanes.\ncurrentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else{// This update does have sufficient priority.\nif(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.\nif(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,\n// we can use the eagerly computed state\nnewState=update.eagerState;}else{var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else{newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.lanes=NoLanes;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous\n// work-in-progress hook.\nvar dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.\nqueue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the\n// priority because it will always be the same as the current\n// render's.\nvar action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to\n// the base state unless the queue is empty.\n// TODO: Not sure if this is the desired semantics, but it's what we\n// do for gDSFP. I can't remember why.\nif(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return[newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else{nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\n//\n// We won't do this if we're hydrating server-rendered content, because if\n// the content is stale, it's already visible anyway. Instead we'll patch\n// it up in a passive effect.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nhook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.\nmountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update\n// this whenever subscribe, getSnapshot, or value changes. Because there's no\n// clean-up function, and we track the deps correctly, we can call pushEffect\n// directly, without storing any additional state. For the same reason, we\n// don't need to set a static flag, either.\n// TODO: We can move this to the passive phase once we add a pre-commit\n// consistency check. See the next comment.\nfiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nvar nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the\n// commit phase if there was an interleaved mutation. In concurrent mode\n// this can happen all the time, but even in synchronous mode, an earlier\n// effect may have mutated the store.\nif(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by\n// checking whether we scheduled a subscription effect above.\nworkInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else{var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else{stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase\ninst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could\n// have been in an event that fired before the passive effects, or it could\n// have been in a layout effect. In that case, we would have used the old\n// snapsho and getSnapshot values to bail out. We need to check one more time.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function(){// The store changed. Check if the snapshot changed since the last time we\n// read from the store.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.\nreturn subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types\ninitialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular\nnext:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else{return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.\n// The react-debug-hooks package injects its own implementation\n// so that e.g. DevTools can display custom hook values.\n}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.\nif(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var hook=mountWorkInProgressHook();hook.memoizedState=value;return value;}function updateDeferredValue(value){var hook=updateWorkInProgressHook();var resolvedCurrentHook=currentHook;var prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null){// This is a rerender during a mount.\nhook.memoizedState=value;return value;}else{// This is a rerender during an update.\nvar prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){// This is an urgent update. If the value has changed, keep using the\n// previous value and spawn a deferred render to update it later.\nif(!objectIs(value,prevValue)){// Schedule a deferred render\nvar deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane);markSkippedUpdateLanes(deferredLane);// Set this to true to indicate that the rendered value is inconsistent\n// from the latest value. The name \"baseState\" doesn't really match how we\n// use it because we're reusing a state hook field instead of creating a\n// new one.\nhook.baseState=true;}// Reuse the previous value\nreturn prevValue;}else{// This is not an urgent update, so we can use the latest value regardless\n// of what it is. No need to defer it.\n// However, if we're currently inside a spawned render, then we need to mark\n// this as an update to prevent the fiber from bailing out.\n//\n// `baseState` is true when the current value is different from the rendered\n// value. The name doesn't really match how we use it because we're reusing\n// a state hook field instead of creating a new one.\nif(hook.baseState){// Flip this back to false.\nhook.baseState=false;markWorkInProgressReceivedUpdate();}hook.memoizedState=value;return value;}}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState=mountState(false),isPending=_mountState[0],setPending=_mountState[1];// The `start` method never changes.\nvar start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return[isPending,start];}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we\n// should do this in Fiber, too? Deferring this decision for now because\n// there's no other place to store the prefix except for an internal field on\n// the public createRoot object, which the fiber tree does not currently have\n// a reference to.\nvar identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.\nid=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end\n// that represents the position of this useId hook among all the useId\n// hooks for this fiber.\nvar localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else{// Use a lowercase r prefix for client-generated ids.\nvar globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the\n// next state before entering the render phase. If the new state is the\n// same as the current state, we may be able to bail out entirely.\nvar lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute\n// it, on the update object. If the reducer hasn't changed by the\n// time we enter the render phase, then the eager state can be used\n// without calling the reducer again.\nupdate.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.\n// It's still possible that we'll need to rebase this update later,\n// if the component re-renders for a different reason and by that\n// time the reducer has changed.\n// TODO: Do we still need to entangle transitions in this case?\nenqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane);return;}}catch(error){// Suppress the error. It will throw again in the render phase.\n}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of\n// queue -> linked list of updates. After this render pass, we'll restart\n// and apply the stashed updates on top of the work-in-progress hook.\ndidScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}// TODO: Move to ReactFiberConcurrentUpdates?\nfunction entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they\n// must have finished. We can remove them from the shared queue, which\n// represents a superset of the actually pending lanes. In some cases we\n// may entangle more than we need to, but that's OK. In fact it's worse if\n// we *don't* entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber.return;}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.\n// In this case, the return pointer is also cleared out,\n// so we won't be able to report the time spent in this Profiler's subtree.\nparentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber.return;}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it\n// after we rerender. This is used as a helper in special cases\n// where we should count the work of multiple passes.\nvar child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function createCapturedValueAtFiber(value,source){// If the value is an error, call this function immediately after it is thrown\n// so the stack is accurate.\nreturn{value:value,source:source,stack:getStackByFiberInDevAndProd(source),digest:null};}function createCapturedValue(value,digest,stack){return{value:value,source:null,stack:stack!=null?stack:null,digest:digest!=null?digest:null};}// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.\n// This enables renderers like ReactNative to better manage redbox behavior.\nif(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling\n// `preventDefault()` in window `error` handler.\n// We record this information as an expando on the error.\nif(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.\n// Ignore it and don't print the stack addendum.\n// This is handy for testing error boundaries without noise.\nreturn;}// The error is fatal. Since the silencing might have\n// been accidental, we'll surface it anyway.\n// However, the browser would have silenced the original error\n// so we'll print it first, and then print the stack addendum.\nconsole['error'](error);// Don't transform to our wrapper\n// For a more detailed description of this block, see:\n// https://github.com/facebook/react/pull/13384\n}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?\"The above error occurred in the <\"+componentName+\"> component:\":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else{var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage=\"React will try to recreate this component tree from scratch \"+(\"using the error boundary you provided, \"+errorBoundaryName+\".\");}var combinedMessage=componentNameMessage+\"\\n\"+componentStack+\"\\n\\n\"+(\"\"+errorBoundaryMessage);// In development, we provide our own message with just the component stack.\n// We don't include the original error message and JS stack because the browser\n// has already printed it. Even if the application swallows the error, it is still\n// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\nconsole['error'](combinedMessage);// Don't transform to our wrapper\n}else{}}catch(e){// This method must not throw, or React internal state will get messed up.\n// If console.error is overridden, or logCapturedError() shows a dialog that throws,\n// we want to report this error outside of the normal stack as a last resort.\n// https://github.com/facebook/react/issues/13188\nsetTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.\nupdate.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,\n// we keep track of which ones already failed during this batch.\n// This gets reset before we yield back to the browser.\n// TODO: Warn in strict mode if getDerivedStateFromError is\n// not defined.\nmarkLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,\n// then it needs to call setState to recover from errors.\n// If no state update is scheduled then the boundary will swallow the error.\nif(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener\n//\n// The data might resolve before we have a chance to commit the fallback. Or,\n// in the case of a refresh, we'll never commit a fallback. So we need to\n// attach a listener now. When it resolves (\"pings\"), we can decide whether to\n// try rendering the tree again.\n//\n// Only attach a listener if one does not already exist for the lanes\n// we're currently rendering (which acts like a \"thread ID\" here).\n//\n// We only need to do this in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nvar pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else{threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.\nthreadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener\n//\n// If the fallback does commit, we need to attach a different type of\n// listener. This one schedules an update on the Suspense boundary to turn\n// the fallback state off.\n//\n// Stash the wakeable on the boundary fiber so we can access it in the\n// commit phase.\n//\n// When the wakeable resolves, we'll attempt to render the boundary\n// again (\"retry\").\nvar wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else{wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.\nvar tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else{sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next\n// boundary.\nnode=node.return;}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,\n// it captures the suspended \"exception\" and does a second (fallback) pass.\nif((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense\n//\n// If the boundary is in legacy mode, we should *not*\n// suspend the commit. Pretend as if the suspended component rendered\n// null and keep rendering. When the Suspense boundary completes,\n// we'll do a second pass to render the fallback.\nif(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of\n// a Suspense boundary's inner Offscreen wrapper fiber. This happens\n// when a React.lazy component is a direct child of a\n// Suspense boundary.\n//\n// Suspense boundaries are implemented as multiple fibers, but they\n// are a single conceptual unit. The legacy mode behavior where we\n// pretend the suspended fiber committed as `null` won't work,\n// because in this case the \"suspended\" fiber is the inner\n// Offscreen wrapper.\n//\n// Because the contents of the boundary haven't started rendering\n// yet (i.e. nothing in the tree has partially rendered) we can\n// switch to the regular, concurrent mode behavior: mark the\n// boundary with ShouldCapture and enter the unwind phase.\nsuspenseBoundary.flags|=ShouldCapture;}else{suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.\n// But we shouldn't call any lifecycle methods or callbacks. Remove\n// all lifecycle effect tags.\nsourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a\n// completed class component. For example, we should not call\n// componentWillUnmount if it is deleted.\nsourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,\n// since it's known to be in an inconsistent state. Use a force update to\n// prevent a bail out.\nvar update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update,SyncLane);}}// The source fiber did not complete. Mark it with Sync priority to\n// indicate that it still has pending work.\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue\n// with the normal suspend path.\n//\n// After this we'll use a set of heuristics to determine whether this\n// render pass will run to completion or restart or \"suspend\" the commit.\n// The actual logic for this is spread out in different places.\n//\n// This first principle is that if we're going to suspend when we complete\n// a root, then we should also restart if we get an update or ping that\n// might unsuspend it, and vice versa. The only reason to suspend is\n// because you think you might want to restart before committing. However,\n// it doesn't make sense to restart only while in the period we're suspended.\n//\n// Restarting too aggressively is also not good because it starves out any\n// intermediate loading state. So we use heuristics to determine when.\n// Suspense Heuristics\n//\n// If nothing threw a Promise or all the same fallbacks are already showing,\n// then don't suspend/restart.\n//\n// If this is an initial render of a new tree of Suspense boundaries and\n// those trigger a fallback, then don't suspend/restart. We want to ensure\n// that we can show the initial loading state as quickly as possible.\n//\n// If we hit a \"Delayed\" case, such as when we'd switch from content back into\n// a fallback, then we should always suspend/restart. Transitions apply\n// to this case. If none is defined, JND is used instead.\n//\n// If we're already showing a fallback and it gets \"retried\", allowing us to show\n// another level, but there's still an inner boundary that would show a fallback,\n// then we suspend/restart for 500ms since the last time we showed a fallback\n// anywhere in the tree. This effectively throttles progressive loading into a\n// consistent train of commits. This also gives us an opportunity to restart to\n// get to the completed state slightly earlier.\n//\n// If there's ambiguity due to batching it's resolved in preference of:\n// 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n//\n// We want to ensure that a \"busy\" state doesn't get force committed. We want to\n// ensure that new initial loading states can commit as soon as possible.\nsuspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in\n// the begin phase to prevent an early bailout.\nsuspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.\nsourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&typeof value==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.\nvar wakeable=value;resetSuspendedComponent(sourceFiber);{if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();}}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nif(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else{// No boundary was found. Unless this is a sync update, this is OK.\n// We can suspend and wait for more data to arrive.\nif(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a\n// Suspense boundary, this will unwind all the way to the root without\n// performing a second pass to render a fallback. (This is arguably how\n// refresh transitions should work, too, since we're not going to commit\n// the fallbacks anyway.)\n//\n// This case also applies to initial hydration.\nattachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error\n// because discrete renders are expected to produce a complete tree\n// synchronously to maintain consistency with external state.\nvar uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.\n// The error will be caught by the nearest suspense boundary.\nvalue=uncaughtSuspenseError;}}else{// This is a regular error, not a Suspense wakeable.\nif(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by\n// discarding the dehydrated content and switching to a client render.\n// Instead of surfacing the error, find the nearest Suspense boundary\n// and render it again without hydration.\nif(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal\n// children again, not the fallback.\n_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should\n// still log it so it can be fixed.\nqueueHydrationError(createCapturedValueAtFiber(value,sourceFiber));return;}}}value=createCapturedValueAtFiber(value,sourceFiber);renderDidError(value);// We didn't find a boundary that could handle this type of exception. Start\n// over and traverse parent path again, this time treating the exception\n// as an error.\nvar workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry\nvar errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state\nvar _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the\n}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we\n// won't update its child set by applying minimal side-effects. Instead,\n// we will add them all to the child before it gets rendered. That means\n// we can optimize this reconciliation pass by not tracking side-effects.\nworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else{// If the current child is the same as the work in progress, it means that\n// we haven't yet started any work on these children. Therefore, we use\n// the clone algorithm to create a copy of all the current children.\n// If we had any progressed work already, that is invalid at this point so\n// let's throw it out.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we\n// want to reconcile without matching against the existing set. This has the\n// effect of all current children being unmounted; even if the type and key\n// are the same, the old child is unmounted and a new child is created.\n//\n// To do this, we're going to go through the reconcile algorithm twice. In\n// the first pass, we schedule a deletion for all the current children by\n// passing null.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we\n// pass null in place of where we usually pass the current child set. This has\n// the effect of remounting all children regardless of whether their\n// identities match.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens after the first render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent\nvar nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.\nComponent.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,\n// and with only the default shallow comparison, we upgrade it\n// to a SimpleMemoComponent to allow fast path updates.\nworkInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(type));}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child.return=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(_innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,\n// unlike current.memoizedProps which will be the unresolved ones.\nvar prevProps=currentChild.memoizedProps;// Default to shallow comparison\nvar compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild.return=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens when the inner render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()\n// so let's just skip over it to find memo() outer wrapper.\n// Inner props for memo are validated later.\nvar lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.\nvar outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)\n'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.\nworkInProgress.type===current.type){didReceiveUpdate=false;// The props are shallowly equal. Reuse the previous props object, like we\n// would during a normal fiber bailout.\n//\n// We don't have strong guarantees that the props object is referentially\n// equal during updates where we can't bail out anyway  like if the props\n// are shallowly equal, but there's a local state or context update in the\n// same batch.\n//\n// However, as a principle, we should aim to make the behavior consistent\n// across different ways of memoizing a component. For example, React.memo\n// has a different internal Fiber layout if you pass a normal function\n// component (SimpleMemoComponent) versus if you pass a different type\n// like forwardRef (MemoComponent). But this is an implementation detail.\n// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n// affect whether the props object is reused during a bailout.\nworkInProgress.pendingProps=nextProps=prevProps;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're\n// about to bail out, but there might be other lanes that weren't\n// included in the current render. Usually, the priority level of the\n// remaining updates is accumulated during the evaluation of the\n// component (i.e. when processing the update queue). But since since\n// we're bailing out early *without* evaluating the component, we need\n// to account for it here, too. Reset to the value of the current fiber.\n// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n// because a MemoComponent fiber does not have hooks or an update queue;\n// rather, it wraps around an inner component, which may or may not\n// contains hooks.\n// TODO: Move the reset at in beginWork out of the common path so that\n// this is no longer necessary.\nworkInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.\nif((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.\n// TODO: Consider how Offscreen should work with transitions in the future\nvar nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out\n// and resume this tree later.\nvar nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else{nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.\nworkInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.\npushRenderLanes(workInProgress,nextBaseLanes);return null;}else{// This is the second render. The surrounding visible content has already\n// committed. Now we resume rendering the hidden tree.\n// Rendering at offscreen, so we can clear the base lanes.\nvar _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.\nvar subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else{// Rendering a visible tree.\nvar _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.\n_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else{// We weren't previously hidden, and we still aren't, so there's nothing\n// special to do. Need to push to the stack regardless, though, to avoid\n// a push/pop misalignment.\n_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}// Note: These happen to have identical begin phases, for now. We shouldn't hold\nfunction updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect\nworkInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.\nswitch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.\n// Is there a better way to do this?\nvar tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes\nvar error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state\nvar update=createClassErrorUpdate(workInProgress,createCapturedValueAtFiber(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress);// In the initial pass we might need to construct the instance.\nconstructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.\nshouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else{shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false\nmarkRef(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering\nif(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender\nReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,\n// unmount all the children. componentDidCatch will schedule an update to\n// re-render a fallback. This is temporary until we migrate everyone to\n// the new API.\n// TODO: Warn in a future release.\nnextChildren=null;{stopProfilerTimerIfRunning();}}else{{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of\n// the existing children. Conceptually, the normal children and the children\n// that are shown on error are two different sets, so we shouldn't reuse\n// normal children even if their identities match.\nforceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.\n// TODO: Restructure so we never read values from the instance.\nworkInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.\nif(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set\npushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;var root=workInProgress.stateNode;// being called \"element\".\nvar nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should\n// attempt to hydrate.\n// Flip isDehydrated to false to indicate that when this render\n// finishes, the root will no longer be dehydrated.\nvar overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't\n// have reducer functions so it doesn't need rebasing.\nupdateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we\n// forced a client render.\nvar recoverableError=createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=createCapturedValueAtFiber(new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else{// The outermost shell has not hydrated yet. Start hydrating.\nenterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nnode.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else{// Root is not dehydrated. Either this is a client-only root, or it\n// already hydrated.\nresetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.\nresetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common\n// case. We won't handle it as a reified child. We will instead handle\n// this in the host environment that also has access to this prop. That\n// avoids allocating another HostText fiber and traversing it.\nnextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to\n// empty, we need to schedule the text content to be reset.\nworkInProgress.flags|=ContentReset;}markRef(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step\n// immediately after.\nreturn null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.\nworkInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only\n'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too\nrenderLanes);return child;}}var hint='';{if(Component!==null&&typeof Component==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent\n// because the fact that it's a separate type of work is an\n// implementation detail.\nthrow new Error(\"Element type is invalid. Received a promise that resolves to: \"+Component+\". \"+(\"Lazy element type must resolve to a class or function.\"+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);// Promote the fiber to a class and try rendering again.\nworkInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`\n// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \"+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.\n// Whether or not it would crash later, we want to show a good message in DEV first.\nif(typeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.\n// Eventually we'll delete this branch altogether.\ntypeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance\nworkInProgress.tag=ClassComponent;// Throw out any hooks that were used.\nworkInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else{// Proceed under the assumption that this is a function component\nworkInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(typeof Component.contextType==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes,cachePool:getSuspendedCache(),transitions:null};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool,transitions:prevOffscreenState.transitions};}// TODO: Probably should inline this back\nfunction shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to\n// remain on that fallback regardless of whether the content has resolved.\n// For example, SuspenseList coordinates when nested content appears.\nif(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback\n// is true. More precise name might be \"ForceRemainSuspenseFallback\".\n// Note: This is a factoring smell. Can't remain on a fallback if there's\n// no fallback to remain on.\nreturn false;}}// Not currently showing content. Consult the Suspense context.\nreturn hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render\nreturn removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.\n{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to\n// rendering the fallback children.\nshowFallback=true;workInProgress.flags&=~DidCapture;}else{// Attempting the main content\nif(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.\n// Mark this subtree context as having at least one invisible parent that could\n// handle the fallback state.\n// Avoided boundaries are not considered since they cannot handle preferred fallback states.\n{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense\n// boundary's children. This involves some custom reconciliation logic. Two\n// main reasons this is so complicated.\n//\n// First, Legacy Mode has different semantics for backwards compatibility. The\n// primary tree will commit in an inconsistent state, so when we do the\n// second pass to render the fallback, we do some exceedingly, uh, clever\n// hacks to make that not totally break. Like transferring effects and\n// deletions from hidden tree. In Concurrent Mode, it's much simpler,\n// because we bailout on the primary tree completely and leave it in its old\n// state, no effects. Same as what we do for Offscreen (except that\n// Offscreen doesn't have the first render pass).\n//\n// Second is hydration. During hydration, the Suspense fiber has a slightly\n// different layout, where the child points to a dehydrated fragment, which\n// contains the DOM rendered by the server.\n//\n// Third, even if you set all that aside, Suspense is like error boundaries in\n// that we first we try to render one tree, and if that fails, we render again\n// and switch to a different tree. Like a try/catch block. So we have to track\n// which branch we're currently rendering. Ideally we would model this using\n// a stack.\nif(current===null){// Initial mount\n// Special path for hydration\n// If we're currently hydrating, try to hydrate this boundary.\ntryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.\nvar suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else{return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else{// This is an update.\n// Special path for hydration\nvar prevState=current.memoizedState;if(prevState!==null){var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){return updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,_dehydrated,prevState,renderLanes);}}if(showFallback){var _nextFallbackChildren=nextProps.fallback;var _nextPrimaryChildren=nextProps.children;var fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment2.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment2.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}else{var _nextPrimaryChildren2=nextProps.children;var _primaryChildFragment3=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren2,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment3;}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment.return=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\nprimaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else{primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n// this wrapper function to constrain it.\nreturn createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this\n// wrapper function to constrain it.\nreturn createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment\nvar deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else{deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\n(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was\n// already cloned. In legacy mode, the only case where this isn't true is\n// when DevTools forces us to display a fallback; we skip the first render\n// pass entirely and go straight to rendering the fallback. (In Concurrent\n// Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n// only codepath.)\nworkInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// The fallback fiber was added as a deletion during the first pass.\n// However, since we're going to remain on the fallback, we no longer want\n// to delete it.\nworkInProgress.deletions=null;}else{primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// Since we're reusing a current tree, we need to reuse the flags, too.\n// (We don't do this in legacy mode, because in legacy mode we don't re-use\n// the current tree; see previous branch.)\nprimaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else{fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;}fallbackChildFragment.return=workInProgress;primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance\n// implications, it's considered a recoverable error, even though the user\n// likely won't observe anything wrong with the UI.\n//\n// The error is passed in as an argument to enforce that every caller provide\n// a custom message, or explicitly opt out (currently the only path that opts\n// out is legacy mode; every concurrent path provides an error).\nif(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.\nvar nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nprimaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense\n// boundary) already mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the\n// deletion. We need to reconcile to delete the current child.\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.\n// Instead, we'll leave the content in place and try to hydrate it later.\nif((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server\n// for this, we need to schedule that at a higher priority based on when it would\n// have timed out. In theory we could render it in this pass but it would have the\n// wrong priority associated with it and will prevent hydration of parent path.\n// Instead, we'll leave work left on it to render it in a separate commit.\n// TODO This time should be the time at which the server rendered response that is\n// a parent to this boundary was displayed. However, since we currently don't have\n// a protocol to transfer that time, we'll just estimate it by using the current\n// time. This will mean that Suspense timeouts are slightly shifted to later than\n// they should be.\n// Schedule a normal pri update to render this content.\nworkInProgress.lanes=laneToLanes(DefaultHydrationLane);}else{// We'll continue hydrating the rest at offscreen priority since we'll already\n// be showing the right content coming from the server, it is no rush.\nworkInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,suspenseInstance,suspenseState,renderLanes){if(!didSuspend){// This is the first render pass. Attempt to hydrate.\n// We should never be hydrating at this point because it is the first pass,\n// but after we've already committed once.\nwarnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument\n// required  every concurrent mode path that causes hydration to\n// de-opt to client rendering should have an error message.\nnull);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never\n// get an update and we'll never be able to hydrate the final content. Let's just try the\n// client side render instead.\nvar digest,message,stack;{var _getSuspenseInstanceF=getSuspenseInstanceFallbackErrorDetails(suspenseInstance);digest=_getSuspenseInstanceF.digest;message=_getSuspenseInstanceF.message;stack=_getSuspenseInstanceF.stack;}var error;if(message){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(message);}else{error=new Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.');}var capturedValue=createCapturedValue(error,digest,stack);return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,capturedValue);}// any context has changed, we need to treat is as if the input might have changed.\nvar hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to\n// hydrate it. We might still be able to hydrate it using a higher priority lane.\nvar root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This\n// is one of the very rare times where we mutate the current tree\n// during the render phase.\nsuspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render\nvar eventTime=NoTimestamp;enqueueConcurrentRenderForLane(current,attemptHydrationAtLane);scheduleUpdateOnFiber(root,current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render\n// since we now have higher priority work, but in case it doesn't, we need to prepare to\n// render something, if we time out. Even if that requires us to delete everything and\n// skip hydration.\n// Delay having to do this as long as the suspense timeout allows us.\nrenderDidSuspendDelayIfPossible();var _capturedValue=createCapturedValue(new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue);}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its\n// content. We treat it as if this component suspended itself. It might seem as if\n// we could just try to render it client-side instead. However, this will perform a\n// lot of unnecessary work and is unlikely to complete since it often will suspend\n// on missing data anyway. Additionally, the server might be able to render more\n// than we can on the client yet. In that case we'd end up with more fallback states\n// on the client than if we just leave it alone. If the server times out or errors\n// these should update this boundary to the permanent Fallback state instead.\n// Mark it as having captured (i.e. suspended).\nworkInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.\nworkInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.\nvar retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else{// This is the first attempt.\nreenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nprimaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}else{// This is the second render pass. We already attempted to hydrated, but\n// something either suspended or errored.\nif(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.\nworkInProgress.flags&=~ForceClientRender;var _capturedValue2=createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue2);}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.\n// Leave the existing child in place.\nworkInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there\n// but the normal suspense pass doesn't.\nworkInProgress.flags|=DidCapture;return null;}else{// Suspended but we should no longer be in dehydrated mode.\n// Therefore we now have to render the fallback.\nvar nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var _primaryChildFragment4=workInProgress.child;_primaryChildFragment4.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.\n// If they were previously forced into fallbacks, they may now be able\n// to unblock.\nvar node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries\n// to schedule work on. In this case we have to schedule it on the\n// list itself.\n// We don't have to traverse to the children of the list since\n// the list will propagate the change when it rerenders.\nscheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already\n// showing content on the screen, as opposed to being in fallback state or\n// new. If a row has multiple Suspense boundaries, any of them being in the\n// fallback state, counts as the whole row being in a fallback state.\n// Note that the \"rows\" will be workInProgress, but any nested children\n// will still be current since we haven't rendered them yet. The mounted\n// order may not be the same as the new order. We use the new order.\nvar row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase \"%s\" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use \"%ss\" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('\"%s\" is not a supported revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);break;}}else{error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('\"%s\" is not a supported value for tail on <SuspenseList />. '+'Did you mean \"collapsed\" or \"hidden\"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is '+'\"forwards\" or \"backwards\". '+'Did you mean to specify revealOrder=\"forwards\"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else{error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else{// We can reuse the existing object from previous renders.\nrenderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else{var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work\n// on any nested boundaries to let them know to try to render\n// again. This is the same as context updating.\npropagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just\n// use make it a noop by treating it as the default revealOrder.\nworkInProgress.memoizedState=null;}else{switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.\n// TODO: We could fast path by just rendering the tail now.\ntail=workInProgress.child;workInProgress.child=null;}else{// Disconnect the tail rows after the content row.\n// We're going to render them separately later.\ntail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards\ntail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.\n// At the same time we're going to reverse the list of everything\n// we pass in the meantime. That's going to be our tail in reverse\n// order.\nvar _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.\nworkInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.\ninitSuspenseListRenderState(workInProgress,true,// isBackwards\n_tail,null,// last\ntailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards\nnull,// tail\nnull,// last\nundefined);break;}default:{// The default reveal order is the same as not having\n// a boundary.\nworkInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount\n// but at commit. Therefore we need to track insertions which the normal\n// flow doesn't do during mount. This doesn't happen at the root because\n// the root always starts with a \"current\" with a null child.\n// TODO: Consider unifying this with how the root works.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else{// The context value changed. Search for matching consumers and schedule\n// them to update.\npropagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In\n// DEV mode, we create a separate object for Context.Consumer that acts\n// like a proxy to Context. This proxy object adds unnecessary code in PROD\n// so we use the old behaviour (Context.Consumer references Context) to\n// reduce size and overhead. The separate object references context via\n// a property called \"_context\", which also gives us the ability to check\n// in DEV mode if this property exists or not and warn if it does not.\n{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).\n// Or it may be because it's older React where they're the same thing.\n// We only want to warn if we're sure it's a new React.\nif(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+\"that isn't a function. A context consumer expects a single child \"+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress){if((workInProgress.mode&ConcurrentMode)===NoMode){if(current!==null){// A lazy component only mounts if it suspended inside a non-\n// concurrent tree, in an inconsistent state. We want to treat it like\n// a new mount, even though an empty version of it already committed.\n// Disconnect the alternate pointers.\ncurrent.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}}}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies\nworkInProgress.dependencies=current.dependencies;}{// Don't update \"base\" render times for bailouts.\nstopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.\nif(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.\n// TODO: Once we add back resuming, we should check if the children are\n// a work-in-progress set. If so, we need to transfer their effects.\n{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child\n// fibers and continue.\ncloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Cannot swap the root fiber.');}// Disconnect from the old current.\n// It will get deleted.\ncurrent.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.\nnewWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress.return=oldWorkInProgress.return;newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.\nif(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else{var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.\n// Since the old fiber is disconnected, we have to schedule it manually.\nvar deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else{deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.\nreturn newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending\n// updates or context.\nvar updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need\nreturn false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering\n// the begin phase. There's still some bookkeeping we that needs to be done\n// in this optimized path, mostly pushing stuff onto the stack.\nswitch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);var root=workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.\nvar hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has\n// been unsuspended it has committed as a resolved Suspense component.\n// If it needs to be retried, it should have work scheduled on it.\nworkInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we\n// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\nreturn null;}// If this boundary is currently timed out, we need to decide\n// whether to retry the primary children, or to skip over it and\n// go straight to the fallback. Check the priority of the primary\n// child fragment.\nvar primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path\n// to attempt to render the primary children again.\nreturn updateSuspenseComponent(current,workInProgress,renderLanes);}else{// The primary child fragment does not have pending work marked\n// on it\npushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient\n// priority. Bailout.\nvar child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the\n// primary children and work on the fallback.\nreturn child.sibling;}else{// Note: We can return `null` here because we already checked\n// whether there were nested context consumers, via the call to\n// `bailoutOnAlreadyFinishedWork` above.\nreturn null;}}}else{pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the\n// same children then we're still in progressive loading state.\n// Something might get unblocked by state updates or retries in the\n// tree which will affect the tail. So we need to use the normal\n// path to compute the correct tail.\nreturn updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nworkInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,\n// then the tail doesn't matter. Anything new that suspends will work\n// in the \"together\" mode, so we can continue from the state we had.\nvar renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the \"together\" mode in case we've started a different\n// update in the past but didn't complete it.\nrenderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else{// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nreturn null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is\n// almost identical to the logic used in the normal update path,\n// so we'll just enter that. The only difference is we'll bail out\n// at the next level instead of this one, because the child props\n// have not changed. Which is fine.\n// TODO: Probably should refactor `beginWork` to split the bailout\n// path from the normal path. I'm tempted to do a labeled break here\n// but I won't :)\nworkInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.\nreturn remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:\nworkInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.\n// This may be unset if the props are determined to be equal later (memo).\ndidReceiveUpdate=true;}else{// Neither props nor legacy context changes. Check if there's a pending\n// update or context change.\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there\n// may not be work scheduled on `current`, so we check for this flag.\n(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.\ndidReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}else{// An update was scheduled on this fiber, but there are no new props\n// nor legacy context. Set this to false. If an update queue or context\n// consumer produces a changed value, it will set this to true. Otherwise,\n// the component will assume the children have not changed and bail out.\ndidReceiveUpdate=false;}}}else{didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in\n// its parent.\n//\n// In a true multi-threaded implementation, we would render children on\n// parallel threads. This would represent the beginning of a new render\n// thread for this subtree.\n//\n// We only use this for id generation during hydration, which is why the\n// logic is located in this special branch.\nvar slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.\n// TODO: This assumes that we're about to evaluate the component and process\n// the update queue. However, there's an exception: SimpleMemoComponent\n// sometimes bails out later in the begin phase. This indicates that we should\n// move this assignment out of the common path and into each branch.\nworkInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent(current,workInProgress,renderLanes);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.\nvar _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only\n'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into\n// a PlacementAndUpdate.\nworkInProgress.flags|=Update;}function markRef$1(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode\nappendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its\n// children to find all the terminal nodes.\nvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function(current,workInProgress){// Noop\n};updateHostComponent$1=function(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to\n// schedule a side-effect to do the updates.\nvar oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because\n// we won't touch this node even if children changed.\nreturn;}// If we get updated because one of our children updated, we don't\n// have newProps so we'll have to reuse them.\n// TODO: Split the update API as separate for the props vs. children.\n// Even better would be if children weren't special cased at all tho.\nvar instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host\n// component is hitting the resume path. Figure out why. Possibly\n// related to `hidden`.\nvar updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.\nworkInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update. All the work is done in commitWork.\nif(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.\nif(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can\n// so we don't leave any behind.\nreturn;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(lastTailNode===null){// All remaining items in the tail are insertions.\nrenderState.tail=null;}else{// Detach the insertion after the last node that was already\n// inserted.\nlastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(_lastTailNode===null){// All remaining items in the tail are insertions.\nif(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one\n// row at the tail. So we'll keep on and cut off the rest.\nrenderState.tail.sibling=null;}else{renderState.tail=null;}}else{// Detach the insertion after the last node that was already\n// inserted.\n_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will\n// only be updated if work is done on the fiber (i.e. it doesn't bailout).\n// When work is done, it should bubble to the parent's actualDuration. If\n// the fiber has not been cloned though, (meaning no work was done), then\n// this value will reflect the amount of time spent working on a previous\n// render. In that case it should not bubble. We determine whether it was\n// cloned by comparing the child pointer.\nactualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else{var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child.return=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else{// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else{var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child3.return=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeDehydratedSuspenseBoundary(current,workInProgress,nextState){if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return false;}var wasHydrated=popHydrationState(workInProgress);if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this\n// Suspense boundary, and also after we've reentered it for further hydration.\nif(current===null){if(!wasHydrated){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return false;}else{// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n// state since we're now exiting out of it. popHydrationState doesn't do that for us.\nresetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.\nworkInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary\n// as having hydrated so events know that they're free to be invoked.\n// It's also a signal to replay events and the suspense callback.\n// If something suspended, schedule an effect to attach retry listeners.\n// So we might as well always mark this.\nworkInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return false;}}else{// Successfully completed this tree. If this was a forced client render,\n// there may have been recoverable errors during first hydration\n// attempt. If so, add them to a queue so we can log them in the\n// commit phase.\nupgradeHydrationErrorsToRecoverable();// Fall through to normal Suspense path\nreturn true;}}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children\n// that weren't hydrated.\nvar wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for\n// the commit side-effects on the root.\nmarkUpdate(workInProgress);}else{if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root\n!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)\n(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the\n// next commit. This handles the case of React rendering into a\n// container with previous children. It's also safe to do for\n// updates too, because current.child would only be null if the\n// previous render was null (so the container would already\n// be empty).\nworkInProgress.flags|=Snapshot;// If this was a forced client render, there may have been\n// recoverable errors during first hydration attempt. If so, add\n// them to a queue so we can log them in the commit phase.\nupgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\nbubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context\n// \"stack\" as the parent. Then append children as we go in beginWork\n// or completeWork depending on whether we want to add them top->down or\n// bottom->up. Top->down is faster in IE11.\nvar _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase\n// to consolidate.\nif(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the\n// commit-phase we mark this as such.\nmarkUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.\n// (eg DOM renderer supports auto-focus for certain elements).\n// Make sure such renderers get scheduled for later work.\nif(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback\nmarkRef$1(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need\n// to schedule a side-effect to do the updates.\nupdateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\n}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;// Special path for dehydrated boundaries. We may eventually move this\n// to its own fiber type so that we can add other kinds of hydration\n// boundaries that aren't associated with a Suspense tree. In anticipation\n// of such a refactor, all the hydration logic is contained in\n// this branch.\nif(current===null||current.memoizedState!==null&&current.memoizedState.dehydrated!==null){var fallthroughToNormalSuspensePath=completeDehydratedSuspenseBoundary(current,workInProgress,nextState);if(!fallthroughToNormalSuspensePath){if(workInProgress.flags&ShouldCapture){// Special case. There were remaining unhydrated nodes. We treat\n// this as a mismatch. Revert to client rendering.\nreturn workInProgress;}else{// Did not finish hydrating, either because this is the initial\n// render or because something suspended.\nreturn null;}}// Continue with the normal Suspense path.\n}if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.\nworkInProgress.lanes=renderLanes;// Do not reset the effect list.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.\nreturn workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=current!==null&&current.memoizedState!==null;// a passive effect, which is when we process the transitions\nif(nextDidTimeout!==prevDidTimeout){// an effect to toggle the subtree's visibility. When we switch from\n// fallback -> primary, the inner Offscreen fiber schedules this effect\n// as part of its normal complete phase. But when we switch from\n// primary -> fallback, the inner Offscreen fiber does not have a complete\n// phase. So we need to schedule its effect here.\n//\n// We also use this flag to connect/disconnect the effects, but the same\n// logic applies: when re-connecting, the Offscreen fiber's complete\n// phase will handle scheduling the effect. It's only when the fallback\n// is active that we have to do anything special.\nif(nextDidTimeout){var _offscreenFiber2=workInProgress.child;_offscreenFiber2.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything\n// in the concurrent tree already suspended during this render.\n// This is a known bug.\nif((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late\n// if this is a large tree which is common for initial loads. We\n// don't know if we should restart a render or not until we get\n// this marker, and this is too late.\n// If this render already had a ping or lower pri updates,\n// and this is the first time we know we're going to suspend we\n// should be able to immediately restart from within throwException.\nvar hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing\n// this boundary is ok.\nrenderDidSuspend();}else{// Otherwise, we're going to have to hide content so we should\n// suspend for longer if possible.\nrenderDidSuspendDelayIfPossible();}}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.\n// TODO: Move to passive phase\nworkInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber\nvar context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are\n// sequential to ensure this switch is compiled to a jump table.\nvar _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, \"independent\" mode.\n// We don't do anything in this mode.\nbubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.\nif(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still\n// suspended in the rendered set.\n// If new content unsuspended, but there's still some content that\n// didn't. Then we need to do a second pass that forces everything\n// to keep showing their fallbacks.\n// We might be suspended if something in this render pass suspended, or\n// something in the previous committed pass suspended. Otherwise,\n// there's no chance so we can skip the expensive call to\n// findFirstSuspended.\nvar cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as\n// part of the second pass. In that case nothing will subscribe to\n// its thenables. Instead, we'll transfer its thenables to the\n// SuspenseList so that it can retry if they resolve.\n// There might be multiple of these in the list but since we're\n// going to wait for all of them anyway, it doesn't really matter\n// which ones gets to ping. In theory we could get clever and keep\n// track of how many dependencies remain but it gets tricky because\n// in the meantime, we can add/remove/change items and dependencies.\n// We might bail out of the loop before finding any but that\n// doesn't matter since that means that the other boundaries that\n// we did find already has their listeners attached.\nvar newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks\n// to stay in place.\n// Reset the effect flags before doing the second pass since that's now invalid.\n// Reset the child fibers to their original state.\nworkInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately\n// rerender the children.\npushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.\nreturn workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows\n// left in the tail. We'll just give up further attempts to render\n// the main content and only render fallbacks.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}else{cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.\n}else{// Append the rendered row to the child list.\nif(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't\n// get lost if this row ends up dropped during a second pass.\nvar _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.\nif(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.\n){// We're done.\nbubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining\n// time we have to render. So rendering one more row would likely\n// exceed it.\nnow()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further\n// attempts to render the main content and only render fallbacks.\n// The assumption is that this is usually faster.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added\n// to the end. This breaks the guarantee that life-cycles fire in\n// sibling order but that isn't a strong guarantee promised by React.\n// Especially since these might also just pop in during future commits.\n// Append to the beginning of the list.\nrenderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else{var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else{workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.\n// Pop a row.\nvar next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.\n// TODO: We can probably just avoid popping it instead and only\n// setting it the first time we go from not suspended to suspended.\nvar suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else{suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.\n// Don't bubble properties in this case.\nreturn next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState=current.memoizedState;var prevIsHidden=_prevState!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding  it only pre-renders.\n!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else{// Don't bubble properties for hidden children unless we're rendering\n// at offscreen priority.\nif(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.\n// If so, we need to hide those nodes in the commit phase, so\n// schedule a visibility effect.\nif(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{var root=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense\n// boundary. Do a second pass on the root to unmount the children.\nworkInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.\nreturn null;}case HostComponent:{// TODO: popHydrationState\npopHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been\n// caught by a nested boundary. If not, it should bubble through.\nreturn null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{var root=interruptedWork.stateNode;popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\nvar offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.\nvar inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded\n// callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n// But we rely on it to surface errors to DEV tools like overlays\n// (https://github.com/facebook/react/issues/21712).\n// As a compromise, rethrow only caught errors in a guard.\n{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else{instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.\nfunction safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else{retVal=ref(null);}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else{ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}var focusedInstanceHandle=null;var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){focusedInstanceHandle=prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber\nvar shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;focusedInstanceHandle=null;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.\nvar child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else{commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types\nbreak;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount\nvar destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount\nvar create=effect.create;{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}effect.destroy=create();{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else{hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\\n\\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\\n\\n'+hookName+'(() => {\\n'+'  async function fetchData() {\\n'+'    // You can await here\\n'+'    const response = await MyAPI.getData(someId);\\n'+'    // ...\\n'+'  }\\n'+'  fetchData();\\n'+\"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else{addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.\nif((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.\n// It does not get reset until the start of the next commit phase.\nvar commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.\n// After we process that Profiler, we'll bubble further up.\nvar parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber.return;}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).\n// This is done to prevent sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else{commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidMount();}}else{var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\ncommitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted\n// (eg DOM renderer may schedule auto-focus for inputs and form controls).\n// These effects should only be committed when components are first mounted,\n// aka when there is no current/alternate.\nif(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.\nbreak;}case HostPortal:{// We have no life-cycles associated with portals.\nbreak;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.\n// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n// because the effect is also where times bubble to parent Profilers.\nenqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.\n// Do not reset these values until the next render so DevTools has a chance to read them first.\nvar parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber.return;}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:case TracingMarkerComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.\n// TODO (Offscreen) Check: flags & LayoutStatic\nswitch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node.return);}finally{recordLayoutEffectDuration(node);}}else{safelyCallCommitHookLayoutEffectListMount(node,node.return);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node.return,instance);}safelyAttachRef(node,node.return);break;}case HostComponent:{safelyAttachRef(node,node.return);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.\nvar hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\nvar node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){try{var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node.return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling.return=node.return;node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag\nif(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else{retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else{{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.\n// This enables us to detect and warn against state updates on an unmounted component.\n// It also prevents events from bubbling from within disconnected components.\n//\n// Ideally, we should also clear the child pointer of the parent alternate to let this\n// get GC:ed but we don't know which for sure which parent is the current\n// one so we'll settle for GC:ing the subtree of this child.\n// This child itself will be GC:ed when the parent updates the next time.\n//\n// Note that we can't clear child or sibling pointers yet.\n// They're needed for passive effects and for findDOMNode.\n// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n//\n// Don't reset the alternate yet, either. We need that so we can detach the\n// alternate's fields in the passive phase. Clearing the return pointer is\n// sufficient for findDOMNode semantics.\nvar alternate=fiber.alternate;if(alternate!==null){alternate.return=null;}fiber.return=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case\n// `deletedTreeCleanUpLevel` is undefined.\n{// Clear cyclical Fiber fields. This level alone is designed to roughly\n// approximate the planned Fiber refactor. In that world, `setState` will be\n// bound to a special \"instance\" object instead of a Fiber. The Instance\n// object will not have any of these fields. It will only be connected to\n// the fiber tree via a single link at the root. So if this level alone is\n// sufficient to fix memory issues, that bodes well for our plans.\nfiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host\n// tree, which has its own pointers to children, parents, and siblings.\n// The other host nodes also point back to fibers, so we should detach that\n// one, too.\nif(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We\n// already disconnect the `return` pointer at the root of the deleted\n// subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n// cyclical  it's only cyclical when combined with `child`, `sibling`, and\n// `alternate`. But we'll clear it in the next level anyway, just in case.\n{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already\n// disconnected the fiber from the tree. So even if something leaks this\n// particular fiber, it won't leak anything else\n//\n// The purpose of this branch is to be super aggressive so we can measure\n// if there's any difference in memory impact. If there is, that could\n// indicate a React leak we don't know about.\nfiber.return=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\nfiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host\n// node. Unfortunately, if multiple insertions are done in a row we have to\n// search past them. This leads to exponential search for the next sibling.\n// TODO: Find a more efficient way to do this.\nvar node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.\nwhile(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the\n// last sibling.\nreturn null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.\n// Try to search down until we find one.\nif(node.flags&Placement){// If we don't have a child, try the siblings instead.\ncontinue siblings;}// If we don't have a child, try the siblings instead.\n// We also skip portals because they are not part of this host tree.\nif(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.\nif(!(node.flags&Placement)){// Found it!\nreturn node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.\nswitch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions\nresetTextContent(parent);// Clear ContentReset from the effect tag\nparentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\ninsertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough\ndefault:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else{appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else{appendChild(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}// These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\nvar hostParent=null;var hostParentIsContainer=false;function commitDeletionEffects(root,returnFiber,deletedFiber){{// We only have the top Fiber that was deleted but we need to recurse down its\n// children to find all the terminal nodes.\n// Recursively delete all host nodes from the parent, detach refs, clean\n// up mounted layout effects, and call componentWillUnmount.\n// We only need to remove the topmost host child in each branch. But then we\n// still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n// could split this into two separate traversals functions, where the second\n// one doesn't include any removeChild logic. This is maybe the same\n// function as \"disappearLayoutEffects\" (or whatever that turns into after\n// the layout phase is refactored to use recursion).\n// Before starting, find the nearest host parent on the stack so we know\n// which instance/container to remove the children from.\n// TODO: Instead of searching up the fiber return path on every deletion, we\n// can track the nearest host component on the JS stack as we traverse the\n// tree during the commit phase. This would make insertions faster, too.\nvar parent=returnFiber;findParent:while(parent!==null){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode;hostParentIsContainer=false;break findParent;}case HostRoot:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}case HostPortal:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}}parent=parent.return;}if(hostParent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}commitDeletionEffectsOnFiber(root,returnFiber,deletedFiber);hostParent=null;hostParentIsContainer=false;}detachFiberMutation(deletedFiber);}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){// TODO: Use a static flag to skip trees that don't have unmount effects\nvar child=parent.child;while(child!==null){commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child);child=child.sibling;}}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){onCommitUnmount(deletedFiber);// The cases in this outer switch modify the stack before they traverse\n// into their subtree. There are simpler cases in the inner switch\n// that don't modify the stack.\nswitch(deletedFiber.tag){case HostComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);}// Intentional fallthrough to next branch\n}// eslint-disable-next-line-no-fallthrough\ncase HostText:{// We only need to remove the nearest host child. Set the host parent\n// to `null` on the stack to indicate that nested children don't\n// need to be removed.\n{var prevHostParent=hostParent;var prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(hostParent!==null){// Now that all the child effects have unmounted, we can remove the\n// node from the tree.\nif(hostParentIsContainer){removeChildFromContainer(hostParent,deletedFiber.stateNode);}else{removeChild(hostParent,deletedFiber.stateNode);}}}return;}case DehydratedFragment:{// Delete the dehydrated suspense boundary and all of its content.\n{if(hostParent!==null){if(hostParentIsContainer){clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode);}else{clearSuspenseBoundary(hostParent,deletedFiber.stateNode);}}}return;}case HostPortal:{{// When we go into a portal, it becomes the parent to remove from.\nvar _prevHostParent=hostParent;var _prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=_prevHostParent;hostParentIsContainer=_prevHostParentIsContainer;}return;}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(deletedFiber);}if(deletedFiber.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);recordLayoutEffectDuration(deletedFiber);}else{safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance);}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case OffscreenComponent:{if(// TODO: Remove this dead flag\ndeletedFiber.mode&ConcurrentMode){// If this offscreen component is hidden, we already unmounted it. Before\n// deleting the children, track that it's already unmounted so that we\n// don't attempt to unmount the effects again.\n// TODO: If the tree is hidden, in most cases we should be able to skip\n// over the nested children entirely. An exception is we haven't yet found\n// the topmost host node to delete, which we already track on the stack.\n// But the other case is portals, which need to be detached no matter how\n// deeply they are nested. We should use a subtree flag to track whether a\n// subtree includes a nested portal.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}break;}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}}}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase\nvar newState=finishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.\n// For each wakeable, attach a listener so that when it resolves, React\n// attempts to re-render the boundary in the primary (pre-timeout) state.\nvar wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.\nvar retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.\nrestorePendingUpdaters(inProgressRoot,inProgressLanes);}else{throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.\nfunction commitMutationEffects(root,finishedWork,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;setCurrentFiber(finishedWork);commitMutationEffectsOnFiber(finishedWork,root);setCurrentFiber(finishedWork);inProgressLanes=null;inProgressRoot=null;}function recursivelyTraverseMutationEffects(root,parentFiber,lanes){// Deletions effects can be scheduled on any fiber type. They need to happen\n// before the children effects hae fired.\nvar deletions=parentFiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletionEffects(root,parentFiber,childToDelete);}catch(error){captureCommitPhaseError(childToDelete,parentFiber,error);}}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask){var child=parentFiber.child;while(child!==null){setCurrentFiber(child);commitMutationEffectsOnFiber(child,root);child=child.sibling;}}setCurrentFiber(prevDebugFiber);}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var current=finishedWork.alternate;var flags=finishedWork.flags;// The effect flag should be checked *after* we refine the type of fiber,\n// because the fiber tag is more specific. An exception is any flag related\n// to reconcilation, because those can be set on all fiber types.\nswitch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return);commitHookEffectListMount(Insertion|HasEffect,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Layout effects are destroyed during the mutation phase so that all\n// destroy functions for all fibers are called before any create functions.\n// This prevents sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}recordLayoutEffectDuration(finishedWork);}else{try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case ClassComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}return;}case HostComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}{// TODO: ContentReset gets cleared by the children during the commit\n// phase. This is a refactor hazard because it means we must read\n// flags the flags after `commitReconciliationEffects` has already run;\n// the order matters. We should refactor so that ContentReset does not\n// rely on mutating the flag during commit. Like by setting a flag\n// during the render phase instead.\nif(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){// Commit the work prepared earlier.\nvar newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.\nvar updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostText:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldText=current!==null?current.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case HostRoot:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(current!==null){var prevRootState=current.memoizedState;if(prevRootState.isDehydrated){try{commitHydratedContainer(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostPortal:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}case SuspenseComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var offscreenInstance=offscreenFiber.stateNode;var newState=offscreenFiber.memoizedState;var isHidden=newState!==null;// Track the current state on the Offscreen instance so we can\n// read it during an event\noffscreenInstance.isHidden=isHidden;if(isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase\nmarkCommitTimeOfFallback();}}}if(flags&Update){try{commitSuspenseCallback(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}attachSuspenseRetryListeners(finishedWork);}return;}case OffscreenComponent:{var _wasHidden=current!==null&&current.memoizedState!==null;if(// TODO: Remove this dead flag\nfinishedWork.mode&ConcurrentMode){// Before committing the children, track on the stack whether this\n// offscreen subtree was already hidden, so that we don't unmount the\n// effects again.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseMutationEffects(root,finishedWork);}commitReconciliationEffects(finishedWork);if(flags&Visibility){var _offscreenInstance=finishedWork.stateNode;var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var offscreenBoundary=finishedWork;// Track the current state on the Offscreen instance so we can\n// read it during an event\n_offscreenInstance.isHidden=_isHidden;{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}}{// TODO: This needs to run whenever there's an insertion or update\n// inside a hidden Offscreen tree.\nhideOrUnhideAllChildren(offscreenBoundary,_isHidden);}}return;}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){attachSuspenseRetryListeners(finishedWork);}return;}case ScopeComponent:{return;}default:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}}}function commitReconciliationEffects(finishedWork){// Placement effects (insertions, reorders) can be scheduled on any fiber\n// type. They needs to happen after the children effects have fired, but\n// before the effects on this fiber have fired.\nvar flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Clear the \"placement\" from effect tag so that we know that this is\n// inserted, before any life-cycles like componentDidMount gets called.\n// TODO: findDOMNode doesn't rely on this any more but isMounted does\n// and isMounted is deprecated anyway so we should be able to kill this.\nfinishedWork.flags&=~Placement;}if(flags&Hydrating){finishedWork.flags&=~Hydrating;}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.\nvar isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.\nvar isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.\ncommitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else{// TODO (Offscreen) Also check: subtreeFlags & LayoutMask\nvar current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.\noffscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects\n// back on.\nnextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.\nroot,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.\nnextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber.return);}finally{recordLayoutEffectDuration(fiber);}}else{commitHookEffectListUnmount(Layout,fiber,fiber.return);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic\nsafelyDetachRef(fiber,fiber.return);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber.return);break;}case OffscreenComponent:{// Check if this is a\nvar isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear\n// its effects.\ndisappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.\nreappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nfirstChild.return=fiber;nextEffect=firstChild;}else{reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic\nsetCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nsibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountEffects(root,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root,committedLanes,committedTransitions);}function commitPassiveMountEffects_begin(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions);}}}function commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber,committedLanes,committedTransitions);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of\n// the previous (alternate) parent fiber's list of children. Because\n// children are a linked list, an earlier sibling that's still alive\n// will be connected to the deleted fiber via its `alternate`:\n//\n//   live fiber\n//   --alternate--> previous live fiber\n//   --sibling--> deleted fiber\n//\n// We can't disconnect `alternate` on nodes that haven't been deleted\n// yet, but we can disconnect the `sibling` and `child` pointers.\nvar previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else{commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);recordPassiveEffectDuration(finishedWork);}else{commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order\n// TODO: Check if fiber has a PassiveStatic flag\nsetCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\nif(child!==null){child.return=fiber;nextEffect=child;}else{commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber.return;{// Recursively traverse the entire deleted tree and clean up fiber fields.\n// This is more aggressive than ideal, and the long term goal is to only\n// have to detach the deleted tree at the root.\ndetachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){sibling.return=returnFiber;nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else{commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}// TODO: Reuse reappearLayoutEffects traversal here?\nfunction invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}}}}}var COMPONENT_TYPE=0;var HAS_PSEUDO_CLASS_TYPE=1;var ROLE_TYPE=2;var TEST_NAME_TYPE=3;var TEXT_TYPE=4;if(typeof Symbol==='function'&&Symbol.for){var symbolFor=Symbol.for;COMPONENT_TYPE=symbolFor('selector.component');HAS_PSEUDO_CLASS_TYPE=symbolFor('selector.has_pseudo_class');ROLE_TYPE=symbolFor('selector.role');TEST_NAME_TYPE=symbolFor('selector.test_id');TEXT_TYPE=symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an\n// act environment whenever `jest` is defined, but you can still turn off\n// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n// to false.\nvar isReactActEnvironmentGlobal=// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest\nvar jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.\nerror('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack\nvar executionContext=NoContext;// The root we're working on\nvar workInProgressRoot=null;// The fiber we're working on\nvar workInProgress=null;// The lanes we're rendering\nvar workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\nvar subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.\nvar workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown\nvar workInProgressRootFatalError=null;// \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\nvar workInProgressRootIncludedLanes=NoLanes;// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nvar workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.\nvar workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).\nvar workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.\nvar workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\nvar workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nvar globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\nvar workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\nvar RENDER_TIMEOUT_MS=500;var workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var pendingPassiveTransitions=null;// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var isFlushingPassiveEffects=false;var didScheduleUpdateDuringPassiveEffects=false;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var rootWithPassiveNestedUpdates=null;// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nvar currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;var isRunningInsertionEffect=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.\nreturn now();}// We're not inside React, so we may be in the middle of a browser event.\nif(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.\nreturn currentEventTime;}// This is the first update since React yielded. Compute a new start time.\ncurrentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The\n// old behavior is to give this the same \"thread\" (lanes) as\n// whatever is currently rendering. So if you call `setState` on a component\n// that happens later in the same render, it will flush. Ideally, we want to\n// remove the special case and treat them as if they came from an\n// interleaved event. Regardless, this pattern is not officially supported.\n// This behavior is only a fallback. The flag only exists until we can roll\n// out the setState warning, since existing code might accidentally rely on\n// the current behavior.\nreturn pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all\n// updates at the same priority within the same event. To do this, the\n// inputs to the algorithm must be the same.\n//\n// The trick we use is to cache the first of each of these inputs within an\n// event. Then reset the cached values once we can be sure the event is\n// over. Our heuristic for that is whenever we enter a concurrent work loop.\nif(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.\ncurrentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have\n// their priority set by tracking it with a context variable.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an\n// appropriate priority, based on the type of event.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense\n// \"retries\"  a special update that attempts to flip a Suspense boundary\n// from its placeholder state to its primary/resolved state.\n// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(root,fiber,lane,eventTime){checkForNestedUpdates();{if(isRunningInsertionEffect){error('useInsertionEffect must not schedule updates.');}}{if(isFlushingPassiveEffects){didScheduleUpdateDuringPassiveEffects=true;}}// Mark that the root has a pending update.\nmarkRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake\n// if the update originates from user space (with the exception of local\n// hook updates, which are handled differently and don't reach this\n// function), but there are some internal React features that use this as\n// an implementation detail, like selective hydration.\nwarnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase\n}else{// This is a normal update, scheduled from outside the render phase. For\n// example, during an input event.\n{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// Received an update to a tree that's in the middle of rendering. Mark\n// that there was an interleaved update work on this root. Unless the\n// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n// phase update. In that case, we don't treat render phase updates as if\n// they were interleaved, for backwards compat reasons.\nif((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render\n// definitely won't finish. Since we have a new update, let's mark it as\n// suspended now, right before marking the incoming update. This has the\n// effect of interrupting the current render and switching to the update.\n// TODO: Make sure this doesn't override pings that happen while we've\n// already started rendering.\nmarkRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside\n// a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n// scheduleCallbackForFiber to preserve the ability to schedule a callback\n// without immediately flushing it. We only do this for user-initiated\n// updates, to preserve historical behavior of legacy mode.\nresetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to\n// schedule the initial hydration of a root that has just been created. Most\n// of the stuff in scheduleUpdateOnFiber can be skipped.\n//\n// The main reason for this separate path, though, is to distinguish the\n// initial children from subsequent updates. In fully client-rendered roots\n// (createRoot instead of hydrateRoot), all top-level renders are modeled as\n// updates, but hydration roots are special because the initial render must\n// match what was rendered on the server.\nvar current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}function isUnsafeClassRenderPhaseUpdate(fiber){// Check if this is a render phase update. Only called by class components,\n// which special (deprecated) behavior for UNSAFE_componentWillReceive props.\nreturn(// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n// decided not to enable it.\n(executionContext&RenderContext)!==NoContext);}// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as\n// expired so we know to work on those next.\nmarkStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.\nvar nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.\nif(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.\nvar newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.\nvar existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a\n// Scheduler task, rather than an `act` task, cancel it and re-scheduled\n// on the `act` queue.\n!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.\n// Assume that discrete update microtasks are non-cancellable and null.\n// TODO: Temporary until we confirm this warning is not fired.\nif(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.\nreturn;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.\ncancelCallback$1(existingCallbackNode);}// Schedule a new callback.\nvar newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special\n// internal queue\nif(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else{scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.\nif(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed\n// at the end of the current scope even when using the sync version\n// of `act`.\nReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else{scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.\n// https://github.com/facebook/react/issues/22459\n// We don't support running callbacks in the middle of render\n// or commit so we need to check against that.\nif((executionContext&(RenderContext|CommitContext))===NoContext){// Note that this would still prematurely flush the callbacks\n// if this happens outside render or commit phase (e.g. in an event).\nflushSyncCallbacks();}});}}newCallbackNode=null;}else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current\n// event time. The next update will compute a new event time.\ncurrentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,\n// in case they schedule additional work.\nvar originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.\n// Check if the task node for this root was changed.\nif(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call\n// `ensureRootIsScheduled` because the check above implies either that\n// there's a new task, or that there's no remaining work on this root.\nreturn null;}}// Determine the next lanes to work on, using the fields stored\n// on the root.\nvar lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.\nreturn null;}// We disable time-slicing in some cases: if the work has been CPU-bound\n// for too long (\"expired\" work, to prevent starvation), or we're in\n// sync-updates-by-default mode.\n// TODO: We only check `didTimeout` defensively, to account for a Scheduler\n// bug we're still investigating. Once the bug in Scheduler is fixed,\n// we can remove this, since we track expiration ourselves.\nvar shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll\n// render synchronously to block concurrent data mutations, and we'll\n// includes all pending updates are included. If it still fails after\n// the second attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special\n// cases where need to exit the current render without producing a\n// consistent tree or committing.\n//\n// This should only happen during a concurrent render, not a discrete or\n// synchronous update. We should have already checked for this when we\n// unwound the stack.\nmarkRootSuspended$1(root,lanes);}else{// The render completed.\n// Check if this render may have yielded to a concurrent event, and if so,\n// confirm that any newly rendered stores are consistent.\n// TODO: It's possible that even a concurrent render may never have yielded\n// to the main thread, if it was fast enough, or if it expired. We could\n// skip the consistency check in that case, too.\nvar renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,\n// synchronously, to block further mutations.\nexitStatus=renderRootSync(root,lanes);// We need to check again if something threw\nif(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any\n// concurrent events.\n}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,\n// or, if something suspended, wait to commit it after a timeout.\nroot.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's\n// currently executed. Need to return a continuation.\nreturn performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall\n// back to client side render.\n// Before rendering again, save the errors from the previous attempt.\nvar errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering\n// during the next attempt. To do this, we call prepareFreshStack now\n// to create the root work-in-progress fiber. This is a bit weird in terms\n// of factoring, because it relies on renderRootSync not calling\n// prepareFreshStack again in the call below, which happens because the\n// root and lanes haven't changed.\n//\n// TODO: I think what we should do is set ForceClientRender inside\n// throwException, like we do for nested Suspense boundaries. The reason\n// it's here instead is so we can switch to the synchronous work loop, too.\n// Something to consider for a future refactor.\nvar rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry\n// The errors from the failed first attempt have been recovered. Add\n// them to the collection of recoverable errors. We'll log them in the\n// commit phase.\nvar errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors\n// from the first attempt, to preserve the causal sequence.\nif(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else{workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break\n// statement, but eslint doesn't know about invariant, so it complains\n// if I do. eslint-disable-next-line no-fallthrough\ncase RootErrored:{// We should have already attempted to retry this tree. If we reached\n// this point, it errored again. Commit it.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we\n// should immediately commit it or wait a bit.\nif(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope\n!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing\n// retries so that we don't show too many loading states too quickly.\nvar msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.\nif(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.\nbreak;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last\n// suspended level. Ping the last suspended level to try\n// rendering it again.\n// FIXME: What if the suspended lanes are Idle? Should not restart.\nvar eventTime=requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no\n// lower priority work to do. Instead of committing the fallback\n// immediately, wait for more data to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break;}}// The work expired. Commit immediately.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a\n// placeholder and without scheduling a timeout. Delay indefinitely\n// until we receive more data.\nbreak;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.\n// Schedule a placeholder to display after a short delay, using the Just\n// Noticeable Difference.\n// TODO: Is the JND optimization worth the added complexity? If this is\n// the only reason we track the event time, then probably not.\n// Consider removing.\nvar mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.\nif(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data\n// to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break;}}// Commit the placeholder.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootCompleted:{// The work completed. Ready to commit.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the\n// stores were mutated in a concurrent event. Intentionally using an iterative\n// loop instead of recursion so we can exit early.\nvar node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.\nreturn false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule\n// a re-render, and the error will be rethrown during render.\nreturn false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child.return=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return true;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does\n// eslint-disable-next-line no-unreachable\nreturn true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more\n// rarely, since we try to avoid it) updated during the render phase.\n// TODO: Lol maybe there's a better way to factor this besides this\n// obnoxiously named function :)\nsuspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.\nensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render\n// synchronously to block concurrent data mutations, and we'll includes\n// all pending updates are included. If it still fails after the second\n// attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we\n// will commit it even if something suspended.\nvar finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);// Before exiting, make sure there's a callback scheduled for the next\n// pending level.\nensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer\n// most batchedUpdates-like method.\nif(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the\n// next event, not at the end of the previous one.\nif(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else{return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.\n// Note that this will happen even if batchedUpdates is higher up\n// the stack.\nif((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from\n// the wrong context.\nreturn(executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback\n// state. Now that we have additional work, cancel the timeout.\nroot.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\ncancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress.return;while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork.return;}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=workInProgressRootIncludedLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;finishQueueingConcurrentUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.\nresetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a\n// separate issue. Write a regression test using string refs.\nReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork.return===null){// Expected to be working on a non-root fiber. This is a fatal error\n// because there's no ancestor that can handle it; the root is\n// supposed to capture all errors that weren't caught by an error\n// boundary.\nworkInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next\n// sibling, or the parent if there are no siblings. But since the root\n// has no siblings nor a parent, we set it to null. Usually this is\n// handled by `completeUnitOfWork` or `unwindWork`, but since we're\n// intentionally not calling those, we need set it here.\n// TODO: Consider calling `unwindWork` to pop the contexts.\nworkInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This\n// avoids inaccurate Profiler durations in the case of a\n// suspended render.\nstopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&typeof thrownValue==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else{markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork.return,erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.\nthrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing\n// the error. Bubble it to the next boundary.\nerroredWork=erroredWork.return;workInProgress=erroredWork;}else{erroredWork=workInProgress;}continue;}// Return to the normal work loop.\nreturn;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.\n// Instead the first renderer will lazily attach one, in order to give\n// nicer error messages.\nreturn ContextOnlyDispatcher;}else{return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked\n// this render.\nif(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on\n// the updates that were skipped. Usually we only suspend at the end of\n// the render phase.\n// TODO: We should probably always mark the root as suspended immediately\n// (inside this function), since by suspending at the end of the render\n// phase introduces a potential mistake where we suspend lanes that were\n// pinged or updated while we were rendering.\nmarkRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else{workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nfunction renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,\n// so those are false.\nreturn workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.\nthrow new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.\nwhile(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.\n{markRenderYielded();}return RootInProgress;}else{// Completed the tree.\n{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.\nreturn workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield\nwhile(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else{next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.\ncompleteUnitOfWork(unitOfWork);}else{workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next\n// sibling. If there are no more siblings, return to the parent fiber.\nvar completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=completedWork.alternate;var returnFiber=completedWork.return;// Check if the work completed or if something threw.\nif((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else{startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.\nworkInProgress=next;return;}}else{// This fiber did not complete because something threw. Pop values off\n// the stack without entering the complete phase. If this is a boundary,\n// capture values if possible.\nvar _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.\nif(_next!==null){// If completing this work spawned new work, do that next. We'll come\n// back here again.\n// Since we're restarting, remove anything that is not a host effect\n// from the effect tag.\n_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.\nvar actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.\nreturnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else{// We've unwound all the way to the root.\nworkInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\nworkInProgress=siblingFiber;return;}// Otherwise, return to the parent\ncompletedWork=returnFiber;// Update the next thing we're working on in case something throws.\nworkInProgress=completedWork;}while(completedWork!==null);// We've reached the root.\nif(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors,transitions){// TODO: This no longer makes any sense. We already wrap the mutation and\n// layout phases. Should be able to remove.\nvar previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,transitions,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,transitions,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n// means `flushPassiveEffects` will sometimes result in additional\n// passive effects. So we need to keep flushing in a loop until there are\n// no more pending effects.\n// TODO: Might be better if `flushPassiveEffects` did not automatically\n// flush synchronous work at the end, to avoid factoring hazards like this.\nflushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else{{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.\n// So we can clear these now to allow a new callback to be scheduled.\nroot.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first\n// pending time is whatever is left on the root fiber.\nvar remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.\nworkInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.\n// Do this as early as possible, so it is queued before anything else that\n// might get scheduled in the commit phase. (See #16714.)\n// TODO: Delete all other places that schedule the passive effect callback\n// They're redundant.\nif((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;// to store it in pendingPassiveTransitions until they get processed\n// We need to pass this through as an argument to commitRoot\n// because workInProgressTransitions might have changed between\n// the previous render and commit if we throttle the commit\n// with setTimeout\npendingPassiveTransitions=transitions;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool\n// *after* passive effects fire to avoid freeing a cache pool that may\n// be referenced by a node in the tree (HostRoot, Cache boundary etc)\nreturn null;});}}// Check if there are any effects in the whole tree.\n// TODO: This is left over from the effect list implementation, where we had\n// to check for the existence of `firstEffect` to satisfy Flow. I think the\n// only other reason this optimization exists is because it affects profiling.\n// Reconsider whether this is necessary.\nvar subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles\nReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass\n// of the effect list for each phase: all mutation effects come before all\n// layout effects, and so on.\n// The first phase a \"before mutation\" phase. We use this phase to read the\n// state of the host tree right before we mutate it. This is where\n// getSnapshotBeforeUpdate is called.\nvar shouldFireAfterActiveInstanceBlur=commitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this\n// batch. This enables them to be grouped later.\nrecordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after\n// the mutation phase, so that the previous tree is still current during\n// componentWillUnmount, but before the layout phase, so that the finished\n// work is current during componentDidMount/Update.\nroot.current=finishedWork;// The next phase is the layout phase, where we call effects that read\n{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.\nrequestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.\nsetCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else{// No effects.\nroot.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were\n// no effects.\n// TODO: Maybe there's a better way to report this.\n{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't\n// schedule a callback until after flushing layout work.\nrootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}else{{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;}}// Read this again, since an effect might have updated it\nremainingLanes=root.pendingLanes;// Check if there's remaining work on this root\n// TODO: This is part of the `componentDidCatch` implementation. Its purpose\n// is to detect whether something might have called setState inside\n// `componentDidCatch`. The mechanism is known to be flawed because `setState`\n// inside `componentDidCatch` is itself flawed  that's why we recommend\n// `getDerivedStateFromError` instead. However, it could be improved by\n// checking if remainingLanes includes Sync work, instead of whether there's\n// any work remaining at all (which would also include stuff like Suspense\n// retries or transitions). It's been like this for a while, though, so fixing\n// it probably isn't that urgent.\nif(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed\n// error boundaries.\nlegacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any\n// additional work on this root is scheduled.\nensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without\n// needing to surface it to the UI. We log them here.\nvar onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];var componentStack=recoverableError.stack;var digest=recoverableError.digest;onRecoverableError(recoverableError.value,{componentStack:componentStack,digest:digest});}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them\n// synchronously at the end of the current task so that the result is\n// immediately observable. Otherwise, we assume that they are not\n// order-dependent and do not need to be observed by external systems, so we\n// can wait until after paint.\n// TODO: We can optimize this by not scheduling the callback earlier. Since we\n// currently schedule the callback in multiple places, will wait until those\n// are consolidated.\nif(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it\nremainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without\n// finishing. If there are too many, it indicates an infinite update loop.\nif(root===rootWithNestedUpdates){nestedUpdateCount++;}else{nestedUpdateCount=0;rootWithNestedUpdates=root;}}else{nestedUpdateCount=0;}// If layout work was scheduled, flush it now.\nflushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.\n// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n// probably just combine the two functions. I believe they were only separate\n// in the first place because we used to wrap it with\n// `Scheduler.runWithPriority`, which accepts a function. But now we track the\n// priority within React itself, so we can mutate the variable directly.\nif(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a\n}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}// Cache and clear the transitions flag\nvar transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n// Figure out why and fix it. It's not causing any known issues (probably\n// because it's only used for profiling), but it's a refactor hazard.\npendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{isFlushingPassiveEffects=true;didScheduleUpdateDuringPassiveEffects=false;}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current,lanes,transitions);// TODO: Move to commitPassiveMountEffects\n{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();{// If additional passive effects were scheduled, increment a counter. If this\n// exceeds the limit, we'll fire a warning.\nif(didScheduleUpdateDuringPassiveEffects){if(root===rootWithPassiveNestedUpdates){nestedPassiveUpdateCount++;}else{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=root;}}else{nestedPassiveUpdateCount=0;}isFlushingPassiveEffects=false;didScheduleUpdateDuringPassiveEffects=false;}// TODO: Move to commitPassiveMountEffects\nonPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValueAtFiber(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);var root=enqueueUpdate(rootFiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){{reportUncaughtErrorInDEV(error$1);setIsRunningInsertionEffect(false);}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root\n// itself should capture it.\ncaptureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValueAtFiber(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);var root=enqueueUpdate(fiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber.return;}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n// will fire for errors that are thrown by destroy functions inside deleted\n// trees. What it should instead do is propagate the error to the parent of\n// the deleted tree. In the meantime, do not add this warning to the\n// allowlist; this is only for our internal use.\nerror('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\\n\\n'+'Error message:\\n\\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\npingCache.delete(wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently\n// rendering. We might want to restart this render. This should mirror\n// the logic of whether or not a root suspends once it completes.\n// TODO: If we're rendering sync either due to Sync, Batched or expired,\n// we should probably never restart.\n// If we're suspended with delay, or if it's a retry, we'll always suspend\n// so we can always restart.\nif(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.\nprepareFreshStack(root,NoLanes);}else{// Even though we can't restart right now, we might get an\n// opportunity later. So we mark this render as having a ping.\nworkInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)\n// previously was rendered in its fallback state. One of the promises that\n// suspended it has resolved, which means at least part of the tree was\n// likely unblocked. Try rendering again, at a new lanes.\nif(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid\n// unnecessary entanglement?\nretryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?\nvar eventTime=requestEventTime();var root=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default\nvar retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\nretryCache.delete(wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;error('Maximum update depth exceeded. This can happen when a component '+\"calls setState inside useEffect, but useEffect either doesn't \"+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n// Maybe not a big deal since this is DEV only behavior.\nsetCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nvar current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else{if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else{current=subtreeRoot=current.return;}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.\nreturn;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.\nreturn;}// We show the whole stack but dedupe on the top component's name because\n// the problematic code almost always lies inside that component.\nvar componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else{didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error(\"Can't perform a React state update on a component that hasn't mounted yet. \"+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously\n// dispatched event, so that the debugger will treat it as an uncaught\n// error See ReactErrorUtils for more information.\n// Before entering the begin phase, copy the work-in-progress onto a dummy\n// fiber. If beginWork throws, we'll use this to reset the state.\nvar originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(didSuspendOrErrorWhileHydratingDEV()||originalError!==null&&typeof originalError==='object'&&typeof originalError.then==='function'){// Don't replay promises.\n// Don't replay errors if we are hydrating and have already suspended or handled an error\nthrow originalError;}// Keep this code in sync with handleError; any changes here must have\n// corresponding changes there.\nresetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the\n// same fiber again.\n// Unwind the failed stack frame\nunwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.\nassignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.\nstartProfilerTimer(unitOfWork);}// Run beginWork again.\ninvokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(typeof replayError==='object'&&replayError!==null&&replayError._suppressLogging&&typeof originalError==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\noriginalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.\n// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\nthrow originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.\nvar dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.\n// Those may still be relevant to the current commit\n// and a future one (e.g. Suspense).\n}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to\n// the `act` queue instead.\nvar actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else{return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.\nreturn cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.\nreturn ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}}else{// Legacy mode has additional cases where we suppress a warning.\nif(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.\n// batchedUpdates or flushSync.\nreturn;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only\n// warns for updates that originate from a hook.\nreturn;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\\n\\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\\n\\n'+'act(() => {\\n'+'  /* fire events that update state */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\\n\\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\\n\\n'+'act(() => {\\n'+'  /* finish loading suspended data */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}function setIsRunningInsertionEffect(isRunning){{isRunningInsertionEffect=isRunning;}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.\nvar failedBoundaries=null;var setRefreshHandler=function(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.\nreturn family.current;}}function resolveClassForHotReloading(type){// No implementation differences.\nreturn resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.\nif(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,\n// but it's possible that we only have its inner render function in the map.\n// If that inner render function is different, we'll build a new forwardRef type.\nvar currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.\nreturn family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.\nvar needsCompareFamilies=false;var $$typeofNextType=typeof nextType==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.\n// We're going to assume that the lazy inner type is stable,\n// and so it is sufficient to avoid reconciling it away.\n// We're not going to unwrap or actually use the new lazy type.\nneedsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,\n// we shouldn't set this.\nneedsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.\nif(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.\n// This means both of them need to be registered to preserve state.\n// If we unwrapped and compared the inner types for wrappers instead,\n// then we would risk falsely saying two separate memo(Foo)\n// calls are equivalent because they wrap the same Foo function.\nvar prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function(root,update){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context\n// but we don't know the parentComponent so we can't pass it.\n// Just ignore. We'll delete this with _renderSubtree code path later.\nreturn;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else{needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){var _root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(_root!==null){scheduleUpdateOnFiber(_root,fiber,SyncLane,NoTimestamp);}}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.\n// There's no need to search deeper because for the purpose of giving\n// visual feedback, \"flashing\" outermost parent rectangles is sufficient.\nfindHostInstancesForFiberShallowly(fiber,hostInstances);}else{// If there's no match, maybe there will be one further down in the child tree.\nif(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.\nvar node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node.return===null){throw new Error('Expected to reach root first.');}node=node.return;}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.\nfoundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.\n}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node.return===null||node.return===fiber){return foundHostInstances;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills\nhasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance\nthis.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber\nthis.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects\nthis.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.\n//\n// Initializing the fields below to smis and later updating them with\n// double values will cause Fibers to end up having separate shapes.\n// This behavior/bug has something to do with Object.preventExtension().\n// Fortunately this only impacts DEV builds.\n// Unfortunately it makes React unusably slow for some applications.\n// To work around this, initialize the fields below with doubles.\n//\n// Learn more about this here:\n// https://github.com/facebook/react/issues/14365\n// https://bugs.chromium.org/p/v8/issues/detail?id=8538\nthis.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.\n// This won't trigger the performance cliff mentioned above,\n// and it simplifies other profiler code (including DevTools).\nthis.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:\nthis._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber=function(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\nreturn new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll\n// only ever need at most two versions of a tree. We pool the \"other\" unused\n// node that we're free to reuse. This is lazily created to avoid allocating\n// extra objects for things that are never updated. It also allow us to\n// reclaim the extra memory if needed.\nworkInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields\nworkInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// We already have an alternate.\n// Reset the effect tag.\nworkInProgress.flags=NoFlags;// The effects are no longer valid.\nworkInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.\n// This prevents time from endlessly accumulating in new commits.\n// This has the downside of resetting values for different priority renders,\n// But works for yielding (the common case) and should support resuming.\nworkInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.\n// Static effects are not specific to a render.\nworkInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation\nworkInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.\nfunction resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would\n// have set the values to before during the first pass. Ideally this wouldn't\n// be necessary but unfortunately many code paths reads from the workInProgress\n// when they should be reading from current and writing to workInProgress.\n// We assume pendingProps, index, key, ref, return are still untouched to\n// avoid doing another reconciliation.\n// Reset the effect flags but keep any Placement tags, since that's something\n// that child fiber is setting, not the reconciliation.\nworkInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.\nvar current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.\nworkInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else{// Reset to the cloned values that createWorkInProgress would've.\nworkInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else{mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.\n// This enables DevTools to start capturing timing at any point\n// Without some nodes in the tree having empty base times.\nmode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType\nkey,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.\nvar resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else{{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots\nmode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough\ndefault:{if(typeof type==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer\nfiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||typeof type==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+\"it's defined in, or you might have mixed up default and \"+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+(\"but got: \"+(type==null?type:typeof type)+\".\"+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.',typeof pendingProps.id);}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={isHidden:false};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates\nimplementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.\n// We only use a Fiber to ensure the same hidden class so DEV isn't slow.\ntarget=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.\n// We tried to use Object.assign() instead but this is called in\n// the hottest path, and Object.assign() was too slow:\n// https://github.com/facebook/react/issues/12502\n// This code is DEV-only so size is not a concern.\ntarget.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.\nvar uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet\ntransitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.2.0';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.\nimplementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return{// This tag allow us to uniquely identify this as a React Portal\n$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else{var keys=Object.keys(component).join(',');throw new Error(\"Argument appears to not be a ReactComponent. Keys: \"+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else{error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in\n// render and there's another warning for that anyway.\nif(previousFiber){setCurrentFiber(previousFiber);}else{resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.\ncallback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor\nroot.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from\n// a regular update because the initial render must match was was rendered\n// on the server.\n// NOTE: This update intentionally doesn't have a payload. We're only using\n// the update to schedule work on the root fiber (and, for legacy roots, to\n// enqueue the callback if one is provided).\nvar current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update,lane);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\\n\\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}var root=enqueueUpdate(current$1,update,lane);if(root!==null){scheduleUpdateOnFiber(root,current$1,lane,eventTime);entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:{var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled \"update\".\nvar lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;}case SuspenseComponent:{flushSync(function(){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,SyncLane,eventTime);}});// If we're still blocked after this, we need to increase\n// the priority of any promises resolving within this\n// boundary so that they next attempt also has higher pri.\nvar retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.\nfunction markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority and they should not suspend on I/O,\n// since you have to wrap anything that might suspend in\n// Suspense.\nreturn;}var lane=SelectiveHydrationLane;var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority other than synchronously flush it.\nreturn;}var lane=requestUpdateLane(fiber);var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var copyWithDeleteImpl=function(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else{delete updated[key];}return updated;}// $FlowFixMe number or string is fine here\nupdated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function(obj,path){return copyWithDeleteImpl(obj,path,0);};var copyWithRenameImpl=function(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here\nupdated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else{delete updated[oldKey];}}else{// $FlowFixMe number or string is fine here\nupdated[oldKey]=copyWithRenameImpl(// $FlowFixMe number or string is fine here\nobj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else{for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return copyWithRenameImpl(obj,oldPath,newPath,0);};var copyWithSetImpl=function(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here\nupdated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function(obj,path,value){return copyWithSetImpl(obj,path,0,value);};var findHook=function(fiber,id){// For now, the \"id\" of stateful hooks is just the stateful hook index.\n// This may change in the future with e.g. nested hooks.\nvar currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.\noverrideHookState=function(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateDeletePath=function(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateRenamePath=function(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};// Support DevTools props for function components, forwardRef, memo, host components, etc.\noverrideProps=function(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsDeletePath=function(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsRenamePath=function(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};scheduleUpdate=function(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};setErrorHandler=function(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh\nfindHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.\ngetCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version\n// which may not match for third party renderers.\nreconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,\n// emulating an uncaught JavaScript error.\nreportError:function(error){// In older browsers and test environments, fallback to console.error.\n// eslint-disable-next-line react-internal/no-production-logging\nconsole['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+\"You don't need to pass it again since you already passed it to create the root.\");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+\"root.unmount() to empty a root's container.\");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;var transitionCallbacks=null;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else{if(typeof options==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\\n\\n'+'  let root = createRoot(domContainer);\\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){transitionCallbacks=options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain\n// the hydration callbacks.\nvar hydrationCallbacks=options!=null?options:null;// TODO: Delete this option\nvar mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.\nlistenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.\n// We only use it in places that are currently more relaxed.\nfunction isValidContainerLegacy(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else{error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the\n// legacy API.\n}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else{// First clear any existing content.\nvar rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.\nflushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount\nroot=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else{root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update\nupdateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?\nreturn legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+\"the createRoot API, your app will behave as if it's running React \"+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}function unmountComponentAtNode(container){if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by another copy of React.');}}// Unmount should not be batched.\nflushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`\ncontainer._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll\n// get `true` twice. That's probably fine?\nreturn true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.\nvar isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype\nMap.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype\nSet.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument\n// $FlowFixMe The Flow type is opaque but there's no way to actually create it.\nreturn createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.\n// This is an array for better minification.\nEvents:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing createRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing hydrateRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.\nif(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.\nif(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging\nconsole.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;exports.createPortal=createPortal$1;exports.createRoot=createRoot$1;exports.findDOMNode=findDOMNode;exports.flushSync=flushSync$1;exports.hydrate=hydrate;exports.hydrateRoot=hydrateRoot$1;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.unstable_batchedUpdates=batchedUpdates$1;exports.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;exports.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcz85ZjYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovJ3VzZSBzdHJpY3QnO2lmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09XCJwcm9kdWN0aW9uXCIpeyhmdW5jdGlvbigpeyd1c2Ugc3RyaWN0JzsvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovaWYodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydD09PSdmdW5jdGlvbicpe19fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO312YXIgUmVhY3Q9cmVxdWlyZSgncmVhY3QnKTt2YXIgU2NoZWR1bGVyPXJlcXVpcmUoJ3NjaGVkdWxlcicpO3ZhciBSZWFjdFNoYXJlZEludGVybmFscz1SZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDt2YXIgc3VwcHJlc3NXYXJuaW5nPWZhbHNlO2Z1bmN0aW9uIHNldFN1cHByZXNzV2FybmluZyhuZXdTdXBwcmVzc1dhcm5pbmcpe3tzdXBwcmVzc1dhcm5pbmc9bmV3U3VwcHJlc3NXYXJuaW5nO319Ly8gSW4gREVWLCBjYWxscyB0byBjb25zb2xlLndhcm4gYW5kIGNvbnNvbGUuZXJyb3IgZ2V0IHJlcGxhY2VkXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCl7e2lmKCFzdXBwcmVzc1dhcm5pbmcpe2Zvcih2YXIgX2xlbj1hcmd1bWVudHMubGVuZ3RoLGFyZ3M9bmV3IEFycmF5KF9sZW4+MT9fbGVuLTE6MCksX2tleT0xO19rZXk8X2xlbjtfa2V5Kyspe2FyZ3NbX2tleS0xXT1hcmd1bWVudHNbX2tleV07fXByaW50V2FybmluZygnd2FybicsZm9ybWF0LGFyZ3MpO319fWZ1bmN0aW9uIGVycm9yKGZvcm1hdCl7e2lmKCFzdXBwcmVzc1dhcm5pbmcpe2Zvcih2YXIgX2xlbjI9YXJndW1lbnRzLmxlbmd0aCxhcmdzPW5ldyBBcnJheShfbGVuMj4xP19sZW4yLTE6MCksX2tleTI9MTtfa2V5MjxfbGVuMjtfa2V5MisrKXthcmdzW19rZXkyLTFdPWFyZ3VtZW50c1tfa2V5Ml07fXByaW50V2FybmluZygnZXJyb3InLGZvcm1hdCxhcmdzKTt9fX1mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsZm9ybWF0LGFyZ3Mpey8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG57dmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWU9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTt2YXIgc3RhY2s9UmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7aWYoc3RhY2shPT0nJyl7Zm9ybWF0Kz0nJXMnO2FyZ3M9YXJncy5jb25jYXQoW3N0YWNrXSk7fS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxudmFyIGFyZ3NXaXRoRm9ybWF0PWFyZ3MubWFwKGZ1bmN0aW9uKGl0ZW0pe3JldHVybiBTdHJpbmcoaXRlbSk7fSk7Ly8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcbmFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcrZm9ybWF0KTsvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sY29uc29sZSxhcmdzV2l0aEZvcm1hdCk7fX12YXIgRnVuY3Rpb25Db21wb25lbnQ9MDt2YXIgQ2xhc3NDb21wb25lbnQ9MTt2YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudD0yOy8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb24gb3IgY2xhc3NcbnZhciBIb3N0Um9vdD0zOy8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxudmFyIEhvc3RQb3J0YWw9NDsvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxudmFyIEhvc3RDb21wb25lbnQ9NTt2YXIgSG9zdFRleHQ9Njt2YXIgRnJhZ21lbnQ9Nzt2YXIgTW9kZT04O3ZhciBDb250ZXh0Q29uc3VtZXI9OTt2YXIgQ29udGV4dFByb3ZpZGVyPTEwO3ZhciBGb3J3YXJkUmVmPTExO3ZhciBQcm9maWxlcj0xMjt2YXIgU3VzcGVuc2VDb21wb25lbnQ9MTM7dmFyIE1lbW9Db21wb25lbnQ9MTQ7dmFyIFNpbXBsZU1lbW9Db21wb25lbnQ9MTU7dmFyIExhenlDb21wb25lbnQ9MTY7dmFyIEluY29tcGxldGVDbGFzc0NvbXBvbmVudD0xNzt2YXIgRGVoeWRyYXRlZEZyYWdtZW50PTE4O3ZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQ9MTk7dmFyIFNjb3BlQ29tcG9uZW50PTIxO3ZhciBPZmZzY3JlZW5Db21wb25lbnQ9MjI7dmFyIExlZ2FjeUhpZGRlbkNvbXBvbmVudD0yMzt2YXIgQ2FjaGVDb21wb25lbnQ9MjQ7dmFyIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ9MjU7Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBlbmFibGVDbGllbnRSZW5kZXJGYWxsYmFja09uVGV4dE1pc21hdGNoPXRydWU7Ly8gVE9ETzogTmVlZCB0byByZXZpZXcgdGhpcyBjb2RlIG9uZSBtb3JlIHRpbWUgYmVmb3JlIGxhbmRpbmdcbi8vIHRoZSByZWFjdC1yZWNvbmNpbGVyIHBhY2thZ2UuXG52YXIgZW5hYmxlTmV3UmVjb25jaWxlcj1mYWxzZTsvLyBTdXBwb3J0IGxlZ2FjeSBQcmltZXIgc3VwcG9ydCBvbiBpbnRlcm5hbCBGQiB3d3dcbnZhciBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uPWZhbHNlOy8vIEZCLW9ubHkgdXNhZ2UuIFRoZSBuZXcgQVBJIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzLlxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbj1mYWxzZTsvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbnZhciBlbmFibGVTdXNwZW5zZUF2b2lkVGhpc0ZhbGxiYWNrPWZhbHNlOy8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaXp6XG4vLyBSZWFjdCBET00gQ2hvcHBpbmcgQmxvY2tcbi8vXG4vLyBTaW1pbGFyIHRvIG1haW4gQ2hvcHBpbmcgQmxvY2sgYnV0IG9ubHkgZmxhZ3MgcmVsYXRlZCB0byBSZWFjdCBET00uIFRoZXNlIGFyZVxuLy8gZ3JvdXBlZCBiZWNhdXNlIHdlIHdpbGwgbGlrZWx5IGJhdGNoIGFsbCBvZiB0aGVtIGludG8gYSBzaW5nbGUgbWFqb3IgcmVsZWFzZS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEaXNhYmxlIHN1cHBvcnQgZm9yIGNvbW1lbnQgbm9kZXMgYXMgUmVhY3QgRE9NIGNvbnRhaW5lcnMuIEFscmVhZHkgZGlzYWJsZWRcbi8vIGluIG9wZW4gc291cmNlLCBidXQgd3d3IGNvZGViYXNlIHN0aWxsIHJlbGllcyBvbiBpdC4gTmVlZCB0byByZW1vdmUuXG52YXIgZGlzYWJsZUNvbW1lbnRzQXNET01Db250YWluZXJzPXRydWU7Ly8gRGlzYWJsZSBqYXZhc2NyaXB0OiBVUkwgc3RyaW5ncyBpbiBocmVmIGZvciBYU1MgcHJvdGVjdGlvbi5cbi8vIGFuZCBjbGllbnQgcmVuZGVyaW5nLCBtb3N0bHkgdG8gYWxsb3cgSlNYIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGN1c3RvbVxuLy8gZWxlbWVudCdzIG9iamVjdCBwcm9wZXJ0aWVzIGluc3RlYWQgb2Ygb25seSBIVE1MIGF0dHJpYnV0ZXMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExMzQ3XG52YXIgZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydD1mYWxzZTsvLyBEaXNhYmxlcyBjaGlsZHJlbiBmb3IgPHRleHRhcmVhPiBlbGVtZW50c1xudmFyIHdhcm5BYm91dFN0cmluZ1JlZnM9ZmFsc2U7Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlYnVnZ2luZyBhbmQgRGV2VG9vbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGRzIHVzZXIgdGltaW5nIG1hcmtzIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wIHN0dWZmLFxuLy8gZm9yIGFuIGV4cGVyaW1lbnRhbCB0aW1lbGluZSB0b29sLlxudmFyIGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcj10cnVlOy8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiByZW5kZXItcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZVxudmFyIGVuYWJsZVByb2ZpbGVyVGltZXI9dHJ1ZTsvLyBSZWNvcmQgZHVyYXRpb25zIGZvciBjb21taXQgYW5kIHBhc3NpdmUgZWZmZWN0cyBwaGFzZXMuXG52YXIgZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcz10cnVlOy8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG52YXIgYWxsTmF0aXZlRXZlbnRzPW5ldyBTZXQoKTsvKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi92YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcz17fTsvKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL3ZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzPXt9Oy8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5mdW5jdGlvbiByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSxkZXBlbmRlbmNpZXMpe3JlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSxkZXBlbmRlbmNpZXMpO3JlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSsnQ2FwdHVyZScsZGVwZW5kZW5jaWVzKTt9ZnVuY3Rpb24gcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLGRlcGVuZGVuY2llcyl7e2lmKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0pe2Vycm9yKCdFdmVudFJlZ2lzdHJ5OiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnKydyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLHJlZ2lzdHJhdGlvbk5hbWUpO319cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXT1kZXBlbmRlbmNpZXM7e3ZhciBsb3dlckNhc2VkTmFtZT1yZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7cG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV09cmVnaXN0cmF0aW9uTmFtZTtpZihyZWdpc3RyYXRpb25OYW1lPT09J29uRG91YmxlQ2xpY2snKXtwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2s9cmVnaXN0cmF0aW9uTmFtZTt9fWZvcih2YXIgaT0wO2k8ZGVwZW5kZW5jaWVzLmxlbmd0aDtpKyspe2FsbE5hdGl2ZUV2ZW50cy5hZGQoZGVwZW5kZW5jaWVzW2ldKTt9fXZhciBjYW5Vc2VET009ISEodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnJiZ0eXBlb2Ygd2luZG93LmRvY3VtZW50IT09J3VuZGVmaW5lZCcmJnR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCE9PSd1bmRlZmluZWQnKTt2YXIgaGFzT3duUHJvcGVydHk9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsvKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqLyAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpe3svLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG52YXIgaGFzVG9TdHJpbmdUYWc9dHlwZW9mIFN5bWJvbD09PSdmdW5jdGlvbicmJlN5bWJvbC50b1N0cmluZ1RhZzt2YXIgdHlwZT1oYXNUb1N0cmluZ1RhZyYmdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXXx8dmFsdWUuY29uc3RydWN0b3IubmFtZXx8J09iamVjdCc7cmV0dXJuIHR5cGU7fX0vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpe3t0cnl7dGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtyZXR1cm4gZmFsc2U7fWNhdGNoKGUpe3JldHVybiB0cnVlO319fWZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSl7Ly8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4vLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4vL1xuLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4vLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4vLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbi8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbi8vXG4vLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4vLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4vL1xuLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbi8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbi8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbi8vXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbnJldHVybicnK3ZhbHVlO31mdW5jdGlvbiBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLGF0dHJpYnV0ZU5hbWUpe3tpZih3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpe2Vycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBhdHRyaWJ1dGUgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nKycgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsYXR0cmlidXRlTmFtZSx0eXBlTmFtZSh2YWx1ZSkpO3JldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOy8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG59fX1mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKXt7aWYod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKXtlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicrJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJyx0eXBlTmFtZSh2YWx1ZSkpO3JldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOy8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG59fX1mdW5jdGlvbiBjaGVja1Byb3BTdHJpbmdDb2VyY2lvbih2YWx1ZSxwcm9wTmFtZSl7e2lmKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSl7ZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIHByb3AgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nKycgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicscHJvcE5hbWUsdHlwZU5hbWUodmFsdWUpKTtyZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxufX19ZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLHByb3BOYW1lKXt7aWYod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKXtlcnJvcignVGhlIHByb3ZpZGVkIGAlc2AgQ1NTIHByb3BlcnR5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJysnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLHByb3BOYW1lLHR5cGVOYW1lKHZhbHVlKSk7cmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7Ly8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbn19fWZ1bmN0aW9uIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHZhbHVlKXt7aWYod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKXtlcnJvcignVGhlIHByb3ZpZGVkIEhUTUwgbWFya3VwIHVzZXMgYSB2YWx1ZSBvZiB1bnN1cHBvcnRlZCB0eXBlICVzLicrJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJyx0eXBlTmFtZSh2YWx1ZSkpO3JldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOy8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG59fX1mdW5jdGlvbiBjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpe3tpZih3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpe2Vycm9yKCdGb3JtIGZpZWxkIHZhbHVlcyAodmFsdWUsIGNoZWNrZWQsIGRlZmF1bHRWYWx1ZSwgb3IgZGVmYXVsdENoZWNrZWQgcHJvcHMpJysnIG11c3QgYmUgc3RyaW5ncywgbm90ICVzLicrJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJyx0eXBlTmFtZSh2YWx1ZSkpO3JldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOy8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG59fX0vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRD0wOy8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxudmFyIFNUUklORz0xOy8vIEEgc3RyaW5nIGF0dHJpYnV0ZSB0aGF0IGFjY2VwdHMgYm9vbGVhbnMgaW4gUmVhY3QuIEluIEhUTUwsIHRoZXNlIGFyZSBjYWxsZWRcbi8vIFwiZW51bWVyYXRlZFwiIGF0dHJpYnV0ZXMgd2l0aCBcInRydWVcIiBhbmQgXCJmYWxzZVwiIGFzIHBvc3NpYmxlIHZhbHVlcy5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwidHJ1ZVwiIHN0cmluZy5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcImZhbHNlXCIgc3RyaW5nLlxudmFyIEJPT0xFQU5JU0hfU1RSSU5HPTI7Ly8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG52YXIgQk9PTEVBTj0zOy8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxudmFyIE9WRVJMT0FERURfQk9PTEVBTj00Oy8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbnZhciBOVU1FUklDPTU7Ly8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxudmFyIFBPU0lUSVZFX05VTUVSSUM9NjsvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovdmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI9XCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovdmFyIEFUVFJJQlVURV9OQU1FX0NIQVI9QVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUitcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7dmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYPW5ldyBSZWdFeHAoJ15bJytBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSKyddWycrQVRUUklCVVRFX05BTUVfQ0hBUisnXSokJyk7dmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGU9e307dmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZT17fTtmdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpe2lmKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLGF0dHJpYnV0ZU5hbWUpKXtyZXR1cm4gdHJ1ZTt9aWYoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLGF0dHJpYnV0ZU5hbWUpKXtyZXR1cm4gZmFsc2U7fWlmKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpe3ZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXT10cnVlO3JldHVybiB0cnVlO31pbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdPXRydWU7e2Vycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJyxhdHRyaWJ1dGVOYW1lKTt9cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpe2lmKHByb3BlcnR5SW5mbyE9PW51bGwpe3JldHVybiBwcm9wZXJ0eUluZm8udHlwZT09PVJFU0VSVkVEO31pZihpc0N1c3RvbUNvbXBvbmVudFRhZyl7cmV0dXJuIGZhbHNlO31pZihuYW1lLmxlbmd0aD4yJiYobmFtZVswXT09PSdvJ3x8bmFtZVswXT09PSdPJykmJihuYW1lWzFdPT09J24nfHxuYW1lWzFdPT09J04nKSl7cmV0dXJuIHRydWU7fXJldHVybiBmYWxzZTt9ZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSx2YWx1ZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpe2lmKHByb3BlcnR5SW5mbyE9PW51bGwmJnByb3BlcnR5SW5mby50eXBlPT09UkVTRVJWRUQpe3JldHVybiBmYWxzZTt9c3dpdGNoKHR5cGVvZiB2YWx1ZSl7Y2FzZSdmdW5jdGlvbic6Ly8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcbmNhc2Unc3ltYm9sJzovLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5yZXR1cm4gdHJ1ZTtjYXNlJ2Jvb2xlYW4nOntpZihpc0N1c3RvbUNvbXBvbmVudFRhZyl7cmV0dXJuIGZhbHNlO31pZihwcm9wZXJ0eUluZm8hPT1udWxsKXtyZXR1cm4hcHJvcGVydHlJbmZvLmFjY2VwdHNCb29sZWFuczt9ZWxzZXt2YXIgcHJlZml4PW5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLDUpO3JldHVybiBwcmVmaXghPT0nZGF0YS0nJiZwcmVmaXghPT0nYXJpYS0nO319ZGVmYXVsdDpyZXR1cm4gZmFsc2U7fX1mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSx2YWx1ZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpe2lmKHZhbHVlPT09bnVsbHx8dHlwZW9mIHZhbHVlPT09J3VuZGVmaW5lZCcpe3JldHVybiB0cnVlO31pZihzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLHZhbHVlLHByb3BlcnR5SW5mbyxpc0N1c3RvbUNvbXBvbmVudFRhZykpe3JldHVybiB0cnVlO31pZihpc0N1c3RvbUNvbXBvbmVudFRhZyl7cmV0dXJuIGZhbHNlO31pZihwcm9wZXJ0eUluZm8hPT1udWxsKXtzd2l0Y2gocHJvcGVydHlJbmZvLnR5cGUpe2Nhc2UgQk9PTEVBTjpyZXR1cm4hdmFsdWU7Y2FzZSBPVkVSTE9BREVEX0JPT0xFQU46cmV0dXJuIHZhbHVlPT09ZmFsc2U7Y2FzZSBOVU1FUklDOnJldHVybiBpc05hTih2YWx1ZSk7Y2FzZSBQT1NJVElWRV9OVU1FUklDOnJldHVybiBpc05hTih2YWx1ZSl8fHZhbHVlPDE7fX1yZXR1cm4gZmFsc2U7fWZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKXtyZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKT9wcm9wZXJ0aWVzW25hbWVdOm51bGw7fWZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLHR5cGUsbXVzdFVzZVByb3BlcnR5LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlTmFtZXNwYWNlLHNhbml0aXplVVJMLHJlbW92ZUVtcHR5U3RyaW5nKXt0aGlzLmFjY2VwdHNCb29sZWFucz10eXBlPT09Qk9PTEVBTklTSF9TVFJJTkd8fHR5cGU9PT1CT09MRUFOfHx0eXBlPT09T1ZFUkxPQURFRF9CT09MRUFOO3RoaXMuYXR0cmlidXRlTmFtZT1hdHRyaWJ1dGVOYW1lO3RoaXMuYXR0cmlidXRlTmFtZXNwYWNlPWF0dHJpYnV0ZU5hbWVzcGFjZTt0aGlzLm11c3RVc2VQcm9wZXJ0eT1tdXN0VXNlUHJvcGVydHk7dGhpcy5wcm9wZXJ0eU5hbWU9bmFtZTt0aGlzLnR5cGU9dHlwZTt0aGlzLnNhbml0aXplVVJMPXNhbml0aXplVVJMO3RoaXMucmVtb3ZlRW1wdHlTdHJpbmc9cmVtb3ZlRW1wdHlTdHJpbmc7fS8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbi8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4vLyBuYW1lIHdhcm5pbmdzLlxudmFyIHByb3BlcnRpZXM9e307Ly8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgcmVzZXJ2ZWRQcm9wcz1bJ2NoaWxkcmVuJywnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsJ2RlZmF1bHRDaGVja2VkJywnaW5uZXJIVE1MJywnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywnc3R5bGUnXTtyZXNlcnZlZFByb3BzLmZvckVhY2goZnVuY3Rpb24obmFtZSl7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsUkVTRVJWRUQsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5uYW1lLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIEEgZmV3IFJlYWN0IHN0cmluZyBhdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbi8vIFRoaXMgaXMgYSBtYXBwaW5nIGZyb20gUmVhY3QgcHJvcCBuYW1lcyB0byB0aGUgYXR0cmlidXRlIG5hbWVzLlxuW1snYWNjZXB0Q2hhcnNldCcsJ2FjY2VwdC1jaGFyc2V0J10sWydjbGFzc05hbWUnLCdjbGFzcyddLFsnaHRtbEZvcicsJ2ZvciddLFsnaHR0cEVxdWl2JywnaHR0cC1lcXVpdiddXS5mb3JFYWNoKGZ1bmN0aW9uKF9yZWYpe3ZhciBuYW1lPV9yZWZbMF0sYXR0cmlidXRlTmFtZT1fcmVmWzFdO3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLFNUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbmF0dHJpYnV0ZU5hbWUsLy8gYXR0cmlidXRlTmFtZVxubnVsbCwvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbmZhbHNlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7fSk7Ly8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblsnY29udGVudEVkaXRhYmxlJywnZHJhZ2dhYmxlJywnc3BlbGxDaGVjaycsJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxCT09MRUFOSVNIX1NUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbm5hbWUudG9Mb3dlckNhc2UoKSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5bJ2F1dG9SZXZlcnNlJywnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsJ2ZvY3VzYWJsZScsJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLEJPT0xFQU5JU0hfU1RSSU5HLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxubmFtZSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5bJ2FsbG93RnVsbFNjcmVlbicsJ2FzeW5jJywvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4vLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4nYXV0b0ZvY3VzJywnYXV0b1BsYXknLCdjb250cm9scycsJ2RlZmF1bHQnLCdkZWZlcicsJ2Rpc2FibGVkJywnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLCdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCdmb3JtTm9WYWxpZGF0ZScsJ2hpZGRlbicsJ2xvb3AnLCdub01vZHVsZScsJ25vVmFsaWRhdGUnLCdvcGVuJywncGxheXNJbmxpbmUnLCdyZWFkT25seScsJ3JlcXVpcmVkJywncmV2ZXJzZWQnLCdzY29wZWQnLCdzZWFtbGVzcycsLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxCT09MRUFOLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxubmFtZS50b0xvd2VyQ2FzZSgpLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuWydjaGVja2VkJywvLyBOb3RlOiBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC4gV2UgaGF2ZSBzcGVjaWFsIGxvZ2ljIGZvciBoYW5kbGluZyB0aGlzLlxuJ211bHRpcGxlJywnbXV0ZWQnLCdzZWxlY3RlZCcvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxCT09MRUFOLHRydWUsLy8gbXVzdFVzZVByb3BlcnR5XG5uYW1lLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuWydjYXB0dXJlJywnZG93bmxvYWQnLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSl7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsT1ZFUkxPQURFRF9CT09MRUFOLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxubmFtZSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuWydjb2xzJywncm93cycsJ3NpemUnLCdzcGFuJy8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLFBPU0lUSVZFX05VTUVSSUMsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5uYW1lLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5bJ3Jvd1NwYW4nLCdzdGFydCddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsTlVNRVJJQyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbm5hbWUudG9Mb3dlckNhc2UoKSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTt2YXIgQ0FNRUxJWkU9L1tcXC1cXDpdKFthLXpdKS9nO3ZhciBjYXBpdGFsaXplPWZ1bmN0aW9uKHRva2VuKXtyZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTt9Oy8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIGF0dHJpYnV0ZSBmaWx0ZXIuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5bJ2FjY2VudC1oZWlnaHQnLCdhbGlnbm1lbnQtYmFzZWxpbmUnLCdhcmFiaWMtZm9ybScsJ2Jhc2VsaW5lLXNoaWZ0JywnY2FwLWhlaWdodCcsJ2NsaXAtcGF0aCcsJ2NsaXAtcnVsZScsJ2NvbG9yLWludGVycG9sYXRpb24nLCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCdjb2xvci1wcm9maWxlJywnY29sb3ItcmVuZGVyaW5nJywnZG9taW5hbnQtYmFzZWxpbmUnLCdlbmFibGUtYmFja2dyb3VuZCcsJ2ZpbGwtb3BhY2l0eScsJ2ZpbGwtcnVsZScsJ2Zsb29kLWNvbG9yJywnZmxvb2Qtb3BhY2l0eScsJ2ZvbnQtZmFtaWx5JywnZm9udC1zaXplJywnZm9udC1zaXplLWFkanVzdCcsJ2ZvbnQtc3RyZXRjaCcsJ2ZvbnQtc3R5bGUnLCdmb250LXZhcmlhbnQnLCdmb250LXdlaWdodCcsJ2dseXBoLW5hbWUnLCdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCdob3Jpei1hZHYteCcsJ2hvcml6LW9yaWdpbi14JywnaW1hZ2UtcmVuZGVyaW5nJywnbGV0dGVyLXNwYWNpbmcnLCdsaWdodGluZy1jb2xvcicsJ21hcmtlci1lbmQnLCdtYXJrZXItbWlkJywnbWFya2VyLXN0YXJ0Jywnb3ZlcmxpbmUtcG9zaXRpb24nLCdvdmVybGluZS10aGlja25lc3MnLCdwYWludC1vcmRlcicsJ3Bhbm9zZS0xJywncG9pbnRlci1ldmVudHMnLCdyZW5kZXJpbmctaW50ZW50Jywnc2hhcGUtcmVuZGVyaW5nJywnc3RvcC1jb2xvcicsJ3N0b3Atb3BhY2l0eScsJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsJ3N0cm9rZS1kYXNoYXJyYXknLCdzdHJva2UtZGFzaG9mZnNldCcsJ3N0cm9rZS1saW5lY2FwJywnc3Ryb2tlLWxpbmVqb2luJywnc3Ryb2tlLW1pdGVybGltaXQnLCdzdHJva2Utb3BhY2l0eScsJ3N0cm9rZS13aWR0aCcsJ3RleHQtYW5jaG9yJywndGV4dC1kZWNvcmF0aW9uJywndGV4dC1yZW5kZXJpbmcnLCd1bmRlcmxpbmUtcG9zaXRpb24nLCd1bmRlcmxpbmUtdGhpY2tuZXNzJywndW5pY29kZS1iaWRpJywndW5pY29kZS1yYW5nZScsJ3VuaXRzLXBlci1lbScsJ3YtYWxwaGFiZXRpYycsJ3YtaGFuZ2luZycsJ3YtaWRlb2dyYXBoaWMnLCd2LW1hdGhlbWF0aWNhbCcsJ3ZlY3Rvci1lZmZlY3QnLCd2ZXJ0LWFkdi15JywndmVydC1vcmlnaW4teCcsJ3ZlcnQtb3JpZ2luLXknLCd3b3JkLXNwYWNpbmcnLCd3cml0aW5nLW1vZGUnLCd4bWxuczp4bGluaycsJ3gtaGVpZ2h0Jy8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUpe3ZhciBuYW1lPWF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSxjYXBpdGFsaXplKTtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxTVFJJTkcsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5hdHRyaWJ1dGVOYW1lLG51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5bJ3hsaW5rOmFjdHVhdGUnLCd4bGluazphcmNyb2xlJywneGxpbms6cm9sZScsJ3hsaW5rOnNob3cnLCd4bGluazp0aXRsZScsJ3hsaW5rOnR5cGUnLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlTmFtZSl7dmFyIG5hbWU9YXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLGNhcGl0YWxpemUpO3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLFNUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbmF0dHJpYnV0ZU5hbWUsJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLGZhbHNlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7fSk7Ly8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5bJ3htbDpiYXNlJywneG1sOmxhbmcnLCd4bWw6c3BhY2UnLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlTmFtZSl7dmFyIG5hbWU9YXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLGNhcGl0YWxpemUpO3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLFNUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbmF0dHJpYnV0ZU5hbWUsJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblsndGFiSW5kZXgnLCdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlTmFtZSl7cHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsU1RSSU5HLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxuYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFRoZXNlIGF0dHJpYnV0ZXMgYWNjZXB0IFVSTHMuIFRoZXNlIG11c3Qgbm90IGFsbG93IGphdmFzY3JpcHQ6IFVSTFMuXG4vLyBUaGVzZSB3aWxsIGFsc28gbmVlZCB0byBhY2NlcHQgVHJ1c3RlZCBUeXBlcyBvYmplY3QgaW4gdGhlIGZ1dHVyZS5cbnZhciB4bGlua0hyZWY9J3hsaW5rSHJlZic7cHJvcGVydGllc1t4bGlua0hyZWZdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsU1RSSU5HLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyx0cnVlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7WydzcmMnLCdocmVmJywnYWN0aW9uJywnZm9ybUFjdGlvbiddLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlTmFtZSl7cHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsU1RSSU5HLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxuYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG50cnVlLC8vIHNhbml0aXplVVJMXG50cnVlKTt9KTsvLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2Vcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi92YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2w9L15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO3ZhciBkaWRXYXJuPWZhbHNlO2Z1bmN0aW9uIHNhbml0aXplVVJMKHVybCl7e2lmKCFkaWRXYXJuJiZpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpe2RpZFdhcm49dHJ1ZTtlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnKydVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJysndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLEpTT04uc3RyaW5naWZ5KHVybCkpO319fS8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovZnVuY3Rpb24gZ2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLG5hbWUsZXhwZWN0ZWQscHJvcGVydHlJbmZvKXt7aWYocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSl7dmFyIHByb3BlcnR5TmFtZT1wcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO3JldHVybiBub2RlW3Byb3BlcnR5TmFtZV07fWVsc2V7Ly8gVGhpcyBjaGVjayBwcm90ZWN0cyBtdWx0aXBsZSB1c2VzIG9mIGBleHBlY3RlZGAsIHdoaWNoIGlzIHdoeSB0aGVcbi8vIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uIHJ1bGUgaXMgZGlzYWJsZWQgaW4gc2V2ZXJhbCBzcG90c1xuLy8gYmVsb3cuXG57Y2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihleHBlY3RlZCxuYW1lKTt9aWYocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKXsvLyBJZiB3ZSBoYXZlbid0IGZ1bGx5IGRpc2FibGVkIGphdmFzY3JpcHQ6IFVSTHMsIGFuZCBpZlxuLy8gdGhlIGh5ZHJhdGlvbiBpcyBzdWNjZXNzZnVsIG9mIGEgamF2YXNjcmlwdDogVVJMLCB3ZVxuLy8gc3RpbGwgd2FudCB0byB3YXJuIG9uIHRoZSBjbGllbnQuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbnNhbml0aXplVVJMKCcnK2V4cGVjdGVkKTt9dmFyIGF0dHJpYnV0ZU5hbWU9cHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7dmFyIHN0cmluZ1ZhbHVlPW51bGw7aWYocHJvcGVydHlJbmZvLnR5cGU9PT1PVkVSTE9BREVEX0JPT0xFQU4pe2lmKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKXt2YXIgdmFsdWU9bm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7aWYodmFsdWU9PT0nJyl7cmV0dXJuIHRydWU7fWlmKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLGV4cGVjdGVkLHByb3BlcnR5SW5mbyxmYWxzZSkpe3JldHVybiB2YWx1ZTt9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5pZih2YWx1ZT09PScnK2V4cGVjdGVkKXtyZXR1cm4gZXhwZWN0ZWQ7fXJldHVybiB2YWx1ZTt9fWVsc2UgaWYobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpe2lmKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLGV4cGVjdGVkLHByb3BlcnR5SW5mbyxmYWxzZSkpey8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbi8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbnJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTt9aWYocHJvcGVydHlJbmZvLnR5cGU9PT1CT09MRUFOKXsvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4vLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxucmV0dXJuIGV4cGVjdGVkO30vLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4vLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4vLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4vLyBpbiBvdXIgY29uZmlnIGF0bS5cbnN0cmluZ1ZhbHVlPW5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO31pZihzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSxleHBlY3RlZCxwcm9wZXJ0eUluZm8sZmFsc2UpKXtyZXR1cm4gc3RyaW5nVmFsdWU9PT1udWxsP2V4cGVjdGVkOnN0cmluZ1ZhbHVlOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxufWVsc2UgaWYoc3RyaW5nVmFsdWU9PT0nJytleHBlY3RlZCl7cmV0dXJuIGV4cGVjdGVkO31lbHNle3JldHVybiBzdHJpbmdWYWx1ZTt9fX19LyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLG5hbWUsZXhwZWN0ZWQsaXNDdXN0b21Db21wb25lbnRUYWcpe3tpZighaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSl7cmV0dXJuO31pZighbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpe3JldHVybiBleHBlY3RlZD09PXVuZGVmaW5lZD91bmRlZmluZWQ6bnVsbDt9dmFyIHZhbHVlPW5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO3tjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGV4cGVjdGVkLG5hbWUpO31pZih2YWx1ZT09PScnK2V4cGVjdGVkKXtyZXR1cm4gZXhwZWN0ZWQ7fXJldHVybiB2YWx1ZTt9fS8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL2Z1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSxuYW1lLHZhbHVlLGlzQ3VzdG9tQ29tcG9uZW50VGFnKXt2YXIgcHJvcGVydHlJbmZvPWdldFByb3BlcnR5SW5mbyhuYW1lKTtpZihzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpKXtyZXR1cm47fWlmKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLHZhbHVlLHByb3BlcnR5SW5mbyxpc0N1c3RvbUNvbXBvbmVudFRhZykpe3ZhbHVlPW51bGw7fWlmKGlzQ3VzdG9tQ29tcG9uZW50VGFnfHxwcm9wZXJ0eUluZm89PT1udWxsKXtpZihpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKXt2YXIgX2F0dHJpYnV0ZU5hbWU9bmFtZTtpZih2YWx1ZT09PW51bGwpe25vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lKTt9ZWxzZXt7Y2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSxuYW1lKTt9bm9kZS5zZXRBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUsJycrdmFsdWUpO319cmV0dXJuO312YXIgbXVzdFVzZVByb3BlcnR5PXByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7aWYobXVzdFVzZVByb3BlcnR5KXt2YXIgcHJvcGVydHlOYW1lPXByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7aWYodmFsdWU9PT1udWxsKXt2YXIgdHlwZT1wcm9wZXJ0eUluZm8udHlwZTtub2RlW3Byb3BlcnR5TmFtZV09dHlwZT09PUJPT0xFQU4/ZmFsc2U6Jyc7fWVsc2V7Ly8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85Llxubm9kZVtwcm9wZXJ0eU5hbWVdPXZhbHVlO31yZXR1cm47fS8vIFRoZSByZXN0IGFyZSB0cmVhdGVkIGFzIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGNhc2VzLlxudmFyIGF0dHJpYnV0ZU5hbWU9cHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlTmFtZXNwYWNlPXByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7aWYodmFsdWU9PT1udWxsKXtub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTt9ZWxzZXt2YXIgX3R5cGU9cHJvcGVydHlJbmZvLnR5cGU7dmFyIGF0dHJpYnV0ZVZhbHVlO2lmKF90eXBlPT09Qk9PTEVBTnx8X3R5cGU9PT1PVkVSTE9BREVEX0JPT0xFQU4mJnZhbHVlPT09dHJ1ZSl7Ly8gSWYgYXR0cmlidXRlIHR5cGUgaXMgYm9vbGVhbiwgd2Uga25vdyBmb3Igc3VyZSBpdCB3b24ndCBiZSBhbiBleGVjdXRpb24gc2lua1xuLy8gYW5kIHdlIHdvbid0IHJlcXVpcmUgVHJ1c3RlZCBUeXBlIGhlcmUuXG5hdHRyaWJ1dGVWYWx1ZT0nJzt9ZWxzZXsvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4vLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG57e2NoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsYXR0cmlidXRlTmFtZSk7fWF0dHJpYnV0ZVZhbHVlPScnK3ZhbHVlO31pZihwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpe3Nhbml0aXplVVJMKGF0dHJpYnV0ZVZhbHVlLnRvU3RyaW5nKCkpO319aWYoYXR0cmlidXRlTmFtZXNwYWNlKXtub2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJpYnV0ZU5hbWVzcGFjZSxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVZhbHVlKTt9ZWxzZXtub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVZhbHVlKTt9fX0vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7dmFyIFJFQUNUX1BPUlRBTF9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO3ZhciBSRUFDVF9GUkFHTUVOVF9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7dmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU9U3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTt2YXIgUkVBQ1RfUFJPRklMRVJfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO3ZhciBSRUFDVF9QUk9WSURFUl9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7dmFyIFJFQUNUX0NPTlRFWFRfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7dmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU9U3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTt2YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO3ZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU9U3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO3ZhciBSRUFDVF9NRU1PX1RZUEU9U3ltYm9sLmZvcigncmVhY3QubWVtbycpO3ZhciBSRUFDVF9MQVpZX1RZUEU9U3ltYm9sLmZvcigncmVhY3QubGF6eScpO3ZhciBSRUFDVF9TQ09QRV9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7dmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTt2YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU9U3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7dmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7dmFyIFJFQUNUX0NBQ0hFX1RZUEU9U3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTt2YXIgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC50cmFjaW5nX21hcmtlcicpO3ZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0w9U3ltYm9sLml0ZXJhdG9yO3ZhciBGQVVYX0lURVJBVE9SX1NZTUJPTD0nQEBpdGVyYXRvcic7ZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKXtpZihtYXliZUl0ZXJhYmxlPT09bnVsbHx8dHlwZW9mIG1heWJlSXRlcmFibGUhPT0nb2JqZWN0Jyl7cmV0dXJuIG51bGw7fXZhciBtYXliZUl0ZXJhdG9yPU1BWUJFX0lURVJBVE9SX1NZTUJPTCYmbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdfHxtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtpZih0eXBlb2YgbWF5YmVJdGVyYXRvcj09PSdmdW5jdGlvbicpe3JldHVybiBtYXliZUl0ZXJhdG9yO31yZXR1cm4gbnVsbDt9dmFyIGFzc2lnbj1PYmplY3QuYXNzaWduOy8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoPTA7dmFyIHByZXZMb2c7dmFyIHByZXZJbmZvO3ZhciBwcmV2V2Fybjt2YXIgcHJldkVycm9yO3ZhciBwcmV2R3JvdXA7dmFyIHByZXZHcm91cENvbGxhcHNlZDt2YXIgcHJldkdyb3VwRW5kO2Z1bmN0aW9uIGRpc2FibGVkTG9nKCl7fWRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZz10cnVlO2Z1bmN0aW9uIGRpc2FibGVMb2dzKCl7e2lmKGRpc2FibGVkRGVwdGg9PT0wKXsvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9wcmV2TG9nPWNvbnNvbGUubG9nO3ByZXZJbmZvPWNvbnNvbGUuaW5mbztwcmV2V2Fybj1jb25zb2xlLndhcm47cHJldkVycm9yPWNvbnNvbGUuZXJyb3I7cHJldkdyb3VwPWNvbnNvbGUuZ3JvdXA7cHJldkdyb3VwQ29sbGFwc2VkPWNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7cHJldkdyb3VwRW5kPWNvbnNvbGUuZ3JvdXBFbmQ7Ly8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxudmFyIHByb3BzPXtjb25maWd1cmFibGU6dHJ1ZSxlbnVtZXJhYmxlOnRydWUsdmFsdWU6ZGlzYWJsZWRMb2csd3JpdGFibGU6dHJ1ZX07Ly8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUse2luZm86cHJvcHMsbG9nOnByb3BzLHdhcm46cHJvcHMsZXJyb3I6cHJvcHMsZ3JvdXA6cHJvcHMsZ3JvdXBDb2xsYXBzZWQ6cHJvcHMsZ3JvdXBFbmQ6cHJvcHN9KTsvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL31kaXNhYmxlZERlcHRoKys7fX1mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKXt7ZGlzYWJsZWREZXB0aC0tO2lmKGRpc2FibGVkRGVwdGg9PT0wKXsvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi92YXIgcHJvcHM9e2NvbmZpZ3VyYWJsZTp0cnVlLGVudW1lcmFibGU6dHJ1ZSx3cml0YWJsZTp0cnVlfTsvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSx7bG9nOmFzc2lnbih7fSxwcm9wcyx7dmFsdWU6cHJldkxvZ30pLGluZm86YXNzaWduKHt9LHByb3BzLHt2YWx1ZTpwcmV2SW5mb30pLHdhcm46YXNzaWduKHt9LHByb3BzLHt2YWx1ZTpwcmV2V2Fybn0pLGVycm9yOmFzc2lnbih7fSxwcm9wcyx7dmFsdWU6cHJldkVycm9yfSksZ3JvdXA6YXNzaWduKHt9LHByb3BzLHt2YWx1ZTpwcmV2R3JvdXB9KSxncm91cENvbGxhcHNlZDphc3NpZ24oe30scHJvcHMse3ZhbHVlOnByZXZHcm91cENvbGxhcHNlZH0pLGdyb3VwRW5kOmFzc2lnbih7fSxwcm9wcyx7dmFsdWU6cHJldkdyb3VwRW5kfSl9KTsvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL31pZihkaXNhYmxlZERlcHRoPDApe2Vycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJysnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX19dmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXI9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjt2YXIgcHJlZml4O2Z1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsc291cmNlLG93bmVyRm4pe3tpZihwcmVmaXg9PT11bmRlZmluZWQpey8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbnRyeXt0aHJvdyBFcnJvcigpO31jYXRjaCh4KXt2YXIgbWF0Y2g9eC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtwcmVmaXg9bWF0Y2gmJm1hdGNoWzFdfHwnJzt9fS8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxucmV0dXJuJ1xcbicrcHJlZml4K25hbWU7fX12YXIgcmVlbnRyeT1mYWxzZTt2YXIgY29tcG9uZW50RnJhbWVDYWNoZTt7dmFyIFBvc3NpYmx5V2Vha01hcD10eXBlb2YgV2Vha01hcD09PSdmdW5jdGlvbic/V2Vha01hcDpNYXA7Y29tcG9uZW50RnJhbWVDYWNoZT1uZXcgUG9zc2libHlXZWFrTWFwKCk7fWZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sY29uc3RydWN0KXsvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbmlmKCFmbnx8cmVlbnRyeSl7cmV0dXJuJyc7fXt2YXIgZnJhbWU9Y29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO2lmKGZyYW1lIT09dW5kZWZpbmVkKXtyZXR1cm4gZnJhbWU7fX12YXIgY29udHJvbDtyZWVudHJ5PXRydWU7dmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U9RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7Ly8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5FcnJvci5wcmVwYXJlU3RhY2tUcmFjZT11bmRlZmluZWQ7dmFyIHByZXZpb3VzRGlzcGF0Y2hlcjt7cHJldmlvdXNEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbi8vIGZvciB3YXJuaW5ncy5cblJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudD1udWxsO2Rpc2FibGVMb2dzKCk7fXRyeXsvLyBUaGlzIHNob3VsZCB0aHJvdy5cbmlmKGNvbnN0cnVjdCl7Ly8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG52YXIgRmFrZT1mdW5jdGlvbigpe3Rocm93IEVycm9yKCk7fTsvLyAkRmxvd0ZpeE1lXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsJ3Byb3BzJyx7c2V0OmZ1bmN0aW9uKCl7Ly8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxudGhyb3cgRXJyb3IoKTt9fSk7aWYodHlwZW9mIFJlZmxlY3Q9PT0nb2JqZWN0JyYmUmVmbGVjdC5jb25zdHJ1Y3Qpey8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbi8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG50cnl7UmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSxbXSk7fWNhdGNoKHgpe2NvbnRyb2w9eDt9UmVmbGVjdC5jb25zdHJ1Y3QoZm4sW10sRmFrZSk7fWVsc2V7dHJ5e0Zha2UuY2FsbCgpO31jYXRjaCh4KXtjb250cm9sPXg7fWZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO319ZWxzZXt0cnl7dGhyb3cgRXJyb3IoKTt9Y2F0Y2goeCl7Y29udHJvbD14O31mbigpO319Y2F0Y2goc2FtcGxlKXsvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuaWYoc2FtcGxlJiZjb250cm9sJiZ0eXBlb2Ygc2FtcGxlLnN0YWNrPT09J3N0cmluZycpey8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4vLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbnZhciBzYW1wbGVMaW5lcz1zYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO3ZhciBjb250cm9sTGluZXM9Y29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7dmFyIHM9c2FtcGxlTGluZXMubGVuZ3RoLTE7dmFyIGM9Y29udHJvbExpbmVzLmxlbmd0aC0xO3doaWxlKHM+PTEmJmM+PTAmJnNhbXBsZUxpbmVzW3NdIT09Y29udHJvbExpbmVzW2NdKXsvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbi8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbi8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4vLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbi8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuYy0tO31mb3IoO3M+PTEmJmM+PTA7cy0tLGMtLSl7Ly8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4vLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbmlmKHNhbXBsZUxpbmVzW3NdIT09Y29udHJvbExpbmVzW2NdKXsvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbi8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbi8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG5pZihzIT09MXx8YyE9PTEpe2Rve3MtLTtjLS07Ly8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5pZihjPDB8fHNhbXBsZUxpbmVzW3NdIT09Y29udHJvbExpbmVzW2NdKXsvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbnZhciBfZnJhbWU9J1xcbicrc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCcgYXQgJyk7Ly8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5pZihmbi5kaXNwbGF5TmFtZSYmX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKXtfZnJhbWU9X2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+Jyxmbi5kaXNwbGF5TmFtZSk7fXtpZih0eXBlb2YgZm49PT0nZnVuY3Rpb24nKXtjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbixfZnJhbWUpO319Ly8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxucmV0dXJuIF9mcmFtZTt9fXdoaWxlKHM+PTEmJmM+PTApO31icmVhazt9fX19ZmluYWxseXtyZWVudHJ5PWZhbHNlO3tSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ9cHJldmlvdXNEaXNwYXRjaGVyO3JlZW5hYmxlTG9ncygpO31FcnJvci5wcmVwYXJlU3RhY2tUcmFjZT1wcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO30vLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG52YXIgbmFtZT1mbj9mbi5kaXNwbGF5TmFtZXx8Zm4ubmFtZTonJzt2YXIgc3ludGhldGljRnJhbWU9bmFtZT9kZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKTonJzt7aWYodHlwZW9mIGZuPT09J2Z1bmN0aW9uJyl7Y29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sc3ludGhldGljRnJhbWUpO319cmV0dXJuIHN5bnRoZXRpY0ZyYW1lO31mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvcixzb3VyY2Usb3duZXJGbil7e3JldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGN0b3IsdHJ1ZSk7fX1mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sc291cmNlLG93bmVyRm4pe3tyZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbixmYWxzZSk7fX1mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KXt2YXIgcHJvdG90eXBlPUNvbXBvbmVudC5wcm90b3R5cGU7cmV0dXJuISEocHJvdG90eXBlJiZwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7fWZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLHNvdXJjZSxvd25lckZuKXtpZih0eXBlPT1udWxsKXtyZXR1cm4nJzt9aWYodHlwZW9mIHR5cGU9PT0nZnVuY3Rpb24nKXt7cmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSxzaG91bGRDb25zdHJ1Y3QodHlwZSkpO319aWYodHlwZW9mIHR5cGU9PT0nc3RyaW5nJyl7cmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO31zd2l0Y2godHlwZSl7Y2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOnJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpyZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO31pZih0eXBlb2YgdHlwZT09PSdvYmplY3QnKXtzd2l0Y2godHlwZS4kJHR5cGVvZil7Y2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOnJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO2Nhc2UgUkVBQ1RfTUVNT19UWVBFOi8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG5yZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSxzb3VyY2Usb3duZXJGbik7Y2FzZSBSRUFDVF9MQVpZX1RZUEU6e3ZhciBsYXp5Q29tcG9uZW50PXR5cGU7dmFyIHBheWxvYWQ9bGF6eUNvbXBvbmVudC5fcGF5bG9hZDt2YXIgaW5pdD1sYXp5Q29tcG9uZW50Ll9pbml0O3RyeXsvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxucmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLHNvdXJjZSxvd25lckZuKTt9Y2F0Y2goeCl7fX19fXJldHVybicnO31mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKXt2YXIgb3duZXI9ZmliZXIuX2RlYnVnT3duZXI/ZmliZXIuX2RlYnVnT3duZXIudHlwZTpudWxsO3ZhciBzb3VyY2U9ZmliZXIuX2RlYnVnU291cmNlO3N3aXRjaChmaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDpyZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7Y2FzZSBMYXp5Q29tcG9uZW50OnJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO2Nhc2UgU3VzcGVuc2VDb21wb25lbnQ6cmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO2Nhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OnJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OnJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7Y2FzZSBGb3J3YXJkUmVmOnJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZS5yZW5kZXIpO2Nhc2UgQ2xhc3NDb21wb25lbnQ6cmV0dXJuIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShmaWJlci50eXBlKTtkZWZhdWx0OnJldHVybicnO319ZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKXt0cnl7dmFyIGluZm89Jyc7dmFyIG5vZGU9d29ya0luUHJvZ3Jlc3M7ZG97aW5mbys9ZGVzY3JpYmVGaWJlcihub2RlKTtub2RlPW5vZGUucmV0dXJuO313aGlsZShub2RlKTtyZXR1cm4gaW5mbzt9Y2F0Y2goeCl7cmV0dXJuJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcreC5tZXNzYWdlKydcXG4nK3guc3RhY2s7fX1mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsaW5uZXJUeXBlLHdyYXBwZXJOYW1lKXt2YXIgZGlzcGxheU5hbWU9b3V0ZXJUeXBlLmRpc3BsYXlOYW1lO2lmKGRpc3BsYXlOYW1lKXtyZXR1cm4gZGlzcGxheU5hbWU7fXZhciBmdW5jdGlvbk5hbWU9aW5uZXJUeXBlLmRpc3BsYXlOYW1lfHxpbm5lclR5cGUubmFtZXx8Jyc7cmV0dXJuIGZ1bmN0aW9uTmFtZSE9PScnP3dyYXBwZXJOYW1lK1wiKFwiK2Z1bmN0aW9uTmFtZStcIilcIjp3cmFwcGVyTmFtZTt9Ly8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKXtyZXR1cm4gdHlwZS5kaXNwbGF5TmFtZXx8J0NvbnRleHQnO30vLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSl7aWYodHlwZT09bnVsbCl7Ly8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG5yZXR1cm4gbnVsbDt9e2lmKHR5cGVvZiB0eXBlLnRhZz09PSdudW1iZXInKXtlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcrJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fWlmKHR5cGVvZiB0eXBlPT09J2Z1bmN0aW9uJyl7cmV0dXJuIHR5cGUuZGlzcGxheU5hbWV8fHR5cGUubmFtZXx8bnVsbDt9aWYodHlwZW9mIHR5cGU9PT0nc3RyaW5nJyl7cmV0dXJuIHR5cGU7fXN3aXRjaCh0eXBlKXtjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6cmV0dXJuJ0ZyYWdtZW50JztjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOnJldHVybidQb3J0YWwnO2Nhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpyZXR1cm4nUHJvZmlsZXInO2Nhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpyZXR1cm4nU3RyaWN0TW9kZSc7Y2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOnJldHVybidTdXNwZW5zZSc7Y2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6cmV0dXJuJ1N1c3BlbnNlTGlzdCc7fWlmKHR5cGVvZiB0eXBlPT09J29iamVjdCcpe3N3aXRjaCh0eXBlLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTp2YXIgY29udGV4dD10eXBlO3JldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSsnLkNvbnN1bWVyJztjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6dmFyIHByb3ZpZGVyPXR5cGU7cmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSsnLlByb3ZpZGVyJztjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6cmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsdHlwZS5yZW5kZXIsJ0ZvcndhcmRSZWYnKTtjYXNlIFJFQUNUX01FTU9fVFlQRTp2YXIgb3V0ZXJOYW1lPXR5cGUuZGlzcGxheU5hbWV8fG51bGw7aWYob3V0ZXJOYW1lIT09bnVsbCl7cmV0dXJuIG91dGVyTmFtZTt9cmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpfHwnTWVtbyc7Y2FzZSBSRUFDVF9MQVpZX1RZUEU6e3ZhciBsYXp5Q29tcG9uZW50PXR5cGU7dmFyIHBheWxvYWQ9bGF6eUNvbXBvbmVudC5fcGF5bG9hZDt2YXIgaW5pdD1sYXp5Q29tcG9uZW50Ll9pbml0O3RyeXtyZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO31jYXRjaCh4KXtyZXR1cm4gbnVsbDt9fS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxufX1yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUkMShvdXRlclR5cGUsaW5uZXJUeXBlLHdyYXBwZXJOYW1lKXt2YXIgZnVuY3Rpb25OYW1lPWlubmVyVHlwZS5kaXNwbGF5TmFtZXx8aW5uZXJUeXBlLm5hbWV8fCcnO3JldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWV8fChmdW5jdGlvbk5hbWUhPT0nJz93cmFwcGVyTmFtZStcIihcIitmdW5jdGlvbk5hbWUrXCIpXCI6d3JhcHBlck5hbWUpO30vLyBLZWVwIGluIHN5bmMgd2l0aCBzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSQxKHR5cGUpe3JldHVybiB0eXBlLmRpc3BsYXlOYW1lfHwnQ29udGV4dCc7fWZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpe3ZhciB0YWc9ZmliZXIudGFnLHR5cGU9ZmliZXIudHlwZTtzd2l0Y2godGFnKXtjYXNlIENhY2hlQ29tcG9uZW50OnJldHVybidDYWNoZSc7Y2FzZSBDb250ZXh0Q29uc3VtZXI6dmFyIGNvbnRleHQ9dHlwZTtyZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShjb250ZXh0KSsnLkNvbnN1bWVyJztjYXNlIENvbnRleHRQcm92aWRlcjp2YXIgcHJvdmlkZXI9dHlwZTtyZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShwcm92aWRlci5fY29udGV4dCkrJy5Qcm92aWRlcic7Y2FzZSBEZWh5ZHJhdGVkRnJhZ21lbnQ6cmV0dXJuJ0RlaHlkcmF0ZWRGcmFnbWVudCc7Y2FzZSBGb3J3YXJkUmVmOnJldHVybiBnZXRXcmFwcGVkTmFtZSQxKHR5cGUsdHlwZS5yZW5kZXIsJ0ZvcndhcmRSZWYnKTtjYXNlIEZyYWdtZW50OnJldHVybidGcmFnbWVudCc7Y2FzZSBIb3N0Q29tcG9uZW50Oi8vIEhvc3QgY29tcG9uZW50IHR5cGUgaXMgdGhlIGRpc3BsYXkgbmFtZSAoZS5nLiBcImRpdlwiLCBcIlZpZXdcIilcbnJldHVybiB0eXBlO2Nhc2UgSG9zdFBvcnRhbDpyZXR1cm4nUG9ydGFsJztjYXNlIEhvc3RSb290OnJldHVybidSb290JztjYXNlIEhvc3RUZXh0OnJldHVybidUZXh0JztjYXNlIExhenlDb21wb25lbnQ6Ly8gTmFtZSBjb21lcyBmcm9tIHRoZSB0eXBlIGluIHRoaXMgY2FzZTsgd2UgZG9uJ3QgaGF2ZSBhIHRhZy5cbnJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7Y2FzZSBNb2RlOmlmKHR5cGU9PT1SRUFDVF9TVFJJQ1RfTU9ERV9UWVBFKXsvLyBEb24ndCBiZSBsZXNzIHNwZWNpZmljIHRoYW4gc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxucmV0dXJuJ1N0cmljdE1vZGUnO31yZXR1cm4nTW9kZSc7Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6cmV0dXJuJ09mZnNjcmVlbic7Y2FzZSBQcm9maWxlcjpyZXR1cm4nUHJvZmlsZXInO2Nhc2UgU2NvcGVDb21wb25lbnQ6cmV0dXJuJ1Njb3BlJztjYXNlIFN1c3BlbnNlQ29tcG9uZW50OnJldHVybidTdXNwZW5zZSc7Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6cmV0dXJuJ1N1c3BlbnNlTGlzdCc7Y2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OnJldHVybidUcmFjaW5nTWFya2VyJzsvLyBUaGUgZGlzcGxheSBuYW1lIGZvciB0aGlzIHRhZ3MgY29tZSBmcm9tIHRoZSB1c2VyLXByb3ZpZGVkIHR5cGU6XG5jYXNlIENsYXNzQ29tcG9uZW50OmNhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6Y2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OmNhc2UgTWVtb0NvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6aWYodHlwZW9mIHR5cGU9PT0nZnVuY3Rpb24nKXtyZXR1cm4gdHlwZS5kaXNwbGF5TmFtZXx8dHlwZS5uYW1lfHxudWxsO31pZih0eXBlb2YgdHlwZT09PSdzdHJpbmcnKXtyZXR1cm4gdHlwZTt9YnJlYWs7fXJldHVybiBudWxsO312YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZT1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO3ZhciBjdXJyZW50PW51bGw7dmFyIGlzUmVuZGVyaW5nPWZhbHNlO2Z1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCl7e2lmKGN1cnJlbnQ9PT1udWxsKXtyZXR1cm4gbnVsbDt9dmFyIG93bmVyPWN1cnJlbnQuX2RlYnVnT3duZXI7aWYob3duZXIhPT1udWxsJiZ0eXBlb2Ygb3duZXIhPT0ndW5kZWZpbmVkJyl7cmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpO319cmV0dXJuIG51bGw7fWZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKXt7aWYoY3VycmVudD09PW51bGwpe3JldHVybicnO30vLyBTYWZlIGJlY2F1c2UgaWYgY3VycmVudCBmaWJlciBleGlzdHMsIHdlIGFyZSByZWNvbmNpbGluZyxcbi8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG5yZXR1cm4gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO319ZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKXt7UmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s9bnVsbDtjdXJyZW50PW51bGw7aXNSZW5kZXJpbmc9ZmFsc2U7fX1mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpe3tSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaz1maWJlcj09PW51bGw/bnVsbDpnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O2N1cnJlbnQ9ZmliZXI7aXNSZW5kZXJpbmc9ZmFsc2U7fX1mdW5jdGlvbiBnZXRDdXJyZW50RmliZXIoKXt7cmV0dXJuIGN1cnJlbnQ7fX1mdW5jdGlvbiBzZXRJc1JlbmRlcmluZyhyZW5kZXJpbmcpe3tpc1JlbmRlcmluZz1yZW5kZXJpbmc7fX0vLyBGbG93IGRvZXMgbm90IGFsbG93IHN0cmluZyBjb25jYXRlbmF0aW9uIG9mIG1vc3Qgbm9uLXN0cmluZyB0eXBlcy4gVG8gd29ya1xuLy8gYXJvdW5kIHRoaXMgbGltaXRhdGlvbiwgd2UgdXNlIGFuIG9wYXF1ZSB0eXBlIHRoYXQgY2FuIG9ubHkgYmUgb2J0YWluZWQgYnlcbi8vIHBhc3NpbmcgdGhlIHZhbHVlIHRocm91Z2ggZ2V0VG9TdHJpbmdWYWx1ZSBmaXJzdC5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKXsvLyBUaGUgY29lcmNpb24gc2FmZXR5IGNoZWNrIGlzIHBlcmZvcm1lZCBpbiBnZXRUb1N0cmluZ1ZhbHVlKCkuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbnJldHVybicnK3ZhbHVlO31mdW5jdGlvbiBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKXtzd2l0Y2godHlwZW9mIHZhbHVlKXtjYXNlJ2Jvb2xlYW4nOmNhc2UnbnVtYmVyJzpjYXNlJ3N0cmluZyc6Y2FzZSd1bmRlZmluZWQnOnJldHVybiB2YWx1ZTtjYXNlJ29iamVjdCc6e2NoZWNrRm9ybUZpZWxkVmFsdWVTdHJpbmdDb2VyY2lvbih2YWx1ZSk7fXJldHVybiB2YWx1ZTtkZWZhdWx0Oi8vIGZ1bmN0aW9uLCBzeW1ib2wgYXJlIGFzc2lnbmVkIGFzIGVtcHR5IHN0cmluZ3NcbnJldHVybicnO319dmFyIGhhc1JlYWRPbmx5VmFsdWU9e2J1dHRvbjp0cnVlLGNoZWNrYm94OnRydWUsaW1hZ2U6dHJ1ZSxoaWRkZW46dHJ1ZSxyYWRpbzp0cnVlLHJlc2V0OnRydWUsc3VibWl0OnRydWV9O2Z1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSxwcm9wcyl7e2lmKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXXx8cHJvcHMub25DaGFuZ2V8fHByb3BzLm9uSW5wdXR8fHByb3BzLnJlYWRPbmx5fHxwcm9wcy5kaXNhYmxlZHx8cHJvcHMudmFsdWU9PW51bGwpKXtlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcrJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJysndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnKydzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTt9aWYoIShwcm9wcy5vbkNoYW5nZXx8cHJvcHMucmVhZE9ubHl8fHByb3BzLmRpc2FibGVkfHxwcm9wcy5jaGVja2VkPT1udWxsKSl7ZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcrJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJysndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcrJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO319fWZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pe3ZhciB0eXBlPWVsZW0udHlwZTt2YXIgbm9kZU5hbWU9ZWxlbS5ub2RlTmFtZTtyZXR1cm4gbm9kZU5hbWUmJm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT0naW5wdXQnJiYodHlwZT09PSdjaGVja2JveCd8fHR5cGU9PT0ncmFkaW8nKTt9ZnVuY3Rpb24gZ2V0VHJhY2tlcihub2RlKXtyZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO31mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpe25vZGUuX3ZhbHVlVHJhY2tlcj1udWxsO31mdW5jdGlvbiBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpe3ZhciB2YWx1ZT0nJztpZighbm9kZSl7cmV0dXJuIHZhbHVlO31pZihpc0NoZWNrYWJsZShub2RlKSl7dmFsdWU9bm9kZS5jaGVja2VkPyd0cnVlJzonZmFsc2UnO31lbHNle3ZhbHVlPW5vZGUudmFsdWU7fXJldHVybiB2YWx1ZTt9ZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKXt2YXIgdmFsdWVGaWVsZD1pc0NoZWNrYWJsZShub2RlKT8nY2hlY2tlZCc6J3ZhbHVlJzt2YXIgZGVzY3JpcHRvcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLHZhbHVlRmllbGQpO3tjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24obm9kZVt2YWx1ZUZpZWxkXSk7fXZhciBjdXJyZW50VmFsdWU9Jycrbm9kZVt2YWx1ZUZpZWxkXTsvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbi8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4vLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG5pZihub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpfHx0eXBlb2YgZGVzY3JpcHRvcj09PSd1bmRlZmluZWQnfHx0eXBlb2YgZGVzY3JpcHRvci5nZXQhPT0nZnVuY3Rpb24nfHx0eXBlb2YgZGVzY3JpcHRvci5zZXQhPT0nZnVuY3Rpb24nKXtyZXR1cm47fXZhciBnZXQ9ZGVzY3JpcHRvci5nZXQsc2V0PWRlc2NyaXB0b3Iuc2V0O09iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLHZhbHVlRmllbGQse2NvbmZpZ3VyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBnZXQuY2FsbCh0aGlzKTt9LHNldDpmdW5jdGlvbih2YWx1ZSl7e2NoZWNrRm9ybUZpZWxkVmFsdWVTdHJpbmdDb2VyY2lvbih2YWx1ZSk7fWN1cnJlbnRWYWx1ZT0nJyt2YWx1ZTtzZXQuY2FsbCh0aGlzLHZhbHVlKTt9fSk7Ly8gV2UgY291bGQndmUgcGFzc2VkIHRoaXMgdGhlIGZpcnN0IHRpbWVcbi8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuLy8gQ2FsbGluZyBkZWZpbmVQcm9wZXJ0eSgpIGFnYWluIHNob3VsZCBiZSBlcXVpdmFsZW50LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTc2OFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsdmFsdWVGaWVsZCx7ZW51bWVyYWJsZTpkZXNjcmlwdG9yLmVudW1lcmFibGV9KTt2YXIgdHJhY2tlcj17Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gY3VycmVudFZhbHVlO30sc2V0VmFsdWU6ZnVuY3Rpb24odmFsdWUpe3tjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpO31jdXJyZW50VmFsdWU9JycrdmFsdWU7fSxzdG9wVHJhY2tpbmc6ZnVuY3Rpb24oKXtkZXRhY2hUcmFja2VyKG5vZGUpO2RlbGV0ZSBub2RlW3ZhbHVlRmllbGRdO319O3JldHVybiB0cmFja2VyO31mdW5jdGlvbiB0cmFjayhub2RlKXtpZihnZXRUcmFja2VyKG5vZGUpKXtyZXR1cm47fS8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG5ub2RlLl92YWx1ZVRyYWNrZXI9dHJhY2tWYWx1ZU9uTm9kZShub2RlKTt9ZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSl7aWYoIW5vZGUpe3JldHVybiBmYWxzZTt9dmFyIHRyYWNrZXI9Z2V0VHJhY2tlcihub2RlKTsvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuLy8gdGhhdCB0cnlpbmcgYWdhaW4gd2lsbCBzdWNjZWVkXG5pZighdHJhY2tlcil7cmV0dXJuIHRydWU7fXZhciBsYXN0VmFsdWU9dHJhY2tlci5nZXRWYWx1ZSgpO3ZhciBuZXh0VmFsdWU9Z2V0VmFsdWVGcm9tTm9kZShub2RlKTtpZihuZXh0VmFsdWUhPT1sYXN0VmFsdWUpe3RyYWNrZXIuc2V0VmFsdWUobmV4dFZhbHVlKTtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYyl7ZG9jPWRvY3x8KHR5cGVvZiBkb2N1bWVudCE9PSd1bmRlZmluZWQnP2RvY3VtZW50OnVuZGVmaW5lZCk7aWYodHlwZW9mIGRvYz09PSd1bmRlZmluZWQnKXtyZXR1cm4gbnVsbDt9dHJ5e3JldHVybiBkb2MuYWN0aXZlRWxlbWVudHx8ZG9jLmJvZHk7fWNhdGNoKGUpe3JldHVybiBkb2MuYm9keTt9fXZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWU9ZmFsc2U7dmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQ9ZmFsc2U7dmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQ9ZmFsc2U7dmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQ9ZmFsc2U7ZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKXt2YXIgdXNlc0NoZWNrZWQ9cHJvcHMudHlwZT09PSdjaGVja2JveCd8fHByb3BzLnR5cGU9PT0ncmFkaW8nO3JldHVybiB1c2VzQ2hlY2tlZD9wcm9wcy5jaGVja2VkIT1udWxsOnByb3BzLnZhbHVlIT1udWxsO30vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9mdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDt2YXIgY2hlY2tlZD1wcm9wcy5jaGVja2VkO3ZhciBob3N0UHJvcHM9YXNzaWduKHt9LHByb3BzLHtkZWZhdWx0Q2hlY2tlZDp1bmRlZmluZWQsZGVmYXVsdFZhbHVlOnVuZGVmaW5lZCx2YWx1ZTp1bmRlZmluZWQsY2hlY2tlZDpjaGVja2VkIT1udWxsP2NoZWNrZWQ6bm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkfSk7cmV0dXJuIGhvc3RQcm9wczt9ZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LHByb3BzKXt7Y2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnaW5wdXQnLHByb3BzKTtpZihwcm9wcy5jaGVja2VkIT09dW5kZWZpbmVkJiZwcm9wcy5kZWZhdWx0Q2hlY2tlZCE9PXVuZGVmaW5lZCYmIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpe2Vycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJysnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJysnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcrJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcrJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKXx8J0EgY29tcG9uZW50Jyxwcm9wcy50eXBlKTtkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkPXRydWU7fWlmKHByb3BzLnZhbHVlIT09dW5kZWZpbmVkJiZwcm9wcy5kZWZhdWx0VmFsdWUhPT11bmRlZmluZWQmJiFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpe2Vycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnKydJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnKycoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnKydib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnKydlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCl8fCdBIGNvbXBvbmVudCcscHJvcHMudHlwZSk7ZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlPXRydWU7fX12YXIgbm9kZT1lbGVtZW50O3ZhciBkZWZhdWx0VmFsdWU9cHJvcHMuZGVmYXVsdFZhbHVlPT1udWxsPycnOnByb3BzLmRlZmF1bHRWYWx1ZTtub2RlLl93cmFwcGVyU3RhdGU9e2luaXRpYWxDaGVja2VkOnByb3BzLmNoZWNrZWQhPW51bGw/cHJvcHMuY2hlY2tlZDpwcm9wcy5kZWZhdWx0Q2hlY2tlZCxpbml0aWFsVmFsdWU6Z2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSE9bnVsbD9wcm9wcy52YWx1ZTpkZWZhdWx0VmFsdWUpLGNvbnRyb2xsZWQ6aXNDb250cm9sbGVkKHByb3BzKX07fWZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDt2YXIgY2hlY2tlZD1wcm9wcy5jaGVja2VkO2lmKGNoZWNrZWQhPW51bGwpe3NldFZhbHVlRm9yUHJvcGVydHkobm9kZSwnY2hlY2tlZCcsY2hlY2tlZCxmYWxzZSk7fX1mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7e3ZhciBjb250cm9sbGVkPWlzQ29udHJvbGxlZChwcm9wcyk7aWYoIW5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkJiZjb250cm9sbGVkJiYhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCl7ZXJyb3IoJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCB0byBiZSBjb250cm9sbGVkLiAnKydUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gdW5kZWZpbmVkIHRvICcrJ2EgZGVmaW5lZCB2YWx1ZSwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uICcrJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJysnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO2RpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQ9dHJ1ZTt9aWYobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQmJiFjb250cm9sbGVkJiYhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCl7ZXJyb3IoJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCB0byBiZSB1bmNvbnRyb2xsZWQuICcrJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0aGUgdmFsdWUgY2hhbmdpbmcgZnJvbSBhIGRlZmluZWQgdG8gJysndW5kZWZpbmVkLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gJysnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnKydlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7ZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZD10cnVlO319dXBkYXRlQ2hlY2tlZChlbGVtZW50LHByb3BzKTt2YXIgdmFsdWU9Z2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7dmFyIHR5cGU9cHJvcHMudHlwZTtpZih2YWx1ZSE9bnVsbCl7aWYodHlwZT09PSdudW1iZXInKXtpZih2YWx1ZT09PTAmJm5vZGUudmFsdWU9PT0nJ3x8Ly8gV2UgZXhwbGljaXRseSB3YW50IHRvIGNvZXJjZSB0byBudW1iZXIgaGVyZSBpZiBwb3NzaWJsZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxubm9kZS52YWx1ZSE9dmFsdWUpe25vZGUudmFsdWU9dG9TdHJpbmcodmFsdWUpO319ZWxzZSBpZihub2RlLnZhbHVlIT09dG9TdHJpbmcodmFsdWUpKXtub2RlLnZhbHVlPXRvU3RyaW5nKHZhbHVlKTt9fWVsc2UgaWYodHlwZT09PSdzdWJtaXQnfHx0eXBlPT09J3Jlc2V0Jyl7Ly8gU3VibWl0L3Jlc2V0IGlucHV0cyBuZWVkIHRoZSBhdHRyaWJ1dGUgcmVtb3ZlZCBjb21wbGV0ZWx5IHRvIGF2b2lkXG4vLyBibGFuay10ZXh0IGJ1dHRvbnMuXG5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtyZXR1cm47fXsvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIGNvbWVzIGZyb20gYSBjYXNjYWRlIG9mXG4vLyBwcm9wZXJ0aWVzOlxuLy8gIDEuIFRoZSB2YWx1ZSBSZWFjdCBwcm9wZXJ0eVxuLy8gIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHlcbi8vICAzLiBPdGhlcndpc2UgdGhlcmUgc2hvdWxkIGJlIG5vIGNoYW5nZVxuaWYocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpe3NldERlZmF1bHRWYWx1ZShub2RlLHByb3BzLnR5cGUsdmFsdWUpO31lbHNlIGlmKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSl7c2V0RGVmYXVsdFZhbHVlKG5vZGUscHJvcHMudHlwZSxnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSkpO319ey8vIFdoZW4gc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIGl0IG9ubHkgY2hhbmdlcyB3aGVuIGl0IG5lZWRzXG4vLyB0byBiZSByZW1vdmVkLCBzdWNoIGFzIHRyYW5zaXRpb25pbmcgZnJvbSBhIGNoZWNrYm94IGludG8gYSB0ZXh0IGlucHV0XG5pZihwcm9wcy5jaGVja2VkPT1udWxsJiZwcm9wcy5kZWZhdWx0Q2hlY2tlZCE9bnVsbCl7bm9kZS5kZWZhdWx0Q2hlY2tlZD0hIXByb3BzLmRlZmF1bHRDaGVja2VkO319fWZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIoZWxlbWVudCxwcm9wcyxpc0h5ZHJhdGluZyl7dmFyIG5vZGU9ZWxlbWVudDsvLyBEbyBub3QgYXNzaWduIHZhbHVlIGlmIGl0IGlzIGFscmVhZHkgc2V0LiBUaGlzIHByZXZlbnRzIHVzZXIgdGV4dCBpbnB1dFxuLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuaWYocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJyl8fHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSl7dmFyIHR5cGU9cHJvcHMudHlwZTt2YXIgaXNCdXR0b249dHlwZT09PSdzdWJtaXQnfHx0eXBlPT09J3Jlc2V0JzsvLyBBdm9pZCBzZXR0aW5nIHZhbHVlIGF0dHJpYnV0ZSBvbiBzdWJtaXQvcmVzZXQgaW5wdXRzIGFzIGl0IG92ZXJyaWRlcyB0aGVcbi8vIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIuIFNlZTogIzEyODcyXG5pZihpc0J1dHRvbiYmKHByb3BzLnZhbHVlPT09dW5kZWZpbmVkfHxwcm9wcy52YWx1ZT09PW51bGwpKXtyZXR1cm47fXZhciBpbml0aWFsVmFsdWU9dG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSk7Ly8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbi8vIGZyb20gYmVpbmcgbG9zdCBkdXJpbmcgU1NSIGh5ZHJhdGlvbi5cbmlmKCFpc0h5ZHJhdGluZyl7ey8vIFdoZW4gc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCB0aGUgdmFsdWUgcHJvcGVydHkgc2hvdWxkIHVzZVxuLy8gdGhlIHdyYXBwZXJTdGF0ZS5faW5pdGlhbFZhbHVlIHByb3BlcnR5LiBUaGlzIHVzZXM6XG4vL1xuLy8gICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4vLyAgIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4vLyAgIDMuIEFuIGVtcHR5IHN0cmluZ1xuaWYoaW5pdGlhbFZhbHVlIT09bm9kZS52YWx1ZSl7bm9kZS52YWx1ZT1pbml0aWFsVmFsdWU7fX19ey8vIE90aGVyd2lzZSwgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBzeW5jaHJvbml6ZWQgdG8gdGhlIHByb3BlcnR5LFxuLy8gc28gd2UgYXNzaWduIGRlZmF1bHRWYWx1ZSB0byB0aGUgc2FtZSB0aGluZyBhcyB0aGUgdmFsdWUgcHJvcGVydHlcbi8vIGFzc2lnbm1lbnQgc3RlcCBhYm92ZS5cbm5vZGUuZGVmYXVsdFZhbHVlPWluaXRpYWxWYWx1ZTt9fS8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4vLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbi8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG52YXIgbmFtZT1ub2RlLm5hbWU7aWYobmFtZSE9PScnKXtub2RlLm5hbWU9Jyc7fXsvLyBXaGVuIHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCBib3RoIHRoZSBjaGVja2VkIHByb3BlcnR5IGFuZFxuLy8gYXR0cmlidXRlIGFyZSBhc3NpZ25lZCBhdCB0aGUgc2FtZSB0aW1lIHVzaW5nIGRlZmF1bHRDaGVja2VkLiBUaGlzIHVzZXM6XG4vL1xuLy8gICAxLiBUaGUgY2hlY2tlZCBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbi8vICAgMi4gVGhlIGRlZmF1bHRDaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuLy8gICAzLiBPdGhlcndpc2UsIGZhbHNlXG5ub2RlLmRlZmF1bHRDaGVja2VkPSFub2RlLmRlZmF1bHRDaGVja2VkO25vZGUuZGVmYXVsdENoZWNrZWQ9ISFub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7fWlmKG5hbWUhPT0nJyl7bm9kZS5uYW1lPW5hbWU7fX1mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7dXBkYXRlV3JhcHBlcihub2RlLHByb3BzKTt1cGRhdGVOYW1lZENvdXNpbnMobm9kZSxwcm9wcyk7fWZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSxwcm9wcyl7dmFyIG5hbWU9cHJvcHMubmFtZTtpZihwcm9wcy50eXBlPT09J3JhZGlvJyYmbmFtZSE9bnVsbCl7dmFyIHF1ZXJ5Um9vdD1yb290Tm9kZTt3aGlsZShxdWVyeVJvb3QucGFyZW50Tm9kZSl7cXVlcnlSb290PXF1ZXJ5Um9vdC5wYXJlbnROb2RlO30vLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4vLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2Vcbi8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuLy8gZG9jdW1lbnQuIExldCdzIGp1c3QgdXNlIHRoZSBsb2NhbCBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0XG4vLyBtaXNzIGFueXRoaW5nLlxue2NoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24obmFtZSwnbmFtZScpO312YXIgZ3JvdXA9cXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JytKU09OLnN0cmluZ2lmeSgnJytuYW1lKSsnXVt0eXBlPVwicmFkaW9cIl0nKTtmb3IodmFyIGk9MDtpPGdyb3VwLmxlbmd0aDtpKyspe3ZhciBvdGhlck5vZGU9Z3JvdXBbaV07aWYob3RoZXJOb2RlPT09cm9vdE5vZGV8fG90aGVyTm9kZS5mb3JtIT09cm9vdE5vZGUuZm9ybSl7Y29udGludWU7fS8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3Rcbi8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4vLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxudmFyIG90aGVyUHJvcHM9Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShvdGhlck5vZGUpO2lmKCFvdGhlclByb3BzKXt0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSAnKydzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpO30vLyBXZSBuZWVkIHVwZGF0ZSB0aGUgdHJhY2tlZCB2YWx1ZSBvbiB0aGUgbmFtZWQgY291c2luIHNpbmNlIHRoZSB2YWx1ZVxuLy8gd2FzIGNoYW5nZWQgYnV0IHRoZSBpbnB1dCBzYXcgbm8gZXZlbnQgb3IgdmFsdWUgc2V0XG51cGRhdGVWYWx1ZUlmQ2hhbmdlZChvdGhlck5vZGUpOy8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbi8vIGFzIGFwcHJvcHJpYXRlLlxudXBkYXRlV3JhcHBlcihvdGhlck5vZGUsb3RoZXJQcm9wcyk7fX19Ly8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbi8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbi8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4vL1xuLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbi8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbmZ1bmN0aW9uIHNldERlZmF1bHRWYWx1ZShub2RlLHR5cGUsdmFsdWUpe2lmKC8vIEZvY3VzZWQgbnVtYmVyIGlucHV0cyBzeW5jaHJvbml6ZSBvbiBibHVyLiBTZWUgQ2hhbmdlRXZlbnRQbHVnaW4uanNcbnR5cGUhPT0nbnVtYmVyJ3x8Z2V0QWN0aXZlRWxlbWVudChub2RlLm93bmVyRG9jdW1lbnQpIT09bm9kZSl7aWYodmFsdWU9PW51bGwpe25vZGUuZGVmYXVsdFZhbHVlPXRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO31lbHNlIGlmKG5vZGUuZGVmYXVsdFZhbHVlIT09dG9TdHJpbmcodmFsdWUpKXtub2RlLmRlZmF1bHRWYWx1ZT10b1N0cmluZyh2YWx1ZSk7fX19dmFyIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uPWZhbHNlO3ZhciBkaWRXYXJuSW52YWxpZENoaWxkPWZhbHNlO3ZhciBkaWRXYXJuSW52YWxpZElubmVySFRNTD1mYWxzZTsvKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LHByb3BzKXt7Ly8gSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZW4gdGhlIGNoaWxkcmVuIG11c3QgYmUgc2ltcGxlLlxuaWYocHJvcHMudmFsdWU9PW51bGwpe2lmKHR5cGVvZiBwcm9wcy5jaGlsZHJlbj09PSdvYmplY3QnJiZwcm9wcy5jaGlsZHJlbiE9PW51bGwpe1JlYWN0LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sZnVuY3Rpb24oY2hpbGQpe2lmKGNoaWxkPT1udWxsKXtyZXR1cm47fWlmKHR5cGVvZiBjaGlsZD09PSdzdHJpbmcnfHx0eXBlb2YgY2hpbGQ9PT0nbnVtYmVyJyl7cmV0dXJuO31pZighZGlkV2FybkludmFsaWRDaGlsZCl7ZGlkV2FybkludmFsaWRDaGlsZD10cnVlO2Vycm9yKCdDYW5ub3QgaW5mZXIgdGhlIG9wdGlvbiB2YWx1ZSBvZiBjb21wbGV4IGNoaWxkcmVuLiAnKydQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi4nKTt9fSk7fWVsc2UgaWYocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwhPW51bGwpe2lmKCFkaWRXYXJuSW52YWxpZElubmVySFRNTCl7ZGlkV2FybkludmFsaWRJbm5lckhUTUw9dHJ1ZTtlcnJvcignUGFzcyBhIGB2YWx1ZWAgcHJvcCBpZiB5b3Ugc2V0IGRhbmdlcm91c2x5SW5uZXJIVE1MIHNvIFJlYWN0IGtub3dzICcrJ3doaWNoIHZhbHVlIHNob3VsZCBiZSBzZWxlY3RlZC4nKTt9fX0vLyBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbmlmKHByb3BzLnNlbGVjdGVkIT1udWxsJiYhZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pe2Vycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnKydzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7ZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb249dHJ1ZTt9fX1mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDEoZWxlbWVudCxwcm9wcyl7Ly8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG5pZihwcm9wcy52YWx1ZSE9bnVsbCl7ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJyx0b1N0cmluZyhnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKSkpO319dmFyIGlzQXJyYXlJbXBsPUFycmF5LmlzQXJyYXk7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZnVuY3Rpb24gaXNBcnJheShhKXtyZXR1cm4gaXNBcnJheUltcGwoYSk7fXZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMTt7ZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDE9ZmFsc2U7fWZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpe3ZhciBvd25lck5hbWU9Z2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtpZihvd25lck5hbWUpe3JldHVybidcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJytvd25lck5hbWUrJ2AuJzt9cmV0dXJuJyc7fXZhciB2YWx1ZVByb3BOYW1lcz1bJ3ZhbHVlJywnZGVmYXVsdFZhbHVlJ107LyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL2Z1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKXt7Y2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0Jyxwcm9wcyk7Zm9yKHZhciBpPTA7aTx2YWx1ZVByb3BOYW1lcy5sZW5ndGg7aSsrKXt2YXIgcHJvcE5hbWU9dmFsdWVQcm9wTmFtZXNbaV07aWYocHJvcHNbcHJvcE5hbWVdPT1udWxsKXtjb250aW51ZTt9dmFyIHByb3BOYW1lSXNBcnJheT1pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7aWYocHJvcHMubXVsdGlwbGUmJiFwcm9wTmFtZUlzQXJyYXkpe2Vycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJysnYG11bHRpcGxlYCBpcyB0cnVlLiVzJyxwcm9wTmFtZSxnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7fWVsc2UgaWYoIXByb3BzLm11bHRpcGxlJiZwcm9wTmFtZUlzQXJyYXkpe2Vycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJysndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycscHJvcE5hbWUsZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO319fX1mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsbXVsdGlwbGUscHJvcFZhbHVlLHNldERlZmF1bHRTZWxlY3RlZCl7dmFyIG9wdGlvbnM9bm9kZS5vcHRpb25zO2lmKG11bHRpcGxlKXt2YXIgc2VsZWN0ZWRWYWx1ZXM9cHJvcFZhbHVlO3ZhciBzZWxlY3RlZFZhbHVlPXt9O2Zvcih2YXIgaT0wO2k8c2VsZWN0ZWRWYWx1ZXMubGVuZ3RoO2krKyl7Ly8gUHJlZml4IHRvIGF2b2lkIGNoYW9zIHdpdGggc3BlY2lhbCBrZXlzLlxuc2VsZWN0ZWRWYWx1ZVsnJCcrc2VsZWN0ZWRWYWx1ZXNbaV1dPXRydWU7fWZvcih2YXIgX2k9MDtfaTxvcHRpb25zLmxlbmd0aDtfaSsrKXt2YXIgc2VsZWN0ZWQ9c2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcrb3B0aW9uc1tfaV0udmFsdWUpO2lmKG9wdGlvbnNbX2ldLnNlbGVjdGVkIT09c2VsZWN0ZWQpe29wdGlvbnNbX2ldLnNlbGVjdGVkPXNlbGVjdGVkO31pZihzZWxlY3RlZCYmc2V0RGVmYXVsdFNlbGVjdGVkKXtvcHRpb25zW19pXS5kZWZhdWx0U2VsZWN0ZWQ9dHJ1ZTt9fX1lbHNley8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4vLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxudmFyIF9zZWxlY3RlZFZhbHVlPXRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7dmFyIGRlZmF1bHRTZWxlY3RlZD1udWxsO2Zvcih2YXIgX2kyPTA7X2kyPG9wdGlvbnMubGVuZ3RoO19pMisrKXtpZihvcHRpb25zW19pMl0udmFsdWU9PT1fc2VsZWN0ZWRWYWx1ZSl7b3B0aW9uc1tfaTJdLnNlbGVjdGVkPXRydWU7aWYoc2V0RGVmYXVsdFNlbGVjdGVkKXtvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkPXRydWU7fXJldHVybjt9aWYoZGVmYXVsdFNlbGVjdGVkPT09bnVsbCYmIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCl7ZGVmYXVsdFNlbGVjdGVkPW9wdGlvbnNbX2kyXTt9fWlmKGRlZmF1bHRTZWxlY3RlZCE9PW51bGwpe2RlZmF1bHRTZWxlY3RlZC5zZWxlY3RlZD10cnVlO319fS8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCxwcm9wcyl7cmV0dXJuIGFzc2lnbih7fSxwcm9wcyx7dmFsdWU6dW5kZWZpbmVkfSk7fWZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O3tjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcyk7fW5vZGUuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFwcm9wcy5tdWx0aXBsZX07e2lmKHByb3BzLnZhbHVlIT09dW5kZWZpbmVkJiZwcm9wcy5kZWZhdWx0VmFsdWUhPT11bmRlZmluZWQmJiFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSl7ZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnKycoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnKydib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJysnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7ZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDE9dHJ1ZTt9fX1mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDtub2RlLm11bHRpcGxlPSEhcHJvcHMubXVsdGlwbGU7dmFyIHZhbHVlPXByb3BzLnZhbHVlO2lmKHZhbHVlIT1udWxsKXt1cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSx2YWx1ZSxmYWxzZSk7fWVsc2UgaWYocHJvcHMuZGVmYXVsdFZhbHVlIT1udWxsKXt1cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSxwcm9wcy5kZWZhdWx0VmFsdWUsdHJ1ZSk7fX1mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O3ZhciB3YXNNdWx0aXBsZT1ub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7bm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhcHJvcHMubXVsdGlwbGU7dmFyIHZhbHVlPXByb3BzLnZhbHVlO2lmKHZhbHVlIT1udWxsKXt1cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSx2YWx1ZSxmYWxzZSk7fWVsc2UgaWYod2FzTXVsdGlwbGUhPT0hIXByb3BzLm11bHRpcGxlKXsvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG5pZihwcm9wcy5kZWZhdWx0VmFsdWUhPW51bGwpe3VwZGF0ZU9wdGlvbnMobm9kZSwhIXByb3BzLm11bHRpcGxlLHByb3BzLmRlZmF1bHRWYWx1ZSx0cnVlKTt9ZWxzZXsvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG51cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSxwcm9wcy5tdWx0aXBsZT9bXTonJyxmYWxzZSk7fX19ZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7dmFyIHZhbHVlPXByb3BzLnZhbHVlO2lmKHZhbHVlIT1udWxsKXt1cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSx2YWx1ZSxmYWxzZSk7fX12YXIgZGlkV2FyblZhbERlZmF1bHRWYWw9ZmFsc2U7LyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O2lmKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpO30vLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4vLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4vLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbi8vIHRvIGJlIGEgc3RyaW5nLlxudmFyIGhvc3RQcm9wcz1hc3NpZ24oe30scHJvcHMse3ZhbHVlOnVuZGVmaW5lZCxkZWZhdWx0VmFsdWU6dW5kZWZpbmVkLGNoaWxkcmVuOnRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpfSk7cmV0dXJuIGhvc3RQcm9wczt9ZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQyKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7e2NoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJyxwcm9wcyk7aWYocHJvcHMudmFsdWUhPT11bmRlZmluZWQmJnByb3BzLmRlZmF1bHRWYWx1ZSE9PXVuZGVmaW5lZCYmIWRpZFdhcm5WYWxEZWZhdWx0VmFsKXtlcnJvcignJXMgY29udGFpbnMgYSB0ZXh0YXJlYSB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJysnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJysnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJysnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJysnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKXx8J0EgY29tcG9uZW50Jyk7ZGlkV2FyblZhbERlZmF1bHRWYWw9dHJ1ZTt9fXZhciBpbml0aWFsVmFsdWU9cHJvcHMudmFsdWU7Ly8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbmlmKGluaXRpYWxWYWx1ZT09bnVsbCl7dmFyIGNoaWxkcmVuPXByb3BzLmNoaWxkcmVuLGRlZmF1bHRWYWx1ZT1wcm9wcy5kZWZhdWx0VmFsdWU7aWYoY2hpbGRyZW4hPW51bGwpe3tlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnKydjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO317aWYoZGVmYXVsdFZhbHVlIT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKTt9aWYoaXNBcnJheShjaGlsZHJlbikpe2lmKGNoaWxkcmVuLmxlbmd0aD4xKXt0aHJvdyBuZXcgRXJyb3IoJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKTt9Y2hpbGRyZW49Y2hpbGRyZW5bMF07fWRlZmF1bHRWYWx1ZT1jaGlsZHJlbjt9fWlmKGRlZmF1bHRWYWx1ZT09bnVsbCl7ZGVmYXVsdFZhbHVlPScnO31pbml0aWFsVmFsdWU9ZGVmYXVsdFZhbHVlO31ub2RlLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpnZXRUb1N0cmluZ1ZhbHVlKGluaXRpYWxWYWx1ZSl9O31mdW5jdGlvbiB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDt2YXIgdmFsdWU9Z2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7dmFyIGRlZmF1bHRWYWx1ZT1nZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSk7aWYodmFsdWUhPW51bGwpey8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4vLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG52YXIgbmV3VmFsdWU9dG9TdHJpbmcodmFsdWUpOy8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG5pZihuZXdWYWx1ZSE9PW5vZGUudmFsdWUpe25vZGUudmFsdWU9bmV3VmFsdWU7fWlmKHByb3BzLmRlZmF1bHRWYWx1ZT09bnVsbCYmbm9kZS5kZWZhdWx0VmFsdWUhPT1uZXdWYWx1ZSl7bm9kZS5kZWZhdWx0VmFsdWU9bmV3VmFsdWU7fX1pZihkZWZhdWx0VmFsdWUhPW51bGwpe25vZGUuZGVmYXVsdFZhbHVlPXRvU3RyaW5nKGRlZmF1bHRWYWx1ZSk7fX1mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDMoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDsvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4vLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbnZhciB0ZXh0Q29udGVudD1ub2RlLnRleHRDb250ZW50Oy8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4vLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuaWYodGV4dENvbnRlbnQ9PT1ub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKXtpZih0ZXh0Q29udGVudCE9PScnJiZ0ZXh0Q29udGVudCE9PW51bGwpe25vZGUudmFsdWU9dGV4dENvbnRlbnQ7fX19ZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQscHJvcHMpey8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG51cGRhdGVXcmFwcGVyJDEoZWxlbWVudCxwcm9wcyk7fXZhciBIVE1MX05BTUVTUEFDRT0naHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7dmFyIE1BVEhfTkFNRVNQQUNFPSdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJzt2YXIgU1ZHX05BTUVTUEFDRT0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnOy8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKXtzd2l0Y2godHlwZSl7Y2FzZSdzdmcnOnJldHVybiBTVkdfTkFNRVNQQUNFO2Nhc2UnbWF0aCc6cmV0dXJuIE1BVEhfTkFNRVNQQUNFO2RlZmF1bHQ6cmV0dXJuIEhUTUxfTkFNRVNQQUNFO319ZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLHR5cGUpe2lmKHBhcmVudE5hbWVzcGFjZT09bnVsbHx8cGFyZW50TmFtZXNwYWNlPT09SFRNTF9OQU1FU1BBQ0Upey8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG5yZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO31pZihwYXJlbnROYW1lc3BhY2U9PT1TVkdfTkFNRVNQQUNFJiZ0eXBlPT09J2ZvcmVpZ25PYmplY3QnKXsvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbnJldHVybiBIVE1MX05BTUVTUEFDRTt9Ly8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5yZXR1cm4gcGFyZW50TmFtZXNwYWNlO30vKiBnbG9iYWxzIE1TQXBwICovIC8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi92YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbj1mdW5jdGlvbihmdW5jKXtpZih0eXBlb2YgTVNBcHAhPT0ndW5kZWZpbmVkJyYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pe3JldHVybiBmdW5jdGlvbihhcmcwLGFyZzEsYXJnMixhcmczKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBmdW5jKGFyZzAsYXJnMSxhcmcyLGFyZzMpO30pO307fWVsc2V7cmV0dXJuIGZ1bmM7fX07dmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyOy8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi92YXIgc2V0SW5uZXJIVE1MPWNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24obm9kZSxodG1sKXtpZihub2RlLm5hbWVzcGFjZVVSST09PVNWR19OQU1FU1BBQ0Upe2lmKCEoJ2lubmVySFRNTCdpbiBub2RlKSl7Ly8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4vLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4vLyB0aGUgdGFyZ2V0IG5vZGVcbnJldXNhYmxlU1ZHQ29udGFpbmVyPXJldXNhYmxlU1ZHQ29udGFpbmVyfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtyZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUw9Jzxzdmc+JytodG1sLnZhbHVlT2YoKS50b1N0cmluZygpKyc8L3N2Zz4nO3ZhciBzdmdOb2RlPXJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7d2hpbGUobm9kZS5maXJzdENoaWxkKXtub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7fXdoaWxlKHN2Z05vZGUuZmlyc3RDaGlsZCl7bm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO31yZXR1cm47fX1ub2RlLmlubmVySFRNTD1odG1sO30pOy8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL3ZhciBFTEVNRU5UX05PREU9MTt2YXIgVEVYVF9OT0RFPTM7dmFyIENPTU1FTlRfTk9ERT04O3ZhciBET0NVTUVOVF9OT0RFPTk7dmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU9MTE7LyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZS4gRm9yIHRleHQgdXBkYXRlcywgaXQncyBmYXN0ZXJcbiAqIHRvIHNldCB0aGUgYG5vZGVWYWx1ZWAgb2YgdGhlIFRleHQgbm9kZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHVzaW5nXG4gKiBgLnRleHRDb250ZW50YCB3aGljaCB3aWxsIHJlbW92ZSB0aGUgZXhpc3Rpbmcgbm9kZSBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL3ZhciBzZXRUZXh0Q29udGVudD1mdW5jdGlvbihub2RlLHRleHQpe2lmKHRleHQpe3ZhciBmaXJzdENoaWxkPW5vZGUuZmlyc3RDaGlsZDtpZihmaXJzdENoaWxkJiZmaXJzdENoaWxkPT09bm9kZS5sYXN0Q2hpbGQmJmZpcnN0Q2hpbGQubm9kZVR5cGU9PT1URVhUX05PREUpe2ZpcnN0Q2hpbGQubm9kZVZhbHVlPXRleHQ7cmV0dXJuO319bm9kZS50ZXh0Q29udGVudD10ZXh0O307Ly8gTGlzdCBkZXJpdmVkIGZyb20gR2Vja28gc291cmNlIGNvZGU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi80ZTYzOGVmYzcxL2xheW91dC9zdHlsZS90ZXN0L3Byb3BlcnR5X2RhdGFiYXNlLmpzXG52YXIgc2hvcnRoYW5kVG9Mb25naGFuZD17YW5pbWF0aW9uOlsnYW5pbWF0aW9uRGVsYXknLCdhbmltYXRpb25EaXJlY3Rpb24nLCdhbmltYXRpb25EdXJhdGlvbicsJ2FuaW1hdGlvbkZpbGxNb2RlJywnYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCdhbmltYXRpb25OYW1lJywnYW5pbWF0aW9uUGxheVN0YXRlJywnYW5pbWF0aW9uVGltaW5nRnVuY3Rpb24nXSxiYWNrZ3JvdW5kOlsnYmFja2dyb3VuZEF0dGFjaG1lbnQnLCdiYWNrZ3JvdW5kQ2xpcCcsJ2JhY2tncm91bmRDb2xvcicsJ2JhY2tncm91bmRJbWFnZScsJ2JhY2tncm91bmRPcmlnaW4nLCdiYWNrZ3JvdW5kUG9zaXRpb25YJywnYmFja2dyb3VuZFBvc2l0aW9uWScsJ2JhY2tncm91bmRSZXBlYXQnLCdiYWNrZ3JvdW5kU2l6ZSddLGJhY2tncm91bmRQb3NpdGlvbjpbJ2JhY2tncm91bmRQb3NpdGlvblgnLCdiYWNrZ3JvdW5kUG9zaXRpb25ZJ10sYm9yZGVyOlsnYm9yZGVyQm90dG9tQ29sb3InLCdib3JkZXJCb3R0b21TdHlsZScsJ2JvcmRlckJvdHRvbVdpZHRoJywnYm9yZGVySW1hZ2VPdXRzZXQnLCdib3JkZXJJbWFnZVJlcGVhdCcsJ2JvcmRlckltYWdlU2xpY2UnLCdib3JkZXJJbWFnZVNvdXJjZScsJ2JvcmRlckltYWdlV2lkdGgnLCdib3JkZXJMZWZ0Q29sb3InLCdib3JkZXJMZWZ0U3R5bGUnLCdib3JkZXJMZWZ0V2lkdGgnLCdib3JkZXJSaWdodENvbG9yJywnYm9yZGVyUmlnaHRTdHlsZScsJ2JvcmRlclJpZ2h0V2lkdGgnLCdib3JkZXJUb3BDb2xvcicsJ2JvcmRlclRvcFN0eWxlJywnYm9yZGVyVG9wV2lkdGgnXSxib3JkZXJCbG9ja0VuZDpbJ2JvcmRlckJsb2NrRW5kQ29sb3InLCdib3JkZXJCbG9ja0VuZFN0eWxlJywnYm9yZGVyQmxvY2tFbmRXaWR0aCddLGJvcmRlckJsb2NrU3RhcnQ6Wydib3JkZXJCbG9ja1N0YXJ0Q29sb3InLCdib3JkZXJCbG9ja1N0YXJ0U3R5bGUnLCdib3JkZXJCbG9ja1N0YXJ0V2lkdGgnXSxib3JkZXJCb3R0b206Wydib3JkZXJCb3R0b21Db2xvcicsJ2JvcmRlckJvdHRvbVN0eWxlJywnYm9yZGVyQm90dG9tV2lkdGgnXSxib3JkZXJDb2xvcjpbJ2JvcmRlckJvdHRvbUNvbG9yJywnYm9yZGVyTGVmdENvbG9yJywnYm9yZGVyUmlnaHRDb2xvcicsJ2JvcmRlclRvcENvbG9yJ10sYm9yZGVySW1hZ2U6Wydib3JkZXJJbWFnZU91dHNldCcsJ2JvcmRlckltYWdlUmVwZWF0JywnYm9yZGVySW1hZ2VTbGljZScsJ2JvcmRlckltYWdlU291cmNlJywnYm9yZGVySW1hZ2VXaWR0aCddLGJvcmRlcklubGluZUVuZDpbJ2JvcmRlcklubGluZUVuZENvbG9yJywnYm9yZGVySW5saW5lRW5kU3R5bGUnLCdib3JkZXJJbmxpbmVFbmRXaWR0aCddLGJvcmRlcklubGluZVN0YXJ0OlsnYm9yZGVySW5saW5lU3RhcnRDb2xvcicsJ2JvcmRlcklubGluZVN0YXJ0U3R5bGUnLCdib3JkZXJJbmxpbmVTdGFydFdpZHRoJ10sYm9yZGVyTGVmdDpbJ2JvcmRlckxlZnRDb2xvcicsJ2JvcmRlckxlZnRTdHlsZScsJ2JvcmRlckxlZnRXaWR0aCddLGJvcmRlclJhZGl1czpbJ2JvcmRlckJvdHRvbUxlZnRSYWRpdXMnLCdib3JkZXJCb3R0b21SaWdodFJhZGl1cycsJ2JvcmRlclRvcExlZnRSYWRpdXMnLCdib3JkZXJUb3BSaWdodFJhZGl1cyddLGJvcmRlclJpZ2h0OlsnYm9yZGVyUmlnaHRDb2xvcicsJ2JvcmRlclJpZ2h0U3R5bGUnLCdib3JkZXJSaWdodFdpZHRoJ10sYm9yZGVyU3R5bGU6Wydib3JkZXJCb3R0b21TdHlsZScsJ2JvcmRlckxlZnRTdHlsZScsJ2JvcmRlclJpZ2h0U3R5bGUnLCdib3JkZXJUb3BTdHlsZSddLGJvcmRlclRvcDpbJ2JvcmRlclRvcENvbG9yJywnYm9yZGVyVG9wU3R5bGUnLCdib3JkZXJUb3BXaWR0aCddLGJvcmRlcldpZHRoOlsnYm9yZGVyQm90dG9tV2lkdGgnLCdib3JkZXJMZWZ0V2lkdGgnLCdib3JkZXJSaWdodFdpZHRoJywnYm9yZGVyVG9wV2lkdGgnXSxjb2x1bW5SdWxlOlsnY29sdW1uUnVsZUNvbG9yJywnY29sdW1uUnVsZVN0eWxlJywnY29sdW1uUnVsZVdpZHRoJ10sY29sdW1uczpbJ2NvbHVtbkNvdW50JywnY29sdW1uV2lkdGgnXSxmbGV4OlsnZmxleEJhc2lzJywnZmxleEdyb3cnLCdmbGV4U2hyaW5rJ10sZmxleEZsb3c6WydmbGV4RGlyZWN0aW9uJywnZmxleFdyYXAnXSxmb250OlsnZm9udEZhbWlseScsJ2ZvbnRGZWF0dXJlU2V0dGluZ3MnLCdmb250S2VybmluZycsJ2ZvbnRMYW5ndWFnZU92ZXJyaWRlJywnZm9udFNpemUnLCdmb250U2l6ZUFkanVzdCcsJ2ZvbnRTdHJldGNoJywnZm9udFN0eWxlJywnZm9udFZhcmlhbnQnLCdmb250VmFyaWFudEFsdGVybmF0ZXMnLCdmb250VmFyaWFudENhcHMnLCdmb250VmFyaWFudEVhc3RBc2lhbicsJ2ZvbnRWYXJpYW50TGlnYXR1cmVzJywnZm9udFZhcmlhbnROdW1lcmljJywnZm9udFZhcmlhbnRQb3NpdGlvbicsJ2ZvbnRXZWlnaHQnLCdsaW5lSGVpZ2h0J10sZm9udFZhcmlhbnQ6Wydmb250VmFyaWFudEFsdGVybmF0ZXMnLCdmb250VmFyaWFudENhcHMnLCdmb250VmFyaWFudEVhc3RBc2lhbicsJ2ZvbnRWYXJpYW50TGlnYXR1cmVzJywnZm9udFZhcmlhbnROdW1lcmljJywnZm9udFZhcmlhbnRQb3NpdGlvbiddLGdhcDpbJ2NvbHVtbkdhcCcsJ3Jvd0dhcCddLGdyaWQ6WydncmlkQXV0b0NvbHVtbnMnLCdncmlkQXV0b0Zsb3cnLCdncmlkQXV0b1Jvd3MnLCdncmlkVGVtcGxhdGVBcmVhcycsJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCdncmlkVGVtcGxhdGVSb3dzJ10sZ3JpZEFyZWE6WydncmlkQ29sdW1uRW5kJywnZ3JpZENvbHVtblN0YXJ0JywnZ3JpZFJvd0VuZCcsJ2dyaWRSb3dTdGFydCddLGdyaWRDb2x1bW46WydncmlkQ29sdW1uRW5kJywnZ3JpZENvbHVtblN0YXJ0J10sZ3JpZENvbHVtbkdhcDpbJ2NvbHVtbkdhcCddLGdyaWRHYXA6Wydjb2x1bW5HYXAnLCdyb3dHYXAnXSxncmlkUm93OlsnZ3JpZFJvd0VuZCcsJ2dyaWRSb3dTdGFydCddLGdyaWRSb3dHYXA6Wydyb3dHYXAnXSxncmlkVGVtcGxhdGU6WydncmlkVGVtcGxhdGVBcmVhcycsJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCdncmlkVGVtcGxhdGVSb3dzJ10sbGlzdFN0eWxlOlsnbGlzdFN0eWxlSW1hZ2UnLCdsaXN0U3R5bGVQb3NpdGlvbicsJ2xpc3RTdHlsZVR5cGUnXSxtYXJnaW46WydtYXJnaW5Cb3R0b20nLCdtYXJnaW5MZWZ0JywnbWFyZ2luUmlnaHQnLCdtYXJnaW5Ub3AnXSxtYXJrZXI6WydtYXJrZXJFbmQnLCdtYXJrZXJNaWQnLCdtYXJrZXJTdGFydCddLG1hc2s6WydtYXNrQ2xpcCcsJ21hc2tDb21wb3NpdGUnLCdtYXNrSW1hZ2UnLCdtYXNrTW9kZScsJ21hc2tPcmlnaW4nLCdtYXNrUG9zaXRpb25YJywnbWFza1Bvc2l0aW9uWScsJ21hc2tSZXBlYXQnLCdtYXNrU2l6ZSddLG1hc2tQb3NpdGlvbjpbJ21hc2tQb3NpdGlvblgnLCdtYXNrUG9zaXRpb25ZJ10sb3V0bGluZTpbJ291dGxpbmVDb2xvcicsJ291dGxpbmVTdHlsZScsJ291dGxpbmVXaWR0aCddLG92ZXJmbG93Olsnb3ZlcmZsb3dYJywnb3ZlcmZsb3dZJ10scGFkZGluZzpbJ3BhZGRpbmdCb3R0b20nLCdwYWRkaW5nTGVmdCcsJ3BhZGRpbmdSaWdodCcsJ3BhZGRpbmdUb3AnXSxwbGFjZUNvbnRlbnQ6WydhbGlnbkNvbnRlbnQnLCdqdXN0aWZ5Q29udGVudCddLHBsYWNlSXRlbXM6WydhbGlnbkl0ZW1zJywnanVzdGlmeUl0ZW1zJ10scGxhY2VTZWxmOlsnYWxpZ25TZWxmJywnanVzdGlmeVNlbGYnXSx0ZXh0RGVjb3JhdGlvbjpbJ3RleHREZWNvcmF0aW9uQ29sb3InLCd0ZXh0RGVjb3JhdGlvbkxpbmUnLCd0ZXh0RGVjb3JhdGlvblN0eWxlJ10sdGV4dEVtcGhhc2lzOlsndGV4dEVtcGhhc2lzQ29sb3InLCd0ZXh0RW1waGFzaXNTdHlsZSddLHRyYW5zaXRpb246Wyd0cmFuc2l0aW9uRGVsYXknLCd0cmFuc2l0aW9uRHVyYXRpb24nLCd0cmFuc2l0aW9uUHJvcGVydHknLCd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nXSx3b3JkV3JhcDpbJ292ZXJmbG93V3JhcCddfTsvKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL3ZhciBpc1VuaXRsZXNzTnVtYmVyPXthbmltYXRpb25JdGVyYXRpb25Db3VudDp0cnVlLGFzcGVjdFJhdGlvOnRydWUsYm9yZGVySW1hZ2VPdXRzZXQ6dHJ1ZSxib3JkZXJJbWFnZVNsaWNlOnRydWUsYm9yZGVySW1hZ2VXaWR0aDp0cnVlLGJveEZsZXg6dHJ1ZSxib3hGbGV4R3JvdXA6dHJ1ZSxib3hPcmRpbmFsR3JvdXA6dHJ1ZSxjb2x1bW5Db3VudDp0cnVlLGNvbHVtbnM6dHJ1ZSxmbGV4OnRydWUsZmxleEdyb3c6dHJ1ZSxmbGV4UG9zaXRpdmU6dHJ1ZSxmbGV4U2hyaW5rOnRydWUsZmxleE5lZ2F0aXZlOnRydWUsZmxleE9yZGVyOnRydWUsZ3JpZEFyZWE6dHJ1ZSxncmlkUm93OnRydWUsZ3JpZFJvd0VuZDp0cnVlLGdyaWRSb3dTcGFuOnRydWUsZ3JpZFJvd1N0YXJ0OnRydWUsZ3JpZENvbHVtbjp0cnVlLGdyaWRDb2x1bW5FbmQ6dHJ1ZSxncmlkQ29sdW1uU3Bhbjp0cnVlLGdyaWRDb2x1bW5TdGFydDp0cnVlLGZvbnRXZWlnaHQ6dHJ1ZSxsaW5lQ2xhbXA6dHJ1ZSxsaW5lSGVpZ2h0OnRydWUsb3BhY2l0eTp0cnVlLG9yZGVyOnRydWUsb3JwaGFuczp0cnVlLHRhYlNpemU6dHJ1ZSx3aWRvd3M6dHJ1ZSx6SW5kZXg6dHJ1ZSx6b29tOnRydWUsLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuZmlsbE9wYWNpdHk6dHJ1ZSxmbG9vZE9wYWNpdHk6dHJ1ZSxzdG9wT3BhY2l0eTp0cnVlLHN0cm9rZURhc2hhcnJheTp0cnVlLHN0cm9rZURhc2hvZmZzZXQ6dHJ1ZSxzdHJva2VNaXRlcmxpbWl0OnRydWUsc3Ryb2tlT3BhY2l0eTp0cnVlLHN0cm9rZVdpZHRoOnRydWV9Oy8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCxrZXkpe3JldHVybiBwcmVmaXgra2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2tleS5zdWJzdHJpbmcoMSk7fS8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi92YXIgcHJlZml4ZXM9WydXZWJraXQnLCdtcycsJ01veicsJ08nXTsvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7cHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbihwcmVmaXgpe2lzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCxwcm9wKV09aXNVbml0bGVzc051bWJlcltwcm9wXTt9KTt9KTsvKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLHZhbHVlLGlzQ3VzdG9tUHJvcGVydHkpey8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbi8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbi8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3Rcbi8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbi8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4vLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcbnZhciBpc0VtcHR5PXZhbHVlPT1udWxsfHx0eXBlb2YgdmFsdWU9PT0nYm9vbGVhbid8fHZhbHVlPT09Jyc7aWYoaXNFbXB0eSl7cmV0dXJuJyc7fWlmKCFpc0N1c3RvbVByb3BlcnR5JiZ0eXBlb2YgdmFsdWU9PT0nbnVtYmVyJyYmdmFsdWUhPT0wJiYhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkmJmlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKXtyZXR1cm4gdmFsdWUrJ3B4JzsvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xufXtjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsbmFtZSk7fXJldHVybignJyt2YWx1ZSkudHJpbSgpO312YXIgdXBwZXJjYXNlUGF0dGVybj0vKFtBLVpdKS9nO3ZhciBtc1BhdHRlcm49L15tcy0vOy8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpe3JldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwnLW1zLScpO312YXIgd2FyblZhbGlkU3R5bGU9ZnVuY3Rpb24oKXt9O3svLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG52YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuPS9eKD86d2Via2l0fG1venxvKVtBLVpdLzt2YXIgbXNQYXR0ZXJuJDE9L14tbXMtLzt2YXIgaHlwaGVuUGF0dGVybj0vLSguKS9nOy8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxudmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybj0vO1xccyokLzt2YXIgd2FybmVkU3R5bGVOYW1lcz17fTt2YXIgd2FybmVkU3R5bGVWYWx1ZXM9e307dmFyIHdhcm5lZEZvck5hTlZhbHVlPWZhbHNlO3ZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlPWZhbHNlO3ZhciBjYW1lbGl6ZT1mdW5jdGlvbihzdHJpbmcpe3JldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLGZ1bmN0aW9uKF8sY2hhcmFjdGVyKXtyZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7fSk7fTt2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWU9ZnVuY3Rpb24obmFtZSl7aWYod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSYmd2FybmVkU3R5bGVOYW1lc1tuYW1lXSl7cmV0dXJuO313YXJuZWRTdHlsZU5hbWVzW25hbWVdPXRydWU7ZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JyxuYW1lLC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbi8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbi8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbmNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwnbXMtJykpKTt9O3ZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWU9ZnVuY3Rpb24obmFtZSl7aWYod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSYmd2FybmVkU3R5bGVOYW1lc1tuYW1lXSl7cmV0dXJuO313YXJuZWRTdHlsZU5hbWVzW25hbWVdPXRydWU7ZXJyb3IoJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsbmFtZSxuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK25hbWUuc2xpY2UoMSkpO307dmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbj1mdW5jdGlvbihuYW1lLHZhbHVlKXtpZih3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkmJndhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSl7cmV0dXJuO313YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV09dHJ1ZTtlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIrJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJyxuYW1lLHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCcnKSk7fTt2YXIgd2FyblN0eWxlVmFsdWVJc05hTj1mdW5jdGlvbihuYW1lLHZhbHVlKXtpZih3YXJuZWRGb3JOYU5WYWx1ZSl7cmV0dXJuO313YXJuZWRGb3JOYU5WYWx1ZT10cnVlO2Vycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJyxuYW1lKTt9O3ZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHk9ZnVuY3Rpb24obmFtZSx2YWx1ZSl7aWYod2FybmVkRm9ySW5maW5pdHlWYWx1ZSl7cmV0dXJuO313YXJuZWRGb3JJbmZpbml0eVZhbHVlPXRydWU7ZXJyb3IoJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsbmFtZSk7fTt3YXJuVmFsaWRTdHlsZT1mdW5jdGlvbihuYW1lLHZhbHVlKXtpZihuYW1lLmluZGV4T2YoJy0nKT4tMSl7d2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7fWVsc2UgaWYoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpe3dhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTt9ZWxzZSBpZihiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpe3dhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLHZhbHVlKTt9aWYodHlwZW9mIHZhbHVlPT09J251bWJlcicpe2lmKGlzTmFOKHZhbHVlKSl7d2FyblN0eWxlVmFsdWVJc05hTihuYW1lLHZhbHVlKTt9ZWxzZSBpZighaXNGaW5pdGUodmFsdWUpKXt3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSx2YWx1ZSk7fX19O312YXIgd2FyblZhbGlkU3R5bGUkMT13YXJuVmFsaWRTdHlsZTsvKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqLyAvKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovZnVuY3Rpb24gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKHN0eWxlcyl7e3ZhciBzZXJpYWxpemVkPScnO3ZhciBkZWxpbWl0ZXI9Jyc7Zm9yKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKXtpZighc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpe2NvbnRpbnVlO312YXIgc3R5bGVWYWx1ZT1zdHlsZXNbc3R5bGVOYW1lXTtpZihzdHlsZVZhbHVlIT1udWxsKXt2YXIgaXNDdXN0b21Qcm9wZXJ0eT1zdHlsZU5hbWUuaW5kZXhPZignLS0nKT09PTA7c2VyaWFsaXplZCs9ZGVsaW1pdGVyKyhpc0N1c3RvbVByb3BlcnR5P3N0eWxlTmFtZTpoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSkrJzonO3NlcmlhbGl6ZWQrPWRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLHN0eWxlVmFsdWUsaXNDdXN0b21Qcm9wZXJ0eSk7ZGVsaW1pdGVyPSc7Jzt9fXJldHVybiBzZXJpYWxpemVkfHxudWxsO319LyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL2Z1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsc3R5bGVzKXt2YXIgc3R5bGU9bm9kZS5zdHlsZTtmb3IodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpe2lmKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSl7Y29udGludWU7fXZhciBpc0N1c3RvbVByb3BlcnR5PXN0eWxlTmFtZS5pbmRleE9mKCctLScpPT09MDt7aWYoIWlzQ3VzdG9tUHJvcGVydHkpe3dhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLHN0eWxlc1tzdHlsZU5hbWVdKTt9fXZhciBzdHlsZVZhbHVlPWRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLHN0eWxlc1tzdHlsZU5hbWVdLGlzQ3VzdG9tUHJvcGVydHkpO2lmKHN0eWxlTmFtZT09PSdmbG9hdCcpe3N0eWxlTmFtZT0nY3NzRmxvYXQnO31pZihpc0N1c3RvbVByb3BlcnR5KXtzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsc3R5bGVWYWx1ZSk7fWVsc2V7c3R5bGVbc3R5bGVOYW1lXT1zdHlsZVZhbHVlO319fWZ1bmN0aW9uIGlzVmFsdWVFbXB0eSh2YWx1ZSl7cmV0dXJuIHZhbHVlPT1udWxsfHx0eXBlb2YgdmFsdWU9PT0nYm9vbGVhbid8fHZhbHVlPT09Jyc7fS8qKlxuICogR2l2ZW4ge2NvbG9yOiAncmVkJywgb3ZlcmZsb3c6ICdoaWRkZW4nfSByZXR1cm5zIHtcbiAqICAgY29sb3I6ICdjb2xvcicsXG4gKiAgIG92ZXJmbG93WDogJ292ZXJmbG93JyxcbiAqICAgb3ZlcmZsb3dZOiAnb3ZlcmZsb3cnLFxuICogfS4gVGhpcyBjYW4gYmUgcmVhZCBhcyBcInRoZSBvdmVyZmxvd1kgcHJvcGVydHkgd2FzIHNldCBieSB0aGUgb3ZlcmZsb3dcbiAqIHNob3J0aGFuZFwiLiBUaGF0IGlzLCB0aGUgdmFsdWVzIGFyZSB0aGUgcHJvcGVydHkgdGhhdCBlYWNoIHdhcyBkZXJpdmVkIGZyb20uXG4gKi9mdW5jdGlvbiBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVzKXt2YXIgZXhwYW5kZWQ9e307Zm9yKHZhciBrZXkgaW4gc3R5bGVzKXt2YXIgbG9uZ2hhbmRzPXNob3J0aGFuZFRvTG9uZ2hhbmRba2V5XXx8W2tleV07Zm9yKHZhciBpPTA7aTxsb25naGFuZHMubGVuZ3RoO2krKyl7ZXhwYW5kZWRbbG9uZ2hhbmRzW2ldXT1rZXk7fX1yZXR1cm4gZXhwYW5kZWQ7fS8qKlxuICogV2hlbiBtaXhpbmcgc2hvcnRoYW5kIGFuZCBsb25naGFuZCBwcm9wZXJ0eSBuYW1lcywgd2Ugd2FybiBkdXJpbmcgdXBkYXRlcyBpZlxuICogd2UgZXhwZWN0IGFuIGluY29ycmVjdCByZXN1bHQgdG8gb2NjdXIuIEluIHBhcnRpY3VsYXIsIHdlIHdhcm4gZm9yOlxuICpcbiAqIFVwZGF0aW5nIGEgc2hvcnRoYW5kIHByb3BlcnR5IChsb25naGFuZCBnZXRzIG92ZXJ3cml0dGVuKTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250OiAnYmF6JywgZm9udFZhcmlhbnQ6ICdiYXInfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250ID0gJ2JheidcbiAqIFJlbW92aW5nIGEgc2hvcnRoYW5kIHByb3BlcnR5IChsb25naGFuZCBnZXRzIGxvc3QgdG9vKTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250VmFyaWFudDogJ2Jhcid9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnQgPSAnJ1xuICogUmVtb3ZpbmcgYSBsb25naGFuZCBwcm9wZXJ0eSAoc2hvdWxkIHJldmVydCB0byBzaG9ydGhhbmQ7IGRvZXNuJ3QpOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnQ6ICdmb28nfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250VmFyaWFudCA9ICcnXG4gKi9mdW5jdGlvbiB2YWxpZGF0ZVNob3J0aGFuZFByb3BlcnR5Q29sbGlzaW9uSW5EZXYoc3R5bGVVcGRhdGVzLG5leHRTdHlsZXMpe3tpZighbmV4dFN0eWxlcyl7cmV0dXJuO312YXIgZXhwYW5kZWRVcGRhdGVzPWV4cGFuZFNob3J0aGFuZE1hcChzdHlsZVVwZGF0ZXMpO3ZhciBleHBhbmRlZFN0eWxlcz1leHBhbmRTaG9ydGhhbmRNYXAobmV4dFN0eWxlcyk7dmFyIHdhcm5lZEFib3V0PXt9O2Zvcih2YXIga2V5IGluIGV4cGFuZGVkVXBkYXRlcyl7dmFyIG9yaWdpbmFsS2V5PWV4cGFuZGVkVXBkYXRlc1trZXldO3ZhciBjb3JyZWN0T3JpZ2luYWxLZXk9ZXhwYW5kZWRTdHlsZXNba2V5XTtpZihjb3JyZWN0T3JpZ2luYWxLZXkmJm9yaWdpbmFsS2V5IT09Y29ycmVjdE9yaWdpbmFsS2V5KXt2YXIgd2FybmluZ0tleT1vcmlnaW5hbEtleSsnLCcrY29ycmVjdE9yaWdpbmFsS2V5O2lmKHdhcm5lZEFib3V0W3dhcm5pbmdLZXldKXtjb250aW51ZTt9d2FybmVkQWJvdXRbd2FybmluZ0tleV09dHJ1ZTtlcnJvcignJXMgYSBzdHlsZSBwcm9wZXJ0eSBkdXJpbmcgcmVyZW5kZXIgKCVzKSB3aGVuIGEgJysnY29uZmxpY3RpbmcgcHJvcGVydHkgaXMgc2V0ICglcykgY2FuIGxlYWQgdG8gc3R5bGluZyBidWdzLiBUbyAnK1wiYXZvaWQgdGhpcywgZG9uJ3QgbWl4IHNob3J0aGFuZCBhbmQgbm9uLXNob3J0aGFuZCBwcm9wZXJ0aWVzIFwiKydmb3IgdGhlIHNhbWUgdmFsdWU7IGluc3RlYWQsIHJlcGxhY2UgdGhlIHNob3J0aGFuZCB3aXRoICcrJ3NlcGFyYXRlIHZhbHVlcy4nLGlzVmFsdWVFbXB0eShzdHlsZVVwZGF0ZXNbb3JpZ2luYWxLZXldKT8nUmVtb3ZpbmcnOidVcGRhdGluZycsb3JpZ2luYWxLZXksY29ycmVjdE9yaWdpbmFsS2V5KTt9fX19Ly8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSBsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG52YXIgb21pdHRlZENsb3NlVGFncz17YXJlYTp0cnVlLGJhc2U6dHJ1ZSxicjp0cnVlLGNvbDp0cnVlLGVtYmVkOnRydWUsaHI6dHJ1ZSxpbWc6dHJ1ZSxpbnB1dDp0cnVlLGtleWdlbjp0cnVlLGxpbms6dHJ1ZSxtZXRhOnRydWUscGFyYW06dHJ1ZSxzb3VyY2U6dHJ1ZSx0cmFjazp0cnVlLHdicjp0cnVlLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbn07Ly8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxudmFyIHZvaWRFbGVtZW50VGFncz1hc3NpZ24oe21lbnVpdGVtOnRydWV9LG9taXR0ZWRDbG9zZVRhZ3MpO3ZhciBIVE1MPSdfX2h0bWwnO2Z1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLHByb3BzKXtpZighcHJvcHMpe3JldHVybjt9Ly8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbmlmKHZvaWRFbGVtZW50VGFnc1t0YWddKXtpZihwcm9wcy5jaGlsZHJlbiE9bnVsbHx8cHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwhPW51bGwpe3Rocm93IG5ldyBFcnJvcih0YWcrXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIisndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7fX1pZihwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCE9bnVsbCl7aWYocHJvcHMuY2hpbGRyZW4hPW51bGwpe3Rocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7fWlmKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCE9PSdvYmplY3QnfHwhKEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKXt0aHJvdyBuZXcgRXJyb3IoJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuICcrJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJysnZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7fX17aWYoIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyYmcHJvcHMuY29udGVudEVkaXRhYmxlJiZwcm9wcy5jaGlsZHJlbiE9bnVsbCl7ZXJyb3IoJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJysnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJysndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcrJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKTt9fWlmKHByb3BzLnN0eWxlIT1udWxsJiZ0eXBlb2YgcHJvcHMuc3R5bGUhPT0nb2JqZWN0Jyl7dGhyb3cgbmV3IEVycm9yKCdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcrXCJub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gXCIrJ3VzaW5nIEpTWC4nKTt9fWZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUscHJvcHMpe2lmKHRhZ05hbWUuaW5kZXhPZignLScpPT09LTEpe3JldHVybiB0eXBlb2YgcHJvcHMuaXM9PT0nc3RyaW5nJzt9c3dpdGNoKHRhZ05hbWUpey8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbi8vIFdlIGRvbid0IG1pbmQgdGhpcyBsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4vLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuY2FzZSdhbm5vdGF0aW9uLXhtbCc6Y2FzZSdjb2xvci1wcm9maWxlJzpjYXNlJ2ZvbnQtZmFjZSc6Y2FzZSdmb250LWZhY2Utc3JjJzpjYXNlJ2ZvbnQtZmFjZS11cmknOmNhc2UnZm9udC1mYWNlLWZvcm1hdCc6Y2FzZSdmb250LWZhY2UtbmFtZSc6Y2FzZSdtaXNzaW5nLWdseXBoJzpyZXR1cm4gZmFsc2U7ZGVmYXVsdDpyZXR1cm4gdHJ1ZTt9fS8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIGFsbG93ZWQgYXR0cmlidXRlIGxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcz17Ly8gSFRNTFxuYWNjZXB0OidhY2NlcHQnLGFjY2VwdGNoYXJzZXQ6J2FjY2VwdENoYXJzZXQnLCdhY2NlcHQtY2hhcnNldCc6J2FjY2VwdENoYXJzZXQnLGFjY2Vzc2tleTonYWNjZXNzS2V5JyxhY3Rpb246J2FjdGlvbicsYWxsb3dmdWxsc2NyZWVuOidhbGxvd0Z1bGxTY3JlZW4nLGFsdDonYWx0JyxhczonYXMnLGFzeW5jOidhc3luYycsYXV0b2NhcGl0YWxpemU6J2F1dG9DYXBpdGFsaXplJyxhdXRvY29tcGxldGU6J2F1dG9Db21wbGV0ZScsYXV0b2NvcnJlY3Q6J2F1dG9Db3JyZWN0JyxhdXRvZm9jdXM6J2F1dG9Gb2N1cycsYXV0b3BsYXk6J2F1dG9QbGF5JyxhdXRvc2F2ZTonYXV0b1NhdmUnLGNhcHR1cmU6J2NhcHR1cmUnLGNlbGxwYWRkaW5nOidjZWxsUGFkZGluZycsY2VsbHNwYWNpbmc6J2NlbGxTcGFjaW5nJyxjaGFsbGVuZ2U6J2NoYWxsZW5nZScsY2hhcnNldDonY2hhclNldCcsY2hlY2tlZDonY2hlY2tlZCcsY2hpbGRyZW46J2NoaWxkcmVuJyxjaXRlOidjaXRlJyxjbGFzczonY2xhc3NOYW1lJyxjbGFzc2lkOidjbGFzc0lEJyxjbGFzc25hbWU6J2NsYXNzTmFtZScsY29sczonY29scycsY29sc3BhbjonY29sU3BhbicsY29udGVudDonY29udGVudCcsY29udGVudGVkaXRhYmxlOidjb250ZW50RWRpdGFibGUnLGNvbnRleHRtZW51Oidjb250ZXh0TWVudScsY29udHJvbHM6J2NvbnRyb2xzJyxjb250cm9sc2xpc3Q6J2NvbnRyb2xzTGlzdCcsY29vcmRzOidjb29yZHMnLGNyb3Nzb3JpZ2luOidjcm9zc09yaWdpbicsZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6J2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxkYXRhOidkYXRhJyxkYXRldGltZTonZGF0ZVRpbWUnLGRlZmF1bHQ6J2RlZmF1bHQnLGRlZmF1bHRjaGVja2VkOidkZWZhdWx0Q2hlY2tlZCcsZGVmYXVsdHZhbHVlOidkZWZhdWx0VmFsdWUnLGRlZmVyOidkZWZlcicsZGlyOidkaXInLGRpc2FibGVkOidkaXNhYmxlZCcsZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6J2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxkaXNhYmxlcmVtb3RlcGxheWJhY2s6J2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsZG93bmxvYWQ6J2Rvd25sb2FkJyxkcmFnZ2FibGU6J2RyYWdnYWJsZScsZW5jdHlwZTonZW5jVHlwZScsZW50ZXJrZXloaW50OidlbnRlcktleUhpbnQnLGZvcjonaHRtbEZvcicsZm9ybTonZm9ybScsZm9ybW1ldGhvZDonZm9ybU1ldGhvZCcsZm9ybWFjdGlvbjonZm9ybUFjdGlvbicsZm9ybWVuY3R5cGU6J2Zvcm1FbmNUeXBlJyxmb3Jtbm92YWxpZGF0ZTonZm9ybU5vVmFsaWRhdGUnLGZvcm10YXJnZXQ6J2Zvcm1UYXJnZXQnLGZyYW1lYm9yZGVyOidmcmFtZUJvcmRlcicsaGVhZGVyczonaGVhZGVycycsaGVpZ2h0OidoZWlnaHQnLGhpZGRlbjonaGlkZGVuJyxoaWdoOidoaWdoJyxocmVmOidocmVmJyxocmVmbGFuZzonaHJlZkxhbmcnLGh0bWxmb3I6J2h0bWxGb3InLGh0dHBlcXVpdjonaHR0cEVxdWl2JywnaHR0cC1lcXVpdic6J2h0dHBFcXVpdicsaWNvbjonaWNvbicsaWQ6J2lkJyxpbWFnZXNpemVzOidpbWFnZVNpemVzJyxpbWFnZXNyY3NldDonaW1hZ2VTcmNTZXQnLGlubmVyaHRtbDonaW5uZXJIVE1MJyxpbnB1dG1vZGU6J2lucHV0TW9kZScsaW50ZWdyaXR5OidpbnRlZ3JpdHknLGlzOidpcycsaXRlbWlkOidpdGVtSUQnLGl0ZW1wcm9wOidpdGVtUHJvcCcsaXRlbXJlZjonaXRlbVJlZicsaXRlbXNjb3BlOidpdGVtU2NvcGUnLGl0ZW10eXBlOidpdGVtVHlwZScsa2V5cGFyYW1zOidrZXlQYXJhbXMnLGtleXR5cGU6J2tleVR5cGUnLGtpbmQ6J2tpbmQnLGxhYmVsOidsYWJlbCcsbGFuZzonbGFuZycsbGlzdDonbGlzdCcsbG9vcDonbG9vcCcsbG93Oidsb3cnLG1hbmlmZXN0OidtYW5pZmVzdCcsbWFyZ2lud2lkdGg6J21hcmdpbldpZHRoJyxtYXJnaW5oZWlnaHQ6J21hcmdpbkhlaWdodCcsbWF4OidtYXgnLG1heGxlbmd0aDonbWF4TGVuZ3RoJyxtZWRpYTonbWVkaWEnLG1lZGlhZ3JvdXA6J21lZGlhR3JvdXAnLG1ldGhvZDonbWV0aG9kJyxtaW46J21pbicsbWlubGVuZ3RoOidtaW5MZW5ndGgnLG11bHRpcGxlOidtdWx0aXBsZScsbXV0ZWQ6J211dGVkJyxuYW1lOiduYW1lJyxub21vZHVsZTonbm9Nb2R1bGUnLG5vbmNlOidub25jZScsbm92YWxpZGF0ZTonbm9WYWxpZGF0ZScsb3Blbjonb3Blbicsb3B0aW11bTonb3B0aW11bScscGF0dGVybjoncGF0dGVybicscGxhY2Vob2xkZXI6J3BsYWNlaG9sZGVyJyxwbGF5c2lubGluZToncGxheXNJbmxpbmUnLHBvc3RlcjoncG9zdGVyJyxwcmVsb2FkOidwcmVsb2FkJyxwcm9maWxlOidwcm9maWxlJyxyYWRpb2dyb3VwOidyYWRpb0dyb3VwJyxyZWFkb25seToncmVhZE9ubHknLHJlZmVycmVycG9saWN5OidyZWZlcnJlclBvbGljeScscmVsOidyZWwnLHJlcXVpcmVkOidyZXF1aXJlZCcscmV2ZXJzZWQ6J3JldmVyc2VkJyxyb2xlOidyb2xlJyxyb3dzOidyb3dzJyxyb3dzcGFuOidyb3dTcGFuJyxzYW5kYm94OidzYW5kYm94JyxzY29wZTonc2NvcGUnLHNjb3BlZDonc2NvcGVkJyxzY3JvbGxpbmc6J3Njcm9sbGluZycsc2VhbWxlc3M6J3NlYW1sZXNzJyxzZWxlY3RlZDonc2VsZWN0ZWQnLHNoYXBlOidzaGFwZScsc2l6ZTonc2l6ZScsc2l6ZXM6J3NpemVzJyxzcGFuOidzcGFuJyxzcGVsbGNoZWNrOidzcGVsbENoZWNrJyxzcmM6J3NyYycsc3JjZG9jOidzcmNEb2MnLHNyY2xhbmc6J3NyY0xhbmcnLHNyY3NldDonc3JjU2V0JyxzdGFydDonc3RhcnQnLHN0ZXA6J3N0ZXAnLHN0eWxlOidzdHlsZScsc3VtbWFyeTonc3VtbWFyeScsdGFiaW5kZXg6J3RhYkluZGV4Jyx0YXJnZXQ6J3RhcmdldCcsdGl0bGU6J3RpdGxlJyx0eXBlOid0eXBlJyx1c2VtYXA6J3VzZU1hcCcsdmFsdWU6J3ZhbHVlJyx3aWR0aDond2lkdGgnLHdtb2RlOid3bW9kZScsd3JhcDond3JhcCcsLy8gU1ZHXG5hYm91dDonYWJvdXQnLGFjY2VudGhlaWdodDonYWNjZW50SGVpZ2h0JywnYWNjZW50LWhlaWdodCc6J2FjY2VudEhlaWdodCcsYWNjdW11bGF0ZTonYWNjdW11bGF0ZScsYWRkaXRpdmU6J2FkZGl0aXZlJyxhbGlnbm1lbnRiYXNlbGluZTonYWxpZ25tZW50QmFzZWxpbmUnLCdhbGlnbm1lbnQtYmFzZWxpbmUnOidhbGlnbm1lbnRCYXNlbGluZScsYWxsb3dyZW9yZGVyOidhbGxvd1Jlb3JkZXInLGFscGhhYmV0aWM6J2FscGhhYmV0aWMnLGFtcGxpdHVkZTonYW1wbGl0dWRlJyxhcmFiaWNmb3JtOidhcmFiaWNGb3JtJywnYXJhYmljLWZvcm0nOidhcmFiaWNGb3JtJyxhc2NlbnQ6J2FzY2VudCcsYXR0cmlidXRlbmFtZTonYXR0cmlidXRlTmFtZScsYXR0cmlidXRldHlwZTonYXR0cmlidXRlVHlwZScsYXV0b3JldmVyc2U6J2F1dG9SZXZlcnNlJyxhemltdXRoOidhemltdXRoJyxiYXNlZnJlcXVlbmN5OidiYXNlRnJlcXVlbmN5JyxiYXNlbGluZXNoaWZ0OidiYXNlbGluZVNoaWZ0JywnYmFzZWxpbmUtc2hpZnQnOidiYXNlbGluZVNoaWZ0JyxiYXNlcHJvZmlsZTonYmFzZVByb2ZpbGUnLGJib3g6J2Jib3gnLGJlZ2luOidiZWdpbicsYmlhczonYmlhcycsYnk6J2J5JyxjYWxjbW9kZTonY2FsY01vZGUnLGNhcGhlaWdodDonY2FwSGVpZ2h0JywnY2FwLWhlaWdodCc6J2NhcEhlaWdodCcsY2xpcDonY2xpcCcsY2xpcHBhdGg6J2NsaXBQYXRoJywnY2xpcC1wYXRoJzonY2xpcFBhdGgnLGNsaXBwYXRodW5pdHM6J2NsaXBQYXRoVW5pdHMnLGNsaXBydWxlOidjbGlwUnVsZScsJ2NsaXAtcnVsZSc6J2NsaXBSdWxlJyxjb2xvcjonY29sb3InLGNvbG9yaW50ZXJwb2xhdGlvbjonY29sb3JJbnRlcnBvbGF0aW9uJywnY29sb3ItaW50ZXJwb2xhdGlvbic6J2NvbG9ySW50ZXJwb2xhdGlvbicsY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczonY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6J2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLGNvbG9ycHJvZmlsZTonY29sb3JQcm9maWxlJywnY29sb3ItcHJvZmlsZSc6J2NvbG9yUHJvZmlsZScsY29sb3JyZW5kZXJpbmc6J2NvbG9yUmVuZGVyaW5nJywnY29sb3ItcmVuZGVyaW5nJzonY29sb3JSZW5kZXJpbmcnLGNvbnRlbnRzY3JpcHR0eXBlOidjb250ZW50U2NyaXB0VHlwZScsY29udGVudHN0eWxldHlwZTonY29udGVudFN0eWxlVHlwZScsY3Vyc29yOidjdXJzb3InLGN4OidjeCcsY3k6J2N5JyxkOidkJyxkYXRhdHlwZTonZGF0YXR5cGUnLGRlY2VsZXJhdGU6J2RlY2VsZXJhdGUnLGRlc2NlbnQ6J2Rlc2NlbnQnLGRpZmZ1c2Vjb25zdGFudDonZGlmZnVzZUNvbnN0YW50JyxkaXJlY3Rpb246J2RpcmVjdGlvbicsZGlzcGxheTonZGlzcGxheScsZGl2aXNvcjonZGl2aXNvcicsZG9taW5hbnRiYXNlbGluZTonZG9taW5hbnRCYXNlbGluZScsJ2RvbWluYW50LWJhc2VsaW5lJzonZG9taW5hbnRCYXNlbGluZScsZHVyOidkdXInLGR4OidkeCcsZHk6J2R5JyxlZGdlbW9kZTonZWRnZU1vZGUnLGVsZXZhdGlvbjonZWxldmF0aW9uJyxlbmFibGViYWNrZ3JvdW5kOidlbmFibGVCYWNrZ3JvdW5kJywnZW5hYmxlLWJhY2tncm91bmQnOidlbmFibGVCYWNrZ3JvdW5kJyxlbmQ6J2VuZCcsZXhwb25lbnQ6J2V4cG9uZW50JyxleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOidleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxmaWxsOidmaWxsJyxmaWxsb3BhY2l0eTonZmlsbE9wYWNpdHknLCdmaWxsLW9wYWNpdHknOidmaWxsT3BhY2l0eScsZmlsbHJ1bGU6J2ZpbGxSdWxlJywnZmlsbC1ydWxlJzonZmlsbFJ1bGUnLGZpbHRlcjonZmlsdGVyJyxmaWx0ZXJyZXM6J2ZpbHRlclJlcycsZmlsdGVydW5pdHM6J2ZpbHRlclVuaXRzJyxmbG9vZG9wYWNpdHk6J2Zsb29kT3BhY2l0eScsJ2Zsb29kLW9wYWNpdHknOidmbG9vZE9wYWNpdHknLGZsb29kY29sb3I6J2Zsb29kQ29sb3InLCdmbG9vZC1jb2xvcic6J2Zsb29kQ29sb3InLGZvY3VzYWJsZTonZm9jdXNhYmxlJyxmb250ZmFtaWx5Oidmb250RmFtaWx5JywnZm9udC1mYW1pbHknOidmb250RmFtaWx5Jyxmb250c2l6ZTonZm9udFNpemUnLCdmb250LXNpemUnOidmb250U2l6ZScsZm9udHNpemVhZGp1c3Q6J2ZvbnRTaXplQWRqdXN0JywnZm9udC1zaXplLWFkanVzdCc6J2ZvbnRTaXplQWRqdXN0Jyxmb250c3RyZXRjaDonZm9udFN0cmV0Y2gnLCdmb250LXN0cmV0Y2gnOidmb250U3RyZXRjaCcsZm9udHN0eWxlOidmb250U3R5bGUnLCdmb250LXN0eWxlJzonZm9udFN0eWxlJyxmb250dmFyaWFudDonZm9udFZhcmlhbnQnLCdmb250LXZhcmlhbnQnOidmb250VmFyaWFudCcsZm9udHdlaWdodDonZm9udFdlaWdodCcsJ2ZvbnQtd2VpZ2h0JzonZm9udFdlaWdodCcsZm9ybWF0Oidmb3JtYXQnLGZyb206J2Zyb20nLGZ4OidmeCcsZnk6J2Z5JyxnMTonZzEnLGcyOidnMicsZ2x5cGhuYW1lOidnbHlwaE5hbWUnLCdnbHlwaC1uYW1lJzonZ2x5cGhOYW1lJyxnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDonZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLCdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzonZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDonZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJywnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOidnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLGdseXBocmVmOidnbHlwaFJlZicsZ3JhZGllbnR0cmFuc2Zvcm06J2dyYWRpZW50VHJhbnNmb3JtJyxncmFkaWVudHVuaXRzOidncmFkaWVudFVuaXRzJyxoYW5naW5nOidoYW5naW5nJyxob3JpemFkdng6J2hvcml6QWR2WCcsJ2hvcml6LWFkdi14JzonaG9yaXpBZHZYJyxob3Jpem9yaWdpbng6J2hvcml6T3JpZ2luWCcsJ2hvcml6LW9yaWdpbi14JzonaG9yaXpPcmlnaW5YJyxpZGVvZ3JhcGhpYzonaWRlb2dyYXBoaWMnLGltYWdlcmVuZGVyaW5nOidpbWFnZVJlbmRlcmluZycsJ2ltYWdlLXJlbmRlcmluZyc6J2ltYWdlUmVuZGVyaW5nJyxpbjI6J2luMicsaW46J2luJyxpbmxpc3Q6J2lubGlzdCcsaW50ZXJjZXB0OidpbnRlcmNlcHQnLGsxOidrMScsazI6J2syJyxrMzonazMnLGs0OidrNCcsazonaycsa2VybmVsbWF0cml4OidrZXJuZWxNYXRyaXgnLGtlcm5lbHVuaXRsZW5ndGg6J2tlcm5lbFVuaXRMZW5ndGgnLGtlcm5pbmc6J2tlcm5pbmcnLGtleXBvaW50czona2V5UG9pbnRzJyxrZXlzcGxpbmVzOidrZXlTcGxpbmVzJyxrZXl0aW1lczona2V5VGltZXMnLGxlbmd0aGFkanVzdDonbGVuZ3RoQWRqdXN0JyxsZXR0ZXJzcGFjaW5nOidsZXR0ZXJTcGFjaW5nJywnbGV0dGVyLXNwYWNpbmcnOidsZXR0ZXJTcGFjaW5nJyxsaWdodGluZ2NvbG9yOidsaWdodGluZ0NvbG9yJywnbGlnaHRpbmctY29sb3InOidsaWdodGluZ0NvbG9yJyxsaW1pdGluZ2NvbmVhbmdsZTonbGltaXRpbmdDb25lQW5nbGUnLGxvY2FsOidsb2NhbCcsbWFya2VyZW5kOidtYXJrZXJFbmQnLCdtYXJrZXItZW5kJzonbWFya2VyRW5kJyxtYXJrZXJoZWlnaHQ6J21hcmtlckhlaWdodCcsbWFya2VybWlkOidtYXJrZXJNaWQnLCdtYXJrZXItbWlkJzonbWFya2VyTWlkJyxtYXJrZXJzdGFydDonbWFya2VyU3RhcnQnLCdtYXJrZXItc3RhcnQnOidtYXJrZXJTdGFydCcsbWFya2VydW5pdHM6J21hcmtlclVuaXRzJyxtYXJrZXJ3aWR0aDonbWFya2VyV2lkdGgnLG1hc2s6J21hc2snLG1hc2tjb250ZW50dW5pdHM6J21hc2tDb250ZW50VW5pdHMnLG1hc2t1bml0czonbWFza1VuaXRzJyxtYXRoZW1hdGljYWw6J21hdGhlbWF0aWNhbCcsbW9kZTonbW9kZScsbnVtb2N0YXZlczonbnVtT2N0YXZlcycsb2Zmc2V0OidvZmZzZXQnLG9wYWNpdHk6J29wYWNpdHknLG9wZXJhdG9yOidvcGVyYXRvcicsb3JkZXI6J29yZGVyJyxvcmllbnQ6J29yaWVudCcsb3JpZW50YXRpb246J29yaWVudGF0aW9uJyxvcmlnaW46J29yaWdpbicsb3ZlcmZsb3c6J292ZXJmbG93JyxvdmVybGluZXBvc2l0aW9uOidvdmVybGluZVBvc2l0aW9uJywnb3ZlcmxpbmUtcG9zaXRpb24nOidvdmVybGluZVBvc2l0aW9uJyxvdmVybGluZXRoaWNrbmVzczonb3ZlcmxpbmVUaGlja25lc3MnLCdvdmVybGluZS10aGlja25lc3MnOidvdmVybGluZVRoaWNrbmVzcycscGFpbnRvcmRlcjoncGFpbnRPcmRlcicsJ3BhaW50LW9yZGVyJzoncGFpbnRPcmRlcicscGFub3NlMToncGFub3NlMScsJ3Bhbm9zZS0xJzoncGFub3NlMScscGF0aGxlbmd0aDoncGF0aExlbmd0aCcscGF0dGVybmNvbnRlbnR1bml0czoncGF0dGVybkNvbnRlbnRVbml0cycscGF0dGVybnRyYW5zZm9ybToncGF0dGVyblRyYW5zZm9ybScscGF0dGVybnVuaXRzOidwYXR0ZXJuVW5pdHMnLHBvaW50ZXJldmVudHM6J3BvaW50ZXJFdmVudHMnLCdwb2ludGVyLWV2ZW50cyc6J3BvaW50ZXJFdmVudHMnLHBvaW50czoncG9pbnRzJyxwb2ludHNhdHg6J3BvaW50c0F0WCcscG9pbnRzYXR5Oidwb2ludHNBdFknLHBvaW50c2F0ejoncG9pbnRzQXRaJyxwcmVmaXg6J3ByZWZpeCcscHJlc2VydmVhbHBoYToncHJlc2VydmVBbHBoYScscHJlc2VydmVhc3BlY3RyYXRpbzoncHJlc2VydmVBc3BlY3RSYXRpbycscHJpbWl0aXZldW5pdHM6J3ByaW1pdGl2ZVVuaXRzJyxwcm9wZXJ0eToncHJvcGVydHknLHI6J3InLHJhZGl1czoncmFkaXVzJyxyZWZ4OidyZWZYJyxyZWZ5OidyZWZZJyxyZW5kZXJpbmdpbnRlbnQ6J3JlbmRlcmluZ0ludGVudCcsJ3JlbmRlcmluZy1pbnRlbnQnOidyZW5kZXJpbmdJbnRlbnQnLHJlcGVhdGNvdW50OidyZXBlYXRDb3VudCcscmVwZWF0ZHVyOidyZXBlYXREdXInLHJlcXVpcmVkZXh0ZW5zaW9uczoncmVxdWlyZWRFeHRlbnNpb25zJyxyZXF1aXJlZGZlYXR1cmVzOidyZXF1aXJlZEZlYXR1cmVzJyxyZXNvdXJjZToncmVzb3VyY2UnLHJlc3RhcnQ6J3Jlc3RhcnQnLHJlc3VsdDoncmVzdWx0JyxyZXN1bHRzOidyZXN1bHRzJyxyb3RhdGU6J3JvdGF0ZScscng6J3J4JyxyeToncnknLHNjYWxlOidzY2FsZScsc2VjdXJpdHk6J3NlY3VyaXR5JyxzZWVkOidzZWVkJyxzaGFwZXJlbmRlcmluZzonc2hhcGVSZW5kZXJpbmcnLCdzaGFwZS1yZW5kZXJpbmcnOidzaGFwZVJlbmRlcmluZycsc2xvcGU6J3Nsb3BlJyxzcGFjaW5nOidzcGFjaW5nJyxzcGVjdWxhcmNvbnN0YW50OidzcGVjdWxhckNvbnN0YW50JyxzcGVjdWxhcmV4cG9uZW50OidzcGVjdWxhckV4cG9uZW50JyxzcGVlZDonc3BlZWQnLHNwcmVhZG1ldGhvZDonc3ByZWFkTWV0aG9kJyxzdGFydG9mZnNldDonc3RhcnRPZmZzZXQnLHN0ZGRldmlhdGlvbjonc3RkRGV2aWF0aW9uJyxzdGVtaDonc3RlbWgnLHN0ZW12OidzdGVtdicsc3RpdGNodGlsZXM6J3N0aXRjaFRpbGVzJyxzdG9wY29sb3I6J3N0b3BDb2xvcicsJ3N0b3AtY29sb3InOidzdG9wQ29sb3InLHN0b3BvcGFjaXR5OidzdG9wT3BhY2l0eScsJ3N0b3Atb3BhY2l0eSc6J3N0b3BPcGFjaXR5JyxzdHJpa2V0aHJvdWdocG9zaXRpb246J3N0cmlrZXRocm91Z2hQb3NpdGlvbicsJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOidzdHJpa2V0aHJvdWdoUG9zaXRpb24nLHN0cmlrZXRocm91Z2h0aGlja25lc3M6J3N0cmlrZXRocm91Z2hUaGlja25lc3MnLCdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6J3N0cmlrZXRocm91Z2hUaGlja25lc3MnLHN0cmluZzonc3RyaW5nJyxzdHJva2U6J3N0cm9rZScsc3Ryb2tlZGFzaGFycmF5OidzdHJva2VEYXNoYXJyYXknLCdzdHJva2UtZGFzaGFycmF5Jzonc3Ryb2tlRGFzaGFycmF5JyxzdHJva2VkYXNob2Zmc2V0OidzdHJva2VEYXNob2Zmc2V0Jywnc3Ryb2tlLWRhc2hvZmZzZXQnOidzdHJva2VEYXNob2Zmc2V0JyxzdHJva2VsaW5lY2FwOidzdHJva2VMaW5lY2FwJywnc3Ryb2tlLWxpbmVjYXAnOidzdHJva2VMaW5lY2FwJyxzdHJva2VsaW5lam9pbjonc3Ryb2tlTGluZWpvaW4nLCdzdHJva2UtbGluZWpvaW4nOidzdHJva2VMaW5lam9pbicsc3Ryb2tlbWl0ZXJsaW1pdDonc3Ryb2tlTWl0ZXJsaW1pdCcsJ3N0cm9rZS1taXRlcmxpbWl0Jzonc3Ryb2tlTWl0ZXJsaW1pdCcsc3Ryb2tld2lkdGg6J3N0cm9rZVdpZHRoJywnc3Ryb2tlLXdpZHRoJzonc3Ryb2tlV2lkdGgnLHN0cm9rZW9wYWNpdHk6J3N0cm9rZU9wYWNpdHknLCdzdHJva2Utb3BhY2l0eSc6J3N0cm9rZU9wYWNpdHknLHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzonc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6J3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsc3VyZmFjZXNjYWxlOidzdXJmYWNlU2NhbGUnLHN5c3RlbWxhbmd1YWdlOidzeXN0ZW1MYW5ndWFnZScsdGFibGV2YWx1ZXM6J3RhYmxlVmFsdWVzJyx0YXJnZXR4Oid0YXJnZXRYJyx0YXJnZXR5Oid0YXJnZXRZJyx0ZXh0YW5jaG9yOid0ZXh0QW5jaG9yJywndGV4dC1hbmNob3InOid0ZXh0QW5jaG9yJyx0ZXh0ZGVjb3JhdGlvbjondGV4dERlY29yYXRpb24nLCd0ZXh0LWRlY29yYXRpb24nOid0ZXh0RGVjb3JhdGlvbicsdGV4dGxlbmd0aDondGV4dExlbmd0aCcsdGV4dHJlbmRlcmluZzondGV4dFJlbmRlcmluZycsJ3RleHQtcmVuZGVyaW5nJzondGV4dFJlbmRlcmluZycsdG86J3RvJyx0cmFuc2Zvcm06J3RyYW5zZm9ybScsdHlwZW9mOid0eXBlb2YnLHUxOid1MScsdTI6J3UyJyx1bmRlcmxpbmVwb3NpdGlvbjondW5kZXJsaW5lUG9zaXRpb24nLCd1bmRlcmxpbmUtcG9zaXRpb24nOid1bmRlcmxpbmVQb3NpdGlvbicsdW5kZXJsaW5ldGhpY2tuZXNzOid1bmRlcmxpbmVUaGlja25lc3MnLCd1bmRlcmxpbmUtdGhpY2tuZXNzJzondW5kZXJsaW5lVGhpY2tuZXNzJyx1bmljb2RlOid1bmljb2RlJyx1bmljb2RlYmlkaTondW5pY29kZUJpZGknLCd1bmljb2RlLWJpZGknOid1bmljb2RlQmlkaScsdW5pY29kZXJhbmdlOid1bmljb2RlUmFuZ2UnLCd1bmljb2RlLXJhbmdlJzondW5pY29kZVJhbmdlJyx1bml0c3BlcmVtOid1bml0c1BlckVtJywndW5pdHMtcGVyLWVtJzondW5pdHNQZXJFbScsdW5zZWxlY3RhYmxlOid1bnNlbGVjdGFibGUnLHZhbHBoYWJldGljOid2QWxwaGFiZXRpYycsJ3YtYWxwaGFiZXRpYyc6J3ZBbHBoYWJldGljJyx2YWx1ZXM6J3ZhbHVlcycsdmVjdG9yZWZmZWN0Oid2ZWN0b3JFZmZlY3QnLCd2ZWN0b3ItZWZmZWN0JzondmVjdG9yRWZmZWN0Jyx2ZXJzaW9uOid2ZXJzaW9uJyx2ZXJ0YWR2eTondmVydEFkdlknLCd2ZXJ0LWFkdi15JzondmVydEFkdlknLHZlcnRvcmlnaW54Oid2ZXJ0T3JpZ2luWCcsJ3ZlcnQtb3JpZ2luLXgnOid2ZXJ0T3JpZ2luWCcsdmVydG9yaWdpbnk6J3ZlcnRPcmlnaW5ZJywndmVydC1vcmlnaW4teSc6J3ZlcnRPcmlnaW5ZJyx2aGFuZ2luZzondkhhbmdpbmcnLCd2LWhhbmdpbmcnOid2SGFuZ2luZycsdmlkZW9ncmFwaGljOid2SWRlb2dyYXBoaWMnLCd2LWlkZW9ncmFwaGljJzondklkZW9ncmFwaGljJyx2aWV3Ym94Oid2aWV3Qm94Jyx2aWV3dGFyZ2V0Oid2aWV3VGFyZ2V0Jyx2aXNpYmlsaXR5Oid2aXNpYmlsaXR5Jyx2bWF0aGVtYXRpY2FsOid2TWF0aGVtYXRpY2FsJywndi1tYXRoZW1hdGljYWwnOid2TWF0aGVtYXRpY2FsJyx2b2NhYjondm9jYWInLHdpZHRoczond2lkdGhzJyx3b3Jkc3BhY2luZzond29yZFNwYWNpbmcnLCd3b3JkLXNwYWNpbmcnOid3b3JkU3BhY2luZycsd3JpdGluZ21vZGU6J3dyaXRpbmdNb2RlJywnd3JpdGluZy1tb2RlJzond3JpdGluZ01vZGUnLHgxOid4MScseDI6J3gyJyx4Oid4Jyx4Y2hhbm5lbHNlbGVjdG9yOid4Q2hhbm5lbFNlbGVjdG9yJyx4aGVpZ2h0Oid4SGVpZ2h0JywneC1oZWlnaHQnOid4SGVpZ2h0Jyx4bGlua2FjdHVhdGU6J3hsaW5rQWN0dWF0ZScsJ3hsaW5rOmFjdHVhdGUnOid4bGlua0FjdHVhdGUnLHhsaW5rYXJjcm9sZToneGxpbmtBcmNyb2xlJywneGxpbms6YXJjcm9sZSc6J3hsaW5rQXJjcm9sZScseGxpbmtocmVmOid4bGlua0hyZWYnLCd4bGluazpocmVmJzoneGxpbmtIcmVmJyx4bGlua3JvbGU6J3hsaW5rUm9sZScsJ3hsaW5rOnJvbGUnOid4bGlua1JvbGUnLHhsaW5rc2hvdzoneGxpbmtTaG93JywneGxpbms6c2hvdyc6J3hsaW5rU2hvdycseGxpbmt0aXRsZToneGxpbmtUaXRsZScsJ3hsaW5rOnRpdGxlJzoneGxpbmtUaXRsZScseGxpbmt0eXBlOid4bGlua1R5cGUnLCd4bGluazp0eXBlJzoneGxpbmtUeXBlJyx4bWxiYXNlOid4bWxCYXNlJywneG1sOmJhc2UnOid4bWxCYXNlJyx4bWxsYW5nOid4bWxMYW5nJywneG1sOmxhbmcnOid4bWxMYW5nJyx4bWxuczoneG1sbnMnLCd4bWw6c3BhY2UnOid4bWxTcGFjZScseG1sbnN4bGluazoneG1sbnNYbGluaycsJ3htbG5zOnhsaW5rJzoneG1sbnNYbGluaycseG1sc3BhY2U6J3htbFNwYWNlJyx5MToneTEnLHkyOid5MicseToneScseWNoYW5uZWxzZWxlY3RvcjoneUNoYW5uZWxTZWxlY3Rvcicsejoneicsem9vbWFuZHBhbjonem9vbUFuZFBhbid9O3ZhciBhcmlhUHJvcGVydGllcz17J2FyaWEtY3VycmVudCc6MCwvLyBzdGF0ZVxuJ2FyaWEtZGVzY3JpcHRpb24nOjAsJ2FyaWEtZGV0YWlscyc6MCwnYXJpYS1kaXNhYmxlZCc6MCwvLyBzdGF0ZVxuJ2FyaWEtaGlkZGVuJzowLC8vIHN0YXRlXG4nYXJpYS1pbnZhbGlkJzowLC8vIHN0YXRlXG4nYXJpYS1rZXlzaG9ydGN1dHMnOjAsJ2FyaWEtbGFiZWwnOjAsJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzowLC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4nYXJpYS1hdXRvY29tcGxldGUnOjAsJ2FyaWEtY2hlY2tlZCc6MCwnYXJpYS1leHBhbmRlZCc6MCwnYXJpYS1oYXNwb3B1cCc6MCwnYXJpYS1sZXZlbCc6MCwnYXJpYS1tb2RhbCc6MCwnYXJpYS1tdWx0aWxpbmUnOjAsJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzowLCdhcmlhLW9yaWVudGF0aW9uJzowLCdhcmlhLXBsYWNlaG9sZGVyJzowLCdhcmlhLXByZXNzZWQnOjAsJ2FyaWEtcmVhZG9ubHknOjAsJ2FyaWEtcmVxdWlyZWQnOjAsJ2FyaWEtc2VsZWN0ZWQnOjAsJ2FyaWEtc29ydCc6MCwnYXJpYS12YWx1ZW1heCc6MCwnYXJpYS12YWx1ZW1pbic6MCwnYXJpYS12YWx1ZW5vdyc6MCwnYXJpYS12YWx1ZXRleHQnOjAsLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuJ2FyaWEtYXRvbWljJzowLCdhcmlhLWJ1c3knOjAsJ2FyaWEtbGl2ZSc6MCwnYXJpYS1yZWxldmFudCc6MCwvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbidhcmlhLWRyb3BlZmZlY3QnOjAsJ2FyaWEtZ3JhYmJlZCc6MCwvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6MCwnYXJpYS1jb2xjb3VudCc6MCwnYXJpYS1jb2xpbmRleCc6MCwnYXJpYS1jb2xzcGFuJzowLCdhcmlhLWNvbnRyb2xzJzowLCdhcmlhLWRlc2NyaWJlZGJ5JzowLCdhcmlhLWVycm9ybWVzc2FnZSc6MCwnYXJpYS1mbG93dG8nOjAsJ2FyaWEtbGFiZWxsZWRieSc6MCwnYXJpYS1vd25zJzowLCdhcmlhLXBvc2luc2V0JzowLCdhcmlhLXJvd2NvdW50JzowLCdhcmlhLXJvd2luZGV4JzowLCdhcmlhLXJvd3NwYW4nOjAsJ2FyaWEtc2V0c2l6ZSc6MH07dmFyIHdhcm5lZFByb3BlcnRpZXM9e307dmFyIHJBUklBPW5ldyBSZWdFeHAoJ14oYXJpYSktWycrQVRUUklCVVRFX05BTUVfQ0hBUisnXSokJyk7dmFyIHJBUklBQ2FtZWw9bmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycrQVRUUklCVVRFX05BTUVfQ0hBUisnXSokJyk7ZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLG5hbWUpe3tpZihoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsbmFtZSkmJndhcm5lZFByb3BlcnRpZXNbbmFtZV0pe3JldHVybiB0cnVlO31pZihyQVJJQUNhbWVsLnRlc3QobmFtZSkpe3ZhciBhcmlhTmFtZT0nYXJpYS0nK25hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTt2YXIgY29ycmVjdE5hbWU9YXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpP2FyaWFOYW1lOm51bGw7Ly8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4vLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5pZihjb3JyZWN0TmFtZT09bnVsbCl7ZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsbmFtZSk7d2FybmVkUHJvcGVydGllc1tuYW1lXT10cnVlO3JldHVybiB0cnVlO30vLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbmlmKG5hbWUhPT1jb3JyZWN0TmFtZSl7ZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JyxuYW1lLGNvcnJlY3ROYW1lKTt3YXJuZWRQcm9wZXJ0aWVzW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fX1pZihyQVJJQS50ZXN0KG5hbWUpKXt2YXIgbG93ZXJDYXNlZE5hbWU9bmFtZS50b0xvd2VyQ2FzZSgpO3ZhciBzdGFuZGFyZE5hbWU9YXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpP2xvd2VyQ2FzZWROYW1lOm51bGw7Ly8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4vLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5pZihzdGFuZGFyZE5hbWU9PW51bGwpe3dhcm5lZFByb3BlcnRpZXNbbmFtZV09dHJ1ZTtyZXR1cm4gZmFsc2U7fS8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuaWYobmFtZSE9PXN0YW5kYXJkTmFtZSl7ZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JyxuYW1lLHN0YW5kYXJkTmFtZSk7d2FybmVkUHJvcGVydGllc1tuYW1lXT10cnVlO3JldHVybiB0cnVlO319fXJldHVybiB0cnVlO31mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLHByb3BzKXt7dmFyIGludmFsaWRQcm9wcz1bXTtmb3IodmFyIGtleSBpbiBwcm9wcyl7dmFyIGlzVmFsaWQ9dmFsaWRhdGVQcm9wZXJ0eSh0eXBlLGtleSk7aWYoIWlzVmFsaWQpe2ludmFsaWRQcm9wcy5wdXNoKGtleSk7fX12YXIgdW5rbm93blByb3BTdHJpbmc9aW52YWxpZFByb3BzLm1hcChmdW5jdGlvbihwcm9wKXtyZXR1cm4nYCcrcHJvcCsnYCc7fSkuam9pbignLCAnKTtpZihpbnZhbGlkUHJvcHMubGVuZ3RoPT09MSl7ZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnKydGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLHVua25vd25Qcm9wU3RyaW5nLHR5cGUpO31lbHNlIGlmKGludmFsaWRQcm9wcy5sZW5ndGg+MSl7ZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJysnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJyx1bmtub3duUHJvcFN0cmluZyx0eXBlKTt9fX1mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSxwcm9wcyl7aWYoaXNDdXN0b21Db21wb25lbnQodHlwZSxwcm9wcykpe3JldHVybjt9d2FybkludmFsaWRBUklBUHJvcHModHlwZSxwcm9wcyk7fXZhciBkaWRXYXJuVmFsdWVOdWxsPWZhbHNlO2Z1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUscHJvcHMpe3tpZih0eXBlIT09J2lucHV0JyYmdHlwZSE9PSd0ZXh0YXJlYScmJnR5cGUhPT0nc2VsZWN0Jyl7cmV0dXJuO31pZihwcm9wcyE9bnVsbCYmcHJvcHMudmFsdWU9PT1udWxsJiYhZGlkV2FyblZhbHVlTnVsbCl7ZGlkV2FyblZhbHVlTnVsbD10cnVlO2lmKHR5cGU9PT0nc2VsZWN0JyYmcHJvcHMubXVsdGlwbGUpe2Vycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcrJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcrJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsdHlwZSk7fWVsc2V7ZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJysnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJysnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsdHlwZSk7fX19fXZhciB2YWxpZGF0ZVByb3BlcnR5JDE9ZnVuY3Rpb24oKXt9O3t2YXIgd2FybmVkUHJvcGVydGllcyQxPXt9O3ZhciBFVkVOVF9OQU1FX1JFR0VYPS9eb24uLzt2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYPS9eb25bXkEtWl0vO3ZhciByQVJJQSQxPW5ldyBSZWdFeHAoJ14oYXJpYSktWycrQVRUUklCVVRFX05BTUVfQ0hBUisnXSokJyk7dmFyIHJBUklBQ2FtZWwkMT1uZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJytBVFRSSUJVVEVfTkFNRV9DSEFSKyddKiQnKTt2YWxpZGF0ZVByb3BlcnR5JDE9ZnVuY3Rpb24odGFnTmFtZSxuYW1lLHZhbHVlLGV2ZW50UmVnaXN0cnkpe2lmKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLG5hbWUpJiZ3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pe3JldHVybiB0cnVlO312YXIgbG93ZXJDYXNlZE5hbWU9bmFtZS50b0xvd2VyQ2FzZSgpO2lmKGxvd2VyQ2FzZWROYW1lPT09J29uZm9jdXNpbid8fGxvd2VyQ2FzZWROYW1lPT09J29uZm9jdXNvdXQnKXtlcnJvcignUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcrJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJysnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO30vLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cbmlmKGV2ZW50UmVnaXN0cnkhPW51bGwpe3ZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzPWV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzPWV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztpZihyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKXtyZXR1cm4gdHJ1ZTt9dmFyIHJlZ2lzdHJhdGlvbk5hbWU9cG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSk/cG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV06bnVsbDtpZihyZWdpc3RyYXRpb25OYW1lIT1udWxsKXtlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsbmFtZSxyZWdpc3RyYXRpb25OYW1lKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9aWYoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKXtlcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC4nLG5hbWUpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO319ZWxzZSBpZihFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpey8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4vLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4vLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG5pZihJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSl7ZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnKydSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLG5hbWUpO313YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9Ly8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuaWYockFSSUEkMS50ZXN0KG5hbWUpfHxyQVJJQUNhbWVsJDEudGVzdChuYW1lKSl7cmV0dXJuIHRydWU7fWlmKGxvd2VyQ2FzZWROYW1lPT09J2lubmVyaHRtbCcpe2Vycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcrJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO31pZihsb3dlckNhc2VkTmFtZT09PSdhcmlhJyl7ZXJyb3IoJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnKydQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fWlmKGxvd2VyQ2FzZWROYW1lPT09J2lzJyYmdmFsdWUhPT1udWxsJiZ2YWx1ZSE9PXVuZGVmaW5lZCYmdHlwZW9mIHZhbHVlIT09J3N0cmluZycpe2Vycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcrJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLHR5cGVvZiB2YWx1ZSk7d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fWlmKHR5cGVvZiB2YWx1ZT09PSdudW1iZXInJiZpc05hTih2YWx1ZSkpe2Vycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnKyd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJyxuYW1lKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9dmFyIHByb3BlcnR5SW5mbz1nZXRQcm9wZXJ0eUluZm8obmFtZSk7dmFyIGlzUmVzZXJ2ZWQ9cHJvcGVydHlJbmZvIT09bnVsbCYmcHJvcGVydHlJbmZvLnR5cGU9PT1SRVNFUlZFRDsvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuaWYocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSl7dmFyIHN0YW5kYXJkTmFtZT1wb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO2lmKHN0YW5kYXJkTmFtZSE9PW5hbWUpe2Vycm9yKCdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLG5hbWUsc3RhbmRhcmROYW1lKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9fWVsc2UgaWYoIWlzUmVzZXJ2ZWQmJm5hbWUhPT1sb3dlckNhc2VkTmFtZSl7Ly8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4vLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG5lcnJvcignUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcrJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnKydhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcrJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJysnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJyxuYW1lLGxvd2VyQ2FzZWROYW1lKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9aWYodHlwZW9mIHZhbHVlPT09J2Jvb2xlYW4nJiZzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLHZhbHVlLHByb3BlcnR5SW5mbyxmYWxzZSkpe2lmKHZhbHVlKXtlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nKydJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcrJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJyx2YWx1ZSxuYW1lLG5hbWUsdmFsdWUsbmFtZSk7fWVsc2V7ZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJysnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnKyclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicrJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnKydwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLHZhbHVlLG5hbWUsbmFtZSx2YWx1ZSxuYW1lLG5hbWUsbmFtZSk7fXdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO30vLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbi8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG5pZihpc1Jlc2VydmVkKXtyZXR1cm4gdHJ1ZTt9Ly8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbmlmKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsdmFsdWUscHJvcGVydHlJbmZvLGZhbHNlKSl7d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIGZhbHNlO30vLyBXYXJuIHdoZW4gcGFzc2luZyB0aGUgc3RyaW5ncyAnZmFsc2UnIG9yICd0cnVlJyBpbnRvIGEgYm9vbGVhbiBwcm9wXG5pZigodmFsdWU9PT0nZmFsc2UnfHx2YWx1ZT09PSd0cnVlJykmJnByb3BlcnR5SW5mbyE9PW51bGwmJnByb3BlcnR5SW5mby50eXBlPT09Qk9PTEVBTil7ZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcrJyVzICcrJ0RpZCB5b3UgbWVhbiAlcz17JXN9PycsdmFsdWUsbmFtZSx2YWx1ZT09PSdmYWxzZSc/J1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLic6J0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJyxuYW1lLHZhbHVlKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9cmV0dXJuIHRydWU7fTt9dmFyIHdhcm5Vbmtub3duUHJvcGVydGllcz1mdW5jdGlvbih0eXBlLHByb3BzLGV2ZW50UmVnaXN0cnkpe3t2YXIgdW5rbm93blByb3BzPVtdO2Zvcih2YXIga2V5IGluIHByb3BzKXt2YXIgaXNWYWxpZD12YWxpZGF0ZVByb3BlcnR5JDEodHlwZSxrZXkscHJvcHNba2V5XSxldmVudFJlZ2lzdHJ5KTtpZighaXNWYWxpZCl7dW5rbm93blByb3BzLnB1c2goa2V5KTt9fXZhciB1bmtub3duUHJvcFN0cmluZz11bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uKHByb3Ape3JldHVybidgJytwcm9wKydgJzt9KS5qb2luKCcsICcpO2lmKHVua25vd25Qcm9wcy5sZW5ndGg9PT0xKXtlcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnKydvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcrJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLHVua25vd25Qcm9wU3RyaW5nLHR5cGUpO31lbHNlIGlmKHVua25vd25Qcm9wcy5sZW5ndGg+MSl7ZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcrJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnKydGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJyx1bmtub3duUHJvcFN0cmluZyx0eXBlKTt9fX07ZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSxwcm9wcyxldmVudFJlZ2lzdHJ5KXtpZihpc0N1c3RvbUNvbXBvbmVudCh0eXBlLHByb3BzKSl7cmV0dXJuO313YXJuVW5rbm93blByb3BlcnRpZXModHlwZSxwcm9wcyxldmVudFJlZ2lzdHJ5KTt9dmFyIElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFPTE7dmFyIElTX05PTl9ERUxFR0FURUQ9MTw8MTt2YXIgSVNfQ0FQVFVSRV9QSEFTRT0xPDwyOy8vIHNldCB0byBMRUdBQ1lfRkJfU1VQUE9SVC4gTEVHQUNZX0ZCX1NVUFBPUlQgb25seSBnZXRzIHNldCB3aGVuXG4vLyB3ZSBjYWxsIHdpbGxEZWZlckxhdGVyRm9yTGVnYWN5RkJTdXBwb3J0LCB0aHVzIG5vdCBiYWlsaW5nIG91dFxuLy8gd2lsbCByZXN1bHQgaW4gZW5kbGVzcyBjeWNsZXMgbGlrZSBhbiBpbmZpbml0ZSBsb29wLlxuLy8gV2UgYWxzbyBkb24ndCB3YW50IHRvIGRlZmVyIGR1cmluZyBldmVudCByZXBsYXlpbmcuXG52YXIgU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlM9SVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREV8SVNfTk9OX0RFTEVHQVRFRHxJU19DQVBUVVJFX1BIQVNFOy8vIFRoaXMgZXhpc3RzIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBSZWFjdERPTUV2ZW50UmVwbGF5aW5nXG4vLyBhbmQgRE9NUGx1Z2luRXZlbnRTeXN0ZW0uXG52YXIgY3VycmVudFJlcGxheWluZ0V2ZW50PW51bGw7ZnVuY3Rpb24gc2V0UmVwbGF5aW5nRXZlbnQoZXZlbnQpe3tpZihjdXJyZW50UmVwbGF5aW5nRXZlbnQhPT1udWxsKXtlcnJvcignRXhwZWN0ZWQgY3VycmVudGx5IHJlcGxheWluZyBldmVudCB0byBiZSBudWxsLiBUaGlzIGVycm9yICcrJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319Y3VycmVudFJlcGxheWluZ0V2ZW50PWV2ZW50O31mdW5jdGlvbiByZXNldFJlcGxheWluZ0V2ZW50KCl7e2lmKGN1cnJlbnRSZXBsYXlpbmdFdmVudD09PW51bGwpe2Vycm9yKCdFeHBlY3RlZCBjdXJyZW50bHkgcmVwbGF5aW5nIGV2ZW50IHRvIG5vdCBiZSBudWxsLiBUaGlzIGVycm9yICcrJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319Y3VycmVudFJlcGxheWluZ0V2ZW50PW51bGw7fWZ1bmN0aW9uIGlzUmVwbGF5aW5nRXZlbnQoZXZlbnQpe3JldHVybiBldmVudD09PWN1cnJlbnRSZXBsYXlpbmdFdmVudDt9LyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL2Z1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KXsvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDZcbnZhciB0YXJnZXQ9bmF0aXZlRXZlbnQudGFyZ2V0fHxuYXRpdmVFdmVudC5zcmNFbGVtZW50fHx3aW5kb3c7Ly8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuaWYodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KXt0YXJnZXQ9dGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O30vLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbnJldHVybiB0YXJnZXQubm9kZVR5cGU9PT1URVhUX05PREU/dGFyZ2V0LnBhcmVudE5vZGU6dGFyZ2V0O312YXIgcmVzdG9yZUltcGw9bnVsbDt2YXIgcmVzdG9yZVRhcmdldD1udWxsO3ZhciByZXN0b3JlUXVldWU9bnVsbDtmdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpey8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2Vcbi8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbnZhciBpbnRlcm5hbEluc3RhbmNlPWdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtpZighaW50ZXJuYWxJbnN0YW5jZSl7Ly8gVW5tb3VudGVkXG5yZXR1cm47fWlmKHR5cGVvZiByZXN0b3JlSW1wbCE9PSdmdW5jdGlvbicpe3Rocm93IG5ldyBFcnJvcignc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKCkgbmVlZHMgdG8gYmUgY2FsbGVkIHRvIGhhbmRsZSBhIHRhcmdldCBmb3IgY29udHJvbGxlZCAnKydldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXZhciBzdGF0ZU5vZGU9aW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGU7Ly8gR3VhcmQgYWdhaW5zdCBGaWJlciBiZWluZyB1bm1vdW50ZWQuXG5pZihzdGF0ZU5vZGUpe3ZhciBfcHJvcHM9Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO3Jlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLGludGVybmFsSW5zdGFuY2UudHlwZSxfcHJvcHMpO319ZnVuY3Rpb24gc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKGltcGwpe3Jlc3RvcmVJbXBsPWltcGw7fWZ1bmN0aW9uIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KXtpZihyZXN0b3JlVGFyZ2V0KXtpZihyZXN0b3JlUXVldWUpe3Jlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7fWVsc2V7cmVzdG9yZVF1ZXVlPVt0YXJnZXRdO319ZWxzZXtyZXN0b3JlVGFyZ2V0PXRhcmdldDt9fWZ1bmN0aW9uIG5lZWRzU3RhdGVSZXN0b3JlKCl7cmV0dXJuIHJlc3RvcmVUYXJnZXQhPT1udWxsfHxyZXN0b3JlUXVldWUhPT1udWxsO31mdW5jdGlvbiByZXN0b3JlU3RhdGVJZk5lZWRlZCgpe2lmKCFyZXN0b3JlVGFyZ2V0KXtyZXR1cm47fXZhciB0YXJnZXQ9cmVzdG9yZVRhcmdldDt2YXIgcXVldWVkVGFyZ2V0cz1yZXN0b3JlUXVldWU7cmVzdG9yZVRhcmdldD1udWxsO3Jlc3RvcmVRdWV1ZT1udWxsO3Jlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7aWYocXVldWVkVGFyZ2V0cyl7Zm9yKHZhciBpPTA7aTxxdWV1ZWRUYXJnZXRzLmxlbmd0aDtpKyspe3Jlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO319fS8vIHRoZSByZW5kZXJlci4gU3VjaCBhcyB3aGVuIHdlJ3JlIGRpc3BhdGNoaW5nIGV2ZW50cyBvciBpZiB0aGlyZCBwYXJ0eVxuLy8gbGlicmFyaWVzIG5lZWQgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcy4gRXZlbnR1YWxseSwgdGhpcyBBUEkgd2lsbCBnbyBhd2F5IHdoZW5cbi8vIGV2ZXJ5dGhpbmcgaXMgYmF0Y2hlZCBieSBkZWZhdWx0LiBXZSdsbCB0aGVuIGhhdmUgYSBzaW1pbGFyIEFQSSB0byBvcHQtb3V0IG9mXG4vLyBzY2hlZHVsZWQgd29yayBhbmQgaW5zdGVhZCBkbyBzeW5jaHJvbm91cyB3b3JrLlxuLy8gRGVmYXVsdHNcbnZhciBiYXRjaGVkVXBkYXRlc0ltcGw9ZnVuY3Rpb24oZm4sYm9va2tlZXBpbmcpe3JldHVybiBmbihib29ra2VlcGluZyk7fTt2YXIgZmx1c2hTeW5jSW1wbD1mdW5jdGlvbigpe307dmFyIGlzSW5zaWRlRXZlbnRIYW5kbGVyPWZhbHNlO2Z1bmN0aW9uIGZpbmlzaEV2ZW50SGFuZGxlcigpey8vIEhlcmUgd2Ugd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuLy8gVGhlbiB3ZSByZXN0b3JlIHN0YXRlIG9mIGFueSBjb250cm9sbGVkIGNvbXBvbmVudC5cbnZhciBjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcz1uZWVkc1N0YXRlUmVzdG9yZSgpO2lmKGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzKXsvLyBJZiBhIGNvbnRyb2xsZWQgZXZlbnQgd2FzIGZpcmVkLCB3ZSBtYXkgbmVlZCB0byByZXN0b3JlIHRoZSBzdGF0ZSBvZlxuLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3Rcbi8vIGJhaWxzIG91dCBvZiB0aGUgdXBkYXRlIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbi8vIFRPRE86IFJlc3RvcmUgc3RhdGUgaW4gdGhlIG1pY3JvdGFzaywgYWZ0ZXIgdGhlIGRpc2NyZXRlIHVwZGF0ZXMgZmx1c2gsXG4vLyBpbnN0ZWFkIG9mIGVhcmx5IGZsdXNoaW5nIHRoZW0gaGVyZS5cbmZsdXNoU3luY0ltcGwoKTtyZXN0b3JlU3RhdGVJZk5lZWRlZCgpO319ZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sYSxiKXtpZihpc0luc2lkZUV2ZW50SGFuZGxlcil7Ly8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4vLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbnJldHVybiBmbihhLGIpO31pc0luc2lkZUV2ZW50SGFuZGxlcj10cnVlO3RyeXtyZXR1cm4gYmF0Y2hlZFVwZGF0ZXNJbXBsKGZuLGEsYik7fWZpbmFsbHl7aXNJbnNpZGVFdmVudEhhbmRsZXI9ZmFsc2U7ZmluaXNoRXZlbnRIYW5kbGVyKCk7fX0vLyBUT0RPOiBSZXBsYWNlIHdpdGggZmx1c2hTeW5jXG5mdW5jdGlvbiBzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKF9iYXRjaGVkVXBkYXRlc0ltcGwsX2Rpc2NyZXRlVXBkYXRlc0ltcGwsX2ZsdXNoU3luY0ltcGwpe2JhdGNoZWRVcGRhdGVzSW1wbD1fYmF0Y2hlZFVwZGF0ZXNJbXBsO2ZsdXNoU3luY0ltcGw9X2ZsdXNoU3luY0ltcGw7fWZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKXtyZXR1cm4gdGFnPT09J2J1dHRvbid8fHRhZz09PSdpbnB1dCd8fHRhZz09PSdzZWxlY3QnfHx0YWc9PT0ndGV4dGFyZWEnO31mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLHR5cGUscHJvcHMpe3N3aXRjaChuYW1lKXtjYXNlJ29uQ2xpY2snOmNhc2Unb25DbGlja0NhcHR1cmUnOmNhc2Unb25Eb3VibGVDbGljayc6Y2FzZSdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6Y2FzZSdvbk1vdXNlRG93bic6Y2FzZSdvbk1vdXNlRG93bkNhcHR1cmUnOmNhc2Unb25Nb3VzZU1vdmUnOmNhc2Unb25Nb3VzZU1vdmVDYXB0dXJlJzpjYXNlJ29uTW91c2VVcCc6Y2FzZSdvbk1vdXNlVXBDYXB0dXJlJzpjYXNlJ29uTW91c2VFbnRlcic6cmV0dXJuISEocHJvcHMuZGlzYWJsZWQmJmlzSW50ZXJhY3RpdmUodHlwZSkpO2RlZmF1bHQ6cmV0dXJuIGZhbHNlO319LyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCxyZWdpc3RyYXRpb25OYW1lKXt2YXIgc3RhdGVOb2RlPWluc3Quc3RhdGVOb2RlO2lmKHN0YXRlTm9kZT09PW51bGwpey8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxucmV0dXJuIG51bGw7fXZhciBwcm9wcz1nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7aWYocHJvcHM9PT1udWxsKXsvLyBXb3JrIGluIHByb2dyZXNzLlxucmV0dXJuIG51bGw7fXZhciBsaXN0ZW5lcj1wcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtpZihzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLGluc3QudHlwZSxwcm9wcykpe3JldHVybiBudWxsO31pZihsaXN0ZW5lciYmdHlwZW9mIGxpc3RlbmVyIT09J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYFwiK3JlZ2lzdHJhdGlvbk5hbWUrXCJgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYFwiK3R5cGVvZiBsaXN0ZW5lcitcImAgdHlwZS5cIik7fXJldHVybiBsaXN0ZW5lcjt9dmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkPWZhbHNlOy8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydCBldmVudHMgd2l0aCBwYXNzaXZlIGxpc3RlbmVyc1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuaWYoY2FuVXNlRE9NKXt0cnl7dmFyIG9wdGlvbnM9e307Ly8gJEZsb3dGaXhNZTogSWdub3JlIEZsb3cgY29tcGxhaW5pbmcgYWJvdXQgbmVlZGluZyBhIHZhbHVlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywncGFzc2l2ZScse2dldDpmdW5jdGlvbigpe3Bhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkPXRydWU7fX0pO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JyxvcHRpb25zLG9wdGlvbnMpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JyxvcHRpb25zLG9wdGlvbnMpO31jYXRjaChlKXtwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZD1mYWxzZTt9fWZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QobmFtZSxmdW5jLGNvbnRleHQsYSxiLGMsZCxlLGYpe3ZhciBmdW5jQXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7dHJ5e2Z1bmMuYXBwbHkoY29udGV4dCxmdW5jQXJncyk7fWNhdGNoKGVycm9yKXt0aGlzLm9uRXJyb3IoZXJyb3IpO319dmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw9aW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDt7Ly8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbi8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbi8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4vLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbi8vIHVuaW50dWl0aXZlLCB0aG91Z2gsIGJlY2F1c2UgZXZlbiB0aG91Z2ggUmVhY3QgaGFzIGNhdWdodCB0aGUgZXJyb3IsIGZyb21cbi8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuLy9cbi8vIFRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvciwgd2UgZG9uJ3QgdXNlIGFcbi8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbi8vIGZvciB0aGF0IGZha2UgZXZlbnQuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MsIHRoZSBlcnJvciBpcyBcImNhcHR1cmVkXCIgdXNpbmdcbi8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4vLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbi8vIEVmZmVjdGl2ZWx5LCB0aGlzIGdpdmVzIHVzIHRyeS1jYXRjaCBiZWhhdmlvciB3aXRob3V0IGFjdHVhbGx5IHVzaW5nXG4vLyB0cnktY2F0Y2guIE5lYXQhXG4vLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4vLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbmlmKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJyYmdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50PT09J2Z1bmN0aW9uJyYmdHlwZW9mIGRvY3VtZW50IT09J3VuZGVmaW5lZCcmJnR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudD09PSdmdW5jdGlvbicpe3ZhciBmYWtlTm9kZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO2ludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw9ZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2KG5hbWUsZnVuYyxjb250ZXh0LGEsYixjLGQsZSxmKXsvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4vLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4vLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG5pZih0eXBlb2YgZG9jdW1lbnQ9PT0ndW5kZWZpbmVkJ3x8ZG9jdW1lbnQ9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCAnKydkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgJysnc2NoZWR1bGVzIGFuIHVwZGF0ZSBmcm9tIGFuIGFzeW5jaHJvbm91cyBjYWxsYmFjaywgYnV0IHRoZSB0ZXN0IGhhcyBhbHJlYWR5ICcrJ2ZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCAnKyd0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgJysnY2FuY2VsZWQgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YCksIG9yIHlvdSBjYW4gY2hhbmdlIHRoZSB0ZXN0IGl0c2VsZiAnKyd0byBiZSBhc3luY2hyb25vdXMuJyk7fXZhciBldnQ9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7dmFyIGRpZENhbGw9ZmFsc2U7Ly8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2Vcbi8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbi8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbi8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4vLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxudmFyIGRpZEVycm9yPXRydWU7Ly8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4vLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG52YXIgd2luZG93RXZlbnQ9d2luZG93LmV2ZW50Oy8vIEtlZXBzIHRyYWNrIG9mIHRoZSBkZXNjcmlwdG9yIG9mIHdpbmRvdy5ldmVudCB0byByZXN0b3JlIGl0IGFmdGVyIGV2ZW50XG4vLyBkaXNwYXRjaGluZzogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzY4OFxudmFyIHdpbmRvd0V2ZW50RGVzY3JpcHRvcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdywnZXZlbnQnKTtmdW5jdGlvbiByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpey8vIFdlIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBldmVudCBsaXN0ZW5lcnMgc28gdGhhdFxuLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4vLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuLy8gaW4gdGhlIHN0YWNrLlxuZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLGNhbGxDYWxsYmFjayxmYWxzZSk7Ly8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuLy8gd2luZG93LmV2ZW50IGFzc2lnbm1lbnQgaW4gYm90aCBJRSA8PSAxMCBhcyB0aGV5IHRocm93IGFuIGVycm9yXG4vLyBcIk1lbWJlciBub3QgZm91bmRcIiBpbiBzdHJpY3QgbW9kZSwgYW5kIGluIEZpcmVmb3ggd2hpY2ggZG9lcyBub3Rcbi8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuaWYodHlwZW9mIHdpbmRvdy5ldmVudCE9PSd1bmRlZmluZWQnJiZ3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50Jykpe3dpbmRvdy5ldmVudD13aW5kb3dFdmVudDt9fS8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4vLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2Vcbi8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG52YXIgZnVuY0FyZ3M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO2Z1bmN0aW9uIGNhbGxDYWxsYmFjaygpe2RpZENhbGw9dHJ1ZTtyZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO2Z1bmMuYXBwbHkoY29udGV4dCxmdW5jQXJncyk7ZGlkRXJyb3I9ZmFsc2U7fS8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4vLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4vLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4vLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4vLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbi8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG52YXIgZXJyb3I7Ly8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG52YXIgZGlkU2V0RXJyb3I9ZmFsc2U7dmFyIGlzQ3Jvc3NPcmlnaW5FcnJvcj1mYWxzZTtmdW5jdGlvbiBoYW5kbGVXaW5kb3dFcnJvcihldmVudCl7ZXJyb3I9ZXZlbnQuZXJyb3I7ZGlkU2V0RXJyb3I9dHJ1ZTtpZihlcnJvcj09PW51bGwmJmV2ZW50LmNvbG5vPT09MCYmZXZlbnQubGluZW5vPT09MCl7aXNDcm9zc09yaWdpbkVycm9yPXRydWU7fWlmKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpey8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4vLyBCcm93c2VycyBzaWxlbmNlIHRoZSBlcnJvciByZXBvcnQgaWYgdGhpcyBoYXBwZW5zLlxuLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuaWYoZXJyb3IhPW51bGwmJnR5cGVvZiBlcnJvcj09PSdvYmplY3QnKXt0cnl7ZXJyb3IuX3N1cHByZXNzTG9nZ2luZz10cnVlO31jYXRjaChpbm5lcil7Ly8gSWdub3JlLlxufX19fS8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbnZhciBldnRUeXBlPVwicmVhY3QtXCIrKG5hbWU/bmFtZTonaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7Ly8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJyxoYW5kbGVXaW5kb3dFcnJvcik7ZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLGNhbGxDYWxsYmFjayxmYWxzZSk7Ly8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbi8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbmV2dC5pbml0RXZlbnQoZXZ0VHlwZSxmYWxzZSxmYWxzZSk7ZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO2lmKHdpbmRvd0V2ZW50RGVzY3JpcHRvcil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywnZXZlbnQnLHdpbmRvd0V2ZW50RGVzY3JpcHRvcik7fWlmKGRpZENhbGwmJmRpZEVycm9yKXtpZighZGlkU2V0RXJyb3Ipey8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbmVycm9yPW5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcrXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiKydmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJysnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnK1wiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiKyd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcrJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJysnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fWVsc2UgaWYoaXNDcm9zc09yaWdpbkVycm9yKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuZXJyb3I9bmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIisndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7fXRoaXMub25FcnJvcihlcnJvcik7fS8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLGhhbmRsZVdpbmRvd0Vycm9yKTtpZighZGlkQ2FsbCl7Ly8gU29tZXRoaW5nIHdlbnQgcmVhbGx5IHdyb25nLCBhbmQgb3VyIGV2ZW50IHdhcyBub3QgZGlzcGF0Y2hlZC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MzRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY1ODVcbi8vIEZhbGwgYmFjayB0byB0aGUgcHJvZHVjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbnJlc3RvcmVBZnRlckRpc3BhdGNoKCk7cmV0dXJuIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QuYXBwbHkodGhpcyxhcmd1bWVudHMpO319O319dmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMT1pbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsO3ZhciBoYXNFcnJvcj1mYWxzZTt2YXIgY2F1Z2h0RXJyb3I9bnVsbDsvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxudmFyIGhhc1JldGhyb3dFcnJvcj1mYWxzZTt2YXIgcmV0aHJvd0Vycm9yPW51bGw7dmFyIHJlcG9ydGVyPXtvbkVycm9yOmZ1bmN0aW9uKGVycm9yKXtoYXNFcnJvcj10cnVlO2NhdWdodEVycm9yPWVycm9yO319Oy8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSxmdW5jLGNvbnRleHQsYSxiLGMsZCxlLGYpe2hhc0Vycm9yPWZhbHNlO2NhdWdodEVycm9yPW51bGw7aW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxLmFwcGx5KHJlcG9ydGVyLGFyZ3VtZW50cyk7fS8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IobmFtZSxmdW5jLGNvbnRleHQsYSxiLGMsZCxlLGYpe2ludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoaGFzRXJyb3Ipe3ZhciBlcnJvcj1jbGVhckNhdWdodEVycm9yKCk7aWYoIWhhc1JldGhyb3dFcnJvcil7aGFzUmV0aHJvd0Vycm9yPXRydWU7cmV0aHJvd0Vycm9yPWVycm9yO319fS8qKlxuICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gKi9mdW5jdGlvbiByZXRocm93Q2F1Z2h0RXJyb3IoKXtpZihoYXNSZXRocm93RXJyb3Ipe3ZhciBlcnJvcj1yZXRocm93RXJyb3I7aGFzUmV0aHJvd0Vycm9yPWZhbHNlO3JldGhyb3dFcnJvcj1udWxsO3Rocm93IGVycm9yO319ZnVuY3Rpb24gaGFzQ2F1Z2h0RXJyb3IoKXtyZXR1cm4gaGFzRXJyb3I7fWZ1bmN0aW9uIGNsZWFyQ2F1Z2h0RXJyb3IoKXtpZihoYXNFcnJvcil7dmFyIGVycm9yPWNhdWdodEVycm9yO2hhc0Vycm9yPWZhbHNlO2NhdWdodEVycm9yPW51bGw7cmV0dXJuIGVycm9yO31lbHNle3Rocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJysnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX0vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9mdW5jdGlvbiBnZXQoa2V5KXtyZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsczt9ZnVuY3Rpb24gaGFzKGtleSl7cmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHMhPT11bmRlZmluZWQ7fWZ1bmN0aW9uIHNldChrZXksdmFsdWUpe2tleS5fcmVhY3RJbnRlcm5hbHM9dmFsdWU7fS8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3M9LyogICAgICAgICAgICAgICAgICAgICAgKi8wO3ZhciBQZXJmb3JtZWRXb3JrPS8qICAgICAgICAgICAgICAgICovMTsvLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cbnZhciBQbGFjZW1lbnQ9LyogICAgICAgICAgICAgICAgICAgICovMjt2YXIgVXBkYXRlPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzQ7dmFyIENoaWxkRGVsZXRpb249LyogICAgICAgICAgICAgICAgKi8xNjt2YXIgQ29udGVudFJlc2V0PS8qICAgICAgICAgICAgICAgICAqLzMyO3ZhciBDYWxsYmFjaz0vKiAgICAgICAgICAgICAgICAgICAgICovNjQ7dmFyIERpZENhcHR1cmU9LyogICAgICAgICAgICAgICAgICAgKi8xMjg7dmFyIEZvcmNlQ2xpZW50UmVuZGVyPS8qICAgICAgICAgICAgKi8yNTY7dmFyIFJlZj0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi81MTI7dmFyIFNuYXBzaG90PS8qICAgICAgICAgICAgICAgICAgICAgKi8xMDI0O3ZhciBQYXNzaXZlPS8qICAgICAgICAgICAgICAgICAgICAgICovMjA0ODt2YXIgSHlkcmF0aW5nPS8qICAgICAgICAgICAgICAgICAgICAqLzQwOTY7dmFyIFZpc2liaWxpdHk9LyogICAgICAgICAgICAgICAgICAgKi84MTkyO3ZhciBTdG9yZUNvbnNpc3RlbmN5PS8qICAgICAgICAgICAgICovMTYzODQ7dmFyIExpZmVjeWNsZUVmZmVjdE1hc2s9UGFzc2l2ZXxVcGRhdGV8Q2FsbGJhY2t8UmVmfFNuYXBzaG90fFN0b3JlQ29uc2lzdGVuY3k7Ly8gVW5pb24gb2YgYWxsIGNvbW1pdCBmbGFncyAoZmxhZ3Mgd2l0aCB0aGUgbGlmZXRpbWUgb2YgYSBwYXJ0aWN1bGFyIGNvbW1pdClcbnZhciBIb3N0RWZmZWN0TWFzaz0vKiAgICAgICAgICAgICAgICovMzI3Njc7Ly8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cbnZhciBJbmNvbXBsZXRlPS8qICAgICAgICAgICAgICAgICAgICovMzI3Njg7dmFyIFNob3VsZENhcHR1cmU9LyogICAgICAgICAgICAgICAgKi82NTUzNjt2YXIgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZT0vKiAqLzEzMTA3Mjt2YXIgRm9ya2VkPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzEwNDg1NzY7Ly8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcbi8vIGUuZy4gYSBmaWJlciB1c2VzIGEgcGFzc2l2ZSBlZmZlY3QgKGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHVwZGF0ZXMgb24gdGhpcyBwYXJ0aWN1bGFyIHJlbmRlcikuXG4vLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGVmZXIgbW9yZSB3b3JrIGluIHRoZSB1bm1vdW50IGNhc2UsXG4vLyBzaW5jZSB3ZSBjYW4gZGVmZXIgdHJhdmVyc2luZyB0aGUgdHJlZSBkdXJpbmcgbGF5b3V0IHRvIGxvb2sgZm9yIFBhc3NpdmUgZWZmZWN0cyxcbi8vIGFuZCBpbnN0ZWFkIHJlbHkgb24gdGhlIHN0YXRpYyBmbGFnIGFzIGEgc2lnbmFsIHRoYXQgdGhlcmUgbWF5IGJlIGNsZWFudXAgd29yay5cbnZhciBSZWZTdGF0aWM9LyogICAgICAgICAgICAgICAgICAgICovMjA5NzE1Mjt2YXIgTGF5b3V0U3RhdGljPS8qICAgICAgICAgICAgICAgICAqLzQxOTQzMDQ7dmFyIFBhc3NpdmVTdGF0aWM9LyogICAgICAgICAgICAgICAgKi84Mzg4NjA4Oy8vIFRoZXNlIGZsYWdzIGFsbG93IHVzIHRvIHRyYXZlcnNlIHRvIGZpYmVycyB0aGF0IGhhdmUgZWZmZWN0cyBvbiBtb3VudFxuLy8gd2l0aG91dCB0cmF2ZXJzaW5nIHRoZSBlbnRpcmUgdHJlZSBhZnRlciBldmVyeSBjb21taXQgZm9yXG4vLyBkb3VibGUgaW52b2tpbmdcbnZhciBNb3VudExheW91dERldj0vKiAgICAgICAgICAgICAgICovMTY3NzcyMTY7dmFyIE1vdW50UGFzc2l2ZURldj0vKiAgICAgICAgICAgICAgKi8zMzU1NDQzMjsvLyBHcm91cHMgb2YgZmxhZ3MgdGhhdCBhcmUgdXNlZCBpbiB0aGUgY29tbWl0IHBoYXNlIHRvIHNraXAgb3ZlciB0cmVlcyB0aGF0XG4vLyBkb24ndCBjb250YWluIGVmZmVjdHMsIGJ5IGNoZWNraW5nIHN1YnRyZWVGbGFncy5cbnZhciBCZWZvcmVNdXRhdGlvbk1hc2s9Ly8gVE9ETzogUmVtb3ZlIFVwZGF0ZSBmbGFnIGZyb20gYmVmb3JlIG11dGF0aW9uIHBoYXNlIGJ5IHJlLWxhbmRpbmcgVmlzaWJpbGl0eVxuLy8gZmxhZyBsb2dpYyAoc2VlICMyMDA0MylcblVwZGF0ZXxTbmFwc2hvdHwwO3ZhciBNdXRhdGlvbk1hc2s9UGxhY2VtZW50fFVwZGF0ZXxDaGlsZERlbGV0aW9ufENvbnRlbnRSZXNldHxSZWZ8SHlkcmF0aW5nfFZpc2liaWxpdHk7dmFyIExheW91dE1hc2s9VXBkYXRlfENhbGxiYWNrfFJlZnxWaXNpYmlsaXR5Oy8vIFRPRE86IFNwbGl0IGludG8gUGFzc2l2ZU1vdW50TWFzayBhbmQgUGFzc2l2ZVVubW91bnRNYXNrXG52YXIgUGFzc2l2ZU1hc2s9UGFzc2l2ZXxDaGlsZERlbGV0aW9uOy8vIFVuaW9uIG9mIHRhZ3MgdGhhdCBkb24ndCBnZXQgcmVzZXQgb24gY2xvbmVzLlxuLy8gVGhpcyBhbGxvd3MgY2VydGFpbiBjb25jZXB0cyB0byBwZXJzaXN0IHdpdGhvdXQgcmVjYWxjdWxhdGluZyB0aGVtLFxuLy8gZS5nLiB3aGV0aGVyIGEgc3VidHJlZSBjb250YWlucyBwYXNzaXZlIGVmZmVjdHMgb3IgcG9ydGFscy5cbnZhciBTdGF0aWNNYXNrPUxheW91dFN0YXRpY3xQYXNzaXZlU3RhdGljfFJlZlN0YXRpYzt2YXIgUmVhY3RDdXJyZW50T3duZXI9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7ZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcil7dmFyIG5vZGU9ZmliZXI7dmFyIG5lYXJlc3RNb3VudGVkPWZpYmVyO2lmKCFmaWJlci5hbHRlcm5hdGUpey8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbi8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxudmFyIG5leHROb2RlPW5vZGU7ZG97bm9kZT1uZXh0Tm9kZTtpZigobm9kZS5mbGFncyYoUGxhY2VtZW50fEh5ZHJhdGluZykpIT09Tm9GbGFncyl7Ly8gVGhpcyBpcyBhbiBpbnNlcnRpb24gb3IgaW4tcHJvZ3Jlc3MgaHlkcmF0aW9uLiBUaGUgbmVhcmVzdCBwb3NzaWJsZVxuLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbi8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG5uZWFyZXN0TW91bnRlZD1ub2RlLnJldHVybjt9bmV4dE5vZGU9bm9kZS5yZXR1cm47fXdoaWxlKG5leHROb2RlKTt9ZWxzZXt3aGlsZShub2RlLnJldHVybil7bm9kZT1ub2RlLnJldHVybjt9fWlmKG5vZGUudGFnPT09SG9zdFJvb3Qpey8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4vLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbnJldHVybiBuZWFyZXN0TW91bnRlZDt9Ly8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4vLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbnJldHVybiBudWxsO31mdW5jdGlvbiBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKGZpYmVyKXtpZihmaWJlci50YWc9PT1TdXNwZW5zZUNvbXBvbmVudCl7dmFyIHN1c3BlbnNlU3RhdGU9ZmliZXIubWVtb2l6ZWRTdGF0ZTtpZihzdXNwZW5zZVN0YXRlPT09bnVsbCl7dmFyIGN1cnJlbnQ9ZmliZXIuYWx0ZXJuYXRlO2lmKGN1cnJlbnQhPT1udWxsKXtzdXNwZW5zZVN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTt9fWlmKHN1c3BlbnNlU3RhdGUhPT1udWxsKXtyZXR1cm4gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkO319cmV0dXJuIG51bGw7fWZ1bmN0aW9uIGdldENvbnRhaW5lckZyb21GaWJlcihmaWJlcil7cmV0dXJuIGZpYmVyLnRhZz09PUhvc3RSb290P2ZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOm51bGw7fWZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKXtyZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik9PT1maWJlcjt9ZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCl7e3ZhciBvd25lcj1SZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O2lmKG93bmVyIT09bnVsbCYmb3duZXIudGFnPT09Q2xhc3NDb21wb25lbnQpe3ZhciBvd25lckZpYmVyPW93bmVyO3ZhciBpbnN0YW5jZT1vd25lckZpYmVyLnN0YXRlTm9kZTtpZighaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyKXtlcnJvcignJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnKydyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcrJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcrJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcrJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lckZpYmVyKXx8J0EgY29tcG9uZW50Jyk7fWluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcj10cnVlO319dmFyIGZpYmVyPWdldChjb21wb25lbnQpO2lmKCFmaWJlcil7cmV0dXJuIGZhbHNlO31yZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik9PT1maWJlcjt9ZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKXtpZihnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSE9PWZpYmVyKXt0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTt9fWZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKXt2YXIgYWx0ZXJuYXRlPWZpYmVyLmFsdGVybmF0ZTtpZighYWx0ZXJuYXRlKXsvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG52YXIgbmVhcmVzdE1vdW50ZWQ9Z2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7aWYobmVhcmVzdE1vdW50ZWQ9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTt9aWYobmVhcmVzdE1vdW50ZWQhPT1maWJlcil7cmV0dXJuIG51bGw7fXJldHVybiBmaWJlcjt9Ly8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4vLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbi8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxudmFyIGE9ZmliZXI7dmFyIGI9YWx0ZXJuYXRlO3doaWxlKHRydWUpe3ZhciBwYXJlbnRBPWEucmV0dXJuO2lmKHBhcmVudEE9PT1udWxsKXsvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbmJyZWFrO312YXIgcGFyZW50Qj1wYXJlbnRBLmFsdGVybmF0ZTtpZihwYXJlbnRCPT09bnVsbCl7Ly8gVGhlcmUgaXMgbm8gYWx0ZXJuYXRlLiBUaGlzIGlzIGFuIHVudXN1YWwgY2FzZS4gQ3VycmVudGx5LCBpdCBvbmx5XG4vLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuLy8gaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiB0aGUgU3VzcGVuc2UgZmliZXIgYW5kIGl0cyBjaGlsZHJlbi4gU2tpcFxuLy8gb3ZlciB0aGlzIGV4dHJhIGZyYWdtZW50IGZpYmVyIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBhcmVudC5cbnZhciBuZXh0UGFyZW50PXBhcmVudEEucmV0dXJuO2lmKG5leHRQYXJlbnQhPT1udWxsKXthPWI9bmV4dFBhcmVudDtjb250aW51ZTt9Ly8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuYnJlYWs7fS8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4vLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5pZihwYXJlbnRBLmNoaWxkPT09cGFyZW50Qi5jaGlsZCl7dmFyIGNoaWxkPXBhcmVudEEuY2hpbGQ7d2hpbGUoY2hpbGQpe2lmKGNoaWxkPT09YSl7Ly8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO3JldHVybiBmaWJlcjt9aWYoY2hpbGQ9PT1iKXsvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG5hc3NlcnRJc01vdW50ZWQocGFyZW50QSk7cmV0dXJuIGFsdGVybmF0ZTt9Y2hpbGQ9Y2hpbGQuc2libGluZzt9Ly8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbi8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cbnRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO31pZihhLnJldHVybiE9PWIucmV0dXJuKXsvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4vLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4vLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4vLyBzZXQgb2YgQi5yZXR1cm4uXG5hPXBhcmVudEE7Yj1wYXJlbnRCO31lbHNley8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbi8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuLy9cbi8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxudmFyIGRpZEZpbmRDaGlsZD1mYWxzZTt2YXIgX2NoaWxkPXBhcmVudEEuY2hpbGQ7d2hpbGUoX2NoaWxkKXtpZihfY2hpbGQ9PT1hKXtkaWRGaW5kQ2hpbGQ9dHJ1ZTthPXBhcmVudEE7Yj1wYXJlbnRCO2JyZWFrO31pZihfY2hpbGQ9PT1iKXtkaWRGaW5kQ2hpbGQ9dHJ1ZTtiPXBhcmVudEE7YT1wYXJlbnRCO2JyZWFrO31fY2hpbGQ9X2NoaWxkLnNpYmxpbmc7fWlmKCFkaWRGaW5kQ2hpbGQpey8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuX2NoaWxkPXBhcmVudEIuY2hpbGQ7d2hpbGUoX2NoaWxkKXtpZihfY2hpbGQ9PT1hKXtkaWRGaW5kQ2hpbGQ9dHJ1ZTthPXBhcmVudEI7Yj1wYXJlbnRBO2JyZWFrO31pZihfY2hpbGQ9PT1iKXtkaWRGaW5kQ2hpbGQ9dHJ1ZTtiPXBhcmVudEI7YT1wYXJlbnRBO2JyZWFrO31fY2hpbGQ9X2NoaWxkLnNpYmxpbmc7fWlmKCFkaWRGaW5kQ2hpbGQpe3Rocm93IG5ldyBFcnJvcignQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgJysnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319fWlmKGEuYWx0ZXJuYXRlIT09Yil7dGhyb3cgbmV3IEVycm9yKFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBcIisnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fS8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4vLyB1bm1vdW50ZWQuXG5pZihhLnRhZyE9PUhvc3RSb290KXt0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTt9aWYoYS5zdGF0ZU5vZGUuY3VycmVudD09PWEpey8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbnJldHVybiBmaWJlcjt9Ly8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxucmV0dXJuIGFsdGVybmF0ZTt9ZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KXt2YXIgY3VycmVudFBhcmVudD1maW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO3JldHVybiBjdXJyZW50UGFyZW50IT09bnVsbD9maW5kQ3VycmVudEhvc3RGaWJlckltcGwoY3VycmVudFBhcmVudCk6bnVsbDt9ZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpey8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5pZihub2RlLnRhZz09PUhvc3RDb21wb25lbnR8fG5vZGUudGFnPT09SG9zdFRleHQpe3JldHVybiBub2RlO312YXIgY2hpbGQ9bm9kZS5jaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe3ZhciBtYXRjaD1maW5kQ3VycmVudEhvc3RGaWJlckltcGwoY2hpbGQpO2lmKG1hdGNoIT09bnVsbCl7cmV0dXJuIG1hdGNoO31jaGlsZD1jaGlsZC5zaWJsaW5nO31yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCl7dmFyIGN1cnJlbnRQYXJlbnQ9ZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtyZXR1cm4gY3VycmVudFBhcmVudCE9PW51bGw/ZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChjdXJyZW50UGFyZW50KTpudWxsO31mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpey8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5pZihub2RlLnRhZz09PUhvc3RDb21wb25lbnR8fG5vZGUudGFnPT09SG9zdFRleHQpe3JldHVybiBub2RlO312YXIgY2hpbGQ9bm9kZS5jaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe2lmKGNoaWxkLnRhZyE9PUhvc3RQb3J0YWwpe3ZhciBtYXRjaD1maW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGNoaWxkKTtpZihtYXRjaCE9PW51bGwpe3JldHVybiBtYXRjaDt9fWNoaWxkPWNoaWxkLnNpYmxpbmc7fXJldHVybiBudWxsO30vLyBUaGlzIG1vZHVsZSBvbmx5IGV4aXN0cyBhcyBhbiBFU00gd3JhcHBlciBhcm91bmQgdGhlIGV4dGVybmFsIENvbW1vbkpTXG52YXIgc2NoZWR1bGVDYWxsYmFjaz1TY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjazt2YXIgY2FuY2VsQ2FsbGJhY2s9U2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO3ZhciBzaG91bGRZaWVsZD1TY2hlZHVsZXIudW5zdGFibGVfc2hvdWxkWWllbGQ7dmFyIHJlcXVlc3RQYWludD1TY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50O3ZhciBub3c9U2NoZWR1bGVyLnVuc3RhYmxlX25vdzt2YXIgZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw9U2NoZWR1bGVyLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO3ZhciBJbW1lZGlhdGVQcmlvcml0eT1TY2hlZHVsZXIudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHk7dmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5PVNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eTt2YXIgTm9ybWFsUHJpb3JpdHk9U2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5O3ZhciBMb3dQcmlvcml0eT1TY2hlZHVsZXIudW5zdGFibGVfTG93UHJpb3JpdHk7dmFyIElkbGVQcmlvcml0eT1TY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5Oy8vIHRoaXMgZG9lc24ndCBhY3R1YWxseSBleGlzdCBvbiB0aGUgc2NoZWR1bGVyLCBidXQgaXQgKmRvZXMqXG4vLyBvbiBzY2hlZHVsZXIvdW5zdGFibGVfbW9jaywgd2hpY2ggd2UnbGwgbmVlZCBmb3IgaW50ZXJuYWwgdGVzdGluZ1xudmFyIHVuc3RhYmxlX3lpZWxkVmFsdWU9U2NoZWR1bGVyLnVuc3RhYmxlX3lpZWxkVmFsdWU7dmFyIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlPVNjaGVkdWxlci51bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZTt2YXIgcmVuZGVyZXJJRD1udWxsO3ZhciBpbmplY3RlZEhvb2s9bnVsbDt2YXIgaW5qZWN0ZWRQcm9maWxpbmdIb29rcz1udWxsO3ZhciBoYXNMb2dnZWRFcnJvcj1mYWxzZTt2YXIgaXNEZXZUb29sc1ByZXNlbnQ9dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyE9PSd1bmRlZmluZWQnO2Z1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpe2lmKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX189PT0ndW5kZWZpbmVkJyl7Ly8gTm8gRGV2VG9vbHNcbnJldHVybiBmYWxzZTt9dmFyIGhvb2s9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGhvb2suaXNEaXNhYmxlZCl7Ly8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbi8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG5yZXR1cm4gdHJ1ZTt9aWYoIWhvb2suc3VwcG9ydHNGaWJlcil7e2Vycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnKyd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scycpO30vLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbnJldHVybiB0cnVlO310cnl7aWYoZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyKXsvLyBDb25kaXRpb25hbGx5IGluamVjdCB0aGVzZSBob29rcyBvbmx5IGlmIFRpbWVsaW5lIHByb2ZpbGVyIGlzIHN1cHBvcnRlZCBieSB0aGlzIGJ1aWxkLlxuLy8gVGhpcyBnaXZlcyBEZXZUb29scyBhIHdheSB0byBmZWF0dXJlIGRldGVjdCB0aGF0IGlzbid0IHRpZWQgdG8gdmVyc2lvbiBudW1iZXJcbi8vIChzaW5jZSBwcm9maWxpbmcgYW5kIHRpbWVsaW5lIGFyZSBjb250cm9sbGVkIGJ5IGRpZmZlcmVudCBmZWF0dXJlIGZsYWdzKS5cbmludGVybmFscz1hc3NpZ24oe30saW50ZXJuYWxzLHtnZXRMYW5lTGFiZWxNYXA6Z2V0TGFuZUxhYmVsTWFwLGluamVjdFByb2ZpbGluZ0hvb2tzOmluamVjdFByb2ZpbGluZ0hvb2tzfSk7fXJlbmRlcmVySUQ9aG9vay5pbmplY3QoaW50ZXJuYWxzKTsvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuaW5qZWN0ZWRIb29rPWhvb2s7fWNhdGNoKGVycil7Ly8gQ2F0Y2ggYWxsIGVycm9ycyBiZWNhdXNlIGl0IGlzIHVuc2FmZSB0byB0aHJvdyBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG57ZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJyxlcnIpO319aWYoaG9vay5jaGVja0RDRSl7Ly8gVGhpcyBpcyB0aGUgcmVhbCBEZXZUb29scy5cbnJldHVybiB0cnVlO31lbHNley8vIFRoaXMgaXMgbGlrZWx5IGEgaG9vayBpbnN0YWxsZWQgYnkgRmFzdCBSZWZyZXNoIHJ1bnRpbWUuXG5yZXR1cm4gZmFsc2U7fX1mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LGNoaWxkcmVuKXt7aWYoaW5qZWN0ZWRIb29rJiZ0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3Q9PT0nZnVuY3Rpb24nKXt0cnl7aW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QocmVuZGVyZXJJRCxyb290LGNoaWxkcmVuKTt9Y2F0Y2goZXJyKXtpZighaGFzTG9nZ2VkRXJyb3Ipe2hhc0xvZ2dlZEVycm9yPXRydWU7ZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLGVycik7fX19fX1mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCxldmVudFByaW9yaXR5KXtpZihpbmplY3RlZEhvb2smJnR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3Q9PT0nZnVuY3Rpb24nKXt0cnl7dmFyIGRpZEVycm9yPShyb290LmN1cnJlbnQuZmxhZ3MmRGlkQ2FwdHVyZSk9PT1EaWRDYXB0dXJlO2lmKGVuYWJsZVByb2ZpbGVyVGltZXIpe3ZhciBzY2hlZHVsZXJQcmlvcml0eTtzd2l0Y2goZXZlbnRQcmlvcml0eSl7Y2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6c2NoZWR1bGVyUHJpb3JpdHk9SW1tZWRpYXRlUHJpb3JpdHk7YnJlYWs7Y2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpzY2hlZHVsZXJQcmlvcml0eT1Vc2VyQmxvY2tpbmdQcmlvcml0eTticmVhaztjYXNlIERlZmF1bHRFdmVudFByaW9yaXR5OnNjaGVkdWxlclByaW9yaXR5PU5vcm1hbFByaW9yaXR5O2JyZWFrO2Nhc2UgSWRsZUV2ZW50UHJpb3JpdHk6c2NoZWR1bGVyUHJpb3JpdHk9SWRsZVByaW9yaXR5O2JyZWFrO2RlZmF1bHQ6c2NoZWR1bGVyUHJpb3JpdHk9Tm9ybWFsUHJpb3JpdHk7YnJlYWs7fWluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELHJvb3Qsc2NoZWR1bGVyUHJpb3JpdHksZGlkRXJyb3IpO31lbHNle2luamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELHJvb3QsdW5kZWZpbmVkLGRpZEVycm9yKTt9fWNhdGNoKGVycil7e2lmKCFoYXNMb2dnZWRFcnJvcil7aGFzTG9nZ2VkRXJyb3I9dHJ1ZTtlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsZXJyKTt9fX19fWZ1bmN0aW9uIG9uUG9zdENvbW1pdFJvb3Qocm9vdCl7aWYoaW5qZWN0ZWRIb29rJiZ0eXBlb2YgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdD09PSdmdW5jdGlvbicpe3RyeXtpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290KHJlbmRlcmVySUQscm9vdCk7fWNhdGNoKGVycil7e2lmKCFoYXNMb2dnZWRFcnJvcil7aGFzTG9nZ2VkRXJyb3I9dHJ1ZTtlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsZXJyKTt9fX19fWZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcil7aWYoaW5qZWN0ZWRIb29rJiZ0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50PT09J2Z1bmN0aW9uJyl7dHJ5e2luamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELGZpYmVyKTt9Y2F0Y2goZXJyKXt7aWYoIWhhc0xvZ2dlZEVycm9yKXtoYXNMb2dnZWRFcnJvcj10cnVlO2Vycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJyxlcnIpO319fX19ZnVuY3Rpb24gc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMobmV3SXNTdHJpY3RNb2RlKXt7aWYodHlwZW9mIHVuc3RhYmxlX3lpZWxkVmFsdWU9PT0nZnVuY3Rpb24nKXsvLyBXZSdyZSBpbiBhIHRlc3QgYmVjYXVzZSBTY2hlZHVsZXIudW5zdGFibGVfeWllbGRWYWx1ZSBvbmx5IGV4aXN0c1xuLy8gaW4gU2NoZWR1bGVyTW9jay4gVG8gcmVkdWNlIHRoZSBub2lzZSBpbiBzdHJpY3QgbW9kZSB0ZXN0cyxcbi8vIHN1cHByZXNzIHdhcm5pbmdzIGFuZCBkaXNhYmxlIHNjaGVkdWxlciB5aWVsZGluZyBkdXJpbmcgdGhlIGRvdWJsZSByZW5kZXJcbnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlKG5ld0lzU3RyaWN0TW9kZSk7c2V0U3VwcHJlc3NXYXJuaW5nKG5ld0lzU3RyaWN0TW9kZSk7fWlmKGluamVjdGVkSG9vayYmdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlPT09J2Z1bmN0aW9uJyl7dHJ5e2luamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsbmV3SXNTdHJpY3RNb2RlKTt9Y2F0Y2goZXJyKXt7aWYoIWhhc0xvZ2dlZEVycm9yKXtoYXNMb2dnZWRFcnJvcj10cnVlO2Vycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJyxlcnIpO319fX19fS8vIFByb2ZpbGVyIEFQSSBob29rc1xuZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3Mpe2luamVjdGVkUHJvZmlsaW5nSG9va3M9cHJvZmlsaW5nSG9va3M7fWZ1bmN0aW9uIGdldExhbmVMYWJlbE1hcCgpe3t2YXIgbWFwPW5ldyBNYXAoKTt2YXIgbGFuZT0xO2Zvcih2YXIgaW5kZXg9MDtpbmRleDxUb3RhbExhbmVzO2luZGV4Kyspe3ZhciBsYWJlbD1nZXRMYWJlbEZvckxhbmUobGFuZSk7bWFwLnNldChsYW5lLGxhYmVsKTtsYW5lKj0yO31yZXR1cm4gbWFwO319ZnVuY3Rpb24gbWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkKGxhbmVzKTt9fX1mdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcil7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChmaWJlcil7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudEVycm9yZWQoZmliZXIsdGhyb3duVmFsdWUsbGFuZXMpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLHRocm93blZhbHVlLGxhbmVzKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50U3VzcGVuZGVkKGZpYmVyLHdha2VhYmxlLGxhbmVzKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsd2FrZWFibGUsbGFuZXMpO319fWZ1bmN0aW9uIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyk7fX19ZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO319fWZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7fX19ZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpO319fWZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7fX19ZnVuY3Rpb24gbWFya1JlbmRlcllpZWxkZWQoKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCgpO319fWZ1bmN0aW9uIG1hcmtSZW5kZXJTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0b3BwZWQoKTt9fX1mdW5jdGlvbiBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTt9fX1mdW5jdGlvbiBtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsbGFuZSl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKTt9fX1mdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsbGFuZSl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKTt9fX12YXIgTm9Nb2RlPS8qICAgICAgICAgICAgICAgICAgICAgICAgICovMDsvLyBUT0RPOiBSZW1vdmUgQ29uY3VycmVudE1vZGUgYnkgcmVhZGluZyBmcm9tIHRoZSByb290IHRhZyBpbnN0ZWFkXG52YXIgQ29uY3VycmVudE1vZGU9LyogICAgICAgICAgICAgICAgICovMTt2YXIgUHJvZmlsZU1vZGU9LyogICAgICAgICAgICAgICAgICAgICovMjt2YXIgU3RyaWN0TGVnYWN5TW9kZT0vKiAgICAgICAgICAgICAgICovODt2YXIgU3RyaWN0RWZmZWN0c01vZGU9LyogICAgICAgICAgICAgICovMTY7Ly8gVE9ETzogVGhpcyBpcyBwcmV0dHkgd2VsbCBzdXBwb3J0ZWQgYnkgYnJvd3NlcnMuIE1heWJlIHdlIGNhbiBkcm9wIGl0LlxudmFyIGNsejMyPU1hdGguY2x6MzI/TWF0aC5jbHozMjpjbHozMkZhbGxiYWNrOy8vIENvdW50IGxlYWRpbmcgemVyb3MuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcbnZhciBsb2c9TWF0aC5sb2c7dmFyIExOMj1NYXRoLkxOMjtmdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpe3ZhciBhc1VpbnQ9eD4+PjA7aWYoYXNVaW50PT09MCl7cmV0dXJuIDMyO31yZXR1cm4gMzEtKGxvZyhhc1VpbnQpL0xOMnwwKXwwO30vLyBJZiB0aG9zZSB2YWx1ZXMgYXJlIGNoYW5nZWQgdGhhdCBwYWNrYWdlIHNob3VsZCBiZSByZWJ1aWx0IGFuZCByZWRlcGxveWVkLlxudmFyIFRvdGFsTGFuZXM9MzE7dmFyIE5vTGFuZXM9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzA7dmFyIE5vTGFuZT0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi8wO3ZhciBTeW5jTGFuZT0vKiAgICAgICAgICAgICAgICAgICAgICAgICovMTt2YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZT0vKiAgICAqLzI7dmFyIElucHV0Q29udGludW91c0xhbmU9LyogICAgICAgICAgICAgKi80O3ZhciBEZWZhdWx0SHlkcmF0aW9uTGFuZT0vKiAgICAgICAgICAgICovODt2YXIgRGVmYXVsdExhbmU9LyogICAgICAgICAgICAgICAgICAgICAqLzE2O3ZhciBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZT0vKiAgICAgICAgICAgICAgICAqLzMyO3ZhciBUcmFuc2l0aW9uTGFuZXM9LyogICAgICAgICAgICAgICAgICAgICAgICovNDE5NDI0MDt2YXIgVHJhbnNpdGlvbkxhbmUxPS8qICAgICAgICAgICAgICAgICAgICAgICAgKi82NDt2YXIgVHJhbnNpdGlvbkxhbmUyPS8qICAgICAgICAgICAgICAgICAgICAgICAgKi8xMjg7dmFyIFRyYW5zaXRpb25MYW5lMz0vKiAgICAgICAgICAgICAgICAgICAgICAgICovMjU2O3ZhciBUcmFuc2l0aW9uTGFuZTQ9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzUxMjt2YXIgVHJhbnNpdGlvbkxhbmU1PS8qICAgICAgICAgICAgICAgICAgICAgICAgKi8xMDI0O3ZhciBUcmFuc2l0aW9uTGFuZTY9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzIwNDg7dmFyIFRyYW5zaXRpb25MYW5lNz0vKiAgICAgICAgICAgICAgICAgICAgICAgICovNDA5Njt2YXIgVHJhbnNpdGlvbkxhbmU4PS8qICAgICAgICAgICAgICAgICAgICAgICAgKi84MTkyO3ZhciBUcmFuc2l0aW9uTGFuZTk9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzE2Mzg0O3ZhciBUcmFuc2l0aW9uTGFuZTEwPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzMyNzY4O3ZhciBUcmFuc2l0aW9uTGFuZTExPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzY1NTM2O3ZhciBUcmFuc2l0aW9uTGFuZTEyPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzEzMTA3Mjt2YXIgVHJhbnNpdGlvbkxhbmUxMz0vKiAgICAgICAgICAgICAgICAgICAgICAgKi8yNjIxNDQ7dmFyIFRyYW5zaXRpb25MYW5lMTQ9LyogICAgICAgICAgICAgICAgICAgICAgICovNTI0Mjg4O3ZhciBUcmFuc2l0aW9uTGFuZTE1PS8qICAgICAgICAgICAgICAgICAgICAgICAqLzEwNDg1NzY7dmFyIFRyYW5zaXRpb25MYW5lMTY9LyogICAgICAgICAgICAgICAgICAgICAgICovMjA5NzE1Mjt2YXIgUmV0cnlMYW5lcz0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqLzEzMDAyMzQyNDt2YXIgUmV0cnlMYW5lMT0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi80MTk0MzA0O3ZhciBSZXRyeUxhbmUyPS8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqLzgzODg2MDg7dmFyIFJldHJ5TGFuZTM9LyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovMTY3NzcyMTY7dmFyIFJldHJ5TGFuZTQ9LyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovMzM1NTQ0MzI7dmFyIFJldHJ5TGFuZTU9LyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovNjcxMDg4NjQ7dmFyIFNvbWVSZXRyeUxhbmU9UmV0cnlMYW5lMTt2YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZT0vKiAgICAgICAgICAqLzEzNDIxNzcyODt2YXIgTm9uSWRsZUxhbmVzPS8qICAgICAgICAgICAgICAgICAgICAgICAgICAqLzI2ODQzNTQ1NTt2YXIgSWRsZUh5ZHJhdGlvbkxhbmU9LyogICAgICAgICAgICAgICAqLzI2ODQzNTQ1Njt2YXIgSWRsZUxhbmU9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzUzNjg3MDkxMjt2YXIgT2Zmc2NyZWVuTGFuZT0vKiAgICAgICAgICAgICAgICAgICAqLzEwNzM3NDE4MjQ7Ly8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciB0aGUgZXhwZXJpbWVudGFsIHRpbWVsaW5lIChyZWFjdC1kZXZ0b29scy10aW1lbGluZSlcbi8vIEl0IHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgTGFuZXMgdmFsdWVzIGFib3ZlLlxuZnVuY3Rpb24gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpe3tpZihsYW5lJlN5bmNMYW5lKXtyZXR1cm4nU3luYyc7fWlmKGxhbmUmSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSl7cmV0dXJuJ0lucHV0Q29udGludW91c0h5ZHJhdGlvbic7fWlmKGxhbmUmSW5wdXRDb250aW51b3VzTGFuZSl7cmV0dXJuJ0lucHV0Q29udGludW91cyc7fWlmKGxhbmUmRGVmYXVsdEh5ZHJhdGlvbkxhbmUpe3JldHVybidEZWZhdWx0SHlkcmF0aW9uJzt9aWYobGFuZSZEZWZhdWx0TGFuZSl7cmV0dXJuJ0RlZmF1bHQnO31pZihsYW5lJlRyYW5zaXRpb25IeWRyYXRpb25MYW5lKXtyZXR1cm4nVHJhbnNpdGlvbkh5ZHJhdGlvbic7fWlmKGxhbmUmVHJhbnNpdGlvbkxhbmVzKXtyZXR1cm4nVHJhbnNpdGlvbic7fWlmKGxhbmUmUmV0cnlMYW5lcyl7cmV0dXJuJ1JldHJ5Jzt9aWYobGFuZSZTZWxlY3RpdmVIeWRyYXRpb25MYW5lKXtyZXR1cm4nU2VsZWN0aXZlSHlkcmF0aW9uJzt9aWYobGFuZSZJZGxlSHlkcmF0aW9uTGFuZSl7cmV0dXJuJ0lkbGVIeWRyYXRpb24nO31pZihsYW5lJklkbGVMYW5lKXtyZXR1cm4nSWRsZSc7fWlmKGxhbmUmT2Zmc2NyZWVuTGFuZSl7cmV0dXJuJ09mZnNjcmVlbic7fX19dmFyIE5vVGltZXN0YW1wPS0xO3ZhciBuZXh0VHJhbnNpdGlvbkxhbmU9VHJhbnNpdGlvbkxhbmUxO3ZhciBuZXh0UmV0cnlMYW5lPVJldHJ5TGFuZTE7ZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobGFuZXMpe3N3aXRjaChnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSl7Y2FzZSBTeW5jTGFuZTpyZXR1cm4gU3luY0xhbmU7Y2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOnJldHVybiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO2Nhc2UgSW5wdXRDb250aW51b3VzTGFuZTpyZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOnJldHVybiBEZWZhdWx0SHlkcmF0aW9uTGFuZTtjYXNlIERlZmF1bHRMYW5lOnJldHVybiBEZWZhdWx0TGFuZTtjYXNlIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lOnJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtjYXNlIFRyYW5zaXRpb25MYW5lMTpjYXNlIFRyYW5zaXRpb25MYW5lMjpjYXNlIFRyYW5zaXRpb25MYW5lMzpjYXNlIFRyYW5zaXRpb25MYW5lNDpjYXNlIFRyYW5zaXRpb25MYW5lNTpjYXNlIFRyYW5zaXRpb25MYW5lNjpjYXNlIFRyYW5zaXRpb25MYW5lNzpjYXNlIFRyYW5zaXRpb25MYW5lODpjYXNlIFRyYW5zaXRpb25MYW5lOTpjYXNlIFRyYW5zaXRpb25MYW5lMTA6Y2FzZSBUcmFuc2l0aW9uTGFuZTExOmNhc2UgVHJhbnNpdGlvbkxhbmUxMjpjYXNlIFRyYW5zaXRpb25MYW5lMTM6Y2FzZSBUcmFuc2l0aW9uTGFuZTE0OmNhc2UgVHJhbnNpdGlvbkxhbmUxNTpjYXNlIFRyYW5zaXRpb25MYW5lMTY6cmV0dXJuIGxhbmVzJlRyYW5zaXRpb25MYW5lcztjYXNlIFJldHJ5TGFuZTE6Y2FzZSBSZXRyeUxhbmUyOmNhc2UgUmV0cnlMYW5lMzpjYXNlIFJldHJ5TGFuZTQ6Y2FzZSBSZXRyeUxhbmU1OnJldHVybiBsYW5lcyZSZXRyeUxhbmVzO2Nhc2UgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTpyZXR1cm4gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtjYXNlIElkbGVIeWRyYXRpb25MYW5lOnJldHVybiBJZGxlSHlkcmF0aW9uTGFuZTtjYXNlIElkbGVMYW5lOnJldHVybiBJZGxlTGFuZTtjYXNlIE9mZnNjcmVlbkxhbmU6cmV0dXJuIE9mZnNjcmVlbkxhbmU7ZGVmYXVsdDp7ZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO30vLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxucmV0dXJuIGxhbmVzO319ZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3Qsd2lwTGFuZXMpey8vIEVhcmx5IGJhaWxvdXQgaWYgdGhlcmUncyBubyBwZW5kaW5nIHdvcmsgbGVmdC5cbnZhciBwZW5kaW5nTGFuZXM9cm9vdC5wZW5kaW5nTGFuZXM7aWYocGVuZGluZ0xhbmVzPT09Tm9MYW5lcyl7cmV0dXJuIE5vTGFuZXM7fXZhciBuZXh0TGFuZXM9Tm9MYW5lczt2YXIgc3VzcGVuZGVkTGFuZXM9cm9vdC5zdXNwZW5kZWRMYW5lczt2YXIgcGluZ2VkTGFuZXM9cm9vdC5waW5nZWRMYW5lczsvLyBEbyBub3Qgd29yayBvbiBhbnkgaWRsZSB3b3JrIHVudGlsIGFsbCB0aGUgbm9uLWlkbGUgd29yayBoYXMgZmluaXNoZWQsXG4vLyBldmVuIGlmIHRoZSB3b3JrIGlzIHN1c3BlbmRlZC5cbnZhciBub25JZGxlUGVuZGluZ0xhbmVzPXBlbmRpbmdMYW5lcyZOb25JZGxlTGFuZXM7aWYobm9uSWRsZVBlbmRpbmdMYW5lcyE9PU5vTGFuZXMpe3ZhciBub25JZGxlVW5ibG9ja2VkTGFuZXM9bm9uSWRsZVBlbmRpbmdMYW5lcyZ+c3VzcGVuZGVkTGFuZXM7aWYobm9uSWRsZVVuYmxvY2tlZExhbmVzIT09Tm9MYW5lcyl7bmV4dExhbmVzPWdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7fWVsc2V7dmFyIG5vbklkbGVQaW5nZWRMYW5lcz1ub25JZGxlUGVuZGluZ0xhbmVzJnBpbmdlZExhbmVzO2lmKG5vbklkbGVQaW5nZWRMYW5lcyE9PU5vTGFuZXMpe25leHRMYW5lcz1nZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGluZ2VkTGFuZXMpO319fWVsc2V7Ly8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbnZhciB1bmJsb2NrZWRMYW5lcz1wZW5kaW5nTGFuZXMmfnN1c3BlbmRlZExhbmVzO2lmKHVuYmxvY2tlZExhbmVzIT09Tm9MYW5lcyl7bmV4dExhbmVzPWdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTt9ZWxzZXtpZihwaW5nZWRMYW5lcyE9PU5vTGFuZXMpe25leHRMYW5lcz1nZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwaW5nZWRMYW5lcyk7fX19aWYobmV4dExhbmVzPT09Tm9MYW5lcyl7Ly8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4vLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGluIHRoaXMgcGF0aCBpZiBhIGZhbGxiYWNrIHRpbWVyIGlzIG5vdCBzY2hlZHVsZWQuXG5yZXR1cm4gTm9MYW5lczt9Ly8gSWYgd2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVuZGVyLCBzd2l0Y2hpbmcgbGFuZXMgd2lsbCBpbnRlcnJ1cHRcbi8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuLy8gaGlnaGVyIHByaW9yaXR5LlxuaWYod2lwTGFuZXMhPT1Ob0xhbmVzJiZ3aXBMYW5lcyE9PW5leHRMYW5lcyYmLy8gSWYgd2UgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB0aGVuIGludGVycnVwdGluZyBpcyBmaW5lLiBEb24ndFxuLy8gYm90aGVyIHdhaXRpbmcgdW50aWwgdGhlIHJvb3QgaXMgY29tcGxldGUuXG4od2lwTGFuZXMmc3VzcGVuZGVkTGFuZXMpPT09Tm9MYW5lcyl7dmFyIG5leHRMYW5lPWdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTt2YXIgd2lwTGFuZT1nZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHdpcExhbmVzKTtpZigvLyBUZXN0cyB3aGV0aGVyIHRoZSBuZXh0IGxhbmUgaXMgZXF1YWwgb3IgbG93ZXIgcHJpb3JpdHkgdGhhbiB0aGUgd2lwXG4vLyBvbmUuIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0cyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbm5leHRMYW5lPj13aXBMYW5lfHwvLyBEZWZhdWx0IHByaW9yaXR5IHVwZGF0ZXMgc2hvdWxkIG5vdCBpbnRlcnJ1cHQgdHJhbnNpdGlvbiB1cGRhdGVzLiBUaGVcbi8vIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIGRlZmF1bHQgdXBkYXRlcyBhbmQgdHJhbnNpdGlvbiB1cGRhdGVzIGlzIHRoYXRcbi8vIGRlZmF1bHQgdXBkYXRlcyBkbyBub3Qgc3VwcG9ydCByZWZyZXNoIHRyYW5zaXRpb25zLlxubmV4dExhbmU9PT1EZWZhdWx0TGFuZSYmKHdpcExhbmUmVHJhbnNpdGlvbkxhbmVzKSE9PU5vTGFuZXMpey8vIEtlZXAgd29ya2luZyBvbiB0aGUgZXhpc3RpbmcgaW4tcHJvZ3Jlc3MgdHJlZS4gRG8gbm90IGludGVycnVwdC5cbnJldHVybiB3aXBMYW5lczt9fWlmKChuZXh0TGFuZXMmSW5wdXRDb250aW51b3VzTGFuZSkhPT1Ob0xhbmVzKXsvLyBXaGVuIHVwZGF0ZXMgYXJlIHN5bmMgYnkgZGVmYXVsdCwgd2UgZW50YW5nbGUgY29udGludW91cyBwcmlvcml0eSB1cGRhdGVzXG4vLyBhbmQgZGVmYXVsdCB1cGRhdGVzLCBzbyB0aGV5IHJlbmRlciBpbiB0aGUgc2FtZSBiYXRjaC4gVGhlIG9ubHkgcmVhc29uXG4vLyB0aGV5IHVzZSBzZXBhcmF0ZSBsYW5lcyBpcyBiZWNhdXNlIGNvbnRpbnVvdXMgdXBkYXRlcyBzaG91bGQgaW50ZXJydXB0XG4vLyB0cmFuc2l0aW9ucywgYnV0IGRlZmF1bHQgdXBkYXRlcyBzaG91bGQgbm90LlxubmV4dExhbmVzfD1wZW5kaW5nTGFuZXMmRGVmYXVsdExhbmU7fS8vIENoZWNrIGZvciBlbnRhbmdsZWQgbGFuZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBiYXRjaC5cbi8vXG4vLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbi8vIGluIGEgYmF0Y2ggdGhhdCBkb2VzIG5vdCBhbHNvIGluY2x1ZGUgdGhlIG90aGVyIGxhbmUuIFR5cGljYWxseSB3ZSBkbyB0aGlzXG4vLyB3aGVuIG11bHRpcGxlIHVwZGF0ZXMgaGF2ZSB0aGUgc2FtZSBzb3VyY2UsIGFuZCB3ZSBvbmx5IHdhbnQgdG8gcmVzcG9uZCB0b1xuLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4vL1xuLy8gTm90ZSB0aGF0IHdlIGFwcGx5IGVudGFuZ2xlbWVudHMgKmFmdGVyKiBjaGVja2luZyBmb3IgcGFydGlhbCB3b3JrIGFib3ZlLlxuLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4vLyBpdCdzIGFscmVhZHkgcmVuZGVyaW5nLCB3ZSB3b24ndCBpbnRlcnJ1cHQgaXQuIFRoaXMgaXMgaW50ZW50aW9uYWwsIHNpbmNlXG4vLyBlbnRhbmdsZW1lbnQgaXMgdXN1YWxseSBcImJlc3QgZWZmb3J0XCI6IHdlJ2xsIHRyeSBvdXIgYmVzdCB0byByZW5kZXIgdGhlXG4vLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbi8vIGNvbXBsZXRlZCB3b3JrIGluIG9yZGVyIHRvIGRvIGl0LlxuLy8gVE9ETzogUmVjb25zaWRlciB0aGlzLiBUaGUgY291bnRlci1hcmd1bWVudCBpcyB0aGF0IHRoZSBwYXJ0aWFsIHdvcmtcbi8vIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIHN0YXRlLCB3aGljaCB3ZSBkb24ndCB3YW50IHRvIHNob3cgdG8gdGhlIHVzZXIuXG4vLyBBbmQgYnkgc3BlbmRpbmcgZXh0cmEgdGltZSBmaW5pc2hpbmcgaXQsIHdlJ3JlIGluY3JlYXNpbmcgdGhlIGFtb3VudCBvZlxuLy8gdGltZSBpdCB0YWtlcyB0byBzaG93IHRoZSBmaW5hbCBzdGF0ZSwgd2hpY2ggaXMgd2hhdCB0aGV5IGFyZSBhY3R1YWxseVxuLy8gd2FpdGluZyBmb3IuXG4vL1xuLy8gRm9yIHRob3NlIGV4Y2VwdGlvbnMgd2hlcmUgZW50YW5nbGVtZW50IGlzIHNlbWFudGljYWxseSBpbXBvcnRhbnQsIGxpa2Vcbi8vIHVzZU11dGFibGVTb3VyY2UsIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4vLyB0aW1lIHdlIGFwcGx5IHRoZSBlbnRhbmdsZW1lbnQuXG52YXIgZW50YW5nbGVkTGFuZXM9cm9vdC5lbnRhbmdsZWRMYW5lcztpZihlbnRhbmdsZWRMYW5lcyE9PU5vTGFuZXMpe3ZhciBlbnRhbmdsZW1lbnRzPXJvb3QuZW50YW5nbGVtZW50czt2YXIgbGFuZXM9bmV4dExhbmVzJmVudGFuZ2xlZExhbmVzO3doaWxlKGxhbmVzPjApe3ZhciBpbmRleD1waWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTt2YXIgbGFuZT0xPDxpbmRleDtuZXh0TGFuZXN8PWVudGFuZ2xlbWVudHNbaW5kZXhdO2xhbmVzJj1+bGFuZTt9fXJldHVybiBuZXh0TGFuZXM7fWZ1bmN0aW9uIGdldE1vc3RSZWNlbnRFdmVudFRpbWUocm9vdCxsYW5lcyl7dmFyIGV2ZW50VGltZXM9cm9vdC5ldmVudFRpbWVzO3ZhciBtb3N0UmVjZW50RXZlbnRUaW1lPU5vVGltZXN0YW1wO3doaWxlKGxhbmVzPjApe3ZhciBpbmRleD1waWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTt2YXIgbGFuZT0xPDxpbmRleDt2YXIgZXZlbnRUaW1lPWV2ZW50VGltZXNbaW5kZXhdO2lmKGV2ZW50VGltZT5tb3N0UmVjZW50RXZlbnRUaW1lKXttb3N0UmVjZW50RXZlbnRUaW1lPWV2ZW50VGltZTt9bGFuZXMmPX5sYW5lO31yZXR1cm4gbW9zdFJlY2VudEV2ZW50VGltZTt9ZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsY3VycmVudFRpbWUpe3N3aXRjaChsYW5lKXtjYXNlIFN5bmNMYW5lOmNhc2UgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTpjYXNlIElucHV0Q29udGludW91c0xhbmU6Ly8gVXNlciBpbnRlcmFjdGlvbnMgc2hvdWxkIGV4cGlyZSBzbGlnaHRseSBtb3JlIHF1aWNrbHkuXG4vL1xuLy8gTk9URTogVGhpcyBpcyBzZXQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29uc3RhbnQgYXMgaW4gU2NoZWR1bGVyLmpzLlxuLy8gV2hlbiB3ZSBtYWRlIGl0IGxhcmdlciwgYSBwcm9kdWN0IG1ldHJpYyBpbiB3d3cgcmVncmVzc2VkLCBzdWdnZXN0aW5nXG4vLyB0aGVyZSdzIGEgdXNlciBpbnRlcmFjdGlvbiB0aGF0J3MgYmVpbmcgc3RhcnZlZCBieSBhIHNlcmllcyBvZlxuLy8gc3luY2hyb25vdXMgdXBkYXRlcy4gSWYgdGhhdCB0aGVvcnkgaXMgY29ycmVjdCwgdGhlIHByb3BlciBzb2x1dGlvbiBpc1xuLy8gdG8gZml4IHRoZSBzdGFydmF0aW9uLiBIb3dldmVyLCB0aGlzIHNjZW5hcmlvIHN1cHBvcnRzIHRoZSBpZGVhIHRoYXRcbi8vIGV4cGlyYXRpb24gdGltZXMgYXJlIGFuIGltcG9ydGFudCBzYWZlZ3VhcmQgd2hlbiBzdGFydmF0aW9uXG4vLyBkb2VzIGhhcHBlbi5cbnJldHVybiBjdXJyZW50VGltZSsyNTA7Y2FzZSBEZWZhdWx0SHlkcmF0aW9uTGFuZTpjYXNlIERlZmF1bHRMYW5lOmNhc2UgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmU6Y2FzZSBUcmFuc2l0aW9uTGFuZTE6Y2FzZSBUcmFuc2l0aW9uTGFuZTI6Y2FzZSBUcmFuc2l0aW9uTGFuZTM6Y2FzZSBUcmFuc2l0aW9uTGFuZTQ6Y2FzZSBUcmFuc2l0aW9uTGFuZTU6Y2FzZSBUcmFuc2l0aW9uTGFuZTY6Y2FzZSBUcmFuc2l0aW9uTGFuZTc6Y2FzZSBUcmFuc2l0aW9uTGFuZTg6Y2FzZSBUcmFuc2l0aW9uTGFuZTk6Y2FzZSBUcmFuc2l0aW9uTGFuZTEwOmNhc2UgVHJhbnNpdGlvbkxhbmUxMTpjYXNlIFRyYW5zaXRpb25MYW5lMTI6Y2FzZSBUcmFuc2l0aW9uTGFuZTEzOmNhc2UgVHJhbnNpdGlvbkxhbmUxNDpjYXNlIFRyYW5zaXRpb25MYW5lMTU6Y2FzZSBUcmFuc2l0aW9uTGFuZTE2OnJldHVybiBjdXJyZW50VGltZSs1MDAwO2Nhc2UgUmV0cnlMYW5lMTpjYXNlIFJldHJ5TGFuZTI6Y2FzZSBSZXRyeUxhbmUzOmNhc2UgUmV0cnlMYW5lNDpjYXNlIFJldHJ5TGFuZTU6Ly8gVE9ETzogUmV0cmllcyBzaG91bGQgYmUgYWxsb3dlZCB0byBleHBpcmUgaWYgdGhleSBhcmUgQ1BVIGJvdW5kIGZvclxuLy8gdG9vIGxvbmcsIGJ1dCB3aGVuIEkgbWFkZSB0aGlzIGNoYW5nZSBpdCBjYXVzZWQgYSBzcGlrZSBpbiBicm93c2VyXG4vLyBjcmFzaGVzLiBUaGVyZSBtdXN0IGJlIHNvbWUgb3RoZXIgdW5kZXJseWluZyBidWc7IG5vdCBzdXBlciB1cmdlbnQgYnV0XG4vLyBpZGVhbGx5IHNob3VsZCBmaWd1cmUgb3V0IHdoeSBhbmQgZml4IGl0LiBVbmZvcnR1bmF0ZWx5IHdlIGRvbid0IGhhdmVcbi8vIGEgcmVwcm8gZm9yIHRoZSBjcmFzaGVzLCBvbmx5IGRldGVjdGVkIHZpYSBwcm9kdWN0aW9uIG1ldHJpY3MuXG5yZXR1cm4gTm9UaW1lc3RhbXA7Y2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOmNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6Y2FzZSBJZGxlTGFuZTpjYXNlIE9mZnNjcmVlbkxhbmU6Ly8gQW55dGhpbmcgaWRsZSBwcmlvcml0eSBvciBsb3dlciBzaG91bGQgbmV2ZXIgZXhwaXJlLlxucmV0dXJuIE5vVGltZXN0YW1wO2RlZmF1bHQ6e2Vycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTt9cmV0dXJuIE5vVGltZXN0YW1wO319ZnVuY3Rpb24gbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LGN1cnJlbnRUaW1lKXsvLyBUT0RPOiBUaGlzIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgd2UgeWllbGQuIFdlIGNhbiBvcHRpbWl6ZSBieSBzdG9yaW5nXG4vLyB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lIG9uIHRoZSByb290LiBUaGVuIHVzZSB0aGF0IHRvIHF1aWNrbHkgYmFpbCBvdXRcbi8vIG9mIHRoaXMgZnVuY3Rpb24uXG52YXIgcGVuZGluZ0xhbmVzPXJvb3QucGVuZGluZ0xhbmVzO3ZhciBzdXNwZW5kZWRMYW5lcz1yb290LnN1c3BlbmRlZExhbmVzO3ZhciBwaW5nZWRMYW5lcz1yb290LnBpbmdlZExhbmVzO3ZhciBleHBpcmF0aW9uVGltZXM9cm9vdC5leHBpcmF0aW9uVGltZXM7Ly8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBwZW5kaW5nIGxhbmVzIGFuZCBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRoZWlyXG4vLyBleHBpcmF0aW9uIHRpbWUuIElmIHNvLCB3ZSdsbCBhc3N1bWUgdGhlIHVwZGF0ZSBpcyBiZWluZyBzdGFydmVkIGFuZCBtYXJrXG4vLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cbnZhciBsYW5lcz1wZW5kaW5nTGFuZXM7d2hpbGUobGFuZXM+MCl7dmFyIGluZGV4PXBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO3ZhciBsYW5lPTE8PGluZGV4O3ZhciBleHBpcmF0aW9uVGltZT1leHBpcmF0aW9uVGltZXNbaW5kZXhdO2lmKGV4cGlyYXRpb25UaW1lPT09Tm9UaW1lc3RhbXApey8vIEZvdW5kIGEgcGVuZGluZyBsYW5lIHdpdGggbm8gZXhwaXJhdGlvbiB0aW1lLiBJZiBpdCdzIG5vdCBzdXNwZW5kZWQsIG9yXG4vLyBpZiBpdCdzIHBpbmdlZCwgYXNzdW1lIGl0J3MgQ1BVLWJvdW5kLiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuLy8gdXNpbmcgdGhlIGN1cnJlbnQgdGltZS5cbmlmKChsYW5lJnN1c3BlbmRlZExhbmVzKT09PU5vTGFuZXN8fChsYW5lJnBpbmdlZExhbmVzKSE9PU5vTGFuZXMpey8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuZXhwaXJhdGlvblRpbWVzW2luZGV4XT1jb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSxjdXJyZW50VGltZSk7fX1lbHNlIGlmKGV4cGlyYXRpb25UaW1lPD1jdXJyZW50VGltZSl7Ly8gVGhpcyBsYW5lIGV4cGlyZWRcbnJvb3QuZXhwaXJlZExhbmVzfD1sYW5lO31sYW5lcyY9fmxhbmU7fX0vLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuLy8gYXJlIHN1c3BlbmRlZC5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyhyb290KXtyZXR1cm4gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocm9vdC5wZW5kaW5nTGFuZXMpO31mdW5jdGlvbiBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KXt2YXIgZXZlcnl0aGluZ0J1dE9mZnNjcmVlbj1yb290LnBlbmRpbmdMYW5lcyZ+T2Zmc2NyZWVuTGFuZTtpZihldmVyeXRoaW5nQnV0T2Zmc2NyZWVuIT09Tm9MYW5lcyl7cmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47fWlmKGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4mT2Zmc2NyZWVuTGFuZSl7cmV0dXJuIE9mZnNjcmVlbkxhbmU7fXJldHVybiBOb0xhbmVzO31mdW5jdGlvbiBpbmNsdWRlc1N5bmNMYW5lKGxhbmVzKXtyZXR1cm4obGFuZXMmU3luY0xhbmUpIT09Tm9MYW5lczt9ZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcyl7cmV0dXJuKGxhbmVzJk5vbklkbGVMYW5lcykhPT1Ob0xhbmVzO31mdW5jdGlvbiBpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKXtyZXR1cm4obGFuZXMmUmV0cnlMYW5lcyk9PT1sYW5lczt9ZnVuY3Rpb24gaW5jbHVkZXNPbmx5Tm9uVXJnZW50TGFuZXMobGFuZXMpe3ZhciBVcmdlbnRMYW5lcz1TeW5jTGFuZXxJbnB1dENvbnRpbnVvdXNMYW5lfERlZmF1bHRMYW5lO3JldHVybihsYW5lcyZVcmdlbnRMYW5lcyk9PT1Ob0xhbmVzO31mdW5jdGlvbiBpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcyl7cmV0dXJuKGxhbmVzJlRyYW5zaXRpb25MYW5lcyk9PT1sYW5lczt9ZnVuY3Rpb24gaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCxsYW5lcyl7dmFyIFN5bmNEZWZhdWx0TGFuZXM9SW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZXxJbnB1dENvbnRpbnVvdXNMYW5lfERlZmF1bHRIeWRyYXRpb25MYW5lfERlZmF1bHRMYW5lO3JldHVybihsYW5lcyZTeW5jRGVmYXVsdExhbmVzKSE9PU5vTGFuZXM7fWZ1bmN0aW9uIGluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCxsYW5lcyl7Ly8gVGhpcyBpcyBhIHNlcGFyYXRlIGNoZWNrIGZyb20gaW5jbHVkZXNCbG9ja2luZ0xhbmUgYmVjYXVzZSBhIGxhbmUgY2FuXG4vLyBleHBpcmUgYWZ0ZXIgYSByZW5kZXIgaGFzIGFscmVhZHkgc3RhcnRlZC5cbnJldHVybihsYW5lcyZyb290LmV4cGlyZWRMYW5lcykhPT1Ob0xhbmVzO31mdW5jdGlvbiBpc1RyYW5zaXRpb25MYW5lKGxhbmUpe3JldHVybihsYW5lJlRyYW5zaXRpb25MYW5lcykhPT1Ob0xhbmVzO31mdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpey8vIEN5Y2xlIHRocm91Z2ggdGhlIGxhbmVzLCBhc3NpZ25pbmcgZWFjaCBuZXcgdHJhbnNpdGlvbiB0byB0aGUgbmV4dCBsYW5lLlxuLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBtZWFucyBldmVyeSB0cmFuc2l0aW9uIGdldHMgaXRzIG93biBsYW5lLCB1bnRpbCB3ZVxuLy8gcnVuIG91dCBvZiBsYW5lcyBhbmQgY3ljbGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLlxudmFyIGxhbmU9bmV4dFRyYW5zaXRpb25MYW5lO25leHRUcmFuc2l0aW9uTGFuZTw8PTE7aWYoKG5leHRUcmFuc2l0aW9uTGFuZSZUcmFuc2l0aW9uTGFuZXMpPT09Tm9MYW5lcyl7bmV4dFRyYW5zaXRpb25MYW5lPVRyYW5zaXRpb25MYW5lMTt9cmV0dXJuIGxhbmU7fWZ1bmN0aW9uIGNsYWltTmV4dFJldHJ5TGFuZSgpe3ZhciBsYW5lPW5leHRSZXRyeUxhbmU7bmV4dFJldHJ5TGFuZTw8PTE7aWYoKG5leHRSZXRyeUxhbmUmUmV0cnlMYW5lcyk9PT1Ob0xhbmVzKXtuZXh0UmV0cnlMYW5lPVJldHJ5TGFuZTE7fXJldHVybiBsYW5lO31mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKXtyZXR1cm4gbGFuZXMmLWxhbmVzO31mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcyl7Ly8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGdldHMgaW5saW5lZC4gT25seSBleGlzdHMgc28gdG8gY29tbXVuaWNhdGUgdGhhdCBpdFxuLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggYml0IGlzIHNlbGVjdGVkOyB5b3UgY2FuIHBpY2sgYW55IGJpdCB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4vLyBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lIGJlY2F1c2UgaXQgcmVxdWlyZXMgdGhlIGZld2VzdCBvcGVyYXRpb25zLlxucmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO31mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKXtyZXR1cm4gMzEtY2x6MzIobGFuZXMpO31mdW5jdGlvbiBsYW5lVG9JbmRleChsYW5lKXtyZXR1cm4gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lKTt9ZnVuY3Rpb24gaW5jbHVkZXNTb21lTGFuZShhLGIpe3JldHVybihhJmIpIT09Tm9MYW5lczt9ZnVuY3Rpb24gaXNTdWJzZXRPZkxhbmVzKHNldCxzdWJzZXQpe3JldHVybihzZXQmc3Vic2V0KT09PXN1YnNldDt9ZnVuY3Rpb24gbWVyZ2VMYW5lcyhhLGIpe3JldHVybiBhfGI7fWZ1bmN0aW9uIHJlbW92ZUxhbmVzKHNldCxzdWJzZXQpe3JldHVybiBzZXQmfnN1YnNldDt9ZnVuY3Rpb24gaW50ZXJzZWN0TGFuZXMoYSxiKXtyZXR1cm4gYSZiO30vLyBTZWVtcyByZWR1bmRhbnQsIGJ1dCBpdCBjaGFuZ2VzIHRoZSB0eXBlIGZyb20gYSBzaW5nbGUgbGFuZSAodXNlZCBmb3Jcbi8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuZnVuY3Rpb24gbGFuZVRvTGFuZXMobGFuZSl7cmV0dXJuIGxhbmU7fWZ1bmN0aW9uIGhpZ2hlclByaW9yaXR5TGFuZShhLGIpey8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0IHJhbmdlcyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbnJldHVybiBhIT09Tm9MYW5lJiZhPGI/YTpiO31mdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpey8vIEludGVudGlvbmFsbHkgcHVzaGluZyBvbmUgYnkgb25lLlxuLy8gaHR0cHM6Ly92OC5kZXYvYmxvZy9lbGVtZW50cy1raW5kcyNhdm9pZC1jcmVhdGluZy1ob2xlc1xudmFyIGxhbmVNYXA9W107Zm9yKHZhciBpPTA7aTxUb3RhbExhbmVzO2krKyl7bGFuZU1hcC5wdXNoKGluaXRpYWwpO31yZXR1cm4gbGFuZU1hcDt9ZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkKHJvb3QsdXBkYXRlTGFuZSxldmVudFRpbWUpe3Jvb3QucGVuZGluZ0xhbmVzfD11cGRhdGVMYW5lOy8vIElmIHRoZXJlIGFyZSBhbnkgc3VzcGVuZGVkIHRyYW5zaXRpb25zLCBpdCdzIHBvc3NpYmxlIHRoaXMgbmV3IHVwZGF0ZVxuLy8gY291bGQgdW5ibG9jayB0aGVtLiBDbGVhciB0aGUgc3VzcGVuZGVkIGxhbmVzIHNvIHRoYXQgd2UgY2FuIHRyeSByZW5kZXJpbmdcbi8vIHRoZW0gYWdhaW4uXG4vL1xuLy8gVE9ETzogV2UgcmVhbGx5IG9ubHkgbmVlZCB0byB1bnN1c3BlbmQgb25seSBsYW5lcyB0aGF0IGFyZSBpbiB0aGVcbi8vIGBzdWJ0cmVlTGFuZXNgIG9mIHRoZSB1cGRhdGVkIGZpYmVyLCBvciB0aGUgdXBkYXRlIGxhbmVzIG9mIHRoZSByZXR1cm5cbi8vIHBhdGguIFRoaXMgd291bGQgZXhjbHVkZSBzdXNwZW5kZWQgdXBkYXRlcyBpbiBhbiB1bnJlbGF0ZWQgc2libGluZyB0cmVlLFxuLy8gc2luY2UgdGhlcmUncyBubyB3YXkgZm9yIHRoaXMgdXBkYXRlIHRvIHVuYmxvY2sgaXQuXG4vL1xuLy8gV2UgZG9uJ3QgZG8gdGhpcyBpZiB0aGUgaW5jb21pbmcgdXBkYXRlIGlzIGlkbGUsIGJlY2F1c2Ugd2UgbmV2ZXIgcHJvY2Vzc1xuLy8gaWRsZSB1cGRhdGVzIHVudGlsIGFmdGVyIGFsbCB0aGUgcmVndWxhciB1cGRhdGVzIGhhdmUgZmluaXNoZWQ7IHRoZXJlJ3Mgbm9cbi8vIHdheSBpdCBjb3VsZCB1bmJsb2NrIGEgdHJhbnNpdGlvbi5cbmlmKHVwZGF0ZUxhbmUhPT1JZGxlTGFuZSl7cm9vdC5zdXNwZW5kZWRMYW5lcz1Ob0xhbmVzO3Jvb3QucGluZ2VkTGFuZXM9Tm9MYW5lczt9dmFyIGV2ZW50VGltZXM9cm9vdC5ldmVudFRpbWVzO3ZhciBpbmRleD1sYW5lVG9JbmRleCh1cGRhdGVMYW5lKTsvLyBXZSBjYW4gYWx3YXlzIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB0aW1lc3RhbXAgYmVjYXVzZSB3ZSBwcmVmZXIgdGhlIG1vc3Rcbi8vIHJlY2VudCBldmVudCwgYW5kIHdlIGFzc3VtZSB0aW1lIGlzIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy5cbmV2ZW50VGltZXNbaW5kZXhdPWV2ZW50VGltZTt9ZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCxzdXNwZW5kZWRMYW5lcyl7cm9vdC5zdXNwZW5kZWRMYW5lc3w9c3VzcGVuZGVkTGFuZXM7cm9vdC5waW5nZWRMYW5lcyY9fnN1c3BlbmRlZExhbmVzOy8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG52YXIgZXhwaXJhdGlvblRpbWVzPXJvb3QuZXhwaXJhdGlvblRpbWVzO3ZhciBsYW5lcz1zdXNwZW5kZWRMYW5lczt3aGlsZShsYW5lcz4wKXt2YXIgaW5kZXg9cGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7dmFyIGxhbmU9MTw8aW5kZXg7ZXhwaXJhdGlvblRpbWVzW2luZGV4XT1Ob1RpbWVzdGFtcDtsYW5lcyY9fmxhbmU7fX1mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZChyb290LHBpbmdlZExhbmVzLGV2ZW50VGltZSl7cm9vdC5waW5nZWRMYW5lc3w9cm9vdC5zdXNwZW5kZWRMYW5lcyZwaW5nZWRMYW5lczt9ZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChyb290LHJlbWFpbmluZ0xhbmVzKXt2YXIgbm9Mb25nZXJQZW5kaW5nTGFuZXM9cm9vdC5wZW5kaW5nTGFuZXMmfnJlbWFpbmluZ0xhbmVzO3Jvb3QucGVuZGluZ0xhbmVzPXJlbWFpbmluZ0xhbmVzOy8vIExldCdzIHRyeSBldmVyeXRoaW5nIGFnYWluXG5yb290LnN1c3BlbmRlZExhbmVzPU5vTGFuZXM7cm9vdC5waW5nZWRMYW5lcz1Ob0xhbmVzO3Jvb3QuZXhwaXJlZExhbmVzJj1yZW1haW5pbmdMYW5lcztyb290Lm11dGFibGVSZWFkTGFuZXMmPXJlbWFpbmluZ0xhbmVzO3Jvb3QuZW50YW5nbGVkTGFuZXMmPXJlbWFpbmluZ0xhbmVzO3ZhciBlbnRhbmdsZW1lbnRzPXJvb3QuZW50YW5nbGVtZW50czt2YXIgZXZlbnRUaW1lcz1yb290LmV2ZW50VGltZXM7dmFyIGV4cGlyYXRpb25UaW1lcz1yb290LmV4cGlyYXRpb25UaW1lczsvLyBDbGVhciB0aGUgbGFuZXMgdGhhdCBubyBsb25nZXIgaGF2ZSBwZW5kaW5nIHdvcmtcbnZhciBsYW5lcz1ub0xvbmdlclBlbmRpbmdMYW5lczt3aGlsZShsYW5lcz4wKXt2YXIgaW5kZXg9cGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7dmFyIGxhbmU9MTw8aW5kZXg7ZW50YW5nbGVtZW50c1tpbmRleF09Tm9MYW5lcztldmVudFRpbWVzW2luZGV4XT1Ob1RpbWVzdGFtcDtleHBpcmF0aW9uVGltZXNbaW5kZXhdPU5vVGltZXN0YW1wO2xhbmVzJj1+bGFuZTt9fWZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsZW50YW5nbGVkTGFuZXMpey8vIEluIGFkZGl0aW9uIHRvIGVudGFuZ2xpbmcgZWFjaCBvZiB0aGUgZ2l2ZW4gbGFuZXMgd2l0aCBlYWNoIG90aGVyLCB3ZSBhbHNvXG4vLyBoYXZlIHRvIGNvbnNpZGVyIF90cmFuc2l0aXZlXyBlbnRhbmdsZW1lbnRzLiBGb3IgZWFjaCBsYW5lIHRoYXQgaXMgYWxyZWFkeVxuLy8gZW50YW5nbGVkIHdpdGggKmFueSogb2YgdGhlIGdpdmVuIGxhbmVzLCB0aGF0IGxhbmUgaXMgbm93IHRyYW5zaXRpdmVseVxuLy8gZW50YW5nbGVkIHdpdGggKmFsbCogdGhlIGdpdmVuIGxhbmVzLlxuLy9cbi8vIFRyYW5zbGF0ZWQ6IElmIEMgaXMgZW50YW5nbGVkIHdpdGggQSwgdGhlbiBlbnRhbmdsaW5nIEEgd2l0aCBCIGFsc29cbi8vIGVudGFuZ2xlcyBDIHdpdGggQi5cbi8vXG4vLyBJZiB0aGlzIGlzIGhhcmQgdG8gZ3Jhc3AsIGl0IG1pZ2h0IGhlbHAgdG8gaW50ZW50aW9uYWxseSBicmVhayB0aGlzXG4vLyBmdW5jdGlvbiBhbmQgbG9vayBhdCB0aGUgdGVzdHMgdGhhdCBmYWlsIGluIFJlYWN0VHJhbnNpdGlvbi10ZXN0LmpzLiBUcnlcbi8vIGNvbW1lbnRpbmcgb3V0IG9uZSBvZiB0aGUgY29uZGl0aW9ucyBiZWxvdy5cbnZhciByb290RW50YW5nbGVkTGFuZXM9cm9vdC5lbnRhbmdsZWRMYW5lc3w9ZW50YW5nbGVkTGFuZXM7dmFyIGVudGFuZ2xlbWVudHM9cm9vdC5lbnRhbmdsZW1lbnRzO3ZhciBsYW5lcz1yb290RW50YW5nbGVkTGFuZXM7d2hpbGUobGFuZXMpe3ZhciBpbmRleD1waWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTt2YXIgbGFuZT0xPDxpbmRleDtpZigvLyBJcyB0aGlzIG9uZSBvZiB0aGUgbmV3bHkgZW50YW5nbGVkIGxhbmVzP1xubGFuZSZlbnRhbmdsZWRMYW5lc3wvLyBJcyB0aGlzIGxhbmUgdHJhbnNpdGl2ZWx5IGVudGFuZ2xlZCB3aXRoIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG5lbnRhbmdsZW1lbnRzW2luZGV4XSZlbnRhbmdsZWRMYW5lcyl7ZW50YW5nbGVtZW50c1tpbmRleF18PWVudGFuZ2xlZExhbmVzO31sYW5lcyY9fmxhbmU7fX1mdW5jdGlvbiBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QscmVuZGVyTGFuZXMpe3ZhciByZW5kZXJMYW5lPWdldEhpZ2hlc3RQcmlvcml0eUxhbmUocmVuZGVyTGFuZXMpO3ZhciBsYW5lO3N3aXRjaChyZW5kZXJMYW5lKXtjYXNlIElucHV0Q29udGludW91c0xhbmU6bGFuZT1JbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO2JyZWFrO2Nhc2UgRGVmYXVsdExhbmU6bGFuZT1EZWZhdWx0SHlkcmF0aW9uTGFuZTticmVhaztjYXNlIFRyYW5zaXRpb25MYW5lMTpjYXNlIFRyYW5zaXRpb25MYW5lMjpjYXNlIFRyYW5zaXRpb25MYW5lMzpjYXNlIFRyYW5zaXRpb25MYW5lNDpjYXNlIFRyYW5zaXRpb25MYW5lNTpjYXNlIFRyYW5zaXRpb25MYW5lNjpjYXNlIFRyYW5zaXRpb25MYW5lNzpjYXNlIFRyYW5zaXRpb25MYW5lODpjYXNlIFRyYW5zaXRpb25MYW5lOTpjYXNlIFRyYW5zaXRpb25MYW5lMTA6Y2FzZSBUcmFuc2l0aW9uTGFuZTExOmNhc2UgVHJhbnNpdGlvbkxhbmUxMjpjYXNlIFRyYW5zaXRpb25MYW5lMTM6Y2FzZSBUcmFuc2l0aW9uTGFuZTE0OmNhc2UgVHJhbnNpdGlvbkxhbmUxNTpjYXNlIFRyYW5zaXRpb25MYW5lMTY6Y2FzZSBSZXRyeUxhbmUxOmNhc2UgUmV0cnlMYW5lMjpjYXNlIFJldHJ5TGFuZTM6Y2FzZSBSZXRyeUxhbmU0OmNhc2UgUmV0cnlMYW5lNTpsYW5lPVRyYW5zaXRpb25IeWRyYXRpb25MYW5lO2JyZWFrO2Nhc2UgSWRsZUxhbmU6bGFuZT1JZGxlSHlkcmF0aW9uTGFuZTticmVhaztkZWZhdWx0Oi8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBhbHJlYWR5IGVpdGhlciBhIGh5ZHJhdGlvbiBsYW5lLCBvciBzaG91bGRuJ3Rcbi8vIGJlIHJldHJpZWQgYXQgYSBoeWRyYXRpb24gbGFuZS5cbmxhbmU9Tm9MYW5lO2JyZWFrO30vLyBDaGVjayBpZiB0aGUgbGFuZSB3ZSBjaG9zZSBpcyBzdXNwZW5kZWQuIElmIHNvLCB0aGF0IGluZGljYXRlcyB0aGF0IHdlXG4vLyBhbHJlYWR5IGF0dGVtcHRlZCBhbmQgZmFpbGVkIHRvIGh5ZHJhdGUgYXQgdGhhdCBsZXZlbC4gQWxzbyBjaGVjayBpZiB3ZSdyZVxuLy8gYWxyZWFkeSByZW5kZXJpbmcgdGhhdCBsYW5lLCB3aGljaCBpcyByYXJlIGJ1dCBjb3VsZCBoYXBwZW4uXG5pZigobGFuZSYocm9vdC5zdXNwZW5kZWRMYW5lc3xyZW5kZXJMYW5lcykpIT09Tm9MYW5lKXsvLyBHaXZlIHVwIHRyeWluZyB0byBoeWRyYXRlIGFuZCBmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlci5cbnJldHVybiBOb0xhbmU7fXJldHVybiBsYW5lO31mdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCxmaWJlcixsYW5lcyl7aWYoIWlzRGV2VG9vbHNQcmVzZW50KXtyZXR1cm47fXZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwPXJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDt3aGlsZShsYW5lcz4wKXt2YXIgaW5kZXg9bGFuZVRvSW5kZXgobGFuZXMpO3ZhciBsYW5lPTE8PGluZGV4O3ZhciB1cGRhdGVycz1wZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTt1cGRhdGVycy5hZGQoZmliZXIpO2xhbmVzJj1+bGFuZTt9fWZ1bmN0aW9uIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LGxhbmVzKXtpZighaXNEZXZUb29sc1ByZXNlbnQpe3JldHVybjt9dmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXA9cm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO3ZhciBtZW1vaXplZFVwZGF0ZXJzPXJvb3QubWVtb2l6ZWRVcGRhdGVyczt3aGlsZShsYW5lcz4wKXt2YXIgaW5kZXg9bGFuZVRvSW5kZXgobGFuZXMpO3ZhciBsYW5lPTE8PGluZGV4O3ZhciB1cGRhdGVycz1wZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTtpZih1cGRhdGVycy5zaXplPjApe3VwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpe3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZT09PW51bGx8fCFtZW1vaXplZFVwZGF0ZXJzLmhhcyhhbHRlcm5hdGUpKXttZW1vaXplZFVwZGF0ZXJzLmFkZChmaWJlcik7fX0pO3VwZGF0ZXJzLmNsZWFyKCk7fWxhbmVzJj1+bGFuZTt9fWZ1bmN0aW9uIGdldFRyYW5zaXRpb25zRm9yTGFuZXMocm9vdCxsYW5lcyl7e3JldHVybiBudWxsO319dmFyIERpc2NyZXRlRXZlbnRQcmlvcml0eT1TeW5jTGFuZTt2YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHk9SW5wdXRDb250aW51b3VzTGFuZTt2YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHk9RGVmYXVsdExhbmU7dmFyIElkbGVFdmVudFByaW9yaXR5PUlkbGVMYW5lO3ZhciBjdXJyZW50VXBkYXRlUHJpb3JpdHk9Tm9MYW5lO2Z1bmN0aW9uIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpe3JldHVybiBjdXJyZW50VXBkYXRlUHJpb3JpdHk7fWZ1bmN0aW9uIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSl7Y3VycmVudFVwZGF0ZVByaW9yaXR5PW5ld1ByaW9yaXR5O31mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkocHJpb3JpdHksZm4pe3ZhciBwcmV2aW91c1ByaW9yaXR5PWN1cnJlbnRVcGRhdGVQcmlvcml0eTt0cnl7Y3VycmVudFVwZGF0ZVByaW9yaXR5PXByaW9yaXR5O3JldHVybiBmbigpO31maW5hbGx5e2N1cnJlbnRVcGRhdGVQcmlvcml0eT1wcmV2aW91c1ByaW9yaXR5O319ZnVuY3Rpb24gaGlnaGVyRXZlbnRQcmlvcml0eShhLGIpe3JldHVybiBhIT09MCYmYTxiP2E6Yjt9ZnVuY3Rpb24gbG93ZXJFdmVudFByaW9yaXR5KGEsYil7cmV0dXJuIGE9PT0wfHxhPmI/YTpiO31mdW5jdGlvbiBpc0hpZ2hlckV2ZW50UHJpb3JpdHkoYSxiKXtyZXR1cm4gYSE9PTAmJmE8Yjt9ZnVuY3Rpb24gbGFuZXNUb0V2ZW50UHJpb3JpdHkobGFuZXMpe3ZhciBsYW5lPWdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO2lmKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5LGxhbmUpKXtyZXR1cm4gRGlzY3JldGVFdmVudFByaW9yaXR5O31pZighaXNIaWdoZXJFdmVudFByaW9yaXR5KENvbnRpbnVvdXNFdmVudFByaW9yaXR5LGxhbmUpKXtyZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7fWlmKGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZSkpe3JldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTt9cmV0dXJuIElkbGVFdmVudFByaW9yaXR5O30vLyBUaGlzIGlzIGltcG9ydGVkIGJ5IHRoZSBldmVudCByZXBsYXlpbmcgaW1wbGVtZW50YXRpb24gaW4gUmVhY3QgRE9NLiBJdCdzXG4vLyBpbiBhIHNlcGFyYXRlIGZpbGUgdG8gYnJlYWsgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIHJlbmRlcmVyIGFuZFxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiBpc1Jvb3REZWh5ZHJhdGVkKHJvb3Qpe3ZhciBjdXJyZW50U3RhdGU9cm9vdC5jdXJyZW50Lm1lbW9pemVkU3RhdGU7cmV0dXJuIGN1cnJlbnRTdGF0ZS5pc0RlaHlkcmF0ZWQ7fXZhciBfYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uO2Z1bmN0aW9uIHNldEF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbihmbil7X2F0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbj1mbjt9ZnVuY3Rpb24gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKXtfYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKTt9dmFyIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uO2Z1bmN0aW9uIHNldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGZuKXthdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbj1mbjt9dmFyIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eTtmdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZm4pe2F0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eT1mbjt9dmFyIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSQxO2Z1bmN0aW9uIHNldEdldEN1cnJlbnRVcGRhdGVQcmlvcml0eShmbil7Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDE9Zm47fXZhciBhdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eTtmdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eShmbil7YXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHk9Zm47fS8vIFRPRE86IFVwZ3JhZGUgdGhpcyBkZWZpbml0aW9uIG9uY2Ugd2UncmUgb24gYSBuZXdlciB2ZXJzaW9uIG9mIEZsb3cgdGhhdFxuLy8gaGFzIHRoaXMgZGVmaW5pdGlvbiBidWlsdC1pbi5cbnZhciBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0PWZhbHNlOy8vIFRoZSBxdWV1ZSBvZiBkaXNjcmV0ZSBldmVudHMgdG8gYmUgcmVwbGF5ZWQuXG52YXIgcXVldWVkRGlzY3JldGVFdmVudHM9W107Ly8gSW5kaWNhdGVzIGlmIGFueSBjb250aW51b3VzIGV2ZW50IHRhcmdldHMgYXJlIG5vbi1udWxsIGZvciBlYXJseSBiYWlsb3V0LlxuLy8gaWYgdGhlIGxhc3QgdGFyZ2V0IHdhcyBkZWh5ZHJhdGVkLlxudmFyIHF1ZXVlZEZvY3VzPW51bGw7dmFyIHF1ZXVlZERyYWc9bnVsbDt2YXIgcXVldWVkTW91c2U9bnVsbDsvLyBGb3IgcG9pbnRlciBldmVudHMgdGhlcmUgY2FuIGJlIG9uZSBsYXRlc3QgZXZlbnQgcGVyIHBvaW50ZXJJZC5cbnZhciBxdWV1ZWRQb2ludGVycz1uZXcgTWFwKCk7dmFyIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcz1uZXcgTWFwKCk7Ly8gV2UgY291bGQgY29uc2lkZXIgcmVwbGF5aW5nIHNlbGVjdGlvbmNoYW5nZSBhbmQgdG91Y2htb3ZlcyB0b28uXG52YXIgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzPVtdO3ZhciBkaXNjcmV0ZVJlcGxheWFibGVFdmVudHM9Wydtb3VzZWRvd24nLCdtb3VzZXVwJywndG91Y2hjYW5jZWwnLCd0b3VjaGVuZCcsJ3RvdWNoc3RhcnQnLCdhdXhjbGljaycsJ2RibGNsaWNrJywncG9pbnRlcmNhbmNlbCcsJ3BvaW50ZXJkb3duJywncG9pbnRlcnVwJywnZHJhZ2VuZCcsJ2RyYWdzdGFydCcsJ2Ryb3AnLCdjb21wb3NpdGlvbmVuZCcsJ2NvbXBvc2l0aW9uc3RhcnQnLCdrZXlkb3duJywna2V5cHJlc3MnLCdrZXl1cCcsJ2lucHV0JywndGV4dElucHV0JywvLyBJbnRlbnRpb25hbGx5IGNhbWVsQ2FzZVxuJ2NvcHknLCdjdXQnLCdwYXN0ZScsJ2NsaWNrJywnY2hhbmdlJywnY29udGV4dG1lbnUnLCdyZXNldCcsJ3N1Ym1pdCddO2Z1bmN0aW9uIGlzRGlzY3JldGVFdmVudFRoYXRSZXF1aXJlc0h5ZHJhdGlvbihldmVudFR5cGUpe3JldHVybiBkaXNjcmV0ZVJlcGxheWFibGVFdmVudHMuaW5kZXhPZihldmVudFR5cGUpPi0xO31mdW5jdGlvbiBjcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCl7cmV0dXJue2Jsb2NrZWRPbjpibG9ja2VkT24sZG9tRXZlbnROYW1lOmRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzOmV2ZW50U3lzdGVtRmxhZ3MsbmF0aXZlRXZlbnQ6bmF0aXZlRXZlbnQsdGFyZ2V0Q29udGFpbmVyczpbdGFyZ2V0Q29udGFpbmVyXX07fWZ1bmN0aW9uIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KXtzd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2ZvY3VzaW4nOmNhc2UnZm9jdXNvdXQnOnF1ZXVlZEZvY3VzPW51bGw7YnJlYWs7Y2FzZSdkcmFnZW50ZXInOmNhc2UnZHJhZ2xlYXZlJzpxdWV1ZWREcmFnPW51bGw7YnJlYWs7Y2FzZSdtb3VzZW92ZXInOmNhc2UnbW91c2VvdXQnOnF1ZXVlZE1vdXNlPW51bGw7YnJlYWs7Y2FzZSdwb2ludGVyb3Zlcic6Y2FzZSdwb2ludGVyb3V0Jzp7dmFyIHBvaW50ZXJJZD1uYXRpdmVFdmVudC5wb2ludGVySWQ7cXVldWVkUG9pbnRlcnMuZGVsZXRlKHBvaW50ZXJJZCk7YnJlYWs7fWNhc2UnZ290cG9pbnRlcmNhcHR1cmUnOmNhc2UnbG9zdHBvaW50ZXJjYXB0dXJlJzp7dmFyIF9wb2ludGVySWQ9bmF0aXZlRXZlbnQucG9pbnRlcklkO3F1ZXVlZFBvaW50ZXJDYXB0dXJlcy5kZWxldGUoX3BvaW50ZXJJZCk7YnJlYWs7fX19ZnVuY3Rpb24gYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChleGlzdGluZ1F1ZXVlZEV2ZW50LGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsbmF0aXZlRXZlbnQpe2lmKGV4aXN0aW5nUXVldWVkRXZlbnQ9PT1udWxsfHxleGlzdGluZ1F1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50IT09bmF0aXZlRXZlbnQpe3ZhciBxdWV1ZWRFdmVudD1jcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCk7aWYoYmxvY2tlZE9uIT09bnVsbCl7dmFyIF9maWJlcjI9Z2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO2lmKF9maWJlcjIhPT1udWxsKXsvLyBBdHRlbXB0IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIHRhcmdldC5cbmF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKF9maWJlcjIpO319cmV0dXJuIHF1ZXVlZEV2ZW50O30vLyBJZiB3ZSBoYXZlIGFscmVhZHkgcXVldWVkIHRoaXMgZXhhY3QgZXZlbnQsIHRoZW4gaXQncyBiZWNhdXNlXG4vLyB0aGUgZGlmZmVyZW50IGV2ZW50IHN5c3RlbXMgaGF2ZSBkaWZmZXJlbnQgRE9NIGV2ZW50IGxpc3RlbmVycy5cbi8vIFdlIGNhbiBhY2N1bXVsYXRlIHRoZSBmbGFncywgYW5kIHRoZSB0YXJnZXRDb250YWluZXJzLCBhbmRcbi8vIHN0b3JlIGEgc2luZ2xlIGV2ZW50IHRvIGJlIHJlcGxheWVkLlxuZXhpc3RpbmdRdWV1ZWRFdmVudC5ldmVudFN5c3RlbUZsYWdzfD1ldmVudFN5c3RlbUZsYWdzO3ZhciB0YXJnZXRDb250YWluZXJzPWV4aXN0aW5nUXVldWVkRXZlbnQudGFyZ2V0Q29udGFpbmVycztpZih0YXJnZXRDb250YWluZXIhPT1udWxsJiZ0YXJnZXRDb250YWluZXJzLmluZGV4T2YodGFyZ2V0Q29udGFpbmVyKT09PS0xKXt0YXJnZXRDb250YWluZXJzLnB1c2godGFyZ2V0Q29udGFpbmVyKTt9cmV0dXJuIGV4aXN0aW5nUXVldWVkRXZlbnQ7fWZ1bmN0aW9uIHF1ZXVlSWZDb250aW51b3VzRXZlbnQoYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCl7Ly8gVGhlc2Ugc2V0IHJlbGF0ZWRUYXJnZXQgdG8gbnVsbCBiZWNhdXNlIHRoZSByZXBsYXllZCBldmVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgd2Vcbi8vIG1vdmVkIGZyb20gb3V0c2lkZSB0aGUgd2luZG93IChubyB0YXJnZXQpIG9udG8gdGhlIHRhcmdldCBvbmNlIGl0IGh5ZHJhdGVzLlxuLy8gSW5zdGVhZCBvZiBtdXRhdGluZyB3ZSBjb3VsZCBjbG9uZSB0aGUgZXZlbnQuXG5zd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2ZvY3VzaW4nOnt2YXIgZm9jdXNFdmVudD1uYXRpdmVFdmVudDtxdWV1ZWRGb2N1cz1hY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZEZvY3VzLGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsZm9jdXNFdmVudCk7cmV0dXJuIHRydWU7fWNhc2UnZHJhZ2VudGVyJzp7dmFyIGRyYWdFdmVudD1uYXRpdmVFdmVudDtxdWV1ZWREcmFnPWFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkRHJhZyxibG9ja2VkT24sZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLGRyYWdFdmVudCk7cmV0dXJuIHRydWU7fWNhc2UnbW91c2VvdmVyJzp7dmFyIG1vdXNlRXZlbnQ9bmF0aXZlRXZlbnQ7cXVldWVkTW91c2U9YWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRNb3VzZSxibG9ja2VkT24sZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG1vdXNlRXZlbnQpO3JldHVybiB0cnVlO31jYXNlJ3BvaW50ZXJvdmVyJzp7dmFyIHBvaW50ZXJFdmVudD1uYXRpdmVFdmVudDt2YXIgcG9pbnRlcklkPXBvaW50ZXJFdmVudC5wb2ludGVySWQ7cXVldWVkUG9pbnRlcnMuc2V0KHBvaW50ZXJJZCxhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZFBvaW50ZXJzLmdldChwb2ludGVySWQpfHxudWxsLGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIscG9pbnRlckV2ZW50KSk7cmV0dXJuIHRydWU7fWNhc2UnZ290cG9pbnRlcmNhcHR1cmUnOnt2YXIgX3BvaW50ZXJFdmVudD1uYXRpdmVFdmVudDt2YXIgX3BvaW50ZXJJZDI9X3BvaW50ZXJFdmVudC5wb2ludGVySWQ7cXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChfcG9pbnRlcklkMixhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5nZXQoX3BvaW50ZXJJZDIpfHxudWxsLGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsX3BvaW50ZXJFdmVudCkpO3JldHVybiB0cnVlO319cmV0dXJuIGZhbHNlO30vLyBDaGVjayBpZiB0aGlzIHRhcmdldCBpcyB1bmJsb2NrZWQuIFJldHVybnMgdHJ1ZSBpZiBpdCdzIHVuYmxvY2tlZC5cbmZ1bmN0aW9uIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChxdWV1ZWRUYXJnZXQpey8vIFRPRE86IFRoaXMgZnVuY3Rpb24gc2hhcmVzIGEgbG90IG9mIGxvZ2ljIHdpdGggZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudC5cbi8vIFRyeSB0byB1bmlmeSB0aGVtLiBJdCdzIGEgYml0IHRyaWNreSBzaW5jZSBpdCB3b3VsZCByZXF1aXJlIHR3byByZXR1cm5cbi8vIHZhbHVlcy5cbnZhciB0YXJnZXRJbnN0PWdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHF1ZXVlZFRhcmdldC50YXJnZXQpO2lmKHRhcmdldEluc3QhPT1udWxsKXt2YXIgbmVhcmVzdE1vdW50ZWQ9Z2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtpZihuZWFyZXN0TW91bnRlZCE9PW51bGwpe3ZhciB0YWc9bmVhcmVzdE1vdW50ZWQudGFnO2lmKHRhZz09PVN1c3BlbnNlQ29tcG9uZW50KXt2YXIgaW5zdGFuY2U9Z2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7aWYoaW5zdGFuY2UhPT1udWxsKXsvLyBXZSdyZSBibG9ja2VkIG9uIGh5ZHJhdGluZyB0aGlzIGJvdW5kYXJ5LlxuLy8gSW5jcmVhc2UgaXRzIHByaW9yaXR5LlxucXVldWVkVGFyZ2V0LmJsb2NrZWRPbj1pbnN0YW5jZTthdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eShxdWV1ZWRUYXJnZXQucHJpb3JpdHksZnVuY3Rpb24oKXthdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkobmVhcmVzdE1vdW50ZWQpO30pO3JldHVybjt9fWVsc2UgaWYodGFnPT09SG9zdFJvb3Qpe3ZhciByb290PW5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtpZihpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKXtxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uPWdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7Ly8gV2UgZG9uJ3QgY3VycmVudGx5IGhhdmUgYSB3YXkgdG8gaW5jcmVhc2UgdGhlIHByaW9yaXR5IG9mXG4vLyBhIHJvb3Qgb3RoZXIgdGhhbiBzeW5jLlxucmV0dXJuO319fX1xdWV1ZWRUYXJnZXQuYmxvY2tlZE9uPW51bGw7fWZ1bmN0aW9uIHF1ZXVlRXhwbGljaXRIeWRyYXRpb25UYXJnZXQodGFyZ2V0KXsvLyBUT0RPOiBUaGlzIHdpbGwgcmVhZCB0aGUgcHJpb3JpdHkgaWYgaXQncyBkaXNwYXRjaGVkIGJ5IHRoZSBSZWFjdFxuLy8gZXZlbnQgc3lzdGVtIGJ1dCBub3QgbmF0aXZlIGV2ZW50cy4gU2hvdWxkIHJlYWQgd2luZG93LmV2ZW50LnR5cGUsIGxpa2Vcbi8vIHdlIGRvIGZvciB1cGRhdGVzIChnZXRDdXJyZW50RXZlbnRQcmlvcml0eSkuXG52YXIgdXBkYXRlUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDEoKTt2YXIgcXVldWVkVGFyZ2V0PXtibG9ja2VkT246bnVsbCx0YXJnZXQ6dGFyZ2V0LHByaW9yaXR5OnVwZGF0ZVByaW9yaXR5fTt2YXIgaT0wO2Zvcig7aTxxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoO2krKyl7Ly8gU3RvcCBvbmNlIHdlIGhpdCB0aGUgZmlyc3QgdGFyZ2V0IHdpdGggbG93ZXIgcHJpb3JpdHkgdGhhblxuaWYoIWlzSGlnaGVyRXZlbnRQcmlvcml0eSh1cGRhdGVQcmlvcml0eSxxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHNbaV0ucHJpb3JpdHkpKXticmVhazt9fXF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5zcGxpY2UoaSwwLHF1ZXVlZFRhcmdldCk7aWYoaT09PTApe2F0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChxdWV1ZWRUYXJnZXQpO319ZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCl7aWYocXVldWVkRXZlbnQuYmxvY2tlZE9uIT09bnVsbCl7cmV0dXJuIGZhbHNlO312YXIgdGFyZ2V0Q29udGFpbmVycz1xdWV1ZWRFdmVudC50YXJnZXRDb250YWluZXJzO3doaWxlKHRhcmdldENvbnRhaW5lcnMubGVuZ3RoPjApe3ZhciB0YXJnZXRDb250YWluZXI9dGFyZ2V0Q29udGFpbmVyc1swXTt2YXIgbmV4dEJsb2NrZWRPbj1maW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KHF1ZXVlZEV2ZW50LmRvbUV2ZW50TmFtZSxxdWV1ZWRFdmVudC5ldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixxdWV1ZWRFdmVudC5uYXRpdmVFdmVudCk7aWYobmV4dEJsb2NrZWRPbj09PW51bGwpe3t2YXIgbmF0aXZlRXZlbnQ9cXVldWVkRXZlbnQubmF0aXZlRXZlbnQ7dmFyIG5hdGl2ZUV2ZW50Q2xvbmU9bmV3IG5hdGl2ZUV2ZW50LmNvbnN0cnVjdG9yKG5hdGl2ZUV2ZW50LnR5cGUsbmF0aXZlRXZlbnQpO3NldFJlcGxheWluZ0V2ZW50KG5hdGl2ZUV2ZW50Q2xvbmUpO25hdGl2ZUV2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KG5hdGl2ZUV2ZW50Q2xvbmUpO3Jlc2V0UmVwbGF5aW5nRXZlbnQoKTt9fWVsc2V7Ly8gV2UncmUgc3RpbGwgYmxvY2tlZC4gVHJ5IGFnYWluIGxhdGVyLlxudmFyIF9maWJlcjM9Z2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0QmxvY2tlZE9uKTtpZihfZmliZXIzIT09bnVsbCl7YXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMyk7fXF1ZXVlZEV2ZW50LmJsb2NrZWRPbj1uZXh0QmxvY2tlZE9uO3JldHVybiBmYWxzZTt9Ly8gVGhpcyB0YXJnZXQgY29udGFpbmVyIHdhcyBzdWNjZXNzZnVsbHkgZGlzcGF0Y2hlZC4gVHJ5IHRoZSBuZXh0LlxudGFyZ2V0Q29udGFpbmVycy5zaGlmdCgpO31yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKHF1ZXVlZEV2ZW50LGtleSxtYXApe2lmKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpKXttYXAuZGVsZXRlKGtleSk7fX1mdW5jdGlvbiByZXBsYXlVbmJsb2NrZWRFdmVudHMoKXtoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0PWZhbHNlO2lmKHF1ZXVlZEZvY3VzIT09bnVsbCYmYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRGb2N1cykpe3F1ZXVlZEZvY3VzPW51bGw7fWlmKHF1ZXVlZERyYWchPT1udWxsJiZhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZERyYWcpKXtxdWV1ZWREcmFnPW51bGw7fWlmKHF1ZXVlZE1vdXNlIT09bnVsbCYmYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRNb3VzZSkpe3F1ZXVlZE1vdXNlPW51bGw7fXF1ZXVlZFBvaW50ZXJzLmZvckVhY2goYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKTtxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO31mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRXZlbnQsdW5ibG9ja2VkKXtpZihxdWV1ZWRFdmVudC5ibG9ja2VkT249PT11bmJsb2NrZWQpe3F1ZXVlZEV2ZW50LmJsb2NrZWRPbj1udWxsO2lmKCFoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0KXtoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0PXRydWU7Ly8gU2NoZWR1bGUgYSBjYWxsYmFjayB0byBhdHRlbXB0IHJlcGxheWluZyBhcyBtYW55IGV2ZW50cyBhcyBhcmVcbi8vIG5vdyB1bmJsb2NrZWQuIFRoaXMgZmlyc3QgbWlnaHQgbm90IGFjdHVhbGx5IGJlIHVuYmxvY2tlZCB5ZXQuXG4vLyBXZSBjb3VsZCBjaGVjayBpdCBlYXJseSB0byBhdm9pZCBzY2hlZHVsaW5nIGFuIHVubmVjZXNzYXJ5IGNhbGxiYWNrLlxuU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LHJlcGxheVVuYmxvY2tlZEV2ZW50cyk7fX19ZnVuY3Rpb24gcmV0cnlJZkJsb2NrZWRPbih1bmJsb2NrZWQpey8vIE1hcmsgYW55dGhpbmcgdGhhdCB3YXMgYmxvY2tlZCBvbiB0aGlzIGFzIG5vIGxvbmdlciBibG9ja2VkXG4vLyBhbmQgZWxpZ2libGUgZm9yIGEgcmVwbGF5LlxuaWYocXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoPjApe3NjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREaXNjcmV0ZUV2ZW50c1swXSx1bmJsb2NrZWQpOy8vIFRoaXMgaXMgYSBleHBvbmVudGlhbCBzZWFyY2ggZm9yIGVhY2ggYm91bmRhcnkgdGhhdCBjb21taXRzLiBJIHRoaW5rIGl0J3Ncbi8vIHdvcnRoIGl0IGJlY2F1c2Ugd2UgZXhwZWN0IHZlcnkgZmV3IGRpc2NyZXRlIGV2ZW50cyB0byBxdWV1ZSB1cCBhbmQgb25jZVxuLy8gd2UgYXJlIGFjdHVhbGx5IGZ1bGx5IHVuYmxvY2tlZCBpdCB3aWxsIGJlIGZhc3QgdG8gcmVwbGF5IHRoZW0uXG5mb3IodmFyIGk9MTtpPHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aDtpKyspe3ZhciBxdWV1ZWRFdmVudD1xdWV1ZWREaXNjcmV0ZUV2ZW50c1tpXTtpZihxdWV1ZWRFdmVudC5ibG9ja2VkT249PT11bmJsb2NrZWQpe3F1ZXVlZEV2ZW50LmJsb2NrZWRPbj1udWxsO319fWlmKHF1ZXVlZEZvY3VzIT09bnVsbCl7c2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEZvY3VzLHVuYmxvY2tlZCk7fWlmKHF1ZXVlZERyYWchPT1udWxsKXtzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRHJhZyx1bmJsb2NrZWQpO31pZihxdWV1ZWRNb3VzZSE9PW51bGwpe3NjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRNb3VzZSx1bmJsb2NrZWQpO312YXIgdW5ibG9jaz1mdW5jdGlvbihxdWV1ZWRFdmVudCl7cmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCx1bmJsb2NrZWQpO307cXVldWVkUG9pbnRlcnMuZm9yRWFjaCh1bmJsb2NrKTtxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZm9yRWFjaCh1bmJsb2NrKTtmb3IodmFyIF9pPTA7X2k8cXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aDtfaSsrKXt2YXIgcXVldWVkVGFyZ2V0PXF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tfaV07aWYocXVldWVkVGFyZ2V0LmJsb2NrZWRPbj09PXVuYmxvY2tlZCl7cXVldWVkVGFyZ2V0LmJsb2NrZWRPbj1udWxsO319d2hpbGUocXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aD4wKXt2YXIgbmV4dEV4cGxpY2l0VGFyZ2V0PXF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1swXTtpZihuZXh0RXhwbGljaXRUYXJnZXQuYmxvY2tlZE9uIT09bnVsbCl7Ly8gV2UncmUgc3RpbGwgYmxvY2tlZC5cbmJyZWFrO31lbHNle2F0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChuZXh0RXhwbGljaXRUYXJnZXQpO2lmKG5leHRFeHBsaWNpdFRhcmdldC5ibG9ja2VkT249PT1udWxsKXsvLyBXZSdyZSB1bmJsb2NrZWQuXG5xdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMuc2hpZnQoKTt9fX19dmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOy8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZD10cnVlOy8vIFRoaXMgaXMgZXhwb3J0ZWQgaW4gRkIgYnVpbGRzIGZvciB1c2UgYnkgbGVnYWN5IEZCIGxheWVyIGluZnJhLlxuLy8gV2UnZCBsaWtlIHRvIHJlbW92ZSB0aGlzIGJ1dCBpdCdzIG5vdCBjbGVhciBpZiB0aGlzIGlzIHNhZmUuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpe19lbmFibGVkPSEhZW5hYmxlZDt9ZnVuY3Rpb24gaXNFbmFibGVkKCl7cmV0dXJuIF9lbmFibGVkO31mdW5jdGlvbiBjcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3Mpe3ZhciBldmVudFByaW9yaXR5PWdldEV2ZW50UHJpb3JpdHkoZG9tRXZlbnROYW1lKTt2YXIgbGlzdGVuZXJXcmFwcGVyO3N3aXRjaChldmVudFByaW9yaXR5KXtjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpsaXN0ZW5lcldyYXBwZXI9ZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50O2JyZWFrO2Nhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6bGlzdGVuZXJXcmFwcGVyPWRpc3BhdGNoQ29udGludW91c0V2ZW50O2JyZWFrO2Nhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6ZGVmYXVsdDpsaXN0ZW5lcldyYXBwZXI9ZGlzcGF0Y2hFdmVudDticmVhazt9cmV0dXJuIGxpc3RlbmVyV3JhcHBlci5iaW5kKG51bGwsZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyKTt9ZnVuY3Rpb24gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLGNvbnRhaW5lcixuYXRpdmVFdmVudCl7dmFyIHByZXZpb3VzUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7dmFyIHByZXZUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247UmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbj1udWxsO3RyeXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLGNvbnRhaW5lcixuYXRpdmVFdmVudCk7fWZpbmFsbHl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247fX1mdW5jdGlvbiBkaXNwYXRjaENvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxjb250YWluZXIsbmF0aXZlRXZlbnQpe3ZhciBwcmV2aW91c1ByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3ZhciBwcmV2VHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb249bnVsbDt0cnl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KENvbnRpbnVvdXNFdmVudFByaW9yaXR5KTtkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLGNvbnRhaW5lcixuYXRpdmVFdmVudCk7fWZpbmFsbHl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247fX1mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCl7aWYoIV9lbmFibGVkKXtyZXR1cm47fXtkaXNwYXRjaEV2ZW50V2l0aEVuYWJsZUNhcHR1cmVQaGFzZVNlbGVjdGl2ZUh5ZHJhdGlvbldpdGhvdXREaXNjcmV0ZUV2ZW50UmVwbGF5KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCk7fX1mdW5jdGlvbiBkaXNwYXRjaEV2ZW50V2l0aEVuYWJsZUNhcHR1cmVQaGFzZVNlbGVjdGl2ZUh5ZHJhdGlvbldpdGhvdXREaXNjcmV0ZUV2ZW50UmVwbGF5KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCl7dmFyIGJsb2NrZWRPbj1maW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCk7aWYoYmxvY2tlZE9uPT09bnVsbCl7ZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLG5hdGl2ZUV2ZW50LHJldHVybl90YXJnZXRJbnN0LHRhcmdldENvbnRhaW5lcik7Y2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpO3JldHVybjt9aWYocXVldWVJZkNvbnRpbnVvdXNFdmVudChibG9ja2VkT24sZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KSl7bmF0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7cmV0dXJuO30vLyBXZSBuZWVkIHRvIGNsZWFyIG9ubHkgaWYgd2UgZGlkbid0IHF1ZXVlIGJlY2F1c2Vcbi8vIHF1ZXVlaW5nIGlzIGFjY3VtdWxhdGl2ZS5cbmNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KTtpZihldmVudFN5c3RlbUZsYWdzJklTX0NBUFRVUkVfUEhBU0UmJmlzRGlzY3JldGVFdmVudFRoYXRSZXF1aXJlc0h5ZHJhdGlvbihkb21FdmVudE5hbWUpKXt3aGlsZShibG9ja2VkT24hPT1udWxsKXt2YXIgZmliZXI9Z2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO2lmKGZpYmVyIT09bnVsbCl7YXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKTt9dmFyIG5leHRCbG9ja2VkT249ZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsbmF0aXZlRXZlbnQpO2lmKG5leHRCbG9ja2VkT249PT1udWxsKXtkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsbmF0aXZlRXZlbnQscmV0dXJuX3RhcmdldEluc3QsdGFyZ2V0Q29udGFpbmVyKTt9aWYobmV4dEJsb2NrZWRPbj09PWJsb2NrZWRPbil7YnJlYWs7fWJsb2NrZWRPbj1uZXh0QmxvY2tlZE9uO31pZihibG9ja2VkT24hPT1udWxsKXtuYXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTt9cmV0dXJuO30vLyBUaGlzIGlzIG5vdCByZXBsYXlhYmxlIHNvIHdlJ2xsIGludm9rZSBpdCBidXQgd2l0aG91dCBhIHRhcmdldCxcbi8vIGluIGNhc2UgdGhlIGV2ZW50IHN5c3RlbSBuZWVkcyB0byB0cmFjZSBpdC5cbmRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxuYXRpdmVFdmVudCxudWxsLHRhcmdldENvbnRhaW5lcik7fXZhciByZXR1cm5fdGFyZ2V0SW5zdD1udWxsOy8vIFJldHVybnMgYSBTdXNwZW5zZUluc3RhbmNlIG9yIENvbnRhaW5lciBpZiBpdCdzIGJsb2NrZWQuXG4vLyBUaGUgcmV0dXJuX3RhcmdldEluc3QgZmllbGQgYWJvdmUgaXMgY29uY2VwdHVhbGx5IHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZS5cbmZ1bmN0aW9uIGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KXsvLyBUT0RPOiBXYXJuIGlmIF9lbmFibGVkIGlzIGZhbHNlLlxucmV0dXJuX3RhcmdldEluc3Q9bnVsbDt2YXIgbmF0aXZlRXZlbnRUYXJnZXQ9Z2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO3ZhciB0YXJnZXRJbnN0PWdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtpZih0YXJnZXRJbnN0IT09bnVsbCl7dmFyIG5lYXJlc3RNb3VudGVkPWdldE5lYXJlc3RNb3VudGVkRmliZXIodGFyZ2V0SW5zdCk7aWYobmVhcmVzdE1vdW50ZWQ9PT1udWxsKXsvLyBUaGlzIHRyZWUgaGFzIGJlZW4gdW5tb3VudGVkIGFscmVhZHkuIERpc3BhdGNoIHdpdGhvdXQgYSB0YXJnZXQuXG50YXJnZXRJbnN0PW51bGw7fWVsc2V7dmFyIHRhZz1uZWFyZXN0TW91bnRlZC50YWc7aWYodGFnPT09U3VzcGVuc2VDb21wb25lbnQpe3ZhciBpbnN0YW5jZT1nZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTtpZihpbnN0YW5jZSE9PW51bGwpey8vIFF1ZXVlIHRoZSBldmVudCB0byBiZSByZXBsYXllZCBsYXRlci4gQWJvcnQgZGlzcGF0Y2hpbmcgc2luY2Ugd2Vcbi8vIGRvbid0IHdhbnQgdGhpcyBldmVudCBkaXNwYXRjaGVkIHR3aWNlIHRocm91Z2ggdGhlIGV2ZW50IHN5c3RlbS5cbi8vIFRPRE86IElmIHRoaXMgaXMgdGhlIGZpcnN0IGRpc2NyZXRlIGV2ZW50IGluIHRoZSBxdWV1ZS4gU2NoZWR1bGUgYW4gaW5jcmVhc2VkXG4vLyBwcmlvcml0eSBmb3IgdGhpcyBib3VuZGFyeS5cbnJldHVybiBpbnN0YW5jZTt9Ly8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBzb21ldGhpbmcgd2VudCB3cm9uZyBidXQgdG8gYXZvaWQgYmxvY2tpbmdcbi8vIHRoZSB3aG9sZSBzeXN0ZW0sIGRpc3BhdGNoIHRoZSBldmVudCB3aXRob3V0IGEgdGFyZ2V0LlxuLy8gVE9ETzogV2Fybi5cbnRhcmdldEluc3Q9bnVsbDt9ZWxzZSBpZih0YWc9PT1Ib3N0Um9vdCl7dmFyIHJvb3Q9bmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlO2lmKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpey8vIElmIHRoaXMgaGFwcGVucyBkdXJpbmcgYSByZXBsYXkgc29tZXRoaW5nIHdlbnQgd3JvbmcgYW5kIGl0IG1pZ2h0IGJsb2NrXG4vLyB0aGUgd2hvbGUgc3lzdGVtLlxucmV0dXJuIGdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7fXRhcmdldEluc3Q9bnVsbDt9ZWxzZSBpZihuZWFyZXN0TW91bnRlZCE9PXRhcmdldEluc3Qpey8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbi8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4vLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4vLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbnRhcmdldEluc3Q9bnVsbDt9fX1yZXR1cm5fdGFyZ2V0SW5zdD10YXJnZXRJbnN0Oy8vIFdlJ3JlIG5vdCBibG9ja2VkIG9uIGFueXRoaW5nLlxucmV0dXJuIG51bGw7fWZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoZG9tRXZlbnROYW1lKXtzd2l0Y2goZG9tRXZlbnROYW1lKXsvLyBVc2VkIGJ5IFNpbXBsZUV2ZW50UGx1Z2luOlxuY2FzZSdjYW5jZWwnOmNhc2UnY2xpY2snOmNhc2UnY2xvc2UnOmNhc2UnY29udGV4dG1lbnUnOmNhc2UnY29weSc6Y2FzZSdjdXQnOmNhc2UnYXV4Y2xpY2snOmNhc2UnZGJsY2xpY2snOmNhc2UnZHJhZ2VuZCc6Y2FzZSdkcmFnc3RhcnQnOmNhc2UnZHJvcCc6Y2FzZSdmb2N1c2luJzpjYXNlJ2ZvY3Vzb3V0JzpjYXNlJ2lucHV0JzpjYXNlJ2ludmFsaWQnOmNhc2Una2V5ZG93bic6Y2FzZSdrZXlwcmVzcyc6Y2FzZSdrZXl1cCc6Y2FzZSdtb3VzZWRvd24nOmNhc2UnbW91c2V1cCc6Y2FzZSdwYXN0ZSc6Y2FzZSdwYXVzZSc6Y2FzZSdwbGF5JzpjYXNlJ3BvaW50ZXJjYW5jZWwnOmNhc2UncG9pbnRlcmRvd24nOmNhc2UncG9pbnRlcnVwJzpjYXNlJ3JhdGVjaGFuZ2UnOmNhc2UncmVzZXQnOmNhc2UncmVzaXplJzpjYXNlJ3NlZWtlZCc6Y2FzZSdzdWJtaXQnOmNhc2UndG91Y2hjYW5jZWwnOmNhc2UndG91Y2hlbmQnOmNhc2UndG91Y2hzdGFydCc6Y2FzZSd2b2x1bWVjaGFuZ2UnOi8vIFVzZWQgYnkgcG9seWZpbGxzOlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5jYXNlJ2NoYW5nZSc6Y2FzZSdzZWxlY3Rpb25jaGFuZ2UnOmNhc2UndGV4dElucHV0JzpjYXNlJ2NvbXBvc2l0aW9uc3RhcnQnOmNhc2UnY29tcG9zaXRpb25lbmQnOmNhc2UnY29tcG9zaXRpb251cGRhdGUnOi8vIE9ubHkgZW5hYmxlQ3JlYXRlRXZlbnRIYW5kbGVBUEk6XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UnYmVmb3JlYmx1cic6Y2FzZSdhZnRlcmJsdXInOi8vIE5vdCB1c2VkIGJ5IFJlYWN0IGJ1dCBjb3VsZCBiZSBieSB1c2VyIGNvZGU6XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UnYmVmb3JlaW5wdXQnOmNhc2UnYmx1cic6Y2FzZSdmdWxsc2NyZWVuY2hhbmdlJzpjYXNlJ2ZvY3VzJzpjYXNlJ2hhc2hjaGFuZ2UnOmNhc2UncG9wc3RhdGUnOmNhc2Unc2VsZWN0JzpjYXNlJ3NlbGVjdHN0YXJ0JzpyZXR1cm4gRGlzY3JldGVFdmVudFByaW9yaXR5O2Nhc2UnZHJhZyc6Y2FzZSdkcmFnZW50ZXInOmNhc2UnZHJhZ2V4aXQnOmNhc2UnZHJhZ2xlYXZlJzpjYXNlJ2RyYWdvdmVyJzpjYXNlJ21vdXNlbW92ZSc6Y2FzZSdtb3VzZW91dCc6Y2FzZSdtb3VzZW92ZXInOmNhc2UncG9pbnRlcm1vdmUnOmNhc2UncG9pbnRlcm91dCc6Y2FzZSdwb2ludGVyb3Zlcic6Y2FzZSdzY3JvbGwnOmNhc2UndG9nZ2xlJzpjYXNlJ3RvdWNobW92ZSc6Y2FzZSd3aGVlbCc6Ly8gTm90IHVzZWQgYnkgUmVhY3QgYnV0IGNvdWxkIGJlIGJ5IHVzZXIgY29kZTpcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuY2FzZSdtb3VzZWVudGVyJzpjYXNlJ21vdXNlbGVhdmUnOmNhc2UncG9pbnRlcmVudGVyJzpjYXNlJ3BvaW50ZXJsZWF2ZSc6cmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O2Nhc2UnbWVzc2FnZSc6ey8vIFdlIG1pZ2h0IGJlIGluIHRoZSBTY2hlZHVsZXIgY2FsbGJhY2suXG4vLyBFdmVudHVhbGx5IHRoaXMgbWVjaGFuaXNtIHdpbGwgYmUgcmVwbGFjZWQgYnkgYSBjaGVja1xuLy8gb2YgdGhlIGN1cnJlbnQgcHJpb3JpdHkgb24gdGhlIG5hdGl2ZSBzY2hlZHVsZXIuXG52YXIgc2NoZWR1bGVyUHJpb3JpdHk9Z2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtzd2l0Y2goc2NoZWR1bGVyUHJpb3JpdHkpe2Nhc2UgSW1tZWRpYXRlUHJpb3JpdHk6cmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OnJldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtjYXNlIE5vcm1hbFByaW9yaXR5OmNhc2UgTG93UHJpb3JpdHk6Ly8gVE9ETzogSGFuZGxlIExvd1NjaGVkdWxlclByaW9yaXR5LCBzb21laG93LiBNYXliZSB0aGUgc2FtZSBsYW5lIGFzIGh5ZHJhdGlvbi5cbnJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtjYXNlIElkbGVQcmlvcml0eTpyZXR1cm4gSWRsZUV2ZW50UHJpb3JpdHk7ZGVmYXVsdDpyZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7fX1kZWZhdWx0OnJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTt9fWZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIodGFyZ2V0LGV2ZW50VHlwZSxsaXN0ZW5lcil7dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLGxpc3RlbmVyLGZhbHNlKTtyZXR1cm4gbGlzdGVuZXI7fWZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldCxldmVudFR5cGUsbGlzdGVuZXIpe3RhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSxsaXN0ZW5lcix0cnVlKTtyZXR1cm4gbGlzdGVuZXI7fWZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldCxldmVudFR5cGUsbGlzdGVuZXIscGFzc2l2ZSl7dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLGxpc3RlbmVyLHtjYXB0dXJlOnRydWUscGFzc2l2ZTpwYXNzaXZlfSk7cmV0dXJuIGxpc3RlbmVyO31mdW5jdGlvbiBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldCxldmVudFR5cGUsbGlzdGVuZXIscGFzc2l2ZSl7dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLGxpc3RlbmVyLHtwYXNzaXZlOnBhc3NpdmV9KTtyZXR1cm4gbGlzdGVuZXI7fS8qKlxuICogVGhlc2UgdmFyaWFibGVzIHN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL3ZhciByb290PW51bGw7dmFyIHN0YXJ0VGV4dD1udWxsO3ZhciBmYWxsYmFja1RleHQ9bnVsbDtmdW5jdGlvbiBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KXtyb290PW5hdGl2ZUV2ZW50VGFyZ2V0O3N0YXJ0VGV4dD1nZXRUZXh0KCk7cmV0dXJuIHRydWU7fWZ1bmN0aW9uIHJlc2V0KCl7cm9vdD1udWxsO3N0YXJ0VGV4dD1udWxsO2ZhbGxiYWNrVGV4dD1udWxsO31mdW5jdGlvbiBnZXREYXRhKCl7aWYoZmFsbGJhY2tUZXh0KXtyZXR1cm4gZmFsbGJhY2tUZXh0O312YXIgc3RhcnQ7dmFyIHN0YXJ0VmFsdWU9c3RhcnRUZXh0O3ZhciBzdGFydExlbmd0aD1zdGFydFZhbHVlLmxlbmd0aDt2YXIgZW5kO3ZhciBlbmRWYWx1ZT1nZXRUZXh0KCk7dmFyIGVuZExlbmd0aD1lbmRWYWx1ZS5sZW5ndGg7Zm9yKHN0YXJ0PTA7c3RhcnQ8c3RhcnRMZW5ndGg7c3RhcnQrKyl7aWYoc3RhcnRWYWx1ZVtzdGFydF0hPT1lbmRWYWx1ZVtzdGFydF0pe2JyZWFrO319dmFyIG1pbkVuZD1zdGFydExlbmd0aC1zdGFydDtmb3IoZW5kPTE7ZW5kPD1taW5FbmQ7ZW5kKyspe2lmKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGgtZW5kXSE9PWVuZFZhbHVlW2VuZExlbmd0aC1lbmRdKXticmVhazt9fXZhciBzbGljZVRhaWw9ZW5kPjE/MS1lbmQ6dW5kZWZpbmVkO2ZhbGxiYWNrVGV4dD1lbmRWYWx1ZS5zbGljZShzdGFydCxzbGljZVRhaWwpO3JldHVybiBmYWxsYmFja1RleHQ7fWZ1bmN0aW9uIGdldFRleHQoKXtpZigndmFsdWUnaW4gcm9vdCl7cmV0dXJuIHJvb3QudmFsdWU7fXJldHVybiByb290LnRleHRDb250ZW50O30vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCl7dmFyIGNoYXJDb2RlO3ZhciBrZXlDb2RlPW5hdGl2ZUV2ZW50LmtleUNvZGU7aWYoJ2NoYXJDb2RlJ2luIG5hdGl2ZUV2ZW50KXtjaGFyQ29kZT1uYXRpdmVFdmVudC5jaGFyQ29kZTsvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG5pZihjaGFyQ29kZT09PTAmJmtleUNvZGU9PT0xMyl7Y2hhckNvZGU9MTM7fX1lbHNley8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG5jaGFyQ29kZT1rZXlDb2RlO30vLyBJRSBhbmQgRWRnZSAob24gV2luZG93cykgYW5kIENocm9tZSAvIFNhZmFyaSAob24gV2luZG93cyBhbmQgTGludXgpXG4vLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG5pZihjaGFyQ29kZT09PTEwKXtjaGFyQ29kZT0xMzt9Ly8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4vLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuaWYoY2hhckNvZGU+PTMyfHxjaGFyQ29kZT09PTEzKXtyZXR1cm4gY2hhckNvZGU7fXJldHVybiAwO31mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpe3JldHVybiB0cnVlO31mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKXtyZXR1cm4gZmFsc2U7fS8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhIGZhY3Rvcnkgc28gdGhhdCB3ZSBoYXZlIGRpZmZlcmVudCByZXR1cm5lZCBjb25zdHJ1Y3RvcnMuXG4vLyBJZiB3ZSBoYWQgYSBzaW5nbGUgY29uc3RydWN0b3IsIGl0IHdvdWxkIGJlIG1lZ2Ftb3JwaGljIGFuZCBlbmdpbmVzIHdvdWxkIGRlb3B0LlxuZnVuY3Rpb24gY3JlYXRlU3ludGhldGljRXZlbnQoSW50ZXJmYWNlKXsvKipcbiAgICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICAgKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICAgKlxuICAgKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICAgKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAgICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICAgKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICAgKlxuICAgKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gICAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gICAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAgICovZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KHJlYWN0TmFtZSxyZWFjdEV2ZW50VHlwZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KXt0aGlzLl9yZWFjdE5hbWU9cmVhY3ROYW1lO3RoaXMuX3RhcmdldEluc3Q9dGFyZ2V0SW5zdDt0aGlzLnR5cGU9cmVhY3RFdmVudFR5cGU7dGhpcy5uYXRpdmVFdmVudD1uYXRpdmVFdmVudDt0aGlzLnRhcmdldD1uYXRpdmVFdmVudFRhcmdldDt0aGlzLmN1cnJlbnRUYXJnZXQ9bnVsbDtmb3IodmFyIF9wcm9wTmFtZSBpbiBJbnRlcmZhY2Upe2lmKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSl7Y29udGludWU7fXZhciBub3JtYWxpemU9SW50ZXJmYWNlW19wcm9wTmFtZV07aWYobm9ybWFsaXplKXt0aGlzW19wcm9wTmFtZV09bm9ybWFsaXplKG5hdGl2ZUV2ZW50KTt9ZWxzZXt0aGlzW19wcm9wTmFtZV09bmF0aXZlRXZlbnRbX3Byb3BOYW1lXTt9fXZhciBkZWZhdWx0UHJldmVudGVkPW5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQhPW51bGw/bmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZDpuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZT09PWZhbHNlO2lmKGRlZmF1bHRQcmV2ZW50ZWQpe3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPWZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO31lbHNle3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPWZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTt9dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1mdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7cmV0dXJuIHRoaXM7fWFzc2lnbihTeW50aGV0aWNCYXNlRXZlbnQucHJvdG90eXBlLHtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3RoaXMuZGVmYXVsdFByZXZlbnRlZD10cnVlO3ZhciBldmVudD10aGlzLm5hdGl2ZUV2ZW50O2lmKCFldmVudCl7cmV0dXJuO31pZihldmVudC5wcmV2ZW50RGVmYXVsdCl7ZXZlbnQucHJldmVudERlZmF1bHQoKTsvLyAkRmxvd0ZpeE1lIC0gZmxvdyBpcyBub3QgYXdhcmUgb2YgYHVua25vd25gIGluIElFXG59ZWxzZSBpZih0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUhPT0ndW5rbm93bicpe2V2ZW50LnJldHVyblZhbHVlPWZhbHNlO310aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1mdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTt9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBldmVudD10aGlzLm5hdGl2ZUV2ZW50O2lmKCFldmVudCl7cmV0dXJuO31pZihldmVudC5zdG9wUHJvcGFnYXRpb24pe2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpOy8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbn1lbHNlIGlmKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUhPT0ndW5rbm93bicpey8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4vLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4vLyBJRSBzcGVjaWZpYykuXG5ldmVudC5jYW5jZWxCdWJibGU9dHJ1ZTt9dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1mdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTt9LC8qKlxuICAgICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICovcGVyc2lzdDpmdW5jdGlvbigpey8vIE1vZGVybiBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbn0sLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovaXNQZXJzaXN0ZW50OmZ1bmN0aW9uVGhhdFJldHVybnNUcnVlfSk7cmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDt9LyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL3ZhciBFdmVudEludGVyZmFjZT17ZXZlbnRQaGFzZTowLGJ1YmJsZXM6MCxjYW5jZWxhYmxlOjAsdGltZVN0YW1wOmZ1bmN0aW9uKGV2ZW50KXtyZXR1cm4gZXZlbnQudGltZVN0YW1wfHxEYXRlLm5vdygpO30sZGVmYXVsdFByZXZlbnRlZDowLGlzVHJ1c3RlZDowfTt2YXIgU3ludGhldGljRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoRXZlbnRJbnRlcmZhY2UpO3ZhciBVSUV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxFdmVudEludGVyZmFjZSx7dmlldzowLGRldGFpbDowfSk7dmFyIFN5bnRoZXRpY1VJRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoVUlFdmVudEludGVyZmFjZSk7dmFyIGxhc3RNb3ZlbWVudFg7dmFyIGxhc3RNb3ZlbWVudFk7dmFyIGxhc3RNb3VzZUV2ZW50O2Z1bmN0aW9uIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KXtpZihldmVudCE9PWxhc3RNb3VzZUV2ZW50KXtpZihsYXN0TW91c2VFdmVudCYmZXZlbnQudHlwZT09PSdtb3VzZW1vdmUnKXtsYXN0TW92ZW1lbnRYPWV2ZW50LnNjcmVlblgtbGFzdE1vdXNlRXZlbnQuc2NyZWVuWDtsYXN0TW92ZW1lbnRZPWV2ZW50LnNjcmVlblktbGFzdE1vdXNlRXZlbnQuc2NyZWVuWTt9ZWxzZXtsYXN0TW92ZW1lbnRYPTA7bGFzdE1vdmVtZW50WT0wO31sYXN0TW91c2VFdmVudD1ldmVudDt9fS8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL3ZhciBNb3VzZUV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxVSUV2ZW50SW50ZXJmYWNlLHtzY3JlZW5YOjAsc2NyZWVuWTowLGNsaWVudFg6MCxjbGllbnRZOjAscGFnZVg6MCxwYWdlWTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxnZXRNb2RpZmllclN0YXRlOmdldEV2ZW50TW9kaWZpZXJTdGF0ZSxidXR0b246MCxidXR0b25zOjAscmVsYXRlZFRhcmdldDpmdW5jdGlvbihldmVudCl7aWYoZXZlbnQucmVsYXRlZFRhcmdldD09PXVuZGVmaW5lZClyZXR1cm4gZXZlbnQuZnJvbUVsZW1lbnQ9PT1ldmVudC5zcmNFbGVtZW50P2V2ZW50LnRvRWxlbWVudDpldmVudC5mcm9tRWxlbWVudDtyZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldDt9LG1vdmVtZW50WDpmdW5jdGlvbihldmVudCl7aWYoJ21vdmVtZW50WCdpbiBldmVudCl7cmV0dXJuIGV2ZW50Lm1vdmVtZW50WDt9dXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoZXZlbnQpO3JldHVybiBsYXN0TW92ZW1lbnRYO30sbW92ZW1lbnRZOmZ1bmN0aW9uKGV2ZW50KXtpZignbW92ZW1lbnRZJ2luIGV2ZW50KXtyZXR1cm4gZXZlbnQubW92ZW1lbnRZO30vLyBEb24ndCBuZWVkIHRvIGNhbGwgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoKSBoZXJlXG4vLyBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBoYXZlIGFscmVhZHkgcnVuIHdoZW4gbW92ZW1lbnRYXG4vLyB3YXMgY29waWVkLlxucmV0dXJuIGxhc3RNb3ZlbWVudFk7fX0pO3ZhciBTeW50aGV0aWNNb3VzZUV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KE1vdXNlRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovdmFyIERyYWdFdmVudEludGVyZmFjZT1hc3NpZ24oe30sTW91c2VFdmVudEludGVyZmFjZSx7ZGF0YVRyYW5zZmVyOjB9KTt2YXIgU3ludGhldGljRHJhZ0V2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KERyYWdFdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovdmFyIEZvY3VzRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LFVJRXZlbnRJbnRlcmZhY2Use3JlbGF0ZWRUYXJnZXQ6MH0pO3ZhciBTeW50aGV0aWNGb2N1c0V2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KEZvY3VzRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL3ZhciBBbmltYXRpb25FdmVudEludGVyZmFjZT1hc3NpZ24oe30sRXZlbnRJbnRlcmZhY2Use2FuaW1hdGlvbk5hbWU6MCxlbGFwc2VkVGltZTowLHBzZXVkb0VsZW1lbnQ6MH0pO3ZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudD1jcmVhdGVTeW50aGV0aWNFdmVudChBbmltYXRpb25FdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovdmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxFdmVudEludGVyZmFjZSx7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihldmVudCl7cmV0dXJuJ2NsaXBib2FyZERhdGEnaW4gZXZlbnQ/ZXZlbnQuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YTt9fSk7dmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTsvKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL3ZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxFdmVudEludGVyZmFjZSx7ZGF0YTowfSk7dmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi8gLy8gSGFwcGVucyB0byBzaGFyZSB0aGUgc2FtZSBsaXN0IGZvciBub3cuXG52YXIgU3ludGhldGljSW5wdXRFdmVudD1TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Oy8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL3ZhciBub3JtYWxpemVLZXk9e0VzYzonRXNjYXBlJyxTcGFjZWJhcjonICcsTGVmdDonQXJyb3dMZWZ0JyxVcDonQXJyb3dVcCcsUmlnaHQ6J0Fycm93UmlnaHQnLERvd246J0Fycm93RG93bicsRGVsOidEZWxldGUnLFdpbjonT1MnLE1lbnU6J0NvbnRleHRNZW51JyxBcHBzOidDb250ZXh0TWVudScsU2Nyb2xsOidTY3JvbGxMb2NrJyxNb3pQcmludGFibGVLZXk6J1VuaWRlbnRpZmllZCd9Oy8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovdmFyIHRyYW5zbGF0ZVRvS2V5PXsnOCc6J0JhY2tzcGFjZScsJzknOidUYWInLCcxMic6J0NsZWFyJywnMTMnOidFbnRlcicsJzE2JzonU2hpZnQnLCcxNyc6J0NvbnRyb2wnLCcxOCc6J0FsdCcsJzE5JzonUGF1c2UnLCcyMCc6J0NhcHNMb2NrJywnMjcnOidFc2NhcGUnLCczMic6JyAnLCczMyc6J1BhZ2VVcCcsJzM0JzonUGFnZURvd24nLCczNSc6J0VuZCcsJzM2JzonSG9tZScsJzM3JzonQXJyb3dMZWZ0JywnMzgnOidBcnJvd1VwJywnMzknOidBcnJvd1JpZ2h0JywnNDAnOidBcnJvd0Rvd24nLCc0NSc6J0luc2VydCcsJzQ2JzonRGVsZXRlJywnMTEyJzonRjEnLCcxMTMnOidGMicsJzExNCc6J0YzJywnMTE1JzonRjQnLCcxMTYnOidGNScsJzExNyc6J0Y2JywnMTE4JzonRjcnLCcxMTknOidGOCcsJzEyMCc6J0Y5JywnMTIxJzonRjEwJywnMTIyJzonRjExJywnMTIzJzonRjEyJywnMTQ0JzonTnVtTG9jaycsJzE0NSc6J1Njcm9sbExvY2snLCcyMjQnOidNZXRhJ307LyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCl7aWYobmF0aXZlRXZlbnQua2V5KXsvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbi8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cbi8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4vLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbnZhciBrZXk9bm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV18fG5hdGl2ZUV2ZW50LmtleTtpZihrZXkhPT0nVW5pZGVudGlmaWVkJyl7cmV0dXJuIGtleTt9fS8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbmlmKG5hdGl2ZUV2ZW50LnR5cGU9PT0na2V5cHJlc3MnKXt2YXIgY2hhckNvZGU9Z2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7Ly8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4vLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbnJldHVybiBjaGFyQ29kZT09PTEzPydFbnRlcic6U3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7fWlmKG5hdGl2ZUV2ZW50LnR5cGU9PT0na2V5ZG93bid8fG5hdGl2ZUV2ZW50LnR5cGU9PT0na2V5dXAnKXsvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4vLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxucmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdfHwnVW5pZGVudGlmaWVkJzt9cmV0dXJuJyc7fS8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi92YXIgbW9kaWZpZXJLZXlUb1Byb3A9e0FsdDonYWx0S2V5JyxDb250cm9sOidjdHJsS2V5JyxNZXRhOidtZXRhS2V5JyxTaGlmdDonc2hpZnRLZXknfTsvLyBPbGRlciBicm93c2VycyAoU2FmYXJpIDw9IDEwLCBpT1MgU2FmYXJpIDw9IDEwLjIpIGRvIG5vdCBzdXBwb3J0XG4vLyBnZXRNb2RpZmllclN0YXRlLiBJZiBnZXRNb2RpZmllclN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQsIHdlIG1hcCBpdCB0byBhIHNldCBvZlxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudC4gSW4gdGhpcyBjYXNlLCBMb2NrLWtleXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZyl7dmFyIHN5bnRoZXRpY0V2ZW50PXRoaXM7dmFyIG5hdGl2ZUV2ZW50PXN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O2lmKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpe3JldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7fXZhciBrZXlQcm9wPW1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107cmV0dXJuIGtleVByb3A/ISFuYXRpdmVFdmVudFtrZXlQcm9wXTpmYWxzZTt9ZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KXtyZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjt9LyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovdmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LFVJRXZlbnRJbnRlcmZhY2Use2tleTpnZXRFdmVudEtleSxjb2RlOjAsbG9jYXRpb246MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxhbHRLZXk6MCxtZXRhS2V5OjAscmVwZWF0OjAsbG9jYWxlOjAsZ2V0TW9kaWZpZXJTdGF0ZTpnZXRFdmVudE1vZGlmaWVyU3RhdGUsLy8gTGVnYWN5IEludGVyZmFjZVxuY2hhckNvZGU6ZnVuY3Rpb24oZXZlbnQpey8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3Rcbi8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbmlmKGV2ZW50LnR5cGU9PT0na2V5cHJlc3MnKXtyZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7fXJldHVybiAwO30sa2V5Q29kZTpmdW5jdGlvbihldmVudCl7Ly8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4vLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbi8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbi8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG5pZihldmVudC50eXBlPT09J2tleWRvd24nfHxldmVudC50eXBlPT09J2tleXVwJyl7cmV0dXJuIGV2ZW50LmtleUNvZGU7fXJldHVybiAwO30sd2hpY2g6ZnVuY3Rpb24oZXZlbnQpey8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4vLyB0eXBlIG9mIHRoZSBldmVudC5cbmlmKGV2ZW50LnR5cGU9PT0na2V5cHJlc3MnKXtyZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7fWlmKGV2ZW50LnR5cGU9PT0na2V5ZG93bid8fGV2ZW50LnR5cGU9PT0na2V5dXAnKXtyZXR1cm4gZXZlbnQua2V5Q29kZTt9cmV0dXJuIDA7fX0pO3ZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL3ZhciBQb2ludGVyRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LE1vdXNlRXZlbnRJbnRlcmZhY2Use3BvaW50ZXJJZDowLHdpZHRoOjAsaGVpZ2h0OjAscHJlc3N1cmU6MCx0YW5nZW50aWFsUHJlc3N1cmU6MCx0aWx0WDowLHRpbHRZOjAsdHdpc3Q6MCxwb2ludGVyVHlwZTowLGlzUHJpbWFyeTowfSk7dmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudD1jcmVhdGVTeW50aGV0aWNFdmVudChQb2ludGVyRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL3ZhciBUb3VjaEV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxVSUV2ZW50SW50ZXJmYWNlLHt0b3VjaGVzOjAsdGFyZ2V0VG91Y2hlczowLGNoYW5nZWRUb3VjaGVzOjAsYWx0S2V5OjAsbWV0YUtleTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGdldE1vZGlmaWVyU3RhdGU6Z2V0RXZlbnRNb2RpZmllclN0YXRlfSk7dmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoVG91Y2hFdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL3ZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LEV2ZW50SW50ZXJmYWNlLHtwcm9wZXJ0eU5hbWU6MCxlbGFwc2VkVGltZTowLHBzZXVkb0VsZW1lbnQ6MH0pO3ZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTsvKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi92YXIgV2hlZWxFdmVudEludGVyZmFjZT1hc3NpZ24oe30sTW91c2VFdmVudEludGVyZmFjZSx7ZGVsdGFYOmZ1bmN0aW9uKGV2ZW50KXtyZXR1cm4nZGVsdGFYJ2luIGV2ZW50P2V2ZW50LmRlbHRhWDovLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuJ3doZWVsRGVsdGFYJ2luIGV2ZW50Py1ldmVudC53aGVlbERlbHRhWDowO30sZGVsdGFZOmZ1bmN0aW9uKGV2ZW50KXtyZXR1cm4nZGVsdGFZJ2luIGV2ZW50P2V2ZW50LmRlbHRhWTovLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4nd2hlZWxEZWx0YVknaW4gZXZlbnQ/LWV2ZW50LndoZWVsRGVsdGFZOi8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbid3aGVlbERlbHRhJ2luIGV2ZW50Py1ldmVudC53aGVlbERlbHRhOjA7fSxkZWx0YVo6MCwvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbi8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4vLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG5kZWx0YU1vZGU6MH0pO3ZhciBTeW50aGV0aWNXaGVlbEV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KFdoZWVsRXZlbnRJbnRlcmZhY2UpO3ZhciBFTkRfS0VZQ09ERVM9WzksMTMsMjcsMzJdOy8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERT0yMjk7dmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQ9Y2FuVXNlRE9NJiYnQ29tcG9zaXRpb25FdmVudCdpbiB3aW5kb3c7dmFyIGRvY3VtZW50TW9kZT1udWxsO2lmKGNhblVzZURPTSYmJ2RvY3VtZW50TW9kZSdpbiBkb2N1bWVudCl7ZG9jdW1lbnRNb2RlPWRvY3VtZW50LmRvY3VtZW50TW9kZTt9Ly8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudD1jYW5Vc2VET00mJidUZXh0RXZlbnQnaW4gd2luZG93JiYhZG9jdW1lbnRNb2RlOy8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGE9Y2FuVXNlRE9NJiYoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnR8fGRvY3VtZW50TW9kZSYmZG9jdW1lbnRNb2RlPjgmJmRvY3VtZW50TW9kZTw9MTEpO3ZhciBTUEFDRUJBUl9DT0RFPTMyO3ZhciBTUEFDRUJBUl9DSEFSPVN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7ZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoKXtyZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQmVmb3JlSW5wdXQnLFsnY29tcG9zaXRpb25lbmQnLCdrZXlwcmVzcycsJ3RleHRJbnB1dCcsJ3Bhc3RlJ10pO3JlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvbkVuZCcsWydjb21wb3NpdGlvbmVuZCcsJ2ZvY3Vzb3V0Jywna2V5ZG93bicsJ2tleXByZXNzJywna2V5dXAnLCdtb3VzZWRvd24nXSk7cmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNvbXBvc2l0aW9uU3RhcnQnLFsnY29tcG9zaXRpb25zdGFydCcsJ2ZvY3Vzb3V0Jywna2V5ZG93bicsJ2tleXByZXNzJywna2V5dXAnLCdtb3VzZWRvd24nXSk7cmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNvbXBvc2l0aW9uVXBkYXRlJyxbJ2NvbXBvc2l0aW9udXBkYXRlJywnZm9jdXNvdXQnLCdrZXlkb3duJywna2V5cHJlc3MnLCdrZXl1cCcsJ21vdXNlZG93biddKTt9Ly8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3M9ZmFsc2U7LyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL2Z1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KXtyZXR1cm4obmF0aXZlRXZlbnQuY3RybEtleXx8bmF0aXZlRXZlbnQuYWx0S2V5fHxuYXRpdmVFdmVudC5tZXRhS2V5KSYmLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4hKG5hdGl2ZUV2ZW50LmN0cmxLZXkmJm5hdGl2ZUV2ZW50LmFsdEtleSk7fS8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKi9mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZShkb21FdmVudE5hbWUpe3N3aXRjaChkb21FdmVudE5hbWUpe2Nhc2UnY29tcG9zaXRpb25zdGFydCc6cmV0dXJuJ29uQ29tcG9zaXRpb25TdGFydCc7Y2FzZSdjb21wb3NpdGlvbmVuZCc6cmV0dXJuJ29uQ29tcG9zaXRpb25FbmQnO2Nhc2UnY29tcG9zaXRpb251cGRhdGUnOnJldHVybidvbkNvbXBvc2l0aW9uVXBkYXRlJzt9fS8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKi9mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpe3JldHVybiBkb21FdmVudE5hbWU9PT0na2V5ZG93bicmJm5hdGl2ZUV2ZW50LmtleUNvZGU9PT1TVEFSVF9LRVlDT0RFO30vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKi9mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KXtzd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2tleXVwJzovLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbnJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSE9PS0xO2Nhc2Una2V5ZG93bic6Ly8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG5yZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSE9PVNUQVJUX0tFWUNPREU7Y2FzZSdrZXlwcmVzcyc6Y2FzZSdtb3VzZWRvd24nOmNhc2UnZm9jdXNvdXQnOi8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG5yZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZTt9fS8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KXt2YXIgZGV0YWlsPW5hdGl2ZUV2ZW50LmRldGFpbDtpZih0eXBlb2YgZGV0YWlsPT09J29iamVjdCcmJidkYXRhJ2luIGRldGFpbCl7cmV0dXJuIGRldGFpbC5kYXRhO31yZXR1cm4gbnVsbDt9LyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvc2l0aW9uIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgS29yZWFuIElNRS5cbiAqIE91ciBmYWxsYmFjayBtb2RlIGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIElFJ3MgS29yZWFuIElNRSxcbiAqIHNvIGp1c3QgdXNlIG5hdGl2ZSBjb21wb3NpdGlvbiBldmVudHMgd2hlbiBLb3JlYW4gSU1FIGlzIHVzZWQuXG4gKiBBbHRob3VnaCBDb21wb3NpdGlvbkV2ZW50LmxvY2FsZSBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLFxuICogaXQgaXMgYXZhaWxhYmxlIGluIElFLCB3aGVyZSBvdXIgZmFsbGJhY2sgbW9kZSBpcyBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL2Z1bmN0aW9uIGlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpe3JldHVybiBuYXRpdmVFdmVudC5sb2NhbGU9PT0na28nO30vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG52YXIgaXNDb21wb3Npbmc9ZmFsc2U7LyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudChkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KXt2YXIgZXZlbnRUeXBlO3ZhciBmYWxsYmFja0RhdGE7aWYoY2FuVXNlQ29tcG9zaXRpb25FdmVudCl7ZXZlbnRUeXBlPWdldENvbXBvc2l0aW9uRXZlbnRUeXBlKGRvbUV2ZW50TmFtZSk7fWVsc2UgaWYoIWlzQ29tcG9zaW5nKXtpZihpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpKXtldmVudFR5cGU9J29uQ29tcG9zaXRpb25TdGFydCc7fX1lbHNlIGlmKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpKXtldmVudFR5cGU9J29uQ29tcG9zaXRpb25FbmQnO31pZighZXZlbnRUeXBlKXtyZXR1cm4gbnVsbDt9aWYodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEmJiFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSl7Ly8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4vLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG5pZighaXNDb21wb3NpbmcmJmV2ZW50VHlwZT09PSdvbkNvbXBvc2l0aW9uU3RhcnQnKXtpc0NvbXBvc2luZz1pbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTt9ZWxzZSBpZihldmVudFR5cGU9PT0nb25Db21wb3NpdGlvbkVuZCcpe2lmKGlzQ29tcG9zaW5nKXtmYWxsYmFja0RhdGE9Z2V0RGF0YSgpO319fXZhciBsaXN0ZW5lcnM9YWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsZXZlbnRUeXBlKTtpZihsaXN0ZW5lcnMubGVuZ3RoPjApe3ZhciBldmVudD1uZXcgU3ludGhldGljQ29tcG9zaXRpb25FdmVudChldmVudFR5cGUsZG9tRXZlbnROYW1lLG51bGwsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO2Rpc3BhdGNoUXVldWUucHVzaCh7ZXZlbnQ6ZXZlbnQsbGlzdGVuZXJzOmxpc3RlbmVyc30pO2lmKGZhbGxiYWNrRGF0YSl7Ly8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4vLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuZXZlbnQuZGF0YT1mYWxsYmFja0RhdGE7fWVsc2V7dmFyIGN1c3RvbURhdGE9Z2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7aWYoY3VzdG9tRGF0YSE9PW51bGwpe2V2ZW50LmRhdGE9Y3VzdG9tRGF0YTt9fX19ZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpe3N3aXRjaChkb21FdmVudE5hbWUpe2Nhc2UnY29tcG9zaXRpb25lbmQnOnJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtjYXNlJ2tleXByZXNzJzovKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovdmFyIHdoaWNoPW5hdGl2ZUV2ZW50LndoaWNoO2lmKHdoaWNoIT09U1BBQ0VCQVJfQ09ERSl7cmV0dXJuIG51bGw7fWhhc1NwYWNlS2V5cHJlc3M9dHJ1ZTtyZXR1cm4gU1BBQ0VCQVJfQ0hBUjtjYXNlJ3RleHRJbnB1dCc6Ly8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG52YXIgY2hhcnM9bmF0aXZlRXZlbnQuZGF0YTsvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGlnbm9yZSBpdC5cbmlmKGNoYXJzPT09U1BBQ0VCQVJfQ0hBUiYmaGFzU3BhY2VLZXlwcmVzcyl7cmV0dXJuIG51bGw7fXJldHVybiBjaGFycztkZWZhdWx0Oi8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG5yZXR1cm4gbnVsbDt9fS8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL2Z1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpey8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbi8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbmlmKGlzQ29tcG9zaW5nKXtpZihkb21FdmVudE5hbWU9PT0nY29tcG9zaXRpb25lbmQnfHwhY2FuVXNlQ29tcG9zaXRpb25FdmVudCYmaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSxuYXRpdmVFdmVudCkpe3ZhciBjaGFycz1nZXREYXRhKCk7cmVzZXQoKTtpc0NvbXBvc2luZz1mYWxzZTtyZXR1cm4gY2hhcnM7fXJldHVybiBudWxsO31zd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ3Bhc3RlJzovLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4vLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG5yZXR1cm4gbnVsbDtjYXNlJ2tleXByZXNzJzovKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovaWYoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSl7Ly8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4vLyBUb3VjaCBrZXlib2FyZCBvZiBXaW5kb3dzLiAgSW4gc3VjaCBhIGNhc2UsIHRoZSBgY2hhcmAgcHJvcGVydHlcbi8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbi8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4vLyBJbiBzdWNoIGEgY2FzZSwgd2UgZGlyZWN0bHkgcmV0dXJuIHRoZSBgY2hhcmAgcHJvcGVydHkgaW5zdGVhZCBvZlxuLy8gdXNpbmcgYHdoaWNoYC5cbmlmKG5hdGl2ZUV2ZW50LmNoYXImJm5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoPjEpe3JldHVybiBuYXRpdmVFdmVudC5jaGFyO31lbHNlIGlmKG5hdGl2ZUV2ZW50LndoaWNoKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7fX1yZXR1cm4gbnVsbDtjYXNlJ2NvbXBvc2l0aW9uZW5kJzpyZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEmJiFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KT9udWxsOm5hdGl2ZUV2ZW50LmRhdGE7ZGVmYXVsdDpyZXR1cm4gbnVsbDt9fS8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL2Z1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpe3ZhciBjaGFycztpZihjYW5Vc2VUZXh0SW5wdXRFdmVudCl7Y2hhcnM9Z2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpO31lbHNle2NoYXJzPWdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpO30vLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4vLyBiZSBmaXJlZC5cbmlmKCFjaGFycyl7cmV0dXJuIG51bGw7fXZhciBsaXN0ZW5lcnM9YWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsJ29uQmVmb3JlSW5wdXQnKTtpZihsaXN0ZW5lcnMubGVuZ3RoPjApe3ZhciBldmVudD1uZXcgU3ludGhldGljSW5wdXRFdmVudCgnb25CZWZvcmVJbnB1dCcsJ2JlZm9yZWlucHV0JyxudWxsLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtkaXNwYXRjaFF1ZXVlLnB1c2goe2V2ZW50OmV2ZW50LGxpc3RlbmVyczpsaXN0ZW5lcnN9KTtldmVudC5kYXRhPWNoYXJzO319LyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0LGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyKXtleHRyYWN0Q29tcG9zaXRpb25FdmVudChkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTt9LyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL3ZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzPXtjb2xvcjp0cnVlLGRhdGU6dHJ1ZSxkYXRldGltZTp0cnVlLCdkYXRldGltZS1sb2NhbCc6dHJ1ZSxlbWFpbDp0cnVlLG1vbnRoOnRydWUsbnVtYmVyOnRydWUscGFzc3dvcmQ6dHJ1ZSxyYW5nZTp0cnVlLHNlYXJjaDp0cnVlLHRlbDp0cnVlLHRleHQ6dHJ1ZSx0aW1lOnRydWUsdXJsOnRydWUsd2Vlazp0cnVlfTtmdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSl7dmFyIG5vZGVOYW1lPWVsZW0mJmVsZW0ubm9kZU5hbWUmJmVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihub2RlTmFtZT09PSdpbnB1dCcpe3JldHVybiEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO31pZihub2RlTmFtZT09PSd0ZXh0YXJlYScpe3JldHVybiB0cnVlO31yZXR1cm4gZmFsc2U7fS8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgpe2lmKCFjYW5Vc2VET00pe3JldHVybiBmYWxzZTt9dmFyIGV2ZW50TmFtZT0nb24nK2V2ZW50TmFtZVN1ZmZpeDt2YXIgaXNTdXBwb3J0ZWQ9KGV2ZW50TmFtZSBpbiBkb2N1bWVudCk7aWYoIWlzU3VwcG9ydGVkKXt2YXIgZWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsJ3JldHVybjsnKTtpc1N1cHBvcnRlZD10eXBlb2YgZWxlbWVudFtldmVudE5hbWVdPT09J2Z1bmN0aW9uJzt9cmV0dXJuIGlzU3VwcG9ydGVkO31mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQxKCl7cmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNoYW5nZScsWydjaGFuZ2UnLCdjbGljaycsJ2ZvY3VzaW4nLCdmb2N1c291dCcsJ2lucHV0Jywna2V5ZG93bicsJ2tleXVwJywnc2VsZWN0aW9uY2hhbmdlJ10pO31mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSxpbnN0LG5hdGl2ZUV2ZW50LHRhcmdldCl7Ly8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO3ZhciBsaXN0ZW5lcnM9YWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKGluc3QsJ29uQ2hhbmdlJyk7aWYobGlzdGVuZXJzLmxlbmd0aD4wKXt2YXIgZXZlbnQ9bmV3IFN5bnRoZXRpY0V2ZW50KCdvbkNoYW5nZScsJ2NoYW5nZScsbnVsbCxuYXRpdmVFdmVudCx0YXJnZXQpO2Rpc3BhdGNoUXVldWUucHVzaCh7ZXZlbnQ6ZXZlbnQsbGlzdGVuZXJzOmxpc3RlbmVyc30pO319LyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL3ZhciBhY3RpdmVFbGVtZW50PW51bGw7dmFyIGFjdGl2ZUVsZW1lbnRJbnN0PW51bGw7LyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL2Z1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pe3ZhciBub2RlTmFtZT1lbGVtLm5vZGVOYW1lJiZlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIG5vZGVOYW1lPT09J3NlbGVjdCd8fG5vZGVOYW1lPT09J2lucHV0JyYmZWxlbS50eXBlPT09J2ZpbGUnO31mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KXt2YXIgZGlzcGF0Y2hRdWV1ZT1bXTtjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSxhY3RpdmVFbGVtZW50SW5zdCxuYXRpdmVFdmVudCxnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpOy8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4vLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4vLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbi8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuLy9cbi8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbi8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4vLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbi8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCxkaXNwYXRjaFF1ZXVlKTt9ZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGRpc3BhdGNoUXVldWUpe3Byb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsMCk7fWZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KXt2YXIgdGFyZ2V0Tm9kZT1nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO2lmKHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKHRhcmdldE5vZGUpKXtyZXR1cm4gdGFyZ2V0SW5zdDt9fWZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudChkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCl7aWYoZG9tRXZlbnROYW1lPT09J2NoYW5nZScpe3JldHVybiB0YXJnZXRJbnN0O319LyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovdmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZD1mYWxzZTtpZihjYW5Vc2VET00pey8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG5pc0lucHV0RXZlbnRTdXBwb3J0ZWQ9aXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSYmKCFkb2N1bWVudC5kb2N1bWVudE1vZGV8fGRvY3VtZW50LmRvY3VtZW50TW9kZT45KTt9LyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL2Z1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsdGFyZ2V0SW5zdCl7YWN0aXZlRWxlbWVudD10YXJnZXQ7YWN0aXZlRWxlbWVudEluc3Q9dGFyZ2V0SW5zdDthY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJyxoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7fS8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL2Z1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCl7aWYoIWFjdGl2ZUVsZW1lbnQpe3JldHVybjt9YWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsaGFuZGxlUHJvcGVydHlDaGFuZ2UpO2FjdGl2ZUVsZW1lbnQ9bnVsbDthY3RpdmVFbGVtZW50SW5zdD1udWxsO30vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL2Z1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KXtpZihuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUhPT0ndmFsdWUnKXtyZXR1cm47fWlmKGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCkpe21hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO319ZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSx0YXJnZXQsdGFyZ2V0SW5zdCl7aWYoZG9tRXZlbnROYW1lPT09J2ZvY3VzaW4nKXsvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4vLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4vLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbi8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4vL1xuLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93Llxuc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LHRhcmdldEluc3QpO31lbHNlIGlmKGRvbUV2ZW50TmFtZT09PSdmb2N1c291dCcpe3N0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7fX0vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0KXtpZihkb21FdmVudE5hbWU9PT0nc2VsZWN0aW9uY2hhbmdlJ3x8ZG9tRXZlbnROYW1lPT09J2tleXVwJ3x8ZG9tRXZlbnROYW1lPT09J2tleWRvd24nKXsvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3Rcbi8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuLy9cbi8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbi8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4vLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4vLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4vLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbi8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4vLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbnJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO319LyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKXsvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbi8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4vLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxudmFyIG5vZGVOYW1lPWVsZW0ubm9kZU5hbWU7cmV0dXJuIG5vZGVOYW1lJiZub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09J2lucHV0JyYmKGVsZW0udHlwZT09PSdjaGVja2JveCd8fGVsZW0udHlwZT09PSdyYWRpbycpO31mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudChkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCl7aWYoZG9tRXZlbnROYW1lPT09J2NsaWNrJyl7cmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTt9fWZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLHRhcmdldEluc3Qpe2lmKGRvbUV2ZW50TmFtZT09PSdpbnB1dCd8fGRvbUV2ZW50TmFtZT09PSdjaGFuZ2UnKXtyZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO319ZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihub2RlKXt2YXIgc3RhdGU9bm9kZS5fd3JhcHBlclN0YXRlO2lmKCFzdGF0ZXx8IXN0YXRlLmNvbnRyb2xsZWR8fG5vZGUudHlwZSE9PSdudW1iZXInKXtyZXR1cm47fXsvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG5zZXREZWZhdWx0VmFsdWUobm9kZSwnbnVtYmVyJyxub2RlLnZhbHVlKTt9fS8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDEoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcil7dmFyIHRhcmdldE5vZGU9dGFyZ2V0SW5zdD9nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpOndpbmRvdzt2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsaGFuZGxlRXZlbnRGdW5jO2lmKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKXtnZXRUYXJnZXRJbnN0RnVuYz1nZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7fWVsc2UgaWYoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKXtpZihpc0lucHV0RXZlbnRTdXBwb3J0ZWQpe2dldFRhcmdldEluc3RGdW5jPWdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7fWVsc2V7Z2V0VGFyZ2V0SW5zdEZ1bmM9Z2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtoYW5kbGVFdmVudEZ1bmM9aGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsO319ZWxzZSBpZihzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKXtnZXRUYXJnZXRJbnN0RnVuYz1nZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDt9aWYoZ2V0VGFyZ2V0SW5zdEZ1bmMpe3ZhciBpbnN0PWdldFRhcmdldEluc3RGdW5jKGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0KTtpZihpbnN0KXtjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSxpbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtyZXR1cm47fX1pZihoYW5kbGVFdmVudEZ1bmMpe2hhbmRsZUV2ZW50RnVuYyhkb21FdmVudE5hbWUsdGFyZ2V0Tm9kZSx0YXJnZXRJbnN0KTt9Ly8gV2hlbiBibHVycmluZywgc2V0IHRoZSB2YWx1ZSBhdHRyaWJ1dGUgZm9yIG51bWJlciBpbnB1dHNcbmlmKGRvbUV2ZW50TmFtZT09PSdmb2N1c291dCcpe2hhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0Tm9kZSk7fX1mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQyKCl7cmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUVudGVyJyxbJ21vdXNlb3V0JywnbW91c2VvdmVyJ10pO3JlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uTW91c2VMZWF2ZScsWydtb3VzZW91dCcsJ21vdXNlb3ZlciddKTtyZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJFbnRlcicsWydwb2ludGVyb3V0JywncG9pbnRlcm92ZXInXSk7cmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Qb2ludGVyTGVhdmUnLFsncG9pbnRlcm91dCcsJ3BvaW50ZXJvdmVyJ10pO30vKipcbiAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gKi9mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcil7dmFyIGlzT3ZlckV2ZW50PWRvbUV2ZW50TmFtZT09PSdtb3VzZW92ZXInfHxkb21FdmVudE5hbWU9PT0ncG9pbnRlcm92ZXInO3ZhciBpc091dEV2ZW50PWRvbUV2ZW50TmFtZT09PSdtb3VzZW91dCd8fGRvbUV2ZW50TmFtZT09PSdwb2ludGVyb3V0JztpZihpc092ZXJFdmVudCYmIWlzUmVwbGF5aW5nRXZlbnQobmF0aXZlRXZlbnQpKXsvLyBJZiB0aGlzIGlzIGFuIG92ZXIgZXZlbnQgd2l0aCBhIHRhcmdldCwgd2UgbWlnaHQgaGF2ZSBhbHJlYWR5IGRpc3BhdGNoZWRcbi8vIHRoZSBldmVudCBpbiB0aGUgb3V0IGV2ZW50IG9mIHRoZSBvdGhlciB0YXJnZXQuIElmIHRoaXMgaXMgcmVwbGF5ZWQsXG4vLyB0aGVuIGl0J3MgYmVjYXVzZSB3ZSBjb3VsZG4ndCBkaXNwYXRjaCBhZ2FpbnN0IHRoaXMgdGFyZ2V0IHByZXZpb3VzbHlcbi8vIHNvIHdlIGhhdmUgdG8gZG8gaXQgbm93IGluc3RlYWQuXG52YXIgcmVsYXRlZD1uYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0fHxuYXRpdmVFdmVudC5mcm9tRWxlbWVudDtpZihyZWxhdGVkKXsvLyBJZiB0aGUgcmVsYXRlZCBub2RlIGlzIG1hbmFnZWQgYnkgUmVhY3QsIHdlIGNhbiBhc3N1bWUgdGhhdCB3ZSBoYXZlXG4vLyBhbHJlYWR5IGRpc3BhdGNoZWQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzIGR1cmluZyBpdHMgbW91c2VvdXQuXG5pZihnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKXx8aXNDb250YWluZXJNYXJrZWRBc1Jvb3QocmVsYXRlZCkpe3JldHVybjt9fX1pZighaXNPdXRFdmVudCYmIWlzT3ZlckV2ZW50KXsvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG5yZXR1cm47fXZhciB3aW47Ly8gVE9ETzogd2h5IGlzIHRoaXMgbnVsbGFibGUgaW4gdGhlIHR5cGVzIGJ1dCB3ZSByZWFkIGZyb20gaXQ/XG5pZihuYXRpdmVFdmVudFRhcmdldC53aW5kb3c9PT1uYXRpdmVFdmVudFRhcmdldCl7Ly8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG53aW49bmF0aXZlRXZlbnRUYXJnZXQ7fWVsc2V7Ly8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxudmFyIGRvYz1uYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O2lmKGRvYyl7d2luPWRvYy5kZWZhdWx0Vmlld3x8ZG9jLnBhcmVudFdpbmRvdzt9ZWxzZXt3aW49d2luZG93O319dmFyIGZyb207dmFyIHRvO2lmKGlzT3V0RXZlbnQpe3ZhciBfcmVsYXRlZD1uYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0fHxuYXRpdmVFdmVudC50b0VsZW1lbnQ7ZnJvbT10YXJnZXRJbnN0O3RvPV9yZWxhdGVkP2dldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKF9yZWxhdGVkKTpudWxsO2lmKHRvIT09bnVsbCl7dmFyIG5lYXJlc3RNb3VudGVkPWdldE5lYXJlc3RNb3VudGVkRmliZXIodG8pO2lmKHRvIT09bmVhcmVzdE1vdW50ZWR8fHRvLnRhZyE9PUhvc3RDb21wb25lbnQmJnRvLnRhZyE9PUhvc3RUZXh0KXt0bz1udWxsO319fWVsc2V7Ly8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbmZyb209bnVsbDt0bz10YXJnZXRJbnN0O31pZihmcm9tPT09dG8pey8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbnJldHVybjt9dmFyIFN5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNNb3VzZUV2ZW50O3ZhciBsZWF2ZUV2ZW50VHlwZT0nb25Nb3VzZUxlYXZlJzt2YXIgZW50ZXJFdmVudFR5cGU9J29uTW91c2VFbnRlcic7dmFyIGV2ZW50VHlwZVByZWZpeD0nbW91c2UnO2lmKGRvbUV2ZW50TmFtZT09PSdwb2ludGVyb3V0J3x8ZG9tRXZlbnROYW1lPT09J3BvaW50ZXJvdmVyJyl7U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY1BvaW50ZXJFdmVudDtsZWF2ZUV2ZW50VHlwZT0nb25Qb2ludGVyTGVhdmUnO2VudGVyRXZlbnRUeXBlPSdvblBvaW50ZXJFbnRlcic7ZXZlbnRUeXBlUHJlZml4PSdwb2ludGVyJzt9dmFyIGZyb21Ob2RlPWZyb209PW51bGw/d2luOmdldE5vZGVGcm9tSW5zdGFuY2UoZnJvbSk7dmFyIHRvTm9kZT10bz09bnVsbD93aW46Z2V0Tm9kZUZyb21JbnN0YW5jZSh0byk7dmFyIGxlYXZlPW5ldyBTeW50aGV0aWNFdmVudEN0b3IobGVhdmVFdmVudFR5cGUsZXZlbnRUeXBlUHJlZml4KydsZWF2ZScsZnJvbSxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7bGVhdmUudGFyZ2V0PWZyb21Ob2RlO2xlYXZlLnJlbGF0ZWRUYXJnZXQ9dG9Ob2RlO3ZhciBlbnRlcj1udWxsOy8vIFdlIHNob3VsZCBvbmx5IHByb2Nlc3MgdGhpcyBuYXRpdmVFdmVudCBpZiB3ZSBhcmUgcHJvY2Vzc2luZ1xuLy8gdGhlIGZpcnN0IGFuY2VzdG9yLiBOZXh0IHRpbWUsIHdlIHdpbGwgaWdub3JlIHRoZSBldmVudC5cbnZhciBuYXRpdmVUYXJnZXRJbnN0PWdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtpZihuYXRpdmVUYXJnZXRJbnN0PT09dGFyZ2V0SW5zdCl7dmFyIGVudGVyRXZlbnQ9bmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihlbnRlckV2ZW50VHlwZSxldmVudFR5cGVQcmVmaXgrJ2VudGVyJyx0byxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7ZW50ZXJFdmVudC50YXJnZXQ9dG9Ob2RlO2VudGVyRXZlbnQucmVsYXRlZFRhcmdldD1mcm9tTm9kZTtlbnRlcj1lbnRlckV2ZW50O31hY2N1bXVsYXRlRW50ZXJMZWF2ZVR3b1BoYXNlTGlzdGVuZXJzKGRpc3BhdGNoUXVldWUsbGVhdmUsZW50ZXIsZnJvbSx0byk7fS8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9mdW5jdGlvbiBpcyh4LHkpe3JldHVybiB4PT09eSYmKHghPT0wfHwxL3g9PT0xL3kpfHx4IT09eCYmeSE9PXkvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuO312YXIgb2JqZWN0SXM9dHlwZW9mIE9iamVjdC5pcz09PSdmdW5jdGlvbic/T2JqZWN0LmlzOmlzOy8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL2Z1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLG9iakIpe2lmKG9iamVjdElzKG9iakEsb2JqQikpe3JldHVybiB0cnVlO31pZih0eXBlb2Ygb2JqQSE9PSdvYmplY3QnfHxvYmpBPT09bnVsbHx8dHlwZW9mIG9iakIhPT0nb2JqZWN0J3x8b2JqQj09PW51bGwpe3JldHVybiBmYWxzZTt9dmFyIGtleXNBPU9iamVjdC5rZXlzKG9iakEpO3ZhciBrZXlzQj1PYmplY3Qua2V5cyhvYmpCKTtpZihrZXlzQS5sZW5ndGghPT1rZXlzQi5sZW5ndGgpe3JldHVybiBmYWxzZTt9Ly8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbmZvcih2YXIgaT0wO2k8a2V5c0EubGVuZ3RoO2krKyl7dmFyIGN1cnJlbnRLZXk9a2V5c0FbaV07aWYoIWhhc093blByb3BlcnR5LmNhbGwob2JqQixjdXJyZW50S2V5KXx8IW9iamVjdElzKG9iakFbY3VycmVudEtleV0sb2JqQltjdXJyZW50S2V5XSkpe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO30vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSl7d2hpbGUobm9kZSYmbm9kZS5maXJzdENoaWxkKXtub2RlPW5vZGUuZmlyc3RDaGlsZDt9cmV0dXJuIG5vZGU7fS8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKXt3aGlsZShub2RlKXtpZihub2RlLm5leHRTaWJsaW5nKXtyZXR1cm4gbm9kZS5uZXh0U2libGluZzt9bm9kZT1ub2RlLnBhcmVudE5vZGU7fX0vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3Qsb2Zmc2V0KXt2YXIgbm9kZT1nZXRMZWFmTm9kZShyb290KTt2YXIgbm9kZVN0YXJ0PTA7dmFyIG5vZGVFbmQ9MDt3aGlsZShub2RlKXtpZihub2RlLm5vZGVUeXBlPT09VEVYVF9OT0RFKXtub2RlRW5kPW5vZGVTdGFydCtub2RlLnRleHRDb250ZW50Lmxlbmd0aDtpZihub2RlU3RhcnQ8PW9mZnNldCYmbm9kZUVuZD49b2Zmc2V0KXtyZXR1cm57bm9kZTpub2RlLG9mZnNldDpvZmZzZXQtbm9kZVN0YXJ0fTt9bm9kZVN0YXJ0PW5vZGVFbmQ7fW5vZGU9Z2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO319LyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL2Z1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKXt2YXIgb3duZXJEb2N1bWVudD1vdXRlck5vZGUub3duZXJEb2N1bWVudDt2YXIgd2luPW93bmVyRG9jdW1lbnQmJm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXd8fHdpbmRvdzt2YXIgc2VsZWN0aW9uPXdpbi5nZXRTZWxlY3Rpb24mJndpbi5nZXRTZWxlY3Rpb24oKTtpZighc2VsZWN0aW9ufHxzZWxlY3Rpb24ucmFuZ2VDb3VudD09PTApe3JldHVybiBudWxsO312YXIgYW5jaG9yTm9kZT1zZWxlY3Rpb24uYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQ9c2VsZWN0aW9uLmFuY2hvck9mZnNldCxmb2N1c05vZGU9c2VsZWN0aW9uLmZvY3VzTm9kZSxmb2N1c09mZnNldD1zZWxlY3Rpb24uZm9jdXNPZmZzZXQ7Ly8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4vLyB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91cyBkaXZzIGRvIG5vdCBzZWVtIHRvXG4vLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4vLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuLy8gaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmRcbi8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG50cnl7LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovYW5jaG9yTm9kZS5ub2RlVHlwZTtmb2N1c05vZGUubm9kZVR5cGU7LyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi99Y2F0Y2goZSl7cmV0dXJuIG51bGw7fXJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQsZm9jdXNOb2RlLGZvY3VzT2Zmc2V0KTt9LyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQsZm9jdXNOb2RlLGZvY3VzT2Zmc2V0KXt2YXIgbGVuZ3RoPTA7dmFyIHN0YXJ0PS0xO3ZhciBlbmQ9LTE7dmFyIGluZGV4V2l0aGluQW5jaG9yPTA7dmFyIGluZGV4V2l0aGluRm9jdXM9MDt2YXIgbm9kZT1vdXRlck5vZGU7dmFyIHBhcmVudE5vZGU9bnVsbDtvdXRlcjp3aGlsZSh0cnVlKXt2YXIgbmV4dD1udWxsO3doaWxlKHRydWUpe2lmKG5vZGU9PT1hbmNob3JOb2RlJiYoYW5jaG9yT2Zmc2V0PT09MHx8bm9kZS5ub2RlVHlwZT09PVRFWFRfTk9ERSkpe3N0YXJ0PWxlbmd0aCthbmNob3JPZmZzZXQ7fWlmKG5vZGU9PT1mb2N1c05vZGUmJihmb2N1c09mZnNldD09PTB8fG5vZGUubm9kZVR5cGU9PT1URVhUX05PREUpKXtlbmQ9bGVuZ3RoK2ZvY3VzT2Zmc2V0O31pZihub2RlLm5vZGVUeXBlPT09VEVYVF9OT0RFKXtsZW5ndGgrPW5vZGUubm9kZVZhbHVlLmxlbmd0aDt9aWYoKG5leHQ9bm9kZS5maXJzdENoaWxkKT09PW51bGwpe2JyZWFrO30vLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbnBhcmVudE5vZGU9bm9kZTtub2RlPW5leHQ7fXdoaWxlKHRydWUpe2lmKG5vZGU9PT1vdXRlck5vZGUpey8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4vLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbi8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbi8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbmJyZWFrIG91dGVyO31pZihwYXJlbnROb2RlPT09YW5jaG9yTm9kZSYmKytpbmRleFdpdGhpbkFuY2hvcj09PWFuY2hvck9mZnNldCl7c3RhcnQ9bGVuZ3RoO31pZihwYXJlbnROb2RlPT09Zm9jdXNOb2RlJiYrK2luZGV4V2l0aGluRm9jdXM9PT1mb2N1c09mZnNldCl7ZW5kPWxlbmd0aDt9aWYoKG5leHQ9bm9kZS5uZXh0U2libGluZykhPT1udWxsKXticmVhazt9bm9kZT1wYXJlbnROb2RlO3BhcmVudE5vZGU9bm9kZS5wYXJlbnROb2RlO30vLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG5ub2RlPW5leHQ7fWlmKHN0YXJ0PT09LTF8fGVuZD09PS0xKXsvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3Rcbi8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxucmV0dXJuIG51bGw7fXJldHVybntzdGFydDpzdGFydCxlbmQ6ZW5kfTt9LyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9mdW5jdGlvbiBzZXRPZmZzZXRzKG5vZGUsb2Zmc2V0cyl7dmFyIGRvYz1ub2RlLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50O3ZhciB3aW49ZG9jJiZkb2MuZGVmYXVsdFZpZXd8fHdpbmRvdzsvLyBFZGdlIGZhaWxzIHdpdGggXCJPYmplY3QgZXhwZWN0ZWRcIiBpbiBzb21lIHNjZW5hcmlvcy5cbi8vIChGb3IgaW5zdGFuY2U6IFRpbnlNQ0UgZWRpdG9yIHVzZWQgaW4gYSBsaXN0IGNvbXBvbmVudCB0aGF0IHN1cHBvcnRzIHBhc3RpbmcgdG8gYWRkIG1vcmUsXG4vLyBmYWlscyB3aGVuIHBhc3RpbmcgMTAwKyBpdGVtcylcbmlmKCF3aW4uZ2V0U2VsZWN0aW9uKXtyZXR1cm47fXZhciBzZWxlY3Rpb249d2luLmdldFNlbGVjdGlvbigpO3ZhciBsZW5ndGg9bm9kZS50ZXh0Q29udGVudC5sZW5ndGg7dmFyIHN0YXJ0PU1hdGgubWluKG9mZnNldHMuc3RhcnQsbGVuZ3RoKTt2YXIgZW5kPW9mZnNldHMuZW5kPT09dW5kZWZpbmVkP3N0YXJ0Ok1hdGgubWluKG9mZnNldHMuZW5kLGxlbmd0aCk7Ly8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG5pZighc2VsZWN0aW9uLmV4dGVuZCYmc3RhcnQ+ZW5kKXt2YXIgdGVtcD1lbmQ7ZW5kPXN0YXJ0O3N0YXJ0PXRlbXA7fXZhciBzdGFydE1hcmtlcj1nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsc3RhcnQpO3ZhciBlbmRNYXJrZXI9Z2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLGVuZCk7aWYoc3RhcnRNYXJrZXImJmVuZE1hcmtlcil7aWYoc2VsZWN0aW9uLnJhbmdlQ291bnQ9PT0xJiZzZWxlY3Rpb24uYW5jaG9yTm9kZT09PXN0YXJ0TWFya2VyLm5vZGUmJnNlbGVjdGlvbi5hbmNob3JPZmZzZXQ9PT1zdGFydE1hcmtlci5vZmZzZXQmJnNlbGVjdGlvbi5mb2N1c05vZGU9PT1lbmRNYXJrZXIubm9kZSYmc2VsZWN0aW9uLmZvY3VzT2Zmc2V0PT09ZW5kTWFya2VyLm9mZnNldCl7cmV0dXJuO312YXIgcmFuZ2U9ZG9jLmNyZWF0ZVJhbmdlKCk7cmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSxzdGFydE1hcmtlci5vZmZzZXQpO3NlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtpZihzdGFydD5lbmQpe3NlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7c2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSxlbmRNYXJrZXIub2Zmc2V0KTt9ZWxzZXtyYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsZW5kTWFya2VyLm9mZnNldCk7c2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTt9fX1mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpe3JldHVybiBub2RlJiZub2RlLm5vZGVUeXBlPT09VEVYVF9OT0RFO31mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLGlubmVyTm9kZSl7aWYoIW91dGVyTm9kZXx8IWlubmVyTm9kZSl7cmV0dXJuIGZhbHNlO31lbHNlIGlmKG91dGVyTm9kZT09PWlubmVyTm9kZSl7cmV0dXJuIHRydWU7fWVsc2UgaWYoaXNUZXh0Tm9kZShvdXRlck5vZGUpKXtyZXR1cm4gZmFsc2U7fWVsc2UgaWYoaXNUZXh0Tm9kZShpbm5lck5vZGUpKXtyZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSxpbm5lck5vZGUucGFyZW50Tm9kZSk7fWVsc2UgaWYoJ2NvbnRhaW5zJ2luIG91dGVyTm9kZSl7cmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO31lbHNlIGlmKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbil7cmV0dXJuISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkmMTYpO31lbHNle3JldHVybiBmYWxzZTt9fWZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKXtyZXR1cm4gbm9kZSYmbm9kZS5vd25lckRvY3VtZW50JiZjb250YWluc05vZGUobm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxub2RlKTt9ZnVuY3Rpb24gaXNTYW1lT3JpZ2luRnJhbWUoaWZyYW1lKXt0cnl7Ly8gQWNjZXNzaW5nIHRoZSBjb250ZW50RG9jdW1lbnQgb2YgYSBIVE1MSWZyYW1lRWxlbWVudCBjYW4gY2F1c2UgdGhlIGJyb3dzZXJcbi8vIHRvIHRocm93LCBlLmcuIGlmIGl0IGhhcyBhIGNyb3NzLW9yaWdpbiBzcmMgYXR0cmlidXRlLlxuLy8gU2FmYXJpIHdpbGwgc2hvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aGVuIHRoZSBhY2Nlc3MgcmVzdWx0cyBpbiBcIkJsb2NrZWQgYSBmcmFtZSB3aXRoIG9yaWdpblwiLiBlLmc6XG4vLyBpZnJhbWUuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xuLy8gQSBzYWZldHkgd2F5IGlzIHRvIGFjY2VzcyBvbmUgb2YgdGhlIGNyb3NzIG9yaWdpbiBwcm9wZXJ0aWVzOiBXaW5kb3cgb3IgTG9jYXRpb25cbi8vIFdoaWNoIG1pZ2h0IHJlc3VsdCBpbiBcIlNlY3VyaXR5RXJyb3JcIiBET00gRXhjZXB0aW9uIGFuZCBpdCBpcyBjb21wYXRpYmxlIHRvIFNhZmFyaS5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Jyb3dzZXJzLmh0bWwjaW50ZWdyYXRpb24td2l0aC1pZGxcbnJldHVybiB0eXBlb2YgaWZyYW1lLmNvbnRlbnRXaW5kb3cubG9jYXRpb24uaHJlZj09PSdzdHJpbmcnO31jYXRjaChlcnIpe3JldHVybiBmYWxzZTt9fWZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnREZWVwKCl7dmFyIHdpbj13aW5kb3c7dmFyIGVsZW1lbnQ9Z2V0QWN0aXZlRWxlbWVudCgpO3doaWxlKGVsZW1lbnQgaW5zdGFuY2VvZiB3aW4uSFRNTElGcmFtZUVsZW1lbnQpe2lmKGlzU2FtZU9yaWdpbkZyYW1lKGVsZW1lbnQpKXt3aW49ZWxlbWVudC5jb250ZW50V2luZG93O31lbHNle3JldHVybiBlbGVtZW50O31lbGVtZW50PWdldEFjdGl2ZUVsZW1lbnQod2luLmRvY3VtZW50KTt9cmV0dXJuIGVsZW1lbnQ7fS8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovIC8qKlxuICogQGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogd2UgZ2V0IHRoZSBlbGVtZW50IHR5cGVzIHRoYXQgc3VwcG9ydCBzZWxlY3Rpb25cbiAqIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG8tbm90LWFwcGx5LCBsb29raW5nIGF0IGBzZWxlY3Rpb25TdGFydGBcbiAqIGFuZCBgc2VsZWN0aW9uRW5kYCByb3dzLlxuICovZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pe3ZhciBub2RlTmFtZT1lbGVtJiZlbGVtLm5vZGVOYW1lJiZlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIG5vZGVOYW1lJiYobm9kZU5hbWU9PT0naW5wdXQnJiYoZWxlbS50eXBlPT09J3RleHQnfHxlbGVtLnR5cGU9PT0nc2VhcmNoJ3x8ZWxlbS50eXBlPT09J3RlbCd8fGVsZW0udHlwZT09PSd1cmwnfHxlbGVtLnR5cGU9PT0ncGFzc3dvcmQnKXx8bm9kZU5hbWU9PT0ndGV4dGFyZWEnfHxlbGVtLmNvbnRlbnRFZGl0YWJsZT09PSd0cnVlJyk7fWZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCl7dmFyIGZvY3VzZWRFbGVtPWdldEFjdGl2ZUVsZW1lbnREZWVwKCk7cmV0dXJue2ZvY3VzZWRFbGVtOmZvY3VzZWRFbGVtLHNlbGVjdGlvblJhbmdlOmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSk/Z2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKTpudWxsfTt9LyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pe3ZhciBjdXJGb2N1c2VkRWxlbT1nZXRBY3RpdmVFbGVtZW50RGVlcCgpO3ZhciBwcmlvckZvY3VzZWRFbGVtPXByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07dmFyIHByaW9yU2VsZWN0aW9uUmFuZ2U9cHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtpZihjdXJGb2N1c2VkRWxlbSE9PXByaW9yRm9jdXNlZEVsZW0mJmlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSl7aWYocHJpb3JTZWxlY3Rpb25SYW5nZSE9PW51bGwmJmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSl7c2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0scHJpb3JTZWxlY3Rpb25SYW5nZSk7fS8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG52YXIgYW5jZXN0b3JzPVtdO3ZhciBhbmNlc3Rvcj1wcmlvckZvY3VzZWRFbGVtO3doaWxlKGFuY2VzdG9yPWFuY2VzdG9yLnBhcmVudE5vZGUpe2lmKGFuY2VzdG9yLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFKXthbmNlc3RvcnMucHVzaCh7ZWxlbWVudDphbmNlc3RvcixsZWZ0OmFuY2VzdG9yLnNjcm9sbExlZnQsdG9wOmFuY2VzdG9yLnNjcm9sbFRvcH0pO319aWYodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXM9PT0nZnVuY3Rpb24nKXtwcmlvckZvY3VzZWRFbGVtLmZvY3VzKCk7fWZvcih2YXIgaT0wO2k8YW5jZXN0b3JzLmxlbmd0aDtpKyspe3ZhciBpbmZvPWFuY2VzdG9yc1tpXTtpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdD1pbmZvLmxlZnQ7aW5mby5lbGVtZW50LnNjcm9sbFRvcD1pbmZvLnRvcDt9fX0vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9mdW5jdGlvbiBnZXRTZWxlY3Rpb24oaW5wdXQpe3ZhciBzZWxlY3Rpb247aWYoJ3NlbGVjdGlvblN0YXJ0J2luIGlucHV0KXsvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuc2VsZWN0aW9uPXtzdGFydDppbnB1dC5zZWxlY3Rpb25TdGFydCxlbmQ6aW5wdXQuc2VsZWN0aW9uRW5kfTt9ZWxzZXsvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbnNlbGVjdGlvbj1nZXRPZmZzZXRzKGlucHV0KTt9cmV0dXJuIHNlbGVjdGlvbnx8e3N0YXJ0OjAsZW5kOjB9O30vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LG9mZnNldHMpe3ZhciBzdGFydD1vZmZzZXRzLnN0YXJ0O3ZhciBlbmQ9b2Zmc2V0cy5lbmQ7aWYoZW5kPT09dW5kZWZpbmVkKXtlbmQ9c3RhcnQ7fWlmKCdzZWxlY3Rpb25TdGFydCdpbiBpbnB1dCl7aW5wdXQuc2VsZWN0aW9uU3RhcnQ9c3RhcnQ7aW5wdXQuc2VsZWN0aW9uRW5kPU1hdGgubWluKGVuZCxpbnB1dC52YWx1ZS5sZW5ndGgpO31lbHNle3NldE9mZnNldHMoaW5wdXQsb2Zmc2V0cyk7fX12YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50PWNhblVzZURPTSYmJ2RvY3VtZW50TW9kZSdpbiBkb2N1bWVudCYmZG9jdW1lbnQuZG9jdW1lbnRNb2RlPD0xMTtmdW5jdGlvbiByZWdpc3RlckV2ZW50cyQzKCl7cmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvblNlbGVjdCcsWydmb2N1c291dCcsJ2NvbnRleHRtZW51JywnZHJhZ2VuZCcsJ2ZvY3VzaW4nLCdrZXlkb3duJywna2V5dXAnLCdtb3VzZWRvd24nLCdtb3VzZXVwJywnc2VsZWN0aW9uY2hhbmdlJ10pO312YXIgYWN0aXZlRWxlbWVudCQxPW51bGw7dmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDE9bnVsbDt2YXIgbGFzdFNlbGVjdGlvbj1udWxsO3ZhciBtb3VzZURvd249ZmFsc2U7LyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICovZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEobm9kZSl7aWYoJ3NlbGVjdGlvblN0YXJ0J2luIG5vZGUmJmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSl7cmV0dXJue3N0YXJ0Om5vZGUuc2VsZWN0aW9uU3RhcnQsZW5kOm5vZGUuc2VsZWN0aW9uRW5kfTt9ZWxzZXt2YXIgd2luPW5vZGUub3duZXJEb2N1bWVudCYmbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3c7dmFyIHNlbGVjdGlvbj13aW4uZ2V0U2VsZWN0aW9uKCk7cmV0dXJue2FuY2hvck5vZGU6c2VsZWN0aW9uLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OnNlbGVjdGlvbi5hbmNob3JPZmZzZXQsZm9jdXNOb2RlOnNlbGVjdGlvbi5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6c2VsZWN0aW9uLmZvY3VzT2Zmc2V0fTt9fS8qKlxuICogR2V0IGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQgdGFyZ2V0LlxuICovZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChldmVudFRhcmdldCl7cmV0dXJuIGV2ZW50VGFyZ2V0LndpbmRvdz09PWV2ZW50VGFyZ2V0P2V2ZW50VGFyZ2V0LmRvY3VtZW50OmV2ZW50VGFyZ2V0Lm5vZGVUeXBlPT09RE9DVU1FTlRfTk9ERT9ldmVudFRhcmdldDpldmVudFRhcmdldC5vd25lckRvY3VtZW50O30vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFRhcmdldFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCl7Ly8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4vLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4vLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4vLyB3b24ndCBkaXNwYXRjaC5cbnZhciBkb2M9Z2V0RXZlbnRUYXJnZXREb2N1bWVudChuYXRpdmVFdmVudFRhcmdldCk7aWYobW91c2VEb3dufHxhY3RpdmVFbGVtZW50JDE9PW51bGx8fGFjdGl2ZUVsZW1lbnQkMSE9PWdldEFjdGl2ZUVsZW1lbnQoZG9jKSl7cmV0dXJuO30vLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG52YXIgY3VycmVudFNlbGVjdGlvbj1nZXRTZWxlY3Rpb24kMShhY3RpdmVFbGVtZW50JDEpO2lmKCFsYXN0U2VsZWN0aW9ufHwhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sY3VycmVudFNlbGVjdGlvbikpe2xhc3RTZWxlY3Rpb249Y3VycmVudFNlbGVjdGlvbjt2YXIgbGlzdGVuZXJzPWFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhhY3RpdmVFbGVtZW50SW5zdCQxLCdvblNlbGVjdCcpO2lmKGxpc3RlbmVycy5sZW5ndGg+MCl7dmFyIGV2ZW50PW5ldyBTeW50aGV0aWNFdmVudCgnb25TZWxlY3QnLCdzZWxlY3QnLG51bGwsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO2Rpc3BhdGNoUXVldWUucHVzaCh7ZXZlbnQ6ZXZlbnQsbGlzdGVuZXJzOmxpc3RlbmVyc30pO2V2ZW50LnRhcmdldD1hY3RpdmVFbGVtZW50JDE7fX19LyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIpe3ZhciB0YXJnZXROb2RlPXRhcmdldEluc3Q/Z2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KTp3aW5kb3c7c3dpdGNoKGRvbUV2ZW50TmFtZSl7Ly8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG5jYXNlJ2ZvY3VzaW4nOmlmKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKXx8dGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGU9PT0ndHJ1ZScpe2FjdGl2ZUVsZW1lbnQkMT10YXJnZXROb2RlO2FjdGl2ZUVsZW1lbnRJbnN0JDE9dGFyZ2V0SW5zdDtsYXN0U2VsZWN0aW9uPW51bGw7fWJyZWFrO2Nhc2UnZm9jdXNvdXQnOmFjdGl2ZUVsZW1lbnQkMT1udWxsO2FjdGl2ZUVsZW1lbnRJbnN0JDE9bnVsbDtsYXN0U2VsZWN0aW9uPW51bGw7YnJlYWs7Ly8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbi8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbmNhc2UnbW91c2Vkb3duJzptb3VzZURvd249dHJ1ZTticmVhaztjYXNlJ2NvbnRleHRtZW51JzpjYXNlJ21vdXNldXAnOmNhc2UnZHJhZ2VuZCc6bW91c2VEb3duPWZhbHNlO2NvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO2JyZWFrOy8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4vLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3Rcbi8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuLy9cbi8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbi8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4vLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbi8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbmNhc2Unc2VsZWN0aW9uY2hhbmdlJzppZihza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpe2JyZWFrO30vLyBmYWxscyB0aHJvdWdoXG5jYXNlJ2tleWRvd24nOmNhc2Una2V5dXAnOmNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO319LyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCxldmVudE5hbWUpe3ZhciBwcmVmaXhlcz17fTtwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV09ZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7cHJlZml4ZXNbJ1dlYmtpdCcrc3R5bGVQcm9wXT0nd2Via2l0JytldmVudE5hbWU7cHJlZml4ZXNbJ01veicrc3R5bGVQcm9wXT0nbW96JytldmVudE5hbWU7cmV0dXJuIHByZWZpeGVzO30vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL3ZhciB2ZW5kb3JQcmVmaXhlcz17YW5pbWF0aW9uZW5kOm1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsJ0FuaW1hdGlvbkVuZCcpLGFuaW1hdGlvbml0ZXJhdGlvbjptYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCdBbmltYXRpb25JdGVyYXRpb24nKSxhbmltYXRpb25zdGFydDptYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCdBbmltYXRpb25TdGFydCcpLHRyYW5zaXRpb25lbmQ6bWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsJ1RyYW5zaXRpb25FbmQnKX07LyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi92YXIgcHJlZml4ZWRFdmVudE5hbWVzPXt9Oy8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi92YXIgc3R5bGU9e307LyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovaWYoY2FuVXNlRE9NKXtzdHlsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTsvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4vLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbi8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG5pZighKCdBbmltYXRpb25FdmVudCdpbiB3aW5kb3cpKXtkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO30vLyBTYW1lIGFzIGFib3ZlXG5pZighKCdUcmFuc2l0aW9uRXZlbnQnaW4gd2luZG93KSl7ZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjt9fS8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpe2lmKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKXtyZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07fWVsc2UgaWYoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pe3JldHVybiBldmVudE5hbWU7fXZhciBwcmVmaXhNYXA9dmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtmb3IodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApe2lmKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApJiZzdHlsZVByb3AgaW4gc3R5bGUpe3JldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXT1wcmVmaXhNYXBbc3R5bGVQcm9wXTt9fXJldHVybiBldmVudE5hbWU7fXZhciBBTklNQVRJT05fRU5EPWdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKTt2YXIgQU5JTUFUSU9OX0lURVJBVElPTj1nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJyk7dmFyIEFOSU1BVElPTl9TVEFSVD1nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKTt2YXIgVFJBTlNJVElPTl9FTkQ9Z2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKTt2YXIgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXM9bmV3IE1hcCgpOy8vIE5PVEU6IENhcGl0YWxpemF0aW9uIGlzIGltcG9ydGFudCBpbiB0aGlzIGxpc3QhXG4vL1xuLy8gRS5nLiBpdCBuZWVkcyBcInBvaW50ZXJEb3duXCIsIG5vdCBcInBvaW50ZXJkb3duXCIuXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2UgZGVyaXZlIGJvdGggUmVhY3QgbmFtZSAoXCJvblBvaW50ZXJEb3duXCIpXG4vLyBhbmQgRE9NIG5hbWUgKFwicG9pbnRlcmRvd25cIikgZnJvbSB0aGUgc2FtZSBsaXN0LlxuLy9cbi8vIEV4Y2VwdGlvbnMgdGhhdCBkb24ndCBtYXRjaCB0aGlzIGNvbnZlbnRpb24gYXJlIGxpc3RlZCBzZXBhcmF0ZWx5LlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzPVsnYWJvcnQnLCdhdXhDbGljaycsJ2NhbmNlbCcsJ2NhblBsYXknLCdjYW5QbGF5VGhyb3VnaCcsJ2NsaWNrJywnY2xvc2UnLCdjb250ZXh0TWVudScsJ2NvcHknLCdjdXQnLCdkcmFnJywnZHJhZ0VuZCcsJ2RyYWdFbnRlcicsJ2RyYWdFeGl0JywnZHJhZ0xlYXZlJywnZHJhZ092ZXInLCdkcmFnU3RhcnQnLCdkcm9wJywnZHVyYXRpb25DaGFuZ2UnLCdlbXB0aWVkJywnZW5jcnlwdGVkJywnZW5kZWQnLCdlcnJvcicsJ2dvdFBvaW50ZXJDYXB0dXJlJywnaW5wdXQnLCdpbnZhbGlkJywna2V5RG93bicsJ2tleVByZXNzJywna2V5VXAnLCdsb2FkJywnbG9hZGVkRGF0YScsJ2xvYWRlZE1ldGFkYXRhJywnbG9hZFN0YXJ0JywnbG9zdFBvaW50ZXJDYXB0dXJlJywnbW91c2VEb3duJywnbW91c2VNb3ZlJywnbW91c2VPdXQnLCdtb3VzZU92ZXInLCdtb3VzZVVwJywncGFzdGUnLCdwYXVzZScsJ3BsYXknLCdwbGF5aW5nJywncG9pbnRlckNhbmNlbCcsJ3BvaW50ZXJEb3duJywncG9pbnRlck1vdmUnLCdwb2ludGVyT3V0JywncG9pbnRlck92ZXInLCdwb2ludGVyVXAnLCdwcm9ncmVzcycsJ3JhdGVDaGFuZ2UnLCdyZXNldCcsJ3Jlc2l6ZScsJ3NlZWtlZCcsJ3NlZWtpbmcnLCdzdGFsbGVkJywnc3VibWl0Jywnc3VzcGVuZCcsJ3RpbWVVcGRhdGUnLCd0b3VjaENhbmNlbCcsJ3RvdWNoRW5kJywndG91Y2hTdGFydCcsJ3ZvbHVtZUNoYW5nZScsJ3Njcm9sbCcsJ3RvZ2dsZScsJ3RvdWNoTW92ZScsJ3dhaXRpbmcnLCd3aGVlbCddO2Z1bmN0aW9uIHJlZ2lzdGVyU2ltcGxlRXZlbnQoZG9tRXZlbnROYW1lLHJlYWN0TmFtZSl7dG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuc2V0KGRvbUV2ZW50TmFtZSxyZWFjdE5hbWUpO3JlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWFjdE5hbWUsW2RvbUV2ZW50TmFtZV0pO31mdW5jdGlvbiByZWdpc3RlclNpbXBsZUV2ZW50cygpe2Zvcih2YXIgaT0wO2k8c2ltcGxlRXZlbnRQbHVnaW5FdmVudHMubGVuZ3RoO2krKyl7dmFyIGV2ZW50TmFtZT1zaW1wbGVFdmVudFBsdWdpbkV2ZW50c1tpXTt2YXIgZG9tRXZlbnROYW1lPWV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO3ZhciBjYXBpdGFsaXplZEV2ZW50PWV2ZW50TmFtZVswXS50b1VwcGVyQ2FzZSgpK2V2ZW50TmFtZS5zbGljZSgxKTtyZWdpc3RlclNpbXBsZUV2ZW50KGRvbUV2ZW50TmFtZSwnb24nK2NhcGl0YWxpemVkRXZlbnQpO30vLyBTcGVjaWFsIGNhc2VzIHdoZXJlIGV2ZW50IG5hbWVzIGRvbid0IG1hdGNoLlxucmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fRU5ELCdvbkFuaW1hdGlvbkVuZCcpO3JlZ2lzdGVyU2ltcGxlRXZlbnQoQU5JTUFUSU9OX0lURVJBVElPTiwnb25BbmltYXRpb25JdGVyYXRpb24nKTtyZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9TVEFSVCwnb25BbmltYXRpb25TdGFydCcpO3JlZ2lzdGVyU2ltcGxlRXZlbnQoJ2RibGNsaWNrJywnb25Eb3VibGVDbGljaycpO3JlZ2lzdGVyU2ltcGxlRXZlbnQoJ2ZvY3VzaW4nLCdvbkZvY3VzJyk7cmVnaXN0ZXJTaW1wbGVFdmVudCgnZm9jdXNvdXQnLCdvbkJsdXInKTtyZWdpc3RlclNpbXBsZUV2ZW50KFRSQU5TSVRJT05fRU5ELCdvblRyYW5zaXRpb25FbmQnKTt9ZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ0KGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIpe3ZhciByZWFjdE5hbWU9dG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuZ2V0KGRvbUV2ZW50TmFtZSk7aWYocmVhY3ROYW1lPT09dW5kZWZpbmVkKXtyZXR1cm47fXZhciBTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljRXZlbnQ7dmFyIHJlYWN0RXZlbnRUeXBlPWRvbUV2ZW50TmFtZTtzd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2tleXByZXNzJzovLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbi8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG5pZihnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KT09PTApe3JldHVybjt9LyogZmFsbHMgdGhyb3VnaCAqL2Nhc2Una2V5ZG93bic6Y2FzZSdrZXl1cCc6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7YnJlYWs7Y2FzZSdmb2N1c2luJzpyZWFjdEV2ZW50VHlwZT0nZm9jdXMnO1N5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNGb2N1c0V2ZW50O2JyZWFrO2Nhc2UnZm9jdXNvdXQnOnJlYWN0RXZlbnRUeXBlPSdibHVyJztTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljRm9jdXNFdmVudDticmVhaztjYXNlJ2JlZm9yZWJsdXInOmNhc2UnYWZ0ZXJibHVyJzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljRm9jdXNFdmVudDticmVhaztjYXNlJ2NsaWNrJzovLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbi8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbmlmKG5hdGl2ZUV2ZW50LmJ1dHRvbj09PTIpe3JldHVybjt9LyogZmFsbHMgdGhyb3VnaCAqL2Nhc2UnYXV4Y2xpY2snOmNhc2UnZGJsY2xpY2snOmNhc2UnbW91c2Vkb3duJzpjYXNlJ21vdXNlbW92ZSc6Y2FzZSdtb3VzZXVwJzovLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4vKiBmYWxscyB0aHJvdWdoICovY2FzZSdtb3VzZW91dCc6Y2FzZSdtb3VzZW92ZXInOmNhc2UnY29udGV4dG1lbnUnOlN5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNNb3VzZUV2ZW50O2JyZWFrO2Nhc2UnZHJhZyc6Y2FzZSdkcmFnZW5kJzpjYXNlJ2RyYWdlbnRlcic6Y2FzZSdkcmFnZXhpdCc6Y2FzZSdkcmFnbGVhdmUnOmNhc2UnZHJhZ292ZXInOmNhc2UnZHJhZ3N0YXJ0JzpjYXNlJ2Ryb3AnOlN5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNEcmFnRXZlbnQ7YnJlYWs7Y2FzZSd0b3VjaGNhbmNlbCc6Y2FzZSd0b3VjaGVuZCc6Y2FzZSd0b3VjaG1vdmUnOmNhc2UndG91Y2hzdGFydCc6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY1RvdWNoRXZlbnQ7YnJlYWs7Y2FzZSBBTklNQVRJT05fRU5EOmNhc2UgQU5JTUFUSU9OX0lURVJBVElPTjpjYXNlIEFOSU1BVElPTl9TVEFSVDpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljQW5pbWF0aW9uRXZlbnQ7YnJlYWs7Y2FzZSBUUkFOU0lUSU9OX0VORDpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljVHJhbnNpdGlvbkV2ZW50O2JyZWFrO2Nhc2Unc2Nyb2xsJzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljVUlFdmVudDticmVhaztjYXNlJ3doZWVsJzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljV2hlZWxFdmVudDticmVhaztjYXNlJ2NvcHknOmNhc2UnY3V0JzpjYXNlJ3Bhc3RlJzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7YnJlYWs7Y2FzZSdnb3Rwb2ludGVyY2FwdHVyZSc6Y2FzZSdsb3N0cG9pbnRlcmNhcHR1cmUnOmNhc2UncG9pbnRlcmNhbmNlbCc6Y2FzZSdwb2ludGVyZG93bic6Y2FzZSdwb2ludGVybW92ZSc6Y2FzZSdwb2ludGVyb3V0JzpjYXNlJ3BvaW50ZXJvdmVyJzpjYXNlJ3BvaW50ZXJ1cCc6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY1BvaW50ZXJFdmVudDticmVhazt9dmFyIGluQ2FwdHVyZVBoYXNlPShldmVudFN5c3RlbUZsYWdzJklTX0NBUFRVUkVfUEhBU0UpIT09MDt7Ly8gU29tZSBldmVudHMgZG9uJ3QgYnViYmxlIGluIHRoZSBicm93c2VyLlxuLy8gSW4gdGhlIHBhc3QsIFJlYWN0IGhhcyBhbHdheXMgYnViYmxlZCB0aGVtLCBidXQgdGhpcyBjYW4gYmUgc3VycHJpc2luZy5cbi8vIFdlJ3JlIGdvaW5nIHRvIHRyeSBhbGlnbmluZyBjbG9zZXIgdG8gdGhlIGJyb3dzZXIgYmVoYXZpb3IgYnkgbm90IGJ1YmJsaW5nXG4vLyB0aGVtIGluIFJlYWN0IGVpdGhlci4gV2UnbGwgc3RhcnQgYnkgbm90IGJ1YmJsaW5nIG9uU2Nyb2xsLCBhbmQgdGhlbiBleHBhbmQuXG52YXIgYWNjdW11bGF0ZVRhcmdldE9ubHk9IWluQ2FwdHVyZVBoYXNlJiYvLyBUT0RPOiBpZGVhbGx5LCB3ZSdkIGV2ZW50dWFsbHkgYWRkIGFsbCBldmVudHMgZnJvbVxuLy8gbm9uRGVsZWdhdGVkRXZlbnRzIGxpc3QgaW4gRE9NUGx1Z2luRXZlbnRTeXN0ZW0uXG4vLyBUaGVuIHdlIGNhbiByZW1vdmUgdGhpcyBzcGVjaWFsIGxpc3QuXG4vLyBUaGlzIGlzIGEgYnJlYWtpbmcgY2hhbmdlIHRoYXQgY2FuIHdhaXQgdW50aWwgUmVhY3QgMTguXG5kb21FdmVudE5hbWU9PT0nc2Nyb2xsJzt2YXIgX2xpc3RlbmVycz1hY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCxyZWFjdE5hbWUsbmF0aXZlRXZlbnQudHlwZSxpbkNhcHR1cmVQaGFzZSxhY2N1bXVsYXRlVGFyZ2V0T25seSk7aWYoX2xpc3RlbmVycy5sZW5ndGg+MCl7Ly8gSW50ZW50aW9uYWxseSBjcmVhdGUgZXZlbnQgbGF6aWx5LlxudmFyIF9ldmVudD1uZXcgU3ludGhldGljRXZlbnRDdG9yKHJlYWN0TmFtZSxyZWFjdEV2ZW50VHlwZSxudWxsLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtkaXNwYXRjaFF1ZXVlLnB1c2goe2V2ZW50Ol9ldmVudCxsaXN0ZW5lcnM6X2xpc3RlbmVyc30pO319fS8vIFRPRE86IHJlbW92ZSB0b3AtbGV2ZWwgc2lkZSBlZmZlY3QuXG5yZWdpc3RlclNpbXBsZUV2ZW50cygpO3JlZ2lzdGVyRXZlbnRzJDIoKTtyZWdpc3RlckV2ZW50cyQxKCk7cmVnaXN0ZXJFdmVudHMkMygpO3JlZ2lzdGVyRXZlbnRzKCk7ZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIpey8vIFRPRE86IHdlIHNob3VsZCByZW1vdmUgdGhlIGNvbmNlcHQgb2YgYSBcIlNpbXBsZUV2ZW50UGx1Z2luXCIuXG4vLyBUaGlzIGlzIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXR5IG9mIHRoZSBldmVudCBzeXN0ZW0uIEFsbFxuLy8gdGhlIG90aGVyIHBsdWdpbnMgYXJlIGVzc2VudGlhbGx5IHBvbHlmaWxscy4gU28gdGhlIHBsdWdpblxuLy8gc2hvdWxkIHByb2JhYmx5IGJlIGlubGluZWQgc29tZXdoZXJlIGFuZCBoYXZlIGl0cyBsb2dpY1xuLy8gYmUgY29yZSB0aGUgdG8gZXZlbnQgc3lzdGVtLiBUaGlzIHdvdWxkIHBvdGVudGlhbGx5IGFsbG93XG4vLyB1cyB0byBzaGlwIGJ1aWxkcyBvZiBSZWFjdCB3aXRob3V0IHRoZSBwb2x5ZmlsbGVkIHBsdWdpbnMgYmVsb3cuXG5leHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCxldmVudFN5c3RlbUZsYWdzKTt2YXIgc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucz0oZXZlbnRTeXN0ZW1GbGFncyZTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUyk9PT0wOy8vIFdlIGRvbid0IHByb2Nlc3MgdGhlc2UgZXZlbnRzIHVubGVzcyB3ZSBhcmUgaW4gdGhlXG4vLyBldmVudCdzIG5hdGl2ZSBcImJ1YmJsZVwiIHBoYXNlLCB3aGljaCBtZWFucyB0aGF0IHdlJ3JlXG4vLyBub3QgaW4gdGhlIGNhcHR1cmUgcGhhc2UuIFRoYXQncyBiZWNhdXNlIHdlIGVtdWxhdGVcbi8vIHRoZSBjYXB0dXJlIHBoYXNlIGhlcmUgc3RpbGwuIFRoaXMgaXMgYSB0cmFkZS1vZmYsXG4vLyBiZWNhdXNlIGluIGFuIGlkZWFsIHdvcmxkIHdlIHdvdWxkIG5vdCBlbXVsYXRlIGFuZCB1c2Vcbi8vIHRoZSBwaGFzZXMgcHJvcGVybHksIGxpa2Ugd2UgZG8gd2l0aCB0aGUgU2ltcGxlRXZlbnRcbi8vIHBsdWdpbi4gSG93ZXZlciwgdGhlIHBsdWdpbnMgYmVsb3cgZWl0aGVyIGV4cGVjdFxuLy8gZW11bGF0aW9uIChFbnRlckxlYXZlKSBvciB1c2Ugc3RhdGUgbG9jYWxpemVkIHRvIHRoYXRcbi8vIHBsdWdpbiAoQmVmb3JlSW5wdXQsIENoYW5nZSwgU2VsZWN0KS4gVGhlIHN0YXRlIGluXG4vLyB0aGVzZSBtb2R1bGVzIGNvbXBsaWNhdGVzIHRoaW5ncywgYXMgeW91J2xsIGVzc2VudGlhbGx5XG4vLyBnZXQgdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgcGhhc2UgZXZlbnQgbWlnaHQgY2hhbmdlXG4vLyBzdGF0ZSwgb25seSBmb3IgdGhlIGZvbGxvd2luZyBidWJibGUgZXZlbnQgdG8gY29tZSBpblxuLy8gbGF0ZXIgYW5kIG5vdCB0cmlnZ2VyIGFueXRoaW5nIGFzIHRoZSBzdGF0ZSBub3dcbi8vIGludmFsaWRhdGVzIHRoZSBoZXVyaXN0aWNzIG9mIHRoZSBldmVudCBwbHVnaW4uIFdlXG4vLyBjb3VsZCBhbHRlciBhbGwgdGhlc2UgcGx1Z2lucyB0byB3b3JrIGluIHN1Y2ggd2F5cywgYnV0XG4vLyB0aGF0IG1pZ2h0IGNhdXNlIG90aGVyIHVua25vd24gc2lkZS1lZmZlY3RzIHRoYXQgd2Vcbi8vIGNhbid0IGZvcmVzZWUgcmlnaHQgbm93LlxuaWYoc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucyl7ZXh0cmFjdEV2ZW50cyQyKGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO2V4dHJhY3RFdmVudHMkMShkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtleHRyYWN0RXZlbnRzJDMoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7ZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTt9fS8vIExpc3Qgb2YgZXZlbnRzIHRoYXQgbmVlZCB0byBiZSBpbmRpdmlkdWFsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudHMuXG52YXIgbWVkaWFFdmVudFR5cGVzPVsnYWJvcnQnLCdjYW5wbGF5JywnY2FucGxheXRocm91Z2gnLCdkdXJhdGlvbmNoYW5nZScsJ2VtcHRpZWQnLCdlbmNyeXB0ZWQnLCdlbmRlZCcsJ2Vycm9yJywnbG9hZGVkZGF0YScsJ2xvYWRlZG1ldGFkYXRhJywnbG9hZHN0YXJ0JywncGF1c2UnLCdwbGF5JywncGxheWluZycsJ3Byb2dyZXNzJywncmF0ZWNoYW5nZScsJ3Jlc2l6ZScsJ3NlZWtlZCcsJ3NlZWtpbmcnLCdzdGFsbGVkJywnc3VzcGVuZCcsJ3RpbWV1cGRhdGUnLCd2b2x1bWVjaGFuZ2UnLCd3YWl0aW5nJ107Ly8gV2Ugc2hvdWxkIG5vdCBkZWxlZ2F0ZSB0aGVzZSBldmVudHMgdG8gdGhlIGNvbnRhaW5lciwgYnV0IHJhdGhlclxuLy8gc2V0IHRoZW0gb24gdGhlIGFjdHVhbCB0YXJnZXQgZWxlbWVudCBpdHNlbGYuIFRoaXMgaXMgcHJpbWFyaWx5XG4vLyBiZWNhdXNlIHRoZXNlIGV2ZW50cyBkbyBub3QgY29uc2lzdGVudGx5IGJ1YmJsZSBpbiB0aGUgRE9NLlxudmFyIG5vbkRlbGVnYXRlZEV2ZW50cz1uZXcgU2V0KFsnY2FuY2VsJywnY2xvc2UnLCdpbnZhbGlkJywnbG9hZCcsJ3Njcm9sbCcsJ3RvZ2dsZSddLmNvbmNhdChtZWRpYUV2ZW50VHlwZXMpKTtmdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsbGlzdGVuZXIsY3VycmVudFRhcmdldCl7dmFyIHR5cGU9ZXZlbnQudHlwZXx8J3Vua25vd24tZXZlbnQnO2V2ZW50LmN1cnJlbnRUYXJnZXQ9Y3VycmVudFRhcmdldDtpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSxsaXN0ZW5lcix1bmRlZmluZWQsZXZlbnQpO2V2ZW50LmN1cnJlbnRUYXJnZXQ9bnVsbDt9ZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWVJdGVtc0luT3JkZXIoZXZlbnQsZGlzcGF0Y2hMaXN0ZW5lcnMsaW5DYXB0dXJlUGhhc2Upe3ZhciBwcmV2aW91c0luc3RhbmNlO2lmKGluQ2FwdHVyZVBoYXNlKXtmb3IodmFyIGk9ZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkaT1kaXNwYXRjaExpc3RlbmVyc1tpXSxpbnN0YW5jZT1fZGlzcGF0Y2hMaXN0ZW5lcnMkaS5pbnN0YW5jZSxjdXJyZW50VGFyZ2V0PV9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQsbGlzdGVuZXI9X2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7aWYoaW5zdGFuY2UhPT1wcmV2aW91c0luc3RhbmNlJiZldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXtyZXR1cm47fWV4ZWN1dGVEaXNwYXRjaChldmVudCxsaXN0ZW5lcixjdXJyZW50VGFyZ2V0KTtwcmV2aW91c0luc3RhbmNlPWluc3RhbmNlO319ZWxzZXtmb3IodmFyIF9pPTA7X2k8ZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoO19pKyspe3ZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2k9ZGlzcGF0Y2hMaXN0ZW5lcnNbX2ldLF9pbnN0YW5jZT1fZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuaW5zdGFuY2UsX2N1cnJlbnRUYXJnZXQ9X2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmN1cnJlbnRUYXJnZXQsX2xpc3RlbmVyPV9kaXNwYXRjaExpc3RlbmVycyRfaS5saXN0ZW5lcjtpZihfaW5zdGFuY2UhPT1wcmV2aW91c0luc3RhbmNlJiZldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXtyZXR1cm47fWV4ZWN1dGVEaXNwYXRjaChldmVudCxfbGlzdGVuZXIsX2N1cnJlbnRUYXJnZXQpO3ByZXZpb3VzSW5zdGFuY2U9X2luc3RhbmNlO319fWZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsZXZlbnRTeXN0ZW1GbGFncyl7dmFyIGluQ2FwdHVyZVBoYXNlPShldmVudFN5c3RlbUZsYWdzJklTX0NBUFRVUkVfUEhBU0UpIT09MDtmb3IodmFyIGk9MDtpPGRpc3BhdGNoUXVldWUubGVuZ3RoO2krKyl7dmFyIF9kaXNwYXRjaFF1ZXVlJGk9ZGlzcGF0Y2hRdWV1ZVtpXSxldmVudD1fZGlzcGF0Y2hRdWV1ZSRpLmV2ZW50LGxpc3RlbmVycz1fZGlzcGF0Y2hRdWV1ZSRpLmxpc3RlbmVycztwcm9jZXNzRGlzcGF0Y2hRdWV1ZUl0ZW1zSW5PcmRlcihldmVudCxsaXN0ZW5lcnMsaW5DYXB0dXJlUGhhc2UpOy8vICBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbn0vLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbnJldGhyb3dDYXVnaHRFcnJvcigpO31mdW5jdGlvbiBkaXNwYXRjaEV2ZW50c0ZvclBsdWdpbnMoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsbmF0aXZlRXZlbnQsdGFyZ2V0SW5zdCx0YXJnZXRDb250YWluZXIpe3ZhciBuYXRpdmVFdmVudFRhcmdldD1nZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7dmFyIGRpc3BhdGNoUXVldWU9W107ZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQsZXZlbnRTeXN0ZW1GbGFncyk7cHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSxldmVudFN5c3RlbUZsYWdzKTt9ZnVuY3Rpb24gbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChkb21FdmVudE5hbWUsdGFyZ2V0RWxlbWVudCl7e2lmKCFub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpe2Vycm9yKCdEaWQgbm90IGV4cGVjdCBhIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoKSBjYWxsIGZvciBcIiVzXCIuICcrJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsZG9tRXZlbnROYW1lKTt9fXZhciBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyPWZhbHNlO3ZhciBsaXN0ZW5lclNldD1nZXRFdmVudExpc3RlbmVyU2V0KHRhcmdldEVsZW1lbnQpO3ZhciBsaXN0ZW5lclNldEtleT1nZXRMaXN0ZW5lclNldEtleShkb21FdmVudE5hbWUsaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7aWYoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpe2FkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldEVsZW1lbnQsZG9tRXZlbnROYW1lLElTX05PTl9ERUxFR0FURUQsaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7bGlzdGVuZXJTZXQuYWRkKGxpc3RlbmVyU2V0S2V5KTt9fWZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIsdGFyZ2V0KXt7aWYobm9uRGVsZWdhdGVkRXZlbnRzLmhhcyhkb21FdmVudE5hbWUpJiYhaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcil7ZXJyb3IoJ0RpZCBub3QgZXhwZWN0IGEgbGlzdGVuVG9OYXRpdmVFdmVudCgpIGNhbGwgZm9yIFwiJXNcIiBpbiB0aGUgYnViYmxlIHBoYXNlLiAnKydUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGRvbUV2ZW50TmFtZSk7fX12YXIgZXZlbnRTeXN0ZW1GbGFncz0wO2lmKGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpe2V2ZW50U3lzdGVtRmxhZ3N8PUlTX0NBUFRVUkVfUEhBU0U7fWFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldCxkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTt9Ly8gVGhpcyBpcyBvbmx5IHVzZWQgYnkgY3JlYXRlRXZlbnRIYW5kbGUgd2hlbiB0aGVcbnZhciBsaXN0ZW5pbmdNYXJrZXI9J19yZWFjdExpc3RlbmluZycrTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7ZnVuY3Rpb24gbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpe2lmKCFyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdKXtyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdPXRydWU7YWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZG9tRXZlbnROYW1lKXsvLyBXZSBoYW5kbGUgc2VsZWN0aW9uY2hhbmdlIHNlcGFyYXRlbHkgYmVjYXVzZSBpdFxuLy8gZG9lc24ndCBidWJibGUgYW5kIG5lZWRzIHRvIGJlIG9uIHRoZSBkb2N1bWVudC5cbmlmKGRvbUV2ZW50TmFtZSE9PSdzZWxlY3Rpb25jaGFuZ2UnKXtpZighbm9uRGVsZWdhdGVkRXZlbnRzLmhhcyhkb21FdmVudE5hbWUpKXtsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSxmYWxzZSxyb290Q29udGFpbmVyRWxlbWVudCk7fWxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLHRydWUscm9vdENvbnRhaW5lckVsZW1lbnQpO319KTt2YXIgb3duZXJEb2N1bWVudD1yb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZT09PURPQ1VNRU5UX05PREU/cm9vdENvbnRhaW5lckVsZW1lbnQ6cm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtpZihvd25lckRvY3VtZW50IT09bnVsbCl7Ly8gVGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCBhbHNvIG5lZWRzIGRlZHVwbGljYXRpb25cbi8vIGJ1dCBpdCBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQuXG5pZighb3duZXJEb2N1bWVudFtsaXN0ZW5pbmdNYXJrZXJdKXtvd25lckRvY3VtZW50W2xpc3RlbmluZ01hcmtlcl09dHJ1ZTtsaXN0ZW5Ub05hdGl2ZUV2ZW50KCdzZWxlY3Rpb25jaGFuZ2UnLGZhbHNlLG93bmVyRG9jdW1lbnQpO319fX1mdW5jdGlvbiBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcixpc0RlZmVycmVkTGlzdGVuZXJGb3JMZWdhY3lGQlN1cHBvcnQpe3ZhciBsaXN0ZW5lcj1jcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MpOy8vIElmIHBhc3NpdmUgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQsIHRoZW4gdGhlIGV2ZW50IHdpbGwgYmVcbi8vIGFjdGl2ZSBhbmQgbm90IHBhc3NpdmUuXG52YXIgaXNQYXNzaXZlTGlzdGVuZXI9dW5kZWZpbmVkO2lmKHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkKXsvLyBCcm93c2VycyBpbnRyb2R1Y2VkIGFuIGludGVydmVudGlvbiwgbWFraW5nIHRoZXNlIGV2ZW50c1xuLy8gcGFzc2l2ZSBieSBkZWZhdWx0IG9uIGRvY3VtZW50LiBSZWFjdCBkb2Vzbid0IGJpbmQgdGhlbVxuLy8gdG8gZG9jdW1lbnQgYW55bW9yZSwgYnV0IGNoYW5naW5nIHRoaXMgbm93IHdvdWxkIHVuZG9cbi8vIHRoZSBwZXJmb3JtYW5jZSB3aW5zIGZyb20gdGhlIGNoYW5nZS4gU28gd2UgZW11bGF0ZVxuLy8gdGhlIGV4aXN0aW5nIGJlaGF2aW9yIG1hbnVhbGx5IG9uIHRoZSByb290cyBub3cuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5NjUxXG5pZihkb21FdmVudE5hbWU9PT0ndG91Y2hzdGFydCd8fGRvbUV2ZW50TmFtZT09PSd0b3VjaG1vdmUnfHxkb21FdmVudE5hbWU9PT0nd2hlZWwnKXtpc1Bhc3NpdmVMaXN0ZW5lcj10cnVlO319dGFyZ2V0Q29udGFpbmVyPXRhcmdldENvbnRhaW5lcjt2YXIgdW5zdWJzY3JpYmVMaXN0ZW5lcjsvLyBXaGVuIGxlZ2FjeUZCU3VwcG9ydCBpcyBlbmFibGVkLCBpdCdzIGZvciB3aGVuIHdlXG5pZihpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKXtpZihpc1Bhc3NpdmVMaXN0ZW5lciE9PXVuZGVmaW5lZCl7dW5zdWJzY3JpYmVMaXN0ZW5lcj1hZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGxpc3RlbmVyLGlzUGFzc2l2ZUxpc3RlbmVyKTt9ZWxzZXt1bnN1YnNjcmliZUxpc3RlbmVyPWFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldENvbnRhaW5lcixkb21FdmVudE5hbWUsbGlzdGVuZXIpO319ZWxzZXtpZihpc1Bhc3NpdmVMaXN0ZW5lciE9PXVuZGVmaW5lZCl7dW5zdWJzY3JpYmVMaXN0ZW5lcj1hZGRFdmVudEJ1YmJsZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldENvbnRhaW5lcixkb21FdmVudE5hbWUsbGlzdGVuZXIsaXNQYXNzaXZlTGlzdGVuZXIpO31lbHNle3Vuc3Vic2NyaWJlTGlzdGVuZXI9YWRkRXZlbnRCdWJibGVMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGxpc3RlbmVyKTt9fX1mdW5jdGlvbiBpc01hdGNoaW5nUm9vdENvbnRhaW5lcihncmFuZENvbnRhaW5lcix0YXJnZXRDb250YWluZXIpe3JldHVybiBncmFuZENvbnRhaW5lcj09PXRhcmdldENvbnRhaW5lcnx8Z3JhbmRDb250YWluZXIubm9kZVR5cGU9PT1DT01NRU5UX05PREUmJmdyYW5kQ29udGFpbmVyLnBhcmVudE5vZGU9PT10YXJnZXRDb250YWluZXI7fWZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxuYXRpdmVFdmVudCx0YXJnZXRJbnN0LHRhcmdldENvbnRhaW5lcil7dmFyIGFuY2VzdG9ySW5zdD10YXJnZXRJbnN0O2lmKChldmVudFN5c3RlbUZsYWdzJklTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFKT09PTAmJihldmVudFN5c3RlbUZsYWdzJklTX05PTl9ERUxFR0FURUQpPT09MCl7dmFyIHRhcmdldENvbnRhaW5lck5vZGU9dGFyZ2V0Q29udGFpbmVyOy8vIElmIHdlIGFyZSB1c2luZyB0aGUgbGVnYWN5IEZCIHN1cHBvcnQgZmxhZywgd2VcbmlmKHRhcmdldEluc3QhPT1udWxsKXsvLyBUaGUgYmVsb3cgbG9naWMgYXR0ZW1wdHMgdG8gd29yayBvdXQgaWYgd2UgbmVlZCB0byBjaGFuZ2Vcbi8vIHRoZSB0YXJnZXQgZmliZXIgdG8gYSBkaWZmZXJlbnQgYW5jZXN0b3IuIFdlIGhhZCBzaW1pbGFyIGxvZ2ljXG4vLyBpbiB0aGUgbGVnYWN5IGV2ZW50IHN5c3RlbSwgZXhjZXB0IHRoZSBiaWcgZGlmZmVyZW5jZSBiZXR3ZWVuXG4vLyBzeXN0ZW1zIGlzIHRoYXQgdGhlIG1vZGVybiBldmVudCBzeXN0ZW0gbm93IGhhcyBhbiBldmVudCBsaXN0ZW5lclxuLy8gYXR0YWNoZWQgdG8gZWFjaCBSZWFjdCBSb290IGFuZCBSZWFjdCBQb3J0YWwgUm9vdC4gVG9nZXRoZXIsXG4vLyB0aGUgRE9NIG5vZGVzIHJlcHJlc2VudGluZyB0aGVzZSByb290cyBhcmUgdGhlIFwicm9vdENvbnRhaW5lclwiLlxuLy8gVG8gZmlndXJlIG91dCB3aGljaCBhbmNlc3RvciBpbnN0YW5jZSB3ZSBzaG91bGQgdXNlLCB3ZSB0cmF2ZXJzZVxuLy8gdXAgdGhlIGZpYmVyIHRyZWUgZnJvbSB0aGUgdGFyZ2V0IGluc3RhbmNlIGFuZCBhdHRlbXB0IHRvIGZpbmRcbi8vIHJvb3QgYm91bmRhcmllcyB0aGF0IG1hdGNoIHRoYXQgb2Ygb3VyIGN1cnJlbnQgXCJyb290Q29udGFpbmVyXCIuXG4vLyBJZiB3ZSBmaW5kIHRoYXQgXCJyb290Q29udGFpbmVyXCIsIHdlIGZpbmQgdGhlIHBhcmVudCBmaWJlclxuLy8gc3ViLXRyZWUgZm9yIHRoYXQgcm9vdCBhbmQgbWFrZSB0aGF0IG91ciBhbmNlc3RvciBpbnN0YW5jZS5cbnZhciBub2RlPXRhcmdldEluc3Q7bWFpbkxvb3A6d2hpbGUodHJ1ZSl7aWYobm9kZT09PW51bGwpe3JldHVybjt9dmFyIG5vZGVUYWc9bm9kZS50YWc7aWYobm9kZVRhZz09PUhvc3RSb290fHxub2RlVGFnPT09SG9zdFBvcnRhbCl7dmFyIGNvbnRhaW5lcj1ub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGNvbnRhaW5lcix0YXJnZXRDb250YWluZXJOb2RlKSl7YnJlYWs7fWlmKG5vZGVUYWc9PT1Ib3N0UG9ydGFsKXsvLyBUaGUgdGFyZ2V0IGlzIGEgcG9ydGFsLCBidXQgaXQncyBub3QgdGhlIHJvb3RDb250YWluZXIgd2UncmUgbG9va2luZyBmb3IuXG4vLyBOb3JtYWxseSBwb3J0YWxzIGhhbmRsZSB0aGVpciBvd24gZXZlbnRzIGFsbCB0aGUgd2F5IGRvd24gdG8gdGhlIHJvb3QuXG4vLyBTbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBzdG9wIG5vdy4gSG93ZXZlciwgd2UgZG9uJ3Qga25vdyBpZiB0aGlzIHBvcnRhbFxuLy8gd2FzIHBhcnQgb2YgKm91ciogcm9vdC5cbnZhciBncmFuZE5vZGU9bm9kZS5yZXR1cm47d2hpbGUoZ3JhbmROb2RlIT09bnVsbCl7dmFyIGdyYW5kVGFnPWdyYW5kTm9kZS50YWc7aWYoZ3JhbmRUYWc9PT1Ib3N0Um9vdHx8Z3JhbmRUYWc9PT1Ib3N0UG9ydGFsKXt2YXIgZ3JhbmRDb250YWluZXI9Z3JhbmROb2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGdyYW5kQ29udGFpbmVyLHRhcmdldENvbnRhaW5lck5vZGUpKXsvLyBUaGlzIGlzIHRoZSByb290Q29udGFpbmVyIHdlJ3JlIGxvb2tpbmcgZm9yIGFuZCB3ZSBmb3VuZCBpdCBhc1xuLy8gYSBwYXJlbnQgb2YgdGhlIFBvcnRhbC4gVGhhdCBtZWFucyB3ZSBjYW4gaWdub3JlIGl0IGJlY2F1c2UgdGhlXG4vLyBQb3J0YWwgd2lsbCBidWJibGUgdGhyb3VnaCB0byB1cy5cbnJldHVybjt9fWdyYW5kTm9kZT1ncmFuZE5vZGUucmV0dXJuO319Ly8gTm93IHdlIG5lZWQgdG8gZmluZCBpdCdzIGNvcnJlc3BvbmRpbmcgaG9zdCBmaWJlciBpbiB0aGUgb3RoZXJcbi8vIHRyZWUuIFRvIGRvIHRoaXMgd2UgY2FuIHVzZSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSwgYnV0IHdlXG4vLyBuZWVkIHRvIHZhbGlkYXRlIHRoYXQgdGhlIGZpYmVyIGlzIGEgaG9zdCBpbnN0YW5jZSwgb3RoZXJ3aXNlXG4vLyB3ZSBuZWVkIHRvIHRyYXZlcnNlIHVwIHRocm91Z2ggdGhlIERPTSB0aWxsIHdlIGZpbmQgdGhlIGNvcnJlY3Rcbi8vIG5vZGUgdGhhdCBpcyBmcm9tIHRoZSBvdGhlciB0cmVlLlxud2hpbGUoY29udGFpbmVyIT09bnVsbCl7dmFyIHBhcmVudE5vZGU9Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtpZihwYXJlbnROb2RlPT09bnVsbCl7cmV0dXJuO312YXIgcGFyZW50VGFnPXBhcmVudE5vZGUudGFnO2lmKHBhcmVudFRhZz09PUhvc3RDb21wb25lbnR8fHBhcmVudFRhZz09PUhvc3RUZXh0KXtub2RlPWFuY2VzdG9ySW5zdD1wYXJlbnROb2RlO2NvbnRpbnVlIG1haW5Mb29wO31jb250YWluZXI9Y29udGFpbmVyLnBhcmVudE5vZGU7fX1ub2RlPW5vZGUucmV0dXJuO319fWJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCl7cmV0dXJuIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxuYXRpdmVFdmVudCxhbmNlc3Rvckluc3QpO30pO31mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLGxpc3RlbmVyLGN1cnJlbnRUYXJnZXQpe3JldHVybntpbnN0YW5jZTppbnN0YW5jZSxsaXN0ZW5lcjpsaXN0ZW5lcixjdXJyZW50VGFyZ2V0OmN1cnJlbnRUYXJnZXR9O31mdW5jdGlvbiBhY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnModGFyZ2V0RmliZXIscmVhY3ROYW1lLG5hdGl2ZUV2ZW50VHlwZSxpbkNhcHR1cmVQaGFzZSxhY2N1bXVsYXRlVGFyZ2V0T25seSxuYXRpdmVFdmVudCl7dmFyIGNhcHR1cmVOYW1lPXJlYWN0TmFtZSE9PW51bGw/cmVhY3ROYW1lKydDYXB0dXJlJzpudWxsO3ZhciByZWFjdEV2ZW50TmFtZT1pbkNhcHR1cmVQaGFzZT9jYXB0dXJlTmFtZTpyZWFjdE5hbWU7dmFyIGxpc3RlbmVycz1bXTt2YXIgaW5zdGFuY2U9dGFyZ2V0RmliZXI7dmFyIGxhc3RIb3N0Q29tcG9uZW50PW51bGw7Ly8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxud2hpbGUoaW5zdGFuY2UhPT1udWxsKXt2YXIgX2luc3RhbmNlMj1pbnN0YW5jZSxzdGF0ZU5vZGU9X2luc3RhbmNlMi5zdGF0ZU5vZGUsdGFnPV9pbnN0YW5jZTIudGFnOy8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5pZih0YWc9PT1Ib3N0Q29tcG9uZW50JiZzdGF0ZU5vZGUhPT1udWxsKXtsYXN0SG9zdENvbXBvbmVudD1zdGF0ZU5vZGU7Ly8gY3JlYXRlRXZlbnRIYW5kbGUgbGlzdGVuZXJzXG5pZihyZWFjdEV2ZW50TmFtZSE9PW51bGwpe3ZhciBsaXN0ZW5lcj1nZXRMaXN0ZW5lcihpbnN0YW5jZSxyZWFjdEV2ZW50TmFtZSk7aWYobGlzdGVuZXIhPW51bGwpe2xpc3RlbmVycy5wdXNoKGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsbGlzdGVuZXIsbGFzdEhvc3RDb21wb25lbnQpKTt9fX0vLyBJZiB3ZSBhcmUgb25seSBhY2N1bXVsYXRpbmcgZXZlbnRzIGZvciB0aGUgdGFyZ2V0LCB0aGVuIHdlIGRvbid0XG4vLyBjb250aW51ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgUmVhY3QgZmliZXIgdHJlZSB0byBmaW5kIG90aGVyXG4vLyBsaXN0ZW5lcnMuXG5pZihhY2N1bXVsYXRlVGFyZ2V0T25seSl7YnJlYWs7fS8vIElmIHdlIGFyZSBwcm9jZXNzaW5nIHRoZSBvbkJlZm9yZUJsdXIgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byB0YWtlXG5pbnN0YW5jZT1pbnN0YW5jZS5yZXR1cm47fXJldHVybiBsaXN0ZW5lcnM7fS8vIFdlIHNob3VsZCBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvcjpcbi8vIC0gQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuLy8gLSBDaGFuZ2VFdmVudFBsdWdpblxuLy8gLSBTZWxlY3RFdmVudFBsdWdpblxuLy8gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgcHJvY2VzcyB0aGVzZSBwbHVnaW5zXG4vLyBpbiB0aGUgYnViYmxlIHBoYXNlLCBzbyB3ZSBuZWVkIHRvIGFjY3VtdWxhdGUgdHdvXG4vLyBwaGFzZSBldmVudCBsaXN0ZW5lcnMgKHZpYSBlbXVsYXRpb24pLlxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLHJlYWN0TmFtZSl7dmFyIGNhcHR1cmVOYW1lPXJlYWN0TmFtZSsnQ2FwdHVyZSc7dmFyIGxpc3RlbmVycz1bXTt2YXIgaW5zdGFuY2U9dGFyZ2V0RmliZXI7Ly8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxud2hpbGUoaW5zdGFuY2UhPT1udWxsKXt2YXIgX2luc3RhbmNlMz1pbnN0YW5jZSxzdGF0ZU5vZGU9X2luc3RhbmNlMy5zdGF0ZU5vZGUsdGFnPV9pbnN0YW5jZTMudGFnOy8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5pZih0YWc9PT1Ib3N0Q29tcG9uZW50JiZzdGF0ZU5vZGUhPT1udWxsKXt2YXIgY3VycmVudFRhcmdldD1zdGF0ZU5vZGU7dmFyIGNhcHR1cmVMaXN0ZW5lcj1nZXRMaXN0ZW5lcihpbnN0YW5jZSxjYXB0dXJlTmFtZSk7aWYoY2FwdHVyZUxpc3RlbmVyIT1udWxsKXtsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLGNhcHR1cmVMaXN0ZW5lcixjdXJyZW50VGFyZ2V0KSk7fXZhciBidWJibGVMaXN0ZW5lcj1nZXRMaXN0ZW5lcihpbnN0YW5jZSxyZWFjdE5hbWUpO2lmKGJ1YmJsZUxpc3RlbmVyIT1udWxsKXtsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLGJ1YmJsZUxpc3RlbmVyLGN1cnJlbnRUYXJnZXQpKTt9fWluc3RhbmNlPWluc3RhbmNlLnJldHVybjt9cmV0dXJuIGxpc3RlbmVyczt9ZnVuY3Rpb24gZ2V0UGFyZW50KGluc3Qpe2lmKGluc3Q9PT1udWxsKXtyZXR1cm4gbnVsbDt9ZG97aW5zdD1pbnN0LnJldHVybjsvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbi8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4vLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxufXdoaWxlKGluc3QmJmluc3QudGFnIT09SG9zdENvbXBvbmVudCk7aWYoaW5zdCl7cmV0dXJuIGluc3Q7fXJldHVybiBudWxsO30vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSxpbnN0Qil7dmFyIG5vZGVBPWluc3RBO3ZhciBub2RlQj1pbnN0Qjt2YXIgZGVwdGhBPTA7Zm9yKHZhciB0ZW1wQT1ub2RlQTt0ZW1wQTt0ZW1wQT1nZXRQYXJlbnQodGVtcEEpKXtkZXB0aEErKzt9dmFyIGRlcHRoQj0wO2Zvcih2YXIgdGVtcEI9bm9kZUI7dGVtcEI7dGVtcEI9Z2V0UGFyZW50KHRlbXBCKSl7ZGVwdGhCKys7fS8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbndoaWxlKGRlcHRoQS1kZXB0aEI+MCl7bm9kZUE9Z2V0UGFyZW50KG5vZGVBKTtkZXB0aEEtLTt9Ly8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxud2hpbGUoZGVwdGhCLWRlcHRoQT4wKXtub2RlQj1nZXRQYXJlbnQobm9kZUIpO2RlcHRoQi0tO30vLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbnZhciBkZXB0aD1kZXB0aEE7d2hpbGUoZGVwdGgtLSl7aWYobm9kZUE9PT1ub2RlQnx8bm9kZUIhPT1udWxsJiZub2RlQT09PW5vZGVCLmFsdGVybmF0ZSl7cmV0dXJuIG5vZGVBO31ub2RlQT1nZXRQYXJlbnQobm9kZUEpO25vZGVCPWdldFBhcmVudChub2RlQik7fXJldHVybiBudWxsO31mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KGRpc3BhdGNoUXVldWUsZXZlbnQsdGFyZ2V0LGNvbW1vbixpbkNhcHR1cmVQaGFzZSl7dmFyIHJlZ2lzdHJhdGlvbk5hbWU9ZXZlbnQuX3JlYWN0TmFtZTt2YXIgbGlzdGVuZXJzPVtdO3ZhciBpbnN0YW5jZT10YXJnZXQ7d2hpbGUoaW5zdGFuY2UhPT1udWxsKXtpZihpbnN0YW5jZT09PWNvbW1vbil7YnJlYWs7fXZhciBfaW5zdGFuY2U0PWluc3RhbmNlLGFsdGVybmF0ZT1faW5zdGFuY2U0LmFsdGVybmF0ZSxzdGF0ZU5vZGU9X2luc3RhbmNlNC5zdGF0ZU5vZGUsdGFnPV9pbnN0YW5jZTQudGFnO2lmKGFsdGVybmF0ZSE9PW51bGwmJmFsdGVybmF0ZT09PWNvbW1vbil7YnJlYWs7fWlmKHRhZz09PUhvc3RDb21wb25lbnQmJnN0YXRlTm9kZSE9PW51bGwpe3ZhciBjdXJyZW50VGFyZ2V0PXN0YXRlTm9kZTtpZihpbkNhcHR1cmVQaGFzZSl7dmFyIGNhcHR1cmVMaXN0ZW5lcj1nZXRMaXN0ZW5lcihpbnN0YW5jZSxyZWdpc3RyYXRpb25OYW1lKTtpZihjYXB0dXJlTGlzdGVuZXIhPW51bGwpe2xpc3RlbmVycy51bnNoaWZ0KGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsY2FwdHVyZUxpc3RlbmVyLGN1cnJlbnRUYXJnZXQpKTt9fWVsc2UgaWYoIWluQ2FwdHVyZVBoYXNlKXt2YXIgYnViYmxlTGlzdGVuZXI9Z2V0TGlzdGVuZXIoaW5zdGFuY2UscmVnaXN0cmF0aW9uTmFtZSk7aWYoYnViYmxlTGlzdGVuZXIhPW51bGwpe2xpc3RlbmVycy5wdXNoKGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsYnViYmxlTGlzdGVuZXIsY3VycmVudFRhcmdldCkpO319fWluc3RhbmNlPWluc3RhbmNlLnJldHVybjt9aWYobGlzdGVuZXJzLmxlbmd0aCE9PTApe2Rpc3BhdGNoUXVldWUucHVzaCh7ZXZlbnQ6ZXZlbnQsbGlzdGVuZXJzOmxpc3RlbmVyc30pO319Ly8gV2Ugc2hvdWxkIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yOlxuLy8gLSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbi8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHByb2Nlc3MgdGhpcyBwbHVnaW5cbi8vIGluIHRoZSBidWJibGUgcGhhc2UsIHNvIHdlIG5lZWQgdG8gYWNjdW11bGF0ZSB0d29cbi8vIHBoYXNlIGV2ZW50IGxpc3RlbmVycy5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSxsZWF2ZUV2ZW50LGVudGVyRXZlbnQsZnJvbSx0byl7dmFyIGNvbW1vbj1mcm9tJiZ0bz9nZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLHRvKTpudWxsO2lmKGZyb20hPT1udWxsKXthY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KGRpc3BhdGNoUXVldWUsbGVhdmVFdmVudCxmcm9tLGNvbW1vbixmYWxzZSk7fWlmKHRvIT09bnVsbCYmZW50ZXJFdmVudCE9PW51bGwpe2FjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoZGlzcGF0Y2hRdWV1ZSxlbnRlckV2ZW50LHRvLGNvbW1vbix0cnVlKTt9fWZ1bmN0aW9uIGdldExpc3RlbmVyU2V0S2V5KGRvbUV2ZW50TmFtZSxjYXB0dXJlKXtyZXR1cm4gZG9tRXZlbnROYW1lK1wiX19cIisoY2FwdHVyZT8nY2FwdHVyZSc6J2J1YmJsZScpO312YXIgZGlkV2FybkludmFsaWRIeWRyYXRpb249ZmFsc2U7dmFyIERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MPSdkYW5nZXJvdXNseVNldElubmVySFRNTCc7dmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORz0nc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzt2YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkc9J3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7dmFyIEFVVE9GT0NVUz0nYXV0b0ZvY3VzJzt2YXIgQ0hJTERSRU49J2NoaWxkcmVuJzt2YXIgU1RZTEU9J3N0eWxlJzt2YXIgSFRNTCQxPSdfX2h0bWwnO3ZhciB3YXJuZWRVbmtub3duVGFnczt2YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudDt2YXIgd2FybkZvclByb3BEaWZmZXJlbmNlO3ZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzO3ZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXI7dmFyIGNhbkRpZmZTdHlsZUZvckh5ZHJhdGlvbldhcm5pbmc7dmFyIG5vcm1hbGl6ZUhUTUw7e3dhcm5lZFVua25vd25UYWdzPXsvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbmRpYWxvZzp0cnVlLC8vIEVsZWN0cm9uIHNoaXBzIGEgY3VzdG9tIDx3ZWJ2aWV3PiB0YWcgdG8gZGlzcGxheSBleHRlcm5hbCB3ZWIgY29udGVudCBpblxuLy8gYW4gaXNvbGF0ZWQgZnJhbWUgYW5kIHByb2Nlc3MuXG4vLyBUaGlzIHRhZyBpcyBub3QgcHJlc2VudCBpbiBub24gRWxlY3Ryb24gZW52aXJvbm1lbnRzIHN1Y2ggYXMgSlNEb20gd2hpY2hcbi8vIGlzIG9mdGVuIHVzZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4vLyBAc2VlIGh0dHBzOi8vZWxlY3Ryb25qcy5vcmcvZG9jcy9hcGkvd2Vidmlldy10YWdcbndlYnZpZXc6dHJ1ZX07dmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudD1mdW5jdGlvbih0eXBlLHByb3BzKXt2YWxpZGF0ZVByb3BlcnRpZXModHlwZSxwcm9wcyk7dmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSxwcm9wcyk7dmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSxwcm9wcyx7cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczpyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6cG9zc2libGVSZWdpc3RyYXRpb25OYW1lc30pO307Ly8gSUUgMTEgcGFyc2VzICYgbm9ybWFsaXplcyB0aGUgc3R5bGUgYXR0cmlidXRlIGFzIG9wcG9zZWQgdG8gb3RoZXJcbi8vIGJyb3dzZXJzLiBJdCBhZGRzIHNwYWNlcyBhbmQgc29ydHMgdGhlIHByb3BlcnRpZXMgaW4gc29tZVxuLy8gbm9uLWFscGhhYmV0aWNhbCBvcmRlci4gSGFuZGxpbmcgdGhhdCB3b3VsZCByZXF1aXJlIHNvcnRpbmcgQ1NTXG4vLyBwcm9wZXJ0aWVzIGluIHRoZSBjbGllbnQgJiBzZXJ2ZXIgdmVyc2lvbnMgb3IgYXBwbHlpbmdcbi8vIGBleHBlY3RlZFN0eWxlYCB0byBhIHRlbXBvcmFyeSBET00gbm9kZSB0byByZWFkIGl0cyBgc3R5bGVgIGF0dHJpYnV0ZVxuLy8gbm9ybWFsaXplZC4gU2luY2UgaXQgb25seSBhZmZlY3RzIElFLCB3ZSdyZSBza2lwcGluZyBzdHlsZSB3YXJuaW5nc1xuLy8gaW4gdGhhdCBicm93c2VyIGNvbXBsZXRlbHkgaW4gZmF2b3Igb2YgZG9pbmcgYWxsIHRoYXQgd29yay5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExODA3XG5jYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nPWNhblVzZURPTSYmIWRvY3VtZW50LmRvY3VtZW50TW9kZTt3YXJuRm9yUHJvcERpZmZlcmVuY2U9ZnVuY3Rpb24ocHJvcE5hbWUsc2VydmVyVmFsdWUsY2xpZW50VmFsdWUpe2lmKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKXtyZXR1cm47fXZhciBub3JtYWxpemVkQ2xpZW50VmFsdWU9bm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKTt2YXIgbm9ybWFsaXplZFNlcnZlclZhbHVlPW5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7aWYobm9ybWFsaXplZFNlcnZlclZhbHVlPT09bm9ybWFsaXplZENsaWVudFZhbHVlKXtyZXR1cm47fWRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uPXRydWU7ZXJyb3IoJ1Byb3AgYCVzYCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6ICVzIENsaWVudDogJXMnLHByb3BOYW1lLEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZENsaWVudFZhbHVlKSk7fTt3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzPWZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWVzKXtpZihkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbil7cmV0dXJuO31kaWRXYXJuSW52YWxpZEh5ZHJhdGlvbj10cnVlO3ZhciBuYW1lcz1bXTthdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe25hbWVzLnB1c2gobmFtZSk7fSk7ZXJyb3IoJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsbmFtZXMpO307d2FybkZvckludmFsaWRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKHJlZ2lzdHJhdGlvbk5hbWUsbGlzdGVuZXIpe2lmKGxpc3RlbmVyPT09ZmFsc2Upe2Vycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJysnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcrJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicscmVnaXN0cmF0aW9uTmFtZSxyZWdpc3RyYXRpb25OYW1lLHJlZ2lzdHJhdGlvbk5hbWUpO31lbHNle2Vycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicscmVnaXN0cmF0aW9uTmFtZSx0eXBlb2YgbGlzdGVuZXIpO319Oy8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4vLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cbm5vcm1hbGl6ZUhUTUw9ZnVuY3Rpb24ocGFyZW50LGh0bWwpey8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbi8vIHJlLWluaXRpYWxpemluZyBjdXN0b20gZWxlbWVudHMgaWYgdGhleSBleGlzdC4gQnV0IHRoaXMgYnJlYWtzXG4vLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4vLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG52YXIgdGVzdEVsZW1lbnQ9cGFyZW50Lm5hbWVzcGFjZVVSST09PUhUTUxfTkFNRVNQQUNFP3BhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpOnBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLHBhcmVudC50YWdOYW1lKTt0ZXN0RWxlbWVudC5pbm5lckhUTUw9aHRtbDtyZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO307fS8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zaW5nbGUtcGFnZS5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbi8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbnZhciBOT1JNQUxJWkVfTkVXTElORVNfUkVHRVg9L1xcclxcbj8vZzt2YXIgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYPS9cXHUwMDAwfFxcdUZGRkQvZztmdW5jdGlvbiBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUobWFya3VwKXt7Y2hlY2tIdG1sU3RyaW5nQ29lcmNpb24obWFya3VwKTt9dmFyIG1hcmt1cFN0cmluZz10eXBlb2YgbWFya3VwPT09J3N0cmluZyc/bWFya3VwOicnK21hcmt1cDtyZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCdcXG4nKS5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwnJyk7fWZ1bmN0aW9uIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChzZXJ2ZXJUZXh0LGNsaWVudFRleHQsaXNDb25jdXJyZW50TW9kZSxzaG91bGRXYXJuRGV2KXt2YXIgbm9ybWFsaXplZENsaWVudFRleHQ9bm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO3ZhciBub3JtYWxpemVkU2VydmVyVGV4dD1ub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVGV4dCk7aWYobm9ybWFsaXplZFNlcnZlclRleHQ9PT1ub3JtYWxpemVkQ2xpZW50VGV4dCl7cmV0dXJuO31pZihzaG91bGRXYXJuRGV2KXt7aWYoIWRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKXtkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbj10cnVlO2Vycm9yKCdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0LG5vcm1hbGl6ZWRDbGllbnRUZXh0KTt9fX1pZihpc0NvbmN1cnJlbnRNb2RlJiZlbmFibGVDbGllbnRSZW5kZXJGYWxsYmFja09uVGV4dE1pc21hdGNoKXsvLyBJbiBjb25jdXJyZW50IHJvb3RzLCB3ZSB0aHJvdyB3aGVuIHRoZXJlJ3MgYSB0ZXh0IG1pc21hdGNoIGFuZCByZXZlcnQgdG9cbi8vIGNsaWVudCByZW5kZXJpbmcsIHVwIHRvIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5LlxudGhyb3cgbmV3IEVycm9yKCdUZXh0IGNvbnRlbnQgZG9lcyBub3QgbWF0Y2ggc2VydmVyLXJlbmRlcmVkIEhUTUwuJyk7fX1mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpe3JldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZT09PURPQ1VNRU5UX05PREU/cm9vdENvbnRhaW5lckVsZW1lbnQ6cm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDt9ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChub2RlKXsvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4vLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4vLyByZW1vdmVkLlxuLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbm5vZGUub25jbGljaz1ub29wO31mdW5jdGlvbiBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsZG9tRWxlbWVudCxyb290Q29udGFpbmVyRWxlbWVudCxuZXh0UHJvcHMsaXNDdXN0b21Db21wb25lbnRUYWcpe2Zvcih2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpe2lmKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpe2NvbnRpbnVlO312YXIgbmV4dFByb3A9bmV4dFByb3BzW3Byb3BLZXldO2lmKHByb3BLZXk9PT1TVFlMRSl7e2lmKG5leHRQcm9wKXsvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbk9iamVjdC5mcmVlemUobmV4dFByb3ApO319Ly8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG5zZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LG5leHRQcm9wKTt9ZWxzZSBpZihwcm9wS2V5PT09REFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpe3ZhciBuZXh0SHRtbD1uZXh0UHJvcD9uZXh0UHJvcFtIVE1MJDFdOnVuZGVmaW5lZDtpZihuZXh0SHRtbCE9bnVsbCl7c2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsbmV4dEh0bWwpO319ZWxzZSBpZihwcm9wS2V5PT09Q0hJTERSRU4pe2lmKHR5cGVvZiBuZXh0UHJvcD09PSdzdHJpbmcnKXsvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4vLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4vLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbnZhciBjYW5TZXRUZXh0Q29udGVudD10YWchPT0ndGV4dGFyZWEnfHxuZXh0UHJvcCE9PScnO2lmKGNhblNldFRleHRDb250ZW50KXtzZXRUZXh0Q29udGVudChkb21FbGVtZW50LG5leHRQcm9wKTt9fWVsc2UgaWYodHlwZW9mIG5leHRQcm9wPT09J251bWJlcicpe3NldFRleHRDb250ZW50KGRvbUVsZW1lbnQsJycrbmV4dFByb3ApO319ZWxzZSBpZihwcm9wS2V5PT09U1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HfHxwcm9wS2V5PT09U1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcpO2Vsc2UgaWYocHJvcEtleT09PUFVVE9GT0NVUyk7ZWxzZSBpZihyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKXtpZihuZXh0UHJvcCE9bnVsbCl7aWYodHlwZW9mIG5leHRQcm9wIT09J2Z1bmN0aW9uJyl7d2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksbmV4dFByb3ApO31pZihwcm9wS2V5PT09J29uU2Nyb2xsJyl7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJyxkb21FbGVtZW50KTt9fX1lbHNlIGlmKG5leHRQcm9wIT1udWxsKXtzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQscHJvcEtleSxuZXh0UHJvcCxpc0N1c3RvbUNvbXBvbmVudFRhZyk7fX19ZnVuY3Rpb24gdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LHVwZGF0ZVBheWxvYWQsd2FzQ3VzdG9tQ29tcG9uZW50VGFnLGlzQ3VzdG9tQ29tcG9uZW50VGFnKXsvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG5mb3IodmFyIGk9MDtpPHVwZGF0ZVBheWxvYWQubGVuZ3RoO2krPTIpe3ZhciBwcm9wS2V5PXVwZGF0ZVBheWxvYWRbaV07dmFyIHByb3BWYWx1ZT11cGRhdGVQYXlsb2FkW2krMV07aWYocHJvcEtleT09PVNUWUxFKXtzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LHByb3BWYWx1ZSk7fWVsc2UgaWYocHJvcEtleT09PURBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKXtzZXRJbm5lckhUTUwoZG9tRWxlbWVudCxwcm9wVmFsdWUpO31lbHNlIGlmKHByb3BLZXk9PT1DSElMRFJFTil7c2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCxwcm9wVmFsdWUpO31lbHNle3NldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCxwcm9wS2V5LHByb3BWYWx1ZSxpc0N1c3RvbUNvbXBvbmVudFRhZyk7fX19ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLHByb3BzLHJvb3RDb250YWluZXJFbGVtZW50LHBhcmVudE5hbWVzcGFjZSl7dmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnOy8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbi8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbnZhciBvd25lckRvY3VtZW50PWdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCk7dmFyIGRvbUVsZW1lbnQ7dmFyIG5hbWVzcGFjZVVSST1wYXJlbnROYW1lc3BhY2U7aWYobmFtZXNwYWNlVVJJPT09SFRNTF9OQU1FU1BBQ0Upe25hbWVzcGFjZVVSST1nZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7fWlmKG5hbWVzcGFjZVVSST09PUhUTUxfTkFNRVNQQUNFKXt7aXNDdXN0b21Db21wb25lbnRUYWc9aXNDdXN0b21Db21wb25lbnQodHlwZSxwcm9wcyk7Ly8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuaWYoIWlzQ3VzdG9tQ29tcG9uZW50VGFnJiZ0eXBlIT09dHlwZS50b0xvd2VyQ2FzZSgpKXtlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcrJ1VzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCAnKydvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJyx0eXBlKTt9fWlmKHR5cGU9PT0nc2NyaXB0Jyl7Ly8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbnZhciBkaXY9b3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtkaXYuaW5uZXJIVE1MPSc8c2NyaXB0PjwnKycvc2NyaXB0Pic7Ly8gZXNsaW50LWRpc2FibGUtbGluZVxuLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIHlpZWxkIGEgc2NyaXB0IGVsZW1lbnQuXG52YXIgZmlyc3RDaGlsZD1kaXYuZmlyc3RDaGlsZDtkb21FbGVtZW50PWRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTt9ZWxzZSBpZih0eXBlb2YgcHJvcHMuaXM9PT0nc3RyaW5nJyl7Ly8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG5kb21FbGVtZW50PW93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLHtpczpwcm9wcy5pc30pO31lbHNley8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuZG9tRWxlbWVudD1vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7Ly8gTm9ybWFsbHkgYXR0cmlidXRlcyBhcmUgYXNzaWduZWQgaW4gYHNldEluaXRpYWxET01Qcm9wZXJ0aWVzYCwgaG93ZXZlciB0aGUgYG11bHRpcGxlYCBhbmQgYHNpemVgXG4vLyBhdHRyaWJ1dGVzIG9uIGBzZWxlY3RgcyBuZWVkcyB0byBiZSBhZGRlZCBiZWZvcmUgYG9wdGlvbmBzIGFyZSBpbnNlcnRlZC5cbi8vIFRoaXMgcHJldmVudHM6XG4vLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBkb2VzIG5vdCBzY3JvbGwgdG8gdGhlIGNvcnJlY3Qgb3B0aW9uIGJlY2F1c2Ugc2luZ3VsYXJcbi8vICBgc2VsZWN0YCBlbGVtZW50cyBhdXRvbWF0aWNhbGx5IHBpY2sgdGhlIGZpcnN0IGl0ZW0gIzEzMjIyXG4vLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBzZXQgdGhlIGZpcnN0IGl0ZW0gYXMgc2VsZWN0ZWQgZGVzcGl0ZSB0aGUgYHNpemVgIGF0dHJpYnV0ZSAjMTQyMzlcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMjIyXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDIzOVxuaWYodHlwZT09PSdzZWxlY3QnKXt2YXIgbm9kZT1kb21FbGVtZW50O2lmKHByb3BzLm11bHRpcGxlKXtub2RlLm11bHRpcGxlPXRydWU7fWVsc2UgaWYocHJvcHMuc2l6ZSl7Ly8gU2V0dGluZyBhIHNpemUgZ3JlYXRlciB0aGFuIDEgY2F1c2VzIGEgc2VsZWN0IHRvIGJlaGF2ZSBsaWtlIGBtdWx0aXBsZT10cnVlYCwgd2hlcmVcbi8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLlxuLy9cbi8vIFRoaXMgaXMgb25seSBuZWNlc3Nhcnkgd2hlbiBhIHNlbGVjdCBpbiBcInNpbmdsZSBzZWxlY3Rpb24gbW9kZVwiLlxubm9kZS5zaXplPXByb3BzLnNpemU7fX19fWVsc2V7ZG9tRWxlbWVudD1vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksdHlwZSk7fXtpZihuYW1lc3BhY2VVUkk9PT1IVE1MX05BTUVTUEFDRSl7aWYoIWlzQ3VzdG9tQ29tcG9uZW50VGFnJiZPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCk9PT0nW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyYmIWhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsdHlwZSkpe3dhcm5lZFVua25vd25UYWdzW3R5cGVdPXRydWU7ZXJyb3IoJ1RoZSB0YWcgPCVzPiBpcyB1bnJlY29nbml6ZWQgaW4gdGhpcyBicm93c2VyLiAnKydJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcrJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJyx0eXBlKTt9fX1yZXR1cm4gZG9tRWxlbWVudDt9ZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCxyb290Q29udGFpbmVyRWxlbWVudCl7cmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7fWZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdGFnLHJhd1Byb3BzLHJvb3RDb250YWluZXJFbGVtZW50KXt2YXIgaXNDdXN0b21Db21wb25lbnRUYWc9aXNDdXN0b21Db21wb25lbnQodGFnLHJhd1Byb3BzKTt7dmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcscmF3UHJvcHMpO30vLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxudmFyIHByb3BzO3N3aXRjaCh0YWcpe2Nhc2UnZGlhbG9nJzpsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjYW5jZWwnLGRvbUVsZW1lbnQpO2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Nsb3NlJyxkb21FbGVtZW50KTtwcm9wcz1yYXdQcm9wczticmVhaztjYXNlJ2lmcmFtZSc6Y2FzZSdvYmplY3QnOmNhc2UnZW1iZWQnOi8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsZG9tRWxlbWVudCk7cHJvcHM9cmF3UHJvcHM7YnJlYWs7Y2FzZSd2aWRlbyc6Y2FzZSdhdWRpbyc6Ly8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBhbGwgdGhlIG1lZGlhIGV2ZW50cy5cbmZvcih2YXIgaT0wO2k8bWVkaWFFdmVudFR5cGVzLmxlbmd0aDtpKyspe2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLGRvbUVsZW1lbnQpO31wcm9wcz1yYXdQcm9wczticmVhaztjYXNlJ3NvdXJjZSc6Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGVycm9yIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLGRvbUVsZW1lbnQpO3Byb3BzPXJhd1Byb3BzO2JyZWFrO2Nhc2UnaW1nJzpjYXNlJ2ltYWdlJzpjYXNlJ2xpbmsnOi8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgZXJyb3IgYW5kIGxvYWQgZXZlbnRzLlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLGRvbUVsZW1lbnQpO2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLGRvbUVsZW1lbnQpO3Byb3BzPXJhd1Byb3BzO2JyZWFrO2Nhc2UnZGV0YWlscyc6Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIHRvZ2dsZSBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3RvZ2dsZScsZG9tRWxlbWVudCk7cHJvcHM9cmF3UHJvcHM7YnJlYWs7Y2FzZSdpbnB1dCc6aW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LHJhd1Byb3BzKTtwcm9wcz1nZXRIb3N0UHJvcHMoZG9tRWxlbWVudCxyYXdQcm9wcyk7Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJyxkb21FbGVtZW50KTticmVhaztjYXNlJ29wdGlvbic6dmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LHJhd1Byb3BzKTtwcm9wcz1yYXdQcm9wczticmVhaztjYXNlJ3NlbGVjdCc6aW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQscmF3UHJvcHMpO3Byb3BzPWdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQscmF3UHJvcHMpOy8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSd0ZXh0YXJlYSc6aW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQscmF3UHJvcHMpO3Byb3BzPWdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQscmF3UHJvcHMpOy8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsZG9tRWxlbWVudCk7YnJlYWs7ZGVmYXVsdDpwcm9wcz1yYXdQcm9wczt9YXNzZXJ0VmFsaWRQcm9wcyh0YWcscHJvcHMpO3NldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZyxkb21FbGVtZW50LHJvb3RDb250YWluZXJFbGVtZW50LHByb3BzLGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtzd2l0Y2godGFnKXtjYXNlJ2lucHV0JzovLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4vLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxudHJhY2soZG9tRWxlbWVudCk7cG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LHJhd1Byb3BzLGZhbHNlKTticmVhaztjYXNlJ3RleHRhcmVhJzovLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4vLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxudHJhY2soZG9tRWxlbWVudCk7cG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2Unb3B0aW9uJzpwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCxyYXdQcm9wcyk7YnJlYWs7Y2FzZSdzZWxlY3QnOnBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LHJhd1Byb3BzKTticmVhaztkZWZhdWx0OmlmKHR5cGVvZiBwcm9wcy5vbkNsaWNrPT09J2Z1bmN0aW9uJyl7Ly8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbnRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO31icmVhazt9fS8vIENhbGN1bGF0ZSB0aGUgZGlmZiBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cy5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdGFnLGxhc3RSYXdQcm9wcyxuZXh0UmF3UHJvcHMscm9vdENvbnRhaW5lckVsZW1lbnQpe3t2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZyxuZXh0UmF3UHJvcHMpO312YXIgdXBkYXRlUGF5bG9hZD1udWxsO3ZhciBsYXN0UHJvcHM7dmFyIG5leHRQcm9wcztzd2l0Y2godGFnKXtjYXNlJ2lucHV0JzpsYXN0UHJvcHM9Z2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsbGFzdFJhd1Byb3BzKTtuZXh0UHJvcHM9Z2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsbmV4dFJhd1Byb3BzKTt1cGRhdGVQYXlsb2FkPVtdO2JyZWFrO2Nhc2Unc2VsZWN0JzpsYXN0UHJvcHM9Z2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCxsYXN0UmF3UHJvcHMpO25leHRQcm9wcz1nZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7dXBkYXRlUGF5bG9hZD1bXTticmVhaztjYXNlJ3RleHRhcmVhJzpsYXN0UHJvcHM9Z2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCxsYXN0UmF3UHJvcHMpO25leHRQcm9wcz1nZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7dXBkYXRlUGF5bG9hZD1bXTticmVhaztkZWZhdWx0Omxhc3RQcm9wcz1sYXN0UmF3UHJvcHM7bmV4dFByb3BzPW5leHRSYXdQcm9wcztpZih0eXBlb2YgbGFzdFByb3BzLm9uQ2xpY2shPT0nZnVuY3Rpb24nJiZ0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2s9PT0nZnVuY3Rpb24nKXsvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxudHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7fWJyZWFrO31hc3NlcnRWYWxpZFByb3BzKHRhZyxuZXh0UHJvcHMpO3ZhciBwcm9wS2V5O3ZhciBzdHlsZU5hbWU7dmFyIHN0eWxlVXBkYXRlcz1udWxsO2Zvcihwcm9wS2V5IGluIGxhc3RQcm9wcyl7aWYobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpfHwhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpfHxsYXN0UHJvcHNbcHJvcEtleV09PW51bGwpe2NvbnRpbnVlO31pZihwcm9wS2V5PT09U1RZTEUpe3ZhciBsYXN0U3R5bGU9bGFzdFByb3BzW3Byb3BLZXldO2ZvcihzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKXtpZihsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSl7aWYoIXN0eWxlVXBkYXRlcyl7c3R5bGVVcGRhdGVzPXt9O31zdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXT0nJzt9fX1lbHNlIGlmKHByb3BLZXk9PT1EQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTHx8cHJvcEtleT09PUNISUxEUkVOKTtlbHNlIGlmKHByb3BLZXk9PT1TVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkd8fHByb3BLZXk9PT1TVVBQUkVTU19IWURSQVRJT05fV0FSTklORyk7ZWxzZSBpZihwcm9wS2V5PT09QVVUT0ZPQ1VTKTtlbHNlIGlmKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpey8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4vLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4vLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuaWYoIXVwZGF0ZVBheWxvYWQpe3VwZGF0ZVBheWxvYWQ9W107fX1lbHNley8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuLy8gdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4odXBkYXRlUGF5bG9hZD11cGRhdGVQYXlsb2FkfHxbXSkucHVzaChwcm9wS2V5LG51bGwpO319Zm9yKHByb3BLZXkgaW4gbmV4dFByb3BzKXt2YXIgbmV4dFByb3A9bmV4dFByb3BzW3Byb3BLZXldO3ZhciBsYXN0UHJvcD1sYXN0UHJvcHMhPW51bGw/bGFzdFByb3BzW3Byb3BLZXldOnVuZGVmaW5lZDtpZighbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpfHxuZXh0UHJvcD09PWxhc3RQcm9wfHxuZXh0UHJvcD09bnVsbCYmbGFzdFByb3A9PW51bGwpe2NvbnRpbnVlO31pZihwcm9wS2V5PT09U1RZTEUpe3tpZihuZXh0UHJvcCl7Ly8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbi8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG5PYmplY3QuZnJlZXplKG5leHRQcm9wKTt9fWlmKGxhc3RQcm9wKXsvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG5mb3Ioc3R5bGVOYW1lIGluIGxhc3RQcm9wKXtpZihsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpJiYoIW5leHRQcm9wfHwhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpe2lmKCFzdHlsZVVwZGF0ZXMpe3N0eWxlVXBkYXRlcz17fTt9c3R5bGVVcGRhdGVzW3N0eWxlTmFtZV09Jyc7fX0vLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuZm9yKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCl7aWYobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSYmbGFzdFByb3Bbc3R5bGVOYW1lXSE9PW5leHRQcm9wW3N0eWxlTmFtZV0pe2lmKCFzdHlsZVVwZGF0ZXMpe3N0eWxlVXBkYXRlcz17fTt9c3R5bGVVcGRhdGVzW3N0eWxlTmFtZV09bmV4dFByb3Bbc3R5bGVOYW1lXTt9fX1lbHNley8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuaWYoIXN0eWxlVXBkYXRlcyl7aWYoIXVwZGF0ZVBheWxvYWQpe3VwZGF0ZVBheWxvYWQ9W107fXVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LHN0eWxlVXBkYXRlcyk7fXN0eWxlVXBkYXRlcz1uZXh0UHJvcDt9fWVsc2UgaWYocHJvcEtleT09PURBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKXt2YXIgbmV4dEh0bWw9bmV4dFByb3A/bmV4dFByb3BbSFRNTCQxXTp1bmRlZmluZWQ7dmFyIGxhc3RIdG1sPWxhc3RQcm9wP2xhc3RQcm9wW0hUTUwkMV06dW5kZWZpbmVkO2lmKG5leHRIdG1sIT1udWxsKXtpZihsYXN0SHRtbCE9PW5leHRIdG1sKXsodXBkYXRlUGF5bG9hZD11cGRhdGVQYXlsb2FkfHxbXSkucHVzaChwcm9wS2V5LG5leHRIdG1sKTt9fX1lbHNlIGlmKHByb3BLZXk9PT1DSElMRFJFTil7aWYodHlwZW9mIG5leHRQcm9wPT09J3N0cmluZyd8fHR5cGVvZiBuZXh0UHJvcD09PSdudW1iZXInKXsodXBkYXRlUGF5bG9hZD11cGRhdGVQYXlsb2FkfHxbXSkucHVzaChwcm9wS2V5LCcnK25leHRQcm9wKTt9fWVsc2UgaWYocHJvcEtleT09PVNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklOR3x8cHJvcEtleT09PVNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKTtlbHNlIGlmKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpe2lmKG5leHRQcm9wIT1udWxsKXsvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbmlmKHR5cGVvZiBuZXh0UHJvcCE9PSdmdW5jdGlvbicpe3dhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LG5leHRQcm9wKTt9aWYocHJvcEtleT09PSdvblNjcm9sbCcpe2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsZG9tRWxlbWVudCk7fX1pZighdXBkYXRlUGF5bG9hZCYmbGFzdFByb3AhPT1uZXh0UHJvcCl7Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbi8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbi8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG51cGRhdGVQYXlsb2FkPVtdO319ZWxzZXsvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4vLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSBhbGxvd2VkIHByb3BlcnR5IGxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4odXBkYXRlUGF5bG9hZD11cGRhdGVQYXlsb2FkfHxbXSkucHVzaChwcm9wS2V5LG5leHRQcm9wKTt9fWlmKHN0eWxlVXBkYXRlcyl7e3ZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsbmV4dFByb3BzW1NUWUxFXSk7fSh1cGRhdGVQYXlsb2FkPXVwZGF0ZVBheWxvYWR8fFtdKS5wdXNoKFNUWUxFLHN0eWxlVXBkYXRlcyk7fXJldHVybiB1cGRhdGVQYXlsb2FkO30vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCx1cGRhdGVQYXlsb2FkLHRhZyxsYXN0UmF3UHJvcHMsbmV4dFJhd1Byb3BzKXsvLyBVcGRhdGUgY2hlY2tlZCAqYmVmb3JlKiBuYW1lLlxuLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbi8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuaWYodGFnPT09J2lucHV0JyYmbmV4dFJhd1Byb3BzLnR5cGU9PT0ncmFkaW8nJiZuZXh0UmF3UHJvcHMubmFtZSE9bnVsbCl7dXBkYXRlQ2hlY2tlZChkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7fXZhciB3YXNDdXN0b21Db21wb25lbnRUYWc9aXNDdXN0b21Db21wb25lbnQodGFnLGxhc3RSYXdQcm9wcyk7dmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnPWlzQ3VzdG9tQ29tcG9uZW50KHRhZyxuZXh0UmF3UHJvcHMpOy8vIEFwcGx5IHRoZSBkaWZmLlxudXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LHVwZGF0ZVBheWxvYWQsd2FzQ3VzdG9tQ29tcG9uZW50VGFnLGlzQ3VzdG9tQ29tcG9uZW50VGFnKTsvLyBUT0RPOiBFbnN1cmUgdGhhdCBhbiB1cGRhdGUgZ2V0cyBzY2hlZHVsZWQgaWYgYW55IG9mIHRoZSBzcGVjaWFsIHByb3BzXG4vLyBjaGFuZ2VkLlxuc3dpdGNoKHRhZyl7Y2FzZSdpbnB1dCc6Ly8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbi8vIGhhcHBlbiBhZnRlciBgdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxudXBkYXRlV3JhcHBlcihkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7YnJlYWs7Y2FzZSd0ZXh0YXJlYSc6dXBkYXRlV3JhcHBlciQxKGRvbUVsZW1lbnQsbmV4dFJhd1Byb3BzKTticmVhaztjYXNlJ3NlbGVjdCc6Ly8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4vLyByZWNvbmNpbGlhdGlvblxucG9zdFVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCxuZXh0UmF3UHJvcHMpO2JyZWFrO319ZnVuY3Rpb24gZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUocHJvcE5hbWUpe3t2YXIgbG93ZXJDYXNlZE5hbWU9cHJvcE5hbWUudG9Mb3dlckNhc2UoKTtpZighcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSl7cmV0dXJuIG51bGw7fXJldHVybiBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdfHxudWxsO319ZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhkb21FbGVtZW50LHRhZyxyYXdQcm9wcyxwYXJlbnROYW1lc3BhY2Uscm9vdENvbnRhaW5lckVsZW1lbnQsaXNDb25jdXJyZW50TW9kZSxzaG91bGRXYXJuRGV2KXt2YXIgaXNDdXN0b21Db21wb25lbnRUYWc7dmFyIGV4dHJhQXR0cmlidXRlTmFtZXM7e2lzQ3VzdG9tQ29tcG9uZW50VGFnPWlzQ3VzdG9tQ29tcG9uZW50KHRhZyxyYXdQcm9wcyk7dmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcscmF3UHJvcHMpO30vLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuc3dpdGNoKHRhZyl7Y2FzZSdkaWFsb2cnOmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2NhbmNlbCcsZG9tRWxlbWVudCk7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2xvc2UnLGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2UnaWZyYW1lJzpjYXNlJ29iamVjdCc6Y2FzZSdlbWJlZCc6Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGxvYWQgZXZlbnQuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJyxkb21FbGVtZW50KTticmVhaztjYXNlJ3ZpZGVvJzpjYXNlJ2F1ZGlvJzovLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGFsbCB0aGUgbWVkaWEgZXZlbnRzLlxuZm9yKHZhciBpPTA7aTxtZWRpYUV2ZW50VHlwZXMubGVuZ3RoO2krKyl7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaV0sZG9tRWxlbWVudCk7fWJyZWFrO2Nhc2Unc291cmNlJzovLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgZXJyb3IgZXZlbnQuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSdpbWcnOmNhc2UnaW1hZ2UnOmNhc2UnbGluayc6Ly8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBlcnJvciBhbmQgbG9hZCBldmVudHMuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsZG9tRWxlbWVudCk7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSdkZXRhaWxzJzovLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgdG9nZ2xlIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgndG9nZ2xlJyxkb21FbGVtZW50KTticmVhaztjYXNlJ2lucHV0Jzppbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQscmF3UHJvcHMpOy8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSdvcHRpb24nOnZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCxyYXdQcm9wcyk7YnJlYWs7Y2FzZSdzZWxlY3QnOmluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LHJhd1Byb3BzKTsvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2UndGV4dGFyZWEnOmluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LHJhd1Byb3BzKTsvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLGRvbUVsZW1lbnQpO2JyZWFrO31hc3NlcnRWYWxpZFByb3BzKHRhZyxyYXdQcm9wcyk7e2V4dHJhQXR0cmlidXRlTmFtZXM9bmV3IFNldCgpO3ZhciBhdHRyaWJ1dGVzPWRvbUVsZW1lbnQuYXR0cmlidXRlcztmb3IodmFyIF9pPTA7X2k8YXR0cmlidXRlcy5sZW5ndGg7X2krKyl7dmFyIG5hbWU9YXR0cmlidXRlc1tfaV0ubmFtZS50b0xvd2VyQ2FzZSgpO3N3aXRjaChuYW1lKXsvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbi8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuY2FzZSd2YWx1ZSc6YnJlYWs7Y2FzZSdjaGVja2VkJzpicmVhaztjYXNlJ3NlbGVjdGVkJzpicmVhaztkZWZhdWx0Oi8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG5leHRyYUF0dHJpYnV0ZU5hbWVzLmFkZChhdHRyaWJ1dGVzW19pXS5uYW1lKTt9fX12YXIgdXBkYXRlUGF5bG9hZD1udWxsO2Zvcih2YXIgcHJvcEtleSBpbiByYXdQcm9wcyl7aWYoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKXtjb250aW51ZTt9dmFyIG5leHRQcm9wPXJhd1Byb3BzW3Byb3BLZXldO2lmKHByb3BLZXk9PT1DSElMRFJFTil7Ly8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbi8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbi8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3Rcbi8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbi8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbi8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuaWYodHlwZW9mIG5leHRQcm9wPT09J3N0cmluZycpe2lmKGRvbUVsZW1lbnQudGV4dENvbnRlbnQhPT1uZXh0UHJvcCl7aWYocmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddIT09dHJ1ZSl7Y2hlY2tGb3JVbm1hdGNoZWRUZXh0KGRvbUVsZW1lbnQudGV4dENvbnRlbnQsbmV4dFByb3AsaXNDb25jdXJyZW50TW9kZSxzaG91bGRXYXJuRGV2KTt9dXBkYXRlUGF5bG9hZD1bQ0hJTERSRU4sbmV4dFByb3BdO319ZWxzZSBpZih0eXBlb2YgbmV4dFByb3A9PT0nbnVtYmVyJyl7aWYoZG9tRWxlbWVudC50ZXh0Q29udGVudCE9PScnK25leHRQcm9wKXtpZihyYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10hPT10cnVlKXtjaGVja0ZvclVubWF0Y2hlZFRleHQoZG9tRWxlbWVudC50ZXh0Q29udGVudCxuZXh0UHJvcCxpc0NvbmN1cnJlbnRNb2RlLHNob3VsZFdhcm5EZXYpO311cGRhdGVQYXlsb2FkPVtDSElMRFJFTiwnJytuZXh0UHJvcF07fX19ZWxzZSBpZihyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKXtpZihuZXh0UHJvcCE9bnVsbCl7aWYodHlwZW9mIG5leHRQcm9wIT09J2Z1bmN0aW9uJyl7d2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksbmV4dFByb3ApO31pZihwcm9wS2V5PT09J29uU2Nyb2xsJyl7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJyxkb21FbGVtZW50KTt9fX1lbHNlIGlmKHNob3VsZFdhcm5EZXYmJnRydWUmJi8vIENvbnZpbmNlIEZsb3cgd2UndmUgY2FsY3VsYXRlZCBpdCAoaXQncyBERVYtb25seSBpbiB0aGlzIG1ldGhvZC4pXG50eXBlb2YgaXNDdXN0b21Db21wb25lbnRUYWc9PT0nYm9vbGVhbicpey8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG52YXIgc2VydmVyVmFsdWU9dm9pZCAwO3ZhciBwcm9wZXJ0eUluZm89aXNDdXN0b21Db21wb25lbnRUYWcmJmVuYWJsZUN1c3RvbUVsZW1lbnRQcm9wZXJ0eVN1cHBvcnQ/bnVsbDpnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSk7aWYocmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddPT09dHJ1ZSk7ZWxzZSBpZihwcm9wS2V5PT09U1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HfHxwcm9wS2V5PT09U1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkd8fC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG5wcm9wS2V5PT09J3ZhbHVlJ3x8cHJvcEtleT09PSdjaGVja2VkJ3x8cHJvcEtleT09PSdzZWxlY3RlZCcpO2Vsc2UgaWYocHJvcEtleT09PURBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKXt2YXIgc2VydmVySFRNTD1kb21FbGVtZW50LmlubmVySFRNTDt2YXIgbmV4dEh0bWw9bmV4dFByb3A/bmV4dFByb3BbSFRNTCQxXTp1bmRlZmluZWQ7aWYobmV4dEh0bWwhPW51bGwpe3ZhciBleHBlY3RlZEhUTUw9bm9ybWFsaXplSFRNTChkb21FbGVtZW50LG5leHRIdG1sKTtpZihleHBlY3RlZEhUTUwhPT1zZXJ2ZXJIVE1MKXt3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSxzZXJ2ZXJIVE1MLGV4cGVjdGVkSFRNTCk7fX19ZWxzZSBpZihwcm9wS2V5PT09U1RZTEUpey8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO2lmKGNhbkRpZmZTdHlsZUZvckh5ZHJhdGlvbldhcm5pbmcpe3ZhciBleHBlY3RlZFN0eWxlPWNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7c2VydmVyVmFsdWU9ZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7aWYoZXhwZWN0ZWRTdHlsZSE9PXNlcnZlclZhbHVlKXt3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSxzZXJ2ZXJWYWx1ZSxleHBlY3RlZFN0eWxlKTt9fX1lbHNlIGlmKGlzQ3VzdG9tQ29tcG9uZW50VGFnJiYhZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydCl7Ly8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtzZXJ2ZXJWYWx1ZT1nZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LHByb3BLZXksbmV4dFByb3ApO2lmKG5leHRQcm9wIT09c2VydmVyVmFsdWUpe3dhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LHNlcnZlclZhbHVlLG5leHRQcm9wKTt9fWVsc2UgaWYoIXNob3VsZElnbm9yZUF0dHJpYnV0ZShwcm9wS2V5LHByb3BlcnR5SW5mbyxpc0N1c3RvbUNvbXBvbmVudFRhZykmJiFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSxuZXh0UHJvcCxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpKXt2YXIgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nPWZhbHNlO2lmKHByb3BlcnR5SW5mbyE9PW51bGwpey8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtzZXJ2ZXJWYWx1ZT1nZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQscHJvcEtleSxuZXh0UHJvcCxwcm9wZXJ0eUluZm8pO31lbHNle3ZhciBvd25OYW1lc3BhY2U9cGFyZW50TmFtZXNwYWNlO2lmKG93bk5hbWVzcGFjZT09PUhUTUxfTkFNRVNQQUNFKXtvd25OYW1lc3BhY2U9Z2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7fWlmKG93bk5hbWVzcGFjZT09PUhUTUxfTkFNRVNQQUNFKXsvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5leHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO31lbHNle3ZhciBzdGFuZGFyZE5hbWU9Z2V0UG9zc2libGVTdGFuZGFyZE5hbWUocHJvcEtleSk7aWYoc3RhbmRhcmROYW1lIT09bnVsbCYmc3RhbmRhcmROYW1lIT09cHJvcEtleSl7Ly8gSWYgYW4gU1ZHIHByb3AgaXMgc3VwcGxpZWQgd2l0aCBiYWQgY2FzaW5nLCBpdCB3aWxsXG4vLyBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGZyb20gSFRNTCwgYnV0IHdpbGwgcHJvZHVjZSBhIG1pc21hdGNoXG4vLyAoYW5kIHdvdWxkIGJlIGluY29ycmVjdGx5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQpLlxuLy8gSG93ZXZlciwgd2UgYWxyZWFkeSB3YXJuIGFib3V0IGJhZCBjYXNpbmcgZWxzZXdoZXJlLlxuLy8gU28gd2UnbGwgc2tpcCB0aGUgbWlzbGVhZGluZyBleHRyYSBtaXNtYXRjaCB3YXJuaW5nIGluIHRoaXMgY2FzZS5cbmlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZz10cnVlOy8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHN0YW5kYXJkTmFtZSk7fS8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO31zZXJ2ZXJWYWx1ZT1nZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LHByb3BLZXksbmV4dFByb3ApO312YXIgZG9udFdhcm5DdXN0b21FbGVtZW50PWVuYWJsZUN1c3RvbUVsZW1lbnRQcm9wZXJ0eVN1cHBvcnQ7aWYoIWRvbnRXYXJuQ3VzdG9tRWxlbWVudCYmbmV4dFByb3AhPT1zZXJ2ZXJWYWx1ZSYmIWlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZyl7d2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksc2VydmVyVmFsdWUsbmV4dFByb3ApO319fX17aWYoc2hvdWxkV2FybkRldil7aWYoLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplPjAmJnJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSE9PXRydWUpey8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbndhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7fX19c3dpdGNoKHRhZyl7Y2FzZSdpbnB1dCc6Ly8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbnRyYWNrKGRvbUVsZW1lbnQpO3Bvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCxyYXdQcm9wcyx0cnVlKTticmVhaztjYXNlJ3RleHRhcmVhJzovLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4vLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxudHJhY2soZG9tRWxlbWVudCk7cG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2Unc2VsZWN0JzpjYXNlJ29wdGlvbic6Ly8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4vLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3Jcbi8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3Rcbi8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4vLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuYnJlYWs7ZGVmYXVsdDppZih0eXBlb2YgcmF3UHJvcHMub25DbGljaz09PSdmdW5jdGlvbicpey8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG50cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTt9YnJlYWs7fXJldHVybiB1cGRhdGVQYXlsb2FkO31mdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0KHRleHROb2RlLHRleHQsaXNDb25jdXJyZW50TW9kZSl7dmFyIGlzRGlmZmVyZW50PXRleHROb2RlLm5vZGVWYWx1ZSE9PXRleHQ7cmV0dXJuIGlzRGlmZmVyZW50O31mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudE5vZGUsY2hpbGQpe3tpZihkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbil7cmV0dXJuO31kaWRXYXJuSW52YWxpZEh5ZHJhdGlvbj10cnVlO2Vycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO319ZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnROb2RlLGNoaWxkKXt7aWYoZGlkV2FybkludmFsaWRIeWRyYXRpb24pe3JldHVybjt9ZGlkV2FybkludmFsaWRIeWRyYXRpb249dHJ1ZTtlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LicsY2hpbGQubm9kZVZhbHVlLHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7fX1mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Tm9kZSx0YWcscHJvcHMpe3tpZihkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbil7cmV0dXJuO31kaWRXYXJuSW52YWxpZEh5ZHJhdGlvbj10cnVlO2Vycm9yKCdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LicsdGFnLHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7fX1mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSx0ZXh0KXt7aWYodGV4dD09PScnKXsvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbi8vIHRoZSBIVE1MLlxuLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuLy8gdGV4dCBub2Rlcy5cbnJldHVybjt9aWYoZGlkV2FybkludmFsaWRIeWRyYXRpb24pe3JldHVybjt9ZGlkV2FybkludmFsaWRIeWRyYXRpb249dHJ1ZTtlcnJvcignRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJyx0ZXh0LHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7fX1mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCx0YWcscHJvcHMpe3N3aXRjaCh0YWcpe2Nhc2UnaW5wdXQnOnJlc3RvcmVDb250cm9sbGVkU3RhdGUoZG9tRWxlbWVudCxwcm9wcyk7cmV0dXJuO2Nhc2UndGV4dGFyZWEnOnJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LHByb3BzKTtyZXR1cm47Y2FzZSdzZWxlY3QnOnJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShkb21FbGVtZW50LHByb3BzKTtyZXR1cm47fX12YXIgdmFsaWRhdGVET01OZXN0aW5nPWZ1bmN0aW9uKCl7fTt2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbz1mdW5jdGlvbigpe307ey8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuLy9cbi8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4vLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4vLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4vLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4vLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbi8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG52YXIgc3BlY2lhbFRhZ3M9WydhZGRyZXNzJywnYXBwbGV0JywnYXJlYScsJ2FydGljbGUnLCdhc2lkZScsJ2Jhc2UnLCdiYXNlZm9udCcsJ2Jnc291bmQnLCdibG9ja3F1b3RlJywnYm9keScsJ2JyJywnYnV0dG9uJywnY2FwdGlvbicsJ2NlbnRlcicsJ2NvbCcsJ2NvbGdyb3VwJywnZGQnLCdkZXRhaWxzJywnZGlyJywnZGl2JywnZGwnLCdkdCcsJ2VtYmVkJywnZmllbGRzZXQnLCdmaWdjYXB0aW9uJywnZmlndXJlJywnZm9vdGVyJywnZm9ybScsJ2ZyYW1lJywnZnJhbWVzZXQnLCdoMScsJ2gyJywnaDMnLCdoNCcsJ2g1JywnaDYnLCdoZWFkJywnaGVhZGVyJywnaGdyb3VwJywnaHInLCdodG1sJywnaWZyYW1lJywnaW1nJywnaW5wdXQnLCdpc2luZGV4JywnbGknLCdsaW5rJywnbGlzdGluZycsJ21haW4nLCdtYXJxdWVlJywnbWVudScsJ21lbnVpdGVtJywnbWV0YScsJ25hdicsJ25vZW1iZWQnLCdub2ZyYW1lcycsJ25vc2NyaXB0Jywnb2JqZWN0Jywnb2wnLCdwJywncGFyYW0nLCdwbGFpbnRleHQnLCdwcmUnLCdzY3JpcHQnLCdzZWN0aW9uJywnc2VsZWN0Jywnc291cmNlJywnc3R5bGUnLCdzdW1tYXJ5JywndGFibGUnLCd0Ym9keScsJ3RkJywndGVtcGxhdGUnLCd0ZXh0YXJlYScsJ3Rmb290JywndGgnLCd0aGVhZCcsJ3RpdGxlJywndHInLCd0cmFjaycsJ3VsJywnd2JyJywneG1wJ107Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbnZhciBpblNjb3BlVGFncz1bJ2FwcGxldCcsJ2NhcHRpb24nLCdodG1sJywndGFibGUnLCd0ZCcsJ3RoJywnbWFycXVlZScsJ29iamVjdCcsJ3RlbXBsYXRlJywvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4vLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbi8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3Ncbidmb3JlaWduT2JqZWN0JywnZGVzYycsJ3RpdGxlJ107Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG52YXIgYnV0dG9uU2NvcGVUYWdzPWluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTsvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG52YXIgaW1wbGllZEVuZFRhZ3M9WydkZCcsJ2R0JywnbGknLCdvcHRpb24nLCdvcHRncm91cCcsJ3AnLCdycCcsJ3J0J107dmFyIGVtcHR5QW5jZXN0b3JJbmZvPXtjdXJyZW50Om51bGwsZm9ybVRhZzpudWxsLGFUYWdJblNjb3BlOm51bGwsYnV0dG9uVGFnSW5TY29wZTpudWxsLG5vYnJUYWdJblNjb3BlOm51bGwscFRhZ0luQnV0dG9uU2NvcGU6bnVsbCxsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOm51bGwsZGxJdGVtVGFnQXV0b2Nsb3Npbmc6bnVsbH07dXBkYXRlZEFuY2VzdG9ySW5mbz1mdW5jdGlvbihvbGRJbmZvLHRhZyl7dmFyIGFuY2VzdG9ySW5mbz1hc3NpZ24oe30sb2xkSW5mb3x8ZW1wdHlBbmNlc3RvckluZm8pO3ZhciBpbmZvPXt0YWc6dGFnfTtpZihpblNjb3BlVGFncy5pbmRleE9mKHRhZykhPT0tMSl7YW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlPW51bGw7YW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU9bnVsbDthbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU9bnVsbDt9aWYoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSE9PS0xKXthbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU9bnVsbDt9Ly8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbmlmKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSE9PS0xJiZ0YWchPT0nYWRkcmVzcycmJnRhZyE9PSdkaXYnJiZ0YWchPT0ncCcpe2FuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nPW51bGw7YW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nPW51bGw7fWFuY2VzdG9ySW5mby5jdXJyZW50PWluZm87aWYodGFnPT09J2Zvcm0nKXthbmNlc3RvckluZm8uZm9ybVRhZz1pbmZvO31pZih0YWc9PT0nYScpe2FuY2VzdG9ySW5mby5hVGFnSW5TY29wZT1pbmZvO31pZih0YWc9PT0nYnV0dG9uJyl7YW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU9aW5mbzt9aWYodGFnPT09J25vYnInKXthbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU9aW5mbzt9aWYodGFnPT09J3AnKXthbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU9aW5mbzt9aWYodGFnPT09J2xpJyl7YW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc9aW5mbzt9aWYodGFnPT09J2RkJ3x8dGFnPT09J2R0Jyl7YW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nPWluZm87fXJldHVybiBhbmNlc3RvckluZm87fTsvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL3ZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudD1mdW5jdGlvbih0YWcscGFyZW50VGFnKXsvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbnN3aXRjaChwYXJlbnRUYWcpey8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuY2FzZSdzZWxlY3QnOnJldHVybiB0YWc9PT0nb3B0aW9uJ3x8dGFnPT09J29wdGdyb3VwJ3x8dGFnPT09JyN0ZXh0JztjYXNlJ29wdGdyb3VwJzpyZXR1cm4gdGFnPT09J29wdGlvbid8fHRhZz09PScjdGV4dCc7Ly8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuLy8gYnV0XG5jYXNlJ29wdGlvbic6cmV0dXJuIHRhZz09PScjdGV4dCc7Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbi8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4vLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbmNhc2UndHInOnJldHVybiB0YWc9PT0ndGgnfHx0YWc9PT0ndGQnfHx0YWc9PT0nc3R5bGUnfHx0YWc9PT0nc2NyaXB0J3x8dGFnPT09J3RlbXBsYXRlJzsvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuY2FzZSd0Ym9keSc6Y2FzZSd0aGVhZCc6Y2FzZSd0Zm9vdCc6cmV0dXJuIHRhZz09PSd0cid8fHRhZz09PSdzdHlsZSd8fHRhZz09PSdzY3JpcHQnfHx0YWc9PT0ndGVtcGxhdGUnOy8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG5jYXNlJ2NvbGdyb3VwJzpyZXR1cm4gdGFnPT09J2NvbCd8fHRhZz09PSd0ZW1wbGF0ZSc7Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbmNhc2UndGFibGUnOnJldHVybiB0YWc9PT0nY2FwdGlvbid8fHRhZz09PSdjb2xncm91cCd8fHRhZz09PSd0Ym9keSd8fHRhZz09PSd0Zm9vdCd8fHRhZz09PSd0aGVhZCd8fHRhZz09PSdzdHlsZSd8fHRhZz09PSdzY3JpcHQnfHx0YWc9PT0ndGVtcGxhdGUnOy8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbmNhc2UnaGVhZCc6cmV0dXJuIHRhZz09PSdiYXNlJ3x8dGFnPT09J2Jhc2Vmb250J3x8dGFnPT09J2Jnc291bmQnfHx0YWc9PT0nbGluayd8fHRhZz09PSdtZXRhJ3x8dGFnPT09J3RpdGxlJ3x8dGFnPT09J25vc2NyaXB0J3x8dGFnPT09J25vZnJhbWVzJ3x8dGFnPT09J3N0eWxlJ3x8dGFnPT09J3NjcmlwdCd8fHRhZz09PSd0ZW1wbGF0ZSc7Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuY2FzZSdodG1sJzpyZXR1cm4gdGFnPT09J2hlYWQnfHx0YWc9PT0nYm9keSd8fHRhZz09PSdmcmFtZXNldCc7Y2FzZSdmcmFtZXNldCc6cmV0dXJuIHRhZz09PSdmcmFtZSc7Y2FzZScjZG9jdW1lbnQnOnJldHVybiB0YWc9PT0naHRtbCc7fS8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3Ncbi8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbnN3aXRjaCh0YWcpe2Nhc2UnaDEnOmNhc2UnaDInOmNhc2UnaDMnOmNhc2UnaDQnOmNhc2UnaDUnOmNhc2UnaDYnOnJldHVybiBwYXJlbnRUYWchPT0naDEnJiZwYXJlbnRUYWchPT0naDInJiZwYXJlbnRUYWchPT0naDMnJiZwYXJlbnRUYWchPT0naDQnJiZwYXJlbnRUYWchPT0naDUnJiZwYXJlbnRUYWchPT0naDYnO2Nhc2UncnAnOmNhc2UncnQnOnJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZyk9PT0tMTtjYXNlJ2JvZHknOmNhc2UnY2FwdGlvbic6Y2FzZSdjb2wnOmNhc2UnY29sZ3JvdXAnOmNhc2UnZnJhbWVzZXQnOmNhc2UnZnJhbWUnOmNhc2UnaGVhZCc6Y2FzZSdodG1sJzpjYXNlJ3Rib2R5JzpjYXNlJ3RkJzpjYXNlJ3Rmb290JzpjYXNlJ3RoJzpjYXNlJ3RoZWFkJzpjYXNlJ3RyJzovLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4vLyBjYXNlcyBhcmUgaW52YWxpZC5cbnJldHVybiBwYXJlbnRUYWc9PW51bGw7fXJldHVybiB0cnVlO307LyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi92YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZz1mdW5jdGlvbih0YWcsYW5jZXN0b3JJbmZvKXtzd2l0Y2godGFnKXtjYXNlJ2FkZHJlc3MnOmNhc2UnYXJ0aWNsZSc6Y2FzZSdhc2lkZSc6Y2FzZSdibG9ja3F1b3RlJzpjYXNlJ2NlbnRlcic6Y2FzZSdkZXRhaWxzJzpjYXNlJ2RpYWxvZyc6Y2FzZSdkaXInOmNhc2UnZGl2JzpjYXNlJ2RsJzpjYXNlJ2ZpZWxkc2V0JzpjYXNlJ2ZpZ2NhcHRpb24nOmNhc2UnZmlndXJlJzpjYXNlJ2Zvb3Rlcic6Y2FzZSdoZWFkZXInOmNhc2UnaGdyb3VwJzpjYXNlJ21haW4nOmNhc2UnbWVudSc6Y2FzZSduYXYnOmNhc2Unb2wnOmNhc2UncCc6Y2FzZSdzZWN0aW9uJzpjYXNlJ3N1bW1hcnknOmNhc2UndWwnOmNhc2UncHJlJzpjYXNlJ2xpc3RpbmcnOmNhc2UndGFibGUnOmNhc2UnaHInOmNhc2UneG1wJzpjYXNlJ2gxJzpjYXNlJ2gyJzpjYXNlJ2gzJzpjYXNlJ2g0JzpjYXNlJ2g1JzpjYXNlJ2g2JzpyZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO2Nhc2UnZm9ybSc6cmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnfHxhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7Y2FzZSdsaSc6cmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO2Nhc2UnZGQnOmNhc2UnZHQnOnJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7Y2FzZSdidXR0b24nOnJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtjYXNlJ2EnOi8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxucmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtjYXNlJ25vYnInOnJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7fXJldHVybiBudWxsO307dmFyIGRpZFdhcm4kMT17fTt2YWxpZGF0ZURPTU5lc3Rpbmc9ZnVuY3Rpb24oY2hpbGRUYWcsY2hpbGRUZXh0LGFuY2VzdG9ySW5mbyl7YW5jZXN0b3JJbmZvPWFuY2VzdG9ySW5mb3x8ZW1wdHlBbmNlc3RvckluZm87dmFyIHBhcmVudEluZm89YW5jZXN0b3JJbmZvLmN1cnJlbnQ7dmFyIHBhcmVudFRhZz1wYXJlbnRJbmZvJiZwYXJlbnRJbmZvLnRhZztpZihjaGlsZFRleHQhPW51bGwpe2lmKGNoaWxkVGFnIT1udWxsKXtlcnJvcigndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7fWNoaWxkVGFnPScjdGV4dCc7fXZhciBpbnZhbGlkUGFyZW50PWlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLHBhcmVudFRhZyk/bnVsbDpwYXJlbnRJbmZvO3ZhciBpbnZhbGlkQW5jZXN0b3I9aW52YWxpZFBhcmVudD9udWxsOmZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsYW5jZXN0b3JJbmZvKTt2YXIgaW52YWxpZFBhcmVudE9yQW5jZXN0b3I9aW52YWxpZFBhcmVudHx8aW52YWxpZEFuY2VzdG9yO2lmKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcil7cmV0dXJuO312YXIgYW5jZXN0b3JUYWc9aW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO3ZhciB3YXJuS2V5PSEhaW52YWxpZFBhcmVudCsnfCcrY2hpbGRUYWcrJ3wnK2FuY2VzdG9yVGFnO2lmKGRpZFdhcm4kMVt3YXJuS2V5XSl7cmV0dXJuO31kaWRXYXJuJDFbd2FybktleV09dHJ1ZTt2YXIgdGFnRGlzcGxheU5hbWU9Y2hpbGRUYWc7dmFyIHdoaXRlc3BhY2VJbmZvPScnO2lmKGNoaWxkVGFnPT09JyN0ZXh0Jyl7aWYoL1xcUy8udGVzdChjaGlsZFRleHQpKXt0YWdEaXNwbGF5TmFtZT0nVGV4dCBub2Rlcyc7fWVsc2V7dGFnRGlzcGxheU5hbWU9J1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7d2hpdGVzcGFjZUluZm89XCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIisnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJzt9fWVsc2V7dGFnRGlzcGxheU5hbWU9JzwnK2NoaWxkVGFnKyc+Jzt9aWYoaW52YWxpZFBhcmVudCl7dmFyIGluZm89Jyc7aWYoYW5jZXN0b3JUYWc9PT0ndGFibGUnJiZjaGlsZFRhZz09PSd0cicpe2luZm8rPScgQWRkIGEgPHRib2R5PiwgPHRoZWFkPiBvciA8dGZvb3Q+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcrJ3RoZSBicm93c2VyLic7fWVycm9yKCd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcycsdGFnRGlzcGxheU5hbWUsYW5jZXN0b3JUYWcsd2hpdGVzcGFjZUluZm8saW5mbyk7fWVsc2V7ZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnKyc8JXM+LicsdGFnRGlzcGxheU5hbWUsYW5jZXN0b3JUYWcpO319O312YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMT0nc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzt2YXIgU1VTUEVOU0VfU1RBUlRfREFUQT0nJCc7dmFyIFNVU1BFTlNFX0VORF9EQVRBPScvJCc7dmFyIFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQT0nJD8nO3ZhciBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBPSckISc7dmFyIFNUWUxFJDE9J3N0eWxlJzt2YXIgZXZlbnRzRW5hYmxlZD1udWxsO3ZhciBzZWxlY3Rpb25JbmZvcm1hdGlvbj1udWxsO2Z1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2Upe3ZhciB0eXBlO3ZhciBuYW1lc3BhY2U7dmFyIG5vZGVUeXBlPXJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtzd2l0Y2gobm9kZVR5cGUpe2Nhc2UgRE9DVU1FTlRfTk9ERTpjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6e3R5cGU9bm9kZVR5cGU9PT1ET0NVTUVOVF9OT0RFPycjZG9jdW1lbnQnOicjZnJhZ21lbnQnO3ZhciByb290PXJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7bmFtZXNwYWNlPXJvb3Q/cm9vdC5uYW1lc3BhY2VVUkk6Z2V0Q2hpbGROYW1lc3BhY2UobnVsbCwnJyk7YnJlYWs7fWRlZmF1bHQ6e3ZhciBjb250YWluZXI9bm9kZVR5cGU9PT1DT01NRU5UX05PREU/cm9vdENvbnRhaW5lckluc3RhbmNlLnBhcmVudE5vZGU6cm9vdENvbnRhaW5lckluc3RhbmNlO3ZhciBvd25OYW1lc3BhY2U9Y29udGFpbmVyLm5hbWVzcGFjZVVSSXx8bnVsbDt0eXBlPWNvbnRhaW5lci50YWdOYW1lO25hbWVzcGFjZT1nZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsdHlwZSk7YnJlYWs7fX17dmFyIHZhbGlkYXRlZFRhZz10eXBlLnRvTG93ZXJDYXNlKCk7dmFyIGFuY2VzdG9ySW5mbz11cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsdmFsaWRhdGVkVGFnKTtyZXR1cm57bmFtZXNwYWNlOm5hbWVzcGFjZSxhbmNlc3RvckluZm86YW5jZXN0b3JJbmZvfTt9fWZ1bmN0aW9uIGdldENoaWxkSG9zdENvbnRleHQocGFyZW50SG9zdENvbnRleHQsdHlwZSxyb290Q29udGFpbmVySW5zdGFuY2Upe3t2YXIgcGFyZW50SG9zdENvbnRleHREZXY9cGFyZW50SG9zdENvbnRleHQ7dmFyIG5hbWVzcGFjZT1nZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsdHlwZSk7dmFyIGFuY2VzdG9ySW5mbz11cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyx0eXBlKTtyZXR1cm57bmFtZXNwYWNlOm5hbWVzcGFjZSxhbmNlc3RvckluZm86YW5jZXN0b3JJbmZvfTt9fWZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKXtyZXR1cm4gaW5zdGFuY2U7fWZ1bmN0aW9uIHByZXBhcmVGb3JDb21taXQoY29udGFpbmVySW5mbyl7ZXZlbnRzRW5hYmxlZD1pc0VuYWJsZWQoKTtzZWxlY3Rpb25JbmZvcm1hdGlvbj1nZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO3ZhciBhY3RpdmVJbnN0YW5jZT1udWxsO3NldEVuYWJsZWQoZmFsc2UpO3JldHVybiBhY3RpdmVJbnN0YW5jZTt9ZnVuY3Rpb24gcmVzZXRBZnRlckNvbW1pdChjb250YWluZXJJbmZvKXtyZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtzZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO2V2ZW50c0VuYWJsZWQ9bnVsbDtzZWxlY3Rpb25JbmZvcm1hdGlvbj1udWxsO31mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLHByb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCxpbnRlcm5hbEluc3RhbmNlSGFuZGxlKXt2YXIgcGFyZW50TmFtZXNwYWNlO3svLyBUT0RPOiB0YWtlIG5hbWVzcGFjZSBpbnRvIGFjY291bnQgd2hlbiB2YWxpZGF0aW5nLlxudmFyIGhvc3RDb250ZXh0RGV2PWhvc3RDb250ZXh0O3ZhbGlkYXRlRE9NTmVzdGluZyh0eXBlLG51bGwsaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtpZih0eXBlb2YgcHJvcHMuY2hpbGRyZW49PT0nc3RyaW5nJ3x8dHlwZW9mIHByb3BzLmNoaWxkcmVuPT09J251bWJlcicpe3ZhciBzdHJpbmc9JycrcHJvcHMuY2hpbGRyZW47dmFyIG93bkFuY2VzdG9ySW5mbz11cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyx0eXBlKTt2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCxzdHJpbmcsb3duQW5jZXN0b3JJbmZvKTt9cGFyZW50TmFtZXNwYWNlPWhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTt9dmFyIGRvbUVsZW1lbnQ9Y3JlYXRlRWxlbWVudCh0eXBlLHByb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxwYXJlbnROYW1lc3BhY2UpO3ByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsZG9tRWxlbWVudCk7dXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LHByb3BzKTtyZXR1cm4gZG9tRWxlbWVudDt9ZnVuY3Rpb24gYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudEluc3RhbmNlLGNoaWxkKXtwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7fWZ1bmN0aW9uIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGRvbUVsZW1lbnQsdHlwZSxwcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UsaG9zdENvbnRleHQpe3NldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdHlwZSxwcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UpO3N3aXRjaCh0eXBlKXtjYXNlJ2J1dHRvbic6Y2FzZSdpbnB1dCc6Y2FzZSdzZWxlY3QnOmNhc2UndGV4dGFyZWEnOnJldHVybiEhcHJvcHMuYXV0b0ZvY3VzO2Nhc2UnaW1nJzpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZTt9fWZ1bmN0aW9uIHByZXBhcmVVcGRhdGUoZG9tRWxlbWVudCx0eXBlLG9sZFByb3BzLG5ld1Byb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCl7e3ZhciBob3N0Q29udGV4dERldj1ob3N0Q29udGV4dDtpZih0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4hPT10eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4mJih0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW49PT0nc3RyaW5nJ3x8dHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuPT09J251bWJlcicpKXt2YXIgc3RyaW5nPScnK25ld1Byb3BzLmNoaWxkcmVuO3ZhciBvd25BbmNlc3RvckluZm89dXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sdHlwZSk7dmFsaWRhdGVET01OZXN0aW5nKG51bGwsc3RyaW5nLG93bkFuY2VzdG9ySW5mbyk7fX1yZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCx0eXBlLG9sZFByb3BzLG5ld1Byb3BzKTt9ZnVuY3Rpb24gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSxwcm9wcyl7cmV0dXJuIHR5cGU9PT0ndGV4dGFyZWEnfHx0eXBlPT09J25vc2NyaXB0J3x8dHlwZW9mIHByb3BzLmNoaWxkcmVuPT09J3N0cmluZyd8fHR5cGVvZiBwcm9wcy5jaGlsZHJlbj09PSdudW1iZXInfHx0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9PT0nb2JqZWN0JyYmcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwhPT1udWxsJiZwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwhPW51bGw7fWZ1bmN0aW9uIGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCxpbnRlcm5hbEluc3RhbmNlSGFuZGxlKXt7dmFyIGhvc3RDb250ZXh0RGV2PWhvc3RDb250ZXh0O3ZhbGlkYXRlRE9NTmVzdGluZyhudWxsLHRleHQsaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTt9dmFyIHRleHROb2RlPWNyZWF0ZVRleHROb2RlKHRleHQscm9vdENvbnRhaW5lckluc3RhbmNlKTtwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLHRleHROb2RlKTtyZXR1cm4gdGV4dE5vZGU7fWZ1bmN0aW9uIGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCl7dmFyIGN1cnJlbnRFdmVudD13aW5kb3cuZXZlbnQ7aWYoY3VycmVudEV2ZW50PT09dW5kZWZpbmVkKXtyZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7fXJldHVybiBnZXRFdmVudFByaW9yaXR5KGN1cnJlbnRFdmVudC50eXBlKTt9Ly8gaWYgYSBjb21wb25lbnQganVzdCBpbXBvcnRzIFJlYWN0RE9NIChlLmcuIGZvciBmaW5kRE9NTm9kZSkuXG4vLyBTb21lIGVudmlyb25tZW50cyBtaWdodCBub3QgaGF2ZSBzZXRUaW1lb3V0IG9yIGNsZWFyVGltZW91dC5cbnZhciBzY2hlZHVsZVRpbWVvdXQ9dHlwZW9mIHNldFRpbWVvdXQ9PT0nZnVuY3Rpb24nP3NldFRpbWVvdXQ6dW5kZWZpbmVkO3ZhciBjYW5jZWxUaW1lb3V0PXR5cGVvZiBjbGVhclRpbWVvdXQ9PT0nZnVuY3Rpb24nP2NsZWFyVGltZW91dDp1bmRlZmluZWQ7dmFyIG5vVGltZW91dD0tMTt2YXIgbG9jYWxQcm9taXNlPXR5cGVvZiBQcm9taXNlPT09J2Z1bmN0aW9uJz9Qcm9taXNlOnVuZGVmaW5lZDsvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgc2NoZWR1bGVNaWNyb3Rhc2s9dHlwZW9mIHF1ZXVlTWljcm90YXNrPT09J2Z1bmN0aW9uJz9xdWV1ZU1pY3JvdGFzazp0eXBlb2YgbG9jYWxQcm9taXNlIT09J3VuZGVmaW5lZCc/ZnVuY3Rpb24oY2FsbGJhY2spe3JldHVybiBsb2NhbFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGNhbGxiYWNrKS5jYXRjaChoYW5kbGVFcnJvckluTmV4dFRpY2spO306c2NoZWR1bGVUaW1lb3V0Oy8vIFRPRE86IERldGVybWluZSB0aGUgYmVzdCBmYWxsYmFjayBoZXJlLlxuZnVuY3Rpb24gaGFuZGxlRXJyb3JJbk5leHRUaWNrKGVycm9yKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZXJyb3I7fSk7fS8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNvbW1pdE1vdW50KGRvbUVsZW1lbnQsdHlwZSxuZXdQcm9wcyxpbnRlcm5hbEluc3RhbmNlSGFuZGxlKXsvLyBEZXNwaXRlIHRoZSBuYW1pbmcgdGhhdCBtaWdodCBpbXBseSBvdGhlcndpc2UsIHRoaXMgbWV0aG9kIG9ubHlcbi8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuLy8gVGhpcyBoYXBwZW5zIGlmIGBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbmAgcmV0dXJucyBgdHJ1ZWAgKHdoaWNoIGl0XG4vLyBkb2VzIHRvIGltcGxlbWVudCB0aGUgYGF1dG9Gb2N1c2AgYXR0cmlidXRlIG9uIHRoZSBjbGllbnQpLiBCdXRcbi8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbi8vIHVwIHRleHQgY29udGVudCBkdXJpbmcgaHlkcmF0aW9uIG1pc21hdGNoKS4gU28gd2UnbGwgY2hlY2sgdGhpcyBhZ2Fpbi5cbnN3aXRjaCh0eXBlKXtjYXNlJ2J1dHRvbic6Y2FzZSdpbnB1dCc6Y2FzZSdzZWxlY3QnOmNhc2UndGV4dGFyZWEnOmlmKG5ld1Byb3BzLmF1dG9Gb2N1cyl7ZG9tRWxlbWVudC5mb2N1cygpO31yZXR1cm47Y2FzZSdpbWcnOntpZihuZXdQcm9wcy5zcmMpe2RvbUVsZW1lbnQuc3JjPW5ld1Byb3BzLnNyYzt9cmV0dXJuO319fWZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShkb21FbGVtZW50LHVwZGF0ZVBheWxvYWQsdHlwZSxvbGRQcm9wcyxuZXdQcm9wcyxpbnRlcm5hbEluc3RhbmNlSGFuZGxlKXsvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgRE9NIG5vZGUuXG51cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdXBkYXRlUGF5bG9hZCx0eXBlLG9sZFByb3BzLG5ld1Byb3BzKTsvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbi8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbnVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCxuZXdQcm9wcyk7fWZ1bmN0aW9uIHJlc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCl7c2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwnJyk7fWZ1bmN0aW9uIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLG9sZFRleHQsbmV3VGV4dCl7dGV4dEluc3RhbmNlLm5vZGVWYWx1ZT1uZXdUZXh0O31mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSxjaGlsZCl7cGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO31mdW5jdGlvbiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKGNvbnRhaW5lcixjaGlsZCl7dmFyIHBhcmVudE5vZGU7aWYoY29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXtwYXJlbnROb2RlPWNvbnRhaW5lci5wYXJlbnROb2RlO3BhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLGNvbnRhaW5lcik7fWVsc2V7cGFyZW50Tm9kZT1jb250YWluZXI7cGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7fS8vIFRoaXMgY29udGFpbmVyIG1pZ2h0IGJlIHVzZWQgZm9yIGEgcG9ydGFsLlxuLy8gSWYgc29tZXRoaW5nIGluc2lkZSBhIHBvcnRhbCBpcyBjbGlja2VkLCB0aGF0IGNsaWNrIHNob3VsZCBidWJibGVcbi8vIHRocm91Z2ggdGhlIFJlYWN0IHRyZWUuIEhvd2V2ZXIsIG9uIE1vYmlsZSBTYWZhcmkgdGhlIGNsaWNrIHdvdWxkXG4vLyBuZXZlciBidWJibGUgdGhyb3VnaCB0aGUgKkRPTSogdHJlZSB1bmxlc3MgYW4gYW5jZXN0b3Igd2l0aCBvbmNsaWNrXG4vLyBldmVudCBleGlzdHMuIFNvIHdlIHdvdWxkbid0IHNlZSBpdCBhbmQgZGlzcGF0Y2ggaXQuXG4vLyBUaGlzIGlzIHdoeSB3ZSBlbnN1cmUgdGhhdCBub24gUmVhY3Qgcm9vdCBjb250YWluZXJzIGhhdmUgaW5saW5lIG9uY2xpY2tcbi8vIGRlZmluZWQuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExOTE4XG52YXIgcmVhY3RSb290Q29udGFpbmVyPWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO2lmKChyZWFjdFJvb3RDb250YWluZXI9PT1udWxsfHxyZWFjdFJvb3RDb250YWluZXI9PT11bmRlZmluZWQpJiZwYXJlbnROb2RlLm9uY2xpY2s9PT1udWxsKXsvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxudHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50Tm9kZSk7fX1mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsY2hpbGQsYmVmb3JlQ2hpbGQpe3BhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCxiZWZvcmVDaGlsZCk7fWZ1bmN0aW9uIGluc2VydEluQ29udGFpbmVyQmVmb3JlKGNvbnRhaW5lcixjaGlsZCxiZWZvcmVDaGlsZCl7aWYoY29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXtjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsYmVmb3JlQ2hpbGQpO31lbHNle2NvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsYmVmb3JlQ2hpbGQpO319ZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsY2hpbGQpe3BhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTt9ZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGNvbnRhaW5lcixjaGlsZCl7aWYoY29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXtjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7fWVsc2V7Y29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTt9fWZ1bmN0aW9uIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShwYXJlbnRJbnN0YW5jZSxzdXNwZW5zZUluc3RhbmNlKXt2YXIgbm9kZT1zdXNwZW5zZUluc3RhbmNlOy8vIERlbGV0ZSBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4vLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG52YXIgZGVwdGg9MDtkb3t2YXIgbmV4dE5vZGU9bm9kZS5uZXh0U2libGluZztwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChub2RlKTtpZihuZXh0Tm9kZSYmbmV4dE5vZGUubm9kZVR5cGU9PT1DT01NRU5UX05PREUpe3ZhciBkYXRhPW5leHROb2RlLmRhdGE7aWYoZGF0YT09PVNVU1BFTlNFX0VORF9EQVRBKXtpZihkZXB0aD09PTApe3BhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKG5leHROb2RlKTsvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG5yZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO3JldHVybjt9ZWxzZXtkZXB0aC0tO319ZWxzZSBpZihkYXRhPT09U1VTUEVOU0VfU1RBUlRfREFUQXx8ZGF0YT09PVNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQXx8ZGF0YT09PVNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEpe2RlcHRoKys7fX1ub2RlPW5leHROb2RlO313aGlsZShub2RlKTsvLyBUT0RPOiBXYXJuLCB3ZSBkaWRuJ3QgZmluZCB0aGUgZW5kIGNvbW1lbnQgYm91bmRhcnkuXG4vLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG5yZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO31mdW5jdGlvbiBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKGNvbnRhaW5lcixzdXNwZW5zZUluc3RhbmNlKXtpZihjb250YWluZXIubm9kZVR5cGU9PT1DT01NRU5UX05PREUpe2NsZWFyU3VzcGVuc2VCb3VuZGFyeShjb250YWluZXIucGFyZW50Tm9kZSxzdXNwZW5zZUluc3RhbmNlKTt9ZWxzZSBpZihjb250YWluZXIubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe2NsZWFyU3VzcGVuc2VCb3VuZGFyeShjb250YWluZXIsc3VzcGVuc2VJbnN0YW5jZSk7fS8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbnJldHJ5SWZCbG9ja2VkT24oY29udGFpbmVyKTt9ZnVuY3Rpb24gaGlkZUluc3RhbmNlKGluc3RhbmNlKXsvLyBUT0RPOiBEb2VzIHRoaXMgd29yayBmb3IgYWxsIGVsZW1lbnQgdHlwZXM/IFdoYXQgYWJvdXQgTWF0aE1MPyBTaG91bGQgd2Vcbi8vIHBhc3MgaG9zdCBjb250ZXh0IHRvIHRoaXMgbWV0aG9kP1xuaW5zdGFuY2U9aW5zdGFuY2U7dmFyIHN0eWxlPWluc3RhbmNlLnN0eWxlO2lmKHR5cGVvZiBzdHlsZS5zZXRQcm9wZXJ0eT09PSdmdW5jdGlvbicpe3N0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5Jywnbm9uZScsJ2ltcG9ydGFudCcpO31lbHNle3N0eWxlLmRpc3BsYXk9J25vbmUnO319ZnVuY3Rpb24gaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2Upe3RleHRJbnN0YW5jZS5ub2RlVmFsdWU9Jyc7fWZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLHByb3BzKXtpbnN0YW5jZT1pbnN0YW5jZTt2YXIgc3R5bGVQcm9wPXByb3BzW1NUWUxFJDFdO3ZhciBkaXNwbGF5PXN0eWxlUHJvcCE9PXVuZGVmaW5lZCYmc3R5bGVQcm9wIT09bnVsbCYmc3R5bGVQcm9wLmhhc093blByb3BlcnR5KCdkaXNwbGF5Jyk/c3R5bGVQcm9wLmRpc3BsYXk6bnVsbDtpbnN0YW5jZS5zdHlsZS5kaXNwbGF5PWRhbmdlcm91c1N0eWxlVmFsdWUoJ2Rpc3BsYXknLGRpc3BsYXkpO31mdW5jdGlvbiB1bmhpZGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLHRleHQpe3RleHRJbnN0YW5jZS5ub2RlVmFsdWU9dGV4dDt9ZnVuY3Rpb24gY2xlYXJDb250YWluZXIoY29udGFpbmVyKXtpZihjb250YWluZXIubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe2NvbnRhaW5lci50ZXh0Q29udGVudD0nJzt9ZWxzZSBpZihjb250YWluZXIubm9kZVR5cGU9PT1ET0NVTUVOVF9OT0RFKXtpZihjb250YWluZXIuZG9jdW1lbnRFbGVtZW50KXtjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmRvY3VtZW50RWxlbWVudCk7fX19Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLHR5cGUscHJvcHMpe2lmKGluc3RhbmNlLm5vZGVUeXBlIT09RUxFTUVOVF9OT0RFfHx0eXBlLnRvTG93ZXJDYXNlKCkhPT1pbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXtyZXR1cm4gbnVsbDt9Ly8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhbiBlbGVtZW50IG5vZGUuXG5yZXR1cm4gaW5zdGFuY2U7fWZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsdGV4dCl7aWYodGV4dD09PScnfHxpbnN0YW5jZS5ub2RlVHlwZSE9PVRFWFRfTk9ERSl7Ly8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxucmV0dXJuIG51bGw7fS8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG5yZXR1cm4gaW5zdGFuY2U7fWZ1bmN0aW9uIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKGluc3RhbmNlKXtpZihpbnN0YW5jZS5ub2RlVHlwZSE9PUNPTU1FTlRfTk9ERSl7Ly8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxucmV0dXJuIG51bGw7fS8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSBzdXNwZW5zZSBub2RlLlxucmV0dXJuIGluc3RhbmNlO31mdW5jdGlvbiBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKGluc3RhbmNlKXtyZXR1cm4gaW5zdGFuY2UuZGF0YT09PVNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQTt9ZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soaW5zdGFuY2Upe3JldHVybiBpbnN0YW5jZS5kYXRhPT09U1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQTt9ZnVuY3Rpb24gZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzKGluc3RhbmNlKXt2YXIgZGF0YXNldD1pbnN0YW5jZS5uZXh0U2libGluZyYmaW5zdGFuY2UubmV4dFNpYmxpbmcuZGF0YXNldDt2YXIgZGlnZXN0LG1lc3NhZ2Usc3RhY2s7aWYoZGF0YXNldCl7ZGlnZXN0PWRhdGFzZXQuZGdzdDt7bWVzc2FnZT1kYXRhc2V0Lm1zZztzdGFjaz1kYXRhc2V0LnN0Y2s7fX17cmV0dXJue21lc3NhZ2U6bWVzc2FnZSxkaWdlc3Q6ZGlnZXN0LHN0YWNrOnN0YWNrfTt9Ly8gbGV0IHZhbHVlID0ge21lc3NhZ2U6IHVuZGVmaW5lZCwgaGFzaDogdW5kZWZpbmVkfTtcbi8vIGNvbnN0IG5leHRTaWJsaW5nID0gaW5zdGFuY2UubmV4dFNpYmxpbmc7XG4vLyBpZiAobmV4dFNpYmxpbmcpIHtcbi8vICAgY29uc3QgZGF0YXNldCA9ICgobmV4dFNpYmxpbmc6IGFueSk6IEhUTUxUZW1wbGF0ZUVsZW1lbnQpLmRhdGFzZXQ7XG4vLyAgIHZhbHVlLm1lc3NhZ2UgPSBkYXRhc2V0Lm1zZztcbi8vICAgdmFsdWUuaGFzaCA9IGRhdGFzZXQuaGFzaDtcbi8vICAgaWYgKHRydWUpIHtcbi8vICAgICB2YWx1ZS5zdGFjayA9IGRhdGFzZXQuc3RhY2s7XG4vLyAgIH1cbi8vIH1cbi8vIHJldHVybiB2YWx1ZTtcbn1mdW5jdGlvbiByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShpbnN0YW5jZSxjYWxsYmFjayl7aW5zdGFuY2UuX3JlYWN0UmV0cnk9Y2FsbGJhY2s7fWZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlKG5vZGUpey8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG5mb3IoO25vZGUhPW51bGw7bm9kZT1ub2RlLm5leHRTaWJsaW5nKXt2YXIgbm9kZVR5cGU9bm9kZS5ub2RlVHlwZTtpZihub2RlVHlwZT09PUVMRU1FTlRfTk9ERXx8bm9kZVR5cGU9PT1URVhUX05PREUpe2JyZWFrO31pZihub2RlVHlwZT09PUNPTU1FTlRfTk9ERSl7dmFyIG5vZGVEYXRhPW5vZGUuZGF0YTtpZihub2RlRGF0YT09PVNVU1BFTlNFX1NUQVJUX0RBVEF8fG5vZGVEYXRhPT09U1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQXx8bm9kZURhdGE9PT1TVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEpe2JyZWFrO31pZihub2RlRGF0YT09PVNVU1BFTlNFX0VORF9EQVRBKXtyZXR1cm4gbnVsbDt9fX1yZXR1cm4gbm9kZTt9ZnVuY3Rpb24gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGluc3RhbmNlKXtyZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUoaW5zdGFuY2UubmV4dFNpYmxpbmcpO31mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSl7cmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQpO31mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIpe3JldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRDb250YWluZXIuZmlyc3RDaGlsZCk7fWZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSl7cmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKHBhcmVudEluc3RhbmNlLm5leHRTaWJsaW5nKTt9ZnVuY3Rpb24gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLHR5cGUscHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlLGhvc3RDb250ZXh0LGludGVybmFsSW5zdGFuY2VIYW5kbGUsc2hvdWxkV2FybkRldil7cHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSxpbnN0YW5jZSk7Ly8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4vLyBnZXQgYXR0YWNoZWQuXG51cGRhdGVGaWJlclByb3BzKGluc3RhbmNlLHByb3BzKTt2YXIgcGFyZW50TmFtZXNwYWNlO3t2YXIgaG9zdENvbnRleHREZXY9aG9zdENvbnRleHQ7cGFyZW50TmFtZXNwYWNlPWhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTt9Ly8gVE9ETzogVGVtcG9yYXJ5IGhhY2sgdG8gY2hlY2sgaWYgd2UncmUgaW4gYSBjb25jdXJyZW50IHJvb3QuIFdlIGNhbiBkZWxldGVcbi8vIHdoZW4gdGhlIGxlZ2FjeSByb290IEFQSSBpcyByZW1vdmVkLlxudmFyIGlzQ29uY3VycmVudE1vZGU9KGludGVybmFsSW5zdGFuY2VIYW5kbGUubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7cmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsdHlwZSxwcm9wcyxwYXJlbnROYW1lc3BhY2Uscm9vdENvbnRhaW5lckluc3RhbmNlLGlzQ29uY3VycmVudE1vZGUsc2hvdWxkV2FybkRldik7fWZ1bmN0aW9uIGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLHRleHQsaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSxzaG91bGRXYXJuRGV2KXtwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLHRleHRJbnN0YW5jZSk7Ly8gVE9ETzogVGVtcG9yYXJ5IGhhY2sgdG8gY2hlY2sgaWYgd2UncmUgaW4gYSBjb25jdXJyZW50IHJvb3QuIFdlIGNhbiBkZWxldGVcbi8vIHdoZW4gdGhlIGxlZ2FjeSByb290IEFQSSBpcyByZW1vdmVkLlxudmFyIGlzQ29uY3VycmVudE1vZGU9KGludGVybmFsSW5zdGFuY2VIYW5kbGUubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7cmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLHRleHQpO31mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlLGludGVybmFsSW5zdGFuY2VIYW5kbGUpe3ByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsc3VzcGVuc2VJbnN0YW5jZSk7fWZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSl7dmFyIG5vZGU9c3VzcGVuc2VJbnN0YW5jZS5uZXh0U2libGluZzsvLyBTa2lwIHBhc3QgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbi8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxudmFyIGRlcHRoPTA7d2hpbGUobm9kZSl7aWYobm9kZS5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSl7dmFyIGRhdGE9bm9kZS5kYXRhO2lmKGRhdGE9PT1TVVNQRU5TRV9FTkRfREFUQSl7aWYoZGVwdGg9PT0wKXtyZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5vZGUpO31lbHNle2RlcHRoLS07fX1lbHNlIGlmKGRhdGE9PT1TVVNQRU5TRV9TVEFSVF9EQVRBfHxkYXRhPT09U1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQXx8ZGF0YT09PVNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSl7ZGVwdGgrKzt9fW5vZGU9bm9kZS5uZXh0U2libGluZzt9Ly8gVE9ETzogV2Fybiwgd2UgZGlkbid0IGZpbmQgdGhlIGVuZCBjb21tZW50IGJvdW5kYXJ5LlxucmV0dXJuIG51bGw7fS8vIFJldHVybnMgdGhlIFN1c3BlbnNlSW5zdGFuY2UgaWYgdGhpcyBub2RlIGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbi8vIFN1c3BlbnNlSW5zdGFuY2UuIEkuZS4gaWYgaXRzIHByZXZpb3VzIHNpYmxpbmcgaXMgYSBDb21tZW50IHdpdGhcbi8vIFNVU1BFTlNFX3hfU1RBUlRfREFUQS4gT3RoZXJ3aXNlLCBudWxsLlxuZnVuY3Rpb24gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXRJbnN0YW5jZSl7dmFyIG5vZGU9dGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nOy8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4vLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG52YXIgZGVwdGg9MDt3aGlsZShub2RlKXtpZihub2RlLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXt2YXIgZGF0YT1ub2RlLmRhdGE7aWYoZGF0YT09PVNVU1BFTlNFX1NUQVJUX0RBVEF8fGRhdGE9PT1TVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBfHxkYXRhPT09U1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKXtpZihkZXB0aD09PTApe3JldHVybiBub2RlO31lbHNle2RlcHRoLS07fX1lbHNlIGlmKGRhdGE9PT1TVVNQRU5TRV9FTkRfREFUQSl7ZGVwdGgrKzt9fW5vZGU9bm9kZS5wcmV2aW91c1NpYmxpbmc7fXJldHVybiBudWxsO31mdW5jdGlvbiBjb21taXRIeWRyYXRlZENvbnRhaW5lcihjb250YWluZXIpey8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbnJldHJ5SWZCbG9ja2VkT24oY29udGFpbmVyKTt9ZnVuY3Rpb24gY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2Upey8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbnJldHJ5SWZCbG9ja2VkT24oc3VzcGVuc2VJbnN0YW5jZSk7fWZ1bmN0aW9uIHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKHBhcmVudFR5cGUpe3JldHVybiBwYXJlbnRUeXBlIT09J2hlYWQnJiZwYXJlbnRUeXBlIT09J2JvZHknO31mdW5jdGlvbiBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lcix0ZXh0SW5zdGFuY2UsdGV4dCxpc0NvbmN1cnJlbnRNb2RlKXt2YXIgc2hvdWxkV2FybkRldj10cnVlO2NoZWNrRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlLHRleHQsaXNDb25jdXJyZW50TW9kZSxzaG91bGRXYXJuRGV2KTt9ZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLHRleHRJbnN0YW5jZSx0ZXh0LGlzQ29uY3VycmVudE1vZGUpe2lmKHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdIT09dHJ1ZSl7dmFyIHNob3VsZFdhcm5EZXY9dHJ1ZTtjaGVja0ZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLm5vZGVWYWx1ZSx0ZXh0LGlzQ29uY3VycmVudE1vZGUsc2hvdWxkV2FybkRldik7fX1mdW5jdGlvbiBkaWROb3RIeWRyYXRlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyLGluc3RhbmNlKXt7aWYoaW5zdGFuY2Uubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe3dhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLGluc3RhbmNlKTt9ZWxzZSBpZihpbnN0YW5jZS5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSk7ZWxzZXt3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lcixpbnN0YW5jZSk7fX19ZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSxpbnN0YW5jZSl7ey8vICRGbG93Rml4TWU6IE9ubHkgRWxlbWVudCBvciBEb2N1bWVudCBjYW4gYmUgcGFyZW50IG5vZGVzLlxudmFyIHBhcmVudE5vZGU9cGFyZW50SW5zdGFuY2UucGFyZW50Tm9kZTtpZihwYXJlbnROb2RlIT09bnVsbCl7aWYoaW5zdGFuY2Uubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe3dhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Tm9kZSxpbnN0YW5jZSk7fWVsc2UgaWYoaW5zdGFuY2Uubm9kZVR5cGU9PT1DT01NRU5UX05PREUpO2Vsc2V7d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnROb2RlLGluc3RhbmNlKTt9fX19ZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUscGFyZW50UHJvcHMscGFyZW50SW5zdGFuY2UsaW5zdGFuY2UsaXNDb25jdXJyZW50TW9kZSl7e2lmKGlzQ29uY3VycmVudE1vZGV8fHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdIT09dHJ1ZSl7aWYoaW5zdGFuY2Uubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe3dhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsaW5zdGFuY2UpO31lbHNlIGlmKGluc3RhbmNlLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKTtlbHNle3dhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsaW5zdGFuY2UpO319fX1mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcix0eXBlLHByb3BzKXt7d2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudENvbnRhaW5lcix0eXBlKTt9fWZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcix0ZXh0KXt7d2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudENvbnRhaW5lcix0ZXh0KTt9fWZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHBhcmVudEluc3RhbmNlLHR5cGUscHJvcHMpe3svLyAkRmxvd0ZpeE1lOiBPbmx5IEVsZW1lbnQgb3IgRG9jdW1lbnQgY2FuIGJlIHBhcmVudCBub2Rlcy5cbnZhciBwYXJlbnROb2RlPXBhcmVudEluc3RhbmNlLnBhcmVudE5vZGU7aWYocGFyZW50Tm9kZSE9PW51bGwpd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudE5vZGUsdHlwZSk7fX1mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UsdGV4dCl7ey8vICRGbG93Rml4TWU6IE9ubHkgRWxlbWVudCBvciBEb2N1bWVudCBjYW4gYmUgcGFyZW50IG5vZGVzLlxudmFyIHBhcmVudE5vZGU9cGFyZW50SW5zdGFuY2UucGFyZW50Tm9kZTtpZihwYXJlbnROb2RlIT09bnVsbCl3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSx0ZXh0KTt9fWZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSxwYXJlbnRQcm9wcyxwYXJlbnRJbnN0YW5jZSx0eXBlLHByb3BzLGlzQ29uY3VycmVudE1vZGUpe3tpZihpc0NvbmN1cnJlbnRNb2RlfHxwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSE9PXRydWUpe3dhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRJbnN0YW5jZSx0eXBlKTt9fX1mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLHRleHQsaXNDb25jdXJyZW50TW9kZSl7e2lmKGlzQ29uY3VycmVudE1vZGV8fHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdIT09dHJ1ZSl7d2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLHRleHQpO319fWZ1bmN0aW9uIGVycm9ySHlkcmF0aW5nQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcil7ey8vIFRPRE86IFRoaXMgZ2V0cyBsb2dnZWQgYnkgb25SZWNvdmVyYWJsZUVycm9yLCB0b28sIHNvIHdlIHNob3VsZCBiZVxuLy8gYWJsZSB0byByZW1vdmUgaXQuXG5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVGhlIHNlcnZlciBIVE1MIHdhcyByZXBsYWNlZCB3aXRoIGNsaWVudCBjb250ZW50IGluIDwlcz4uJyxwYXJlbnRDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7fX1mdW5jdGlvbiBwcmVwYXJlUG9ydGFsTW91bnQocG9ydGFsSW5zdGFuY2Upe2xpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHBvcnRhbEluc3RhbmNlKTt9dmFyIHJhbmRvbUtleT1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTt2YXIgaW50ZXJuYWxJbnN0YW5jZUtleT0nX19yZWFjdEZpYmVyJCcrcmFuZG9tS2V5O3ZhciBpbnRlcm5hbFByb3BzS2V5PSdfX3JlYWN0UHJvcHMkJytyYW5kb21LZXk7dmFyIGludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXk9J19fcmVhY3RDb250YWluZXIkJytyYW5kb21LZXk7dmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleT0nX19yZWFjdEV2ZW50cyQnK3JhbmRvbUtleTt2YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXk9J19fcmVhY3RMaXN0ZW5lcnMkJytyYW5kb21LZXk7dmFyIGludGVybmFsRXZlbnRIYW5kbGVzU2V0S2V5PSdfX3JlYWN0SGFuZGxlcyQnK3JhbmRvbUtleTtmdW5jdGlvbiBkZXRhY2hEZWxldGVkSW5zdGFuY2Uobm9kZSl7Ly8gVE9ETzogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBvbiBob3N0IGNvbXBvbmVudHMuIEkgZG9uJ3QgdGhpbmsgYWxsIG9mXG4vLyB0aGVzZSBmaWVsZHMgYXJlIHJlbGV2YW50LlxuZGVsZXRlIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07ZGVsZXRlIG5vZGVbaW50ZXJuYWxQcm9wc0tleV07ZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XTtkZWxldGUgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlckxpc3RlbmVyc0tleV07ZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXNTZXRLZXldO31mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZShob3N0SW5zdCxub2RlKXtub2RlW2ludGVybmFsSW5zdGFuY2VLZXldPWhvc3RJbnN0O31mdW5jdGlvbiBtYXJrQ29udGFpbmVyQXNSb290KGhvc3RSb290LG5vZGUpe25vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV09aG9zdFJvb3Q7fWZ1bmN0aW9uIHVubWFya0NvbnRhaW5lckFzUm9vdChub2RlKXtub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldPW51bGw7fWZ1bmN0aW9uIGlzQ29udGFpbmVyTWFya2VkQXNSb290KG5vZGUpe3JldHVybiEhbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XTt9Ly8gR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IEhvc3RDb21wb25lbnQgb3IgSG9zdFRleHQgZmliZXIgYW5jZXN0b3IuXG4vLyBJZiB0aGUgdGFyZ2V0IG5vZGUgaXMgcGFydCBvZiBhIGh5ZHJhdGVkIG9yIG5vdCB5ZXQgcmVuZGVyZWQgc3VidHJlZSwgdGhlblxuLy8gdGhpcyBtYXkgYWxzbyByZXR1cm4gYSBTdXNwZW5zZUNvbXBvbmVudCBvciBIb3N0Um9vdCB0byBpbmRpY2F0ZSB0aGF0LlxuLy8gQ29uY2VwdHVhbGx5IHRoZSBIb3N0Um9vdCBmaWJlciBpcyBhIGNoaWxkIG9mIHRoZSBDb250YWluZXIgbm9kZS4gU28gaWYgeW91XG4vLyBwYXNzIHRoZSBDb250YWluZXIgbm9kZSBhcyB0aGUgdGFyZ2V0Tm9kZSwgeW91IHdpbGwgbm90IGFjdHVhbGx5IGdldCB0aGVcbi8vIEhvc3RSb290IGJhY2suIFRvIGdldCB0byB0aGUgSG9zdFJvb3QsIHlvdSBuZWVkIHRvIHBhc3MgYSBjaGlsZCBvZiBpdC5cbi8vIFRoZSBzYW1lIHRoaW5nIGFwcGxpZXMgdG8gU3VzcGVuc2UgYm91bmRhcmllcy5cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHRhcmdldE5vZGUpe3ZhciB0YXJnZXRJbnN0PXRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07aWYodGFyZ2V0SW5zdCl7Ly8gRG9uJ3QgcmV0dXJuIEhvc3RSb290IG9yIFN1c3BlbnNlQ29tcG9uZW50IGhlcmUuXG5yZXR1cm4gdGFyZ2V0SW5zdDt9Ly8gSWYgdGhlIGRpcmVjdCBldmVudCB0YXJnZXQgaXNuJ3QgYSBSZWFjdCBvd25lZCBET00gbm9kZSwgd2UgbmVlZCB0byBsb29rXG4vLyB0byBzZWUgaWYgb25lIG9mIGl0cyBwYXJlbnRzIGlzIGEgUmVhY3Qgb3duZWQgRE9NIG5vZGUuXG52YXIgcGFyZW50Tm9kZT10YXJnZXROb2RlLnBhcmVudE5vZGU7d2hpbGUocGFyZW50Tm9kZSl7Ly8gV2UnbGwgY2hlY2sgaWYgdGhpcyBpcyBhIGNvbnRhaW5lciByb290IHRoYXQgY291bGQgaW5jbHVkZVxuLy8gUmVhY3Qgbm9kZXMgaW4gdGhlIGZ1dHVyZS4gV2UgbmVlZCB0byBjaGVjayB0aGlzIGZpcnN0IGJlY2F1c2Vcbi8vIGlmIHdlJ3JlIGEgY2hpbGQgb2YgYSBkZWh5ZHJhdGVkIGNvbnRhaW5lciwgd2UgbmVlZCB0byBmaXJzdFxuLy8gZmluZCB0aGF0IGlubmVyIGNvbnRhaW5lciBiZWZvcmUgbW92aW5nIG9uIHRvIGZpbmRpbmcgdGhlIHBhcmVudFxuLy8gaW5zdGFuY2UuIE5vdGUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGlzIGZpZWxkIG9uICB0aGUgdGFyZ2V0Tm9kZVxuLy8gaXRzZWxmIGJlY2F1c2UgdGhlIGZpYmVycyBhcmUgY29uY2VwdHVhbGx5IGJldHdlZW4gdGhlIGNvbnRhaW5lclxuLy8gbm9kZSBhbmQgdGhlIGZpcnN0IGNoaWxkLiBJdCBpc24ndCBzdXJyb3VuZGluZyB0aGUgY29udGFpbmVyIG5vZGUuXG4vLyBJZiBpdCdzIG5vdCBhIGNvbnRhaW5lciwgd2UgY2hlY2sgaWYgaXQncyBhbiBpbnN0YW5jZS5cbnRhcmdldEluc3Q9cGFyZW50Tm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XXx8cGFyZW50Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtpZih0YXJnZXRJbnN0KXsvLyBTaW5jZSB0aGlzIHdhc24ndCB0aGUgZGlyZWN0IHRhcmdldCBvZiB0aGUgZXZlbnQsIHdlIG1pZ2h0IGhhdmVcbi8vIHN0ZXBwZWQgcGFzdCBkZWh5ZHJhdGVkIERPTSBub2RlcyB0byBnZXQgaGVyZS4gSG93ZXZlciB0aGV5IGNvdWxkXG4vLyBhbHNvIGhhdmUgYmVlbiBub24tUmVhY3Qgbm9kZXMuIFdlIG5lZWQgdG8gYW5zd2VyIHdoaWNoIG9uZS5cbi8vIElmIHdlIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGhhdmUgYW55IGNoaWxkcmVuLCB0aGVuIHRoZXJlIGNhbid0IGJlXG4vLyBhIG5lc3RlZCBzdXNwZW5zZSBib3VuZGFyeSB3aXRoaW4gaXQuIFNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGZhc3Rcbi8vIGJhaWxvdXQuIE1vc3Qgb2YgdGhlIHRpbWUsIHdoZW4gcGVvcGxlIGFkZCBub24tUmVhY3QgY2hpbGRyZW4gdG9cbi8vIHRoZSB0cmVlLCBpdCBpcyB1c2luZyBhIHJlZiB0byBhIGNoaWxkLWxlc3MgRE9NIG5vZGUuXG4vLyBOb3JtYWxseSB3ZSdkIG9ubHkgbmVlZCB0byBjaGVjayBvbmUgb2YgdGhlIGZpYmVycyBiZWNhdXNlIGlmIGl0XG4vLyBoYXMgZXZlciBnb25lIGZyb20gaGF2aW5nIGNoaWxkcmVuIHRvIGRlbGV0aW5nIHRoZW0gb3IgdmljZSB2ZXJzYVxuLy8gaXQgd291bGQgaGF2ZSBkZWxldGVkIHRoZSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IG5lc3RlZCBpbnNpZGUgYWxyZWFkeS5cbi8vIEhvd2V2ZXIsIHNpbmNlIHRoZSBIb3N0Um9vdCBzdGFydHMgb3V0IHdpdGggYW4gYWx0ZXJuYXRlIGl0IG1pZ2h0XG4vLyBoYXZlIG9uZSBvbiB0aGUgYWx0ZXJuYXRlIHNvIHdlIG5lZWQgdG8gY2hlY2sgaW4gY2FzZSB0aGlzIHdhcyBhXG4vLyByb290LlxudmFyIGFsdGVybmF0ZT10YXJnZXRJbnN0LmFsdGVybmF0ZTtpZih0YXJnZXRJbnN0LmNoaWxkIT09bnVsbHx8YWx0ZXJuYXRlIT09bnVsbCYmYWx0ZXJuYXRlLmNoaWxkIT09bnVsbCl7Ly8gTmV4dCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlIG5vZGUgdGhhdCBza2lwcGVkIHBhc3QgaXNcbi8vIG5lc3RlZCB3aXRoaW4gYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGFuZCBpZiBzbywgd2hpY2ggb25lLlxudmFyIHN1c3BlbnNlSW5zdGFuY2U9Z2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTt3aGlsZShzdXNwZW5zZUluc3RhbmNlIT09bnVsbCl7Ly8gV2UgZm91bmQgYSBzdXNwZW5zZSBpbnN0YW5jZS4gVGhhdCBtZWFucyB0aGF0IHdlIGhhdmVuJ3Rcbi8vIGh5ZHJhdGVkIGl0IHlldC4gRXZlbiB0aG91Z2ggd2UgbGVhdmUgdGhlIGNvbW1lbnRzIGluIHRoZVxuLy8gRE9NIGFmdGVyIGh5ZHJhdGluZywgYW5kIHRoZXJlIGFyZSBib3VuZGFyaWVzIGluIHRoZSBET01cbi8vIHRoYXQgY291bGQgYWxyZWFkeSBiZSBoeWRyYXRlZCwgd2Ugd291bGRuJ3QgaGF2ZSBmb3VuZCB0aGVtXG4vLyB0aHJvdWdoIHRoaXMgcGFzcyBzaW5jZSBpZiB0aGUgdGFyZ2V0IGlzIGh5ZHJhdGVkIGl0IHdvdWxkXG4vLyBoYXZlIGhhZCBhbiBpbnRlcm5hbEluc3RhbmNlS2V5IG9uIGl0LlxuLy8gTGV0J3MgZ2V0IHRoZSBmaWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIFN1c3BlbnNlQ29tcG9uZW50XG4vLyBhcyB0aGUgZGVlcGVzdCBpbnN0YW5jZS5cbnZhciB0YXJnZXRTdXNwZW5zZUluc3Q9c3VzcGVuc2VJbnN0YW5jZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtpZih0YXJnZXRTdXNwZW5zZUluc3Qpe3JldHVybiB0YXJnZXRTdXNwZW5zZUluc3Q7fS8vIElmIHdlIGRvbid0IGZpbmQgYSBGaWJlciBvbiB0aGUgY29tbWVudCwgaXQgbWlnaHQgYmUgYmVjYXVzZVxuLy8gd2UgaGF2ZW4ndCBnb3R0ZW4gdG8gaHlkcmF0ZSBpdCB5ZXQuIFRoZXJlIG1pZ2h0IHN0aWxsIGJlIGFcbi8vIHBhcmVudCBib3VuZGFyeSB0aGF0IGhhc24ndCBhYm92ZSB0aGlzIG9uZSBzbyB3ZSBuZWVkIHRvIGZpbmRcbi8vIHRoZSBvdXRlciBtb3N0IHRoYXQgaXMga25vd24uXG5zdXNwZW5zZUluc3RhbmNlPWdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7Ly8gSWYgd2UgZG9uJ3QgZmluZCBvbmUsIHRoZW4gdGhhdCBzaG91bGQgbWVhbiB0aGF0IHRoZSBwYXJlbnRcbi8vIGhvc3QgY29tcG9uZW50IGFsc28gaGFzbid0IGh5ZHJhdGVkIHlldC4gV2UgY2FuIHJldHVybiBpdFxuLy8gYmVsb3cgc2luY2UgaXQgd2lsbCBiYWlsIG91dCBvbiB0aGUgaXNNb3VudGVkIGNoZWNrIGxhdGVyLlxufX1yZXR1cm4gdGFyZ2V0SW5zdDt9dGFyZ2V0Tm9kZT1wYXJlbnROb2RlO3BhcmVudE5vZGU9dGFyZ2V0Tm9kZS5wYXJlbnROb2RlO31yZXR1cm4gbnVsbDt9LyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKXt2YXIgaW5zdD1ub2RlW2ludGVybmFsSW5zdGFuY2VLZXldfHxub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldO2lmKGluc3Qpe2lmKGluc3QudGFnPT09SG9zdENvbXBvbmVudHx8aW5zdC50YWc9PT1Ib3N0VGV4dHx8aW5zdC50YWc9PT1TdXNwZW5zZUNvbXBvbmVudHx8aW5zdC50YWc9PT1Ib3N0Um9vdCl7cmV0dXJuIGluc3Q7fWVsc2V7cmV0dXJuIG51bGw7fX1yZXR1cm4gbnVsbDt9LyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL2Z1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCl7aWYoaW5zdC50YWc9PT1Ib3N0Q29tcG9uZW50fHxpbnN0LnRhZz09PUhvc3RUZXh0KXsvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbi8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxucmV0dXJuIGluc3Quc3RhdGVOb2RlO30vLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbi8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxudGhyb3cgbmV3IEVycm9yKCdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpO31mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG5vZGUpe3JldHVybiBub2RlW2ludGVybmFsUHJvcHNLZXldfHxudWxsO31mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzKG5vZGUscHJvcHMpe25vZGVbaW50ZXJuYWxQcm9wc0tleV09cHJvcHM7fWZ1bmN0aW9uIGdldEV2ZW50TGlzdGVuZXJTZXQobm9kZSl7dmFyIGVsZW1lbnRMaXN0ZW5lclNldD1ub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07aWYoZWxlbWVudExpc3RlbmVyU2V0PT09dW5kZWZpbmVkKXtlbGVtZW50TGlzdGVuZXJTZXQ9bm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldPW5ldyBTZXQoKTt9cmV0dXJuIGVsZW1lbnRMaXN0ZW5lclNldDt9dmFyIGxvZ2dlZFR5cGVGYWlsdXJlcz17fTt2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7ZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCl7e2lmKGVsZW1lbnQpe3ZhciBvd25lcj1lbGVtZW50Ll9vd25lcjt2YXIgc3RhY2s9ZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSxlbGVtZW50Ll9zb3VyY2Usb3duZXI/b3duZXIudHlwZTpudWxsKTtSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTt9ZWxzZXtSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO319fWZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcyx2YWx1ZXMsbG9jYXRpb24sY29tcG9uZW50TmFtZSxlbGVtZW50KXt7Ly8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxudmFyIGhhcz1GdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO2Zvcih2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcyl7aWYoaGFzKHR5cGVTcGVjcyx0eXBlU3BlY05hbWUpKXt2YXIgZXJyb3IkMT12b2lkIDA7Ly8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbi8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbi8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbnRyeXsvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbi8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbmlmKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSE9PSdmdW5jdGlvbicpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG52YXIgZXJyPUVycm9yKChjb21wb25lbnROYW1lfHwnUmVhY3QgY2xhc3MnKSsnOiAnK2xvY2F0aW9uKycgdHlwZSBgJyt0eXBlU3BlY05hbWUrJ2AgaXMgaW52YWxpZDsgJysnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcrdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKydgLicrJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO2Vyci5uYW1lPSdJbnZhcmlhbnQgVmlvbGF0aW9uJzt0aHJvdyBlcnI7fWVycm9yJDE9dHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLHR5cGVTcGVjTmFtZSxjb21wb25lbnROYW1lLGxvY2F0aW9uLG51bGwsJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7fWNhdGNoKGV4KXtlcnJvciQxPWV4O31pZihlcnJvciQxJiYhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpe3NldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO2Vycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJysnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnKydmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJysnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJysnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnKydzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJyxjb21wb25lbnROYW1lfHwnUmVhY3QgY2xhc3MnLGxvY2F0aW9uLHR5cGVTcGVjTmFtZSx0eXBlb2YgZXJyb3IkMSk7c2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7fWlmKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciYmIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSl7Ly8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4vLyBzYW1lIGVycm9yLlxubG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV09dHJ1ZTtzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJyxsb2NhdGlvbixlcnJvciQxLm1lc3NhZ2UpO3NldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO319fX19dmFyIHZhbHVlU3RhY2s9W107dmFyIGZpYmVyU3RhY2s7e2ZpYmVyU3RhY2s9W107fXZhciBpbmRleD0tMTtmdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKXtyZXR1cm57Y3VycmVudDpkZWZhdWx0VmFsdWV9O31mdW5jdGlvbiBwb3AoY3Vyc29yLGZpYmVyKXtpZihpbmRleDwwKXt7ZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO31yZXR1cm47fXtpZihmaWJlciE9PWZpYmVyU3RhY2tbaW5kZXhdKXtlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7fX1jdXJzb3IuY3VycmVudD12YWx1ZVN0YWNrW2luZGV4XTt2YWx1ZVN0YWNrW2luZGV4XT1udWxsO3tmaWJlclN0YWNrW2luZGV4XT1udWxsO31pbmRleC0tO31mdW5jdGlvbiBwdXNoKGN1cnNvcix2YWx1ZSxmaWJlcil7aW5kZXgrKzt2YWx1ZVN0YWNrW2luZGV4XT1jdXJzb3IuY3VycmVudDt7ZmliZXJTdGFja1tpbmRleF09ZmliZXI7fWN1cnNvci5jdXJyZW50PXZhbHVlO312YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O3t3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQ9e307fXZhciBlbXB0eUNvbnRleHRPYmplY3Q9e307e09iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTt9Ly8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3I9Y3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7Ly8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yPWNyZWF0ZUN1cnNvcihmYWxzZSk7Ly8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxudmFyIHByZXZpb3VzQ29udGV4dD1lbXB0eUNvbnRleHRPYmplY3Q7ZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIpe3tpZihkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXImJmlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpey8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbi8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4vLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbnJldHVybiBwcmV2aW91c0NvbnRleHQ7fXJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDt9fWZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQsbWFza2VkQ29udGV4dCl7e3ZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD11bm1hc2tlZENvbnRleHQ7aW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9bWFza2VkQ29udGV4dDt9fWZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsdW5tYXNrZWRDb250ZXh0KXt7dmFyIHR5cGU9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgY29udGV4dFR5cGVzPXR5cGUuY29udGV4dFR5cGVzO2lmKCFjb250ZXh0VHlwZXMpe3JldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7fS8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4vLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbi8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cbnZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aWYoaW5zdGFuY2UmJmluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT11bm1hc2tlZENvbnRleHQpe3JldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDt9dmFyIGNvbnRleHQ9e307Zm9yKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKXtjb250ZXh0W2tleV09dW5tYXNrZWRDb250ZXh0W2tleV07fXt2YXIgbmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKXx8J1Vua25vd24nO2NoZWNrUHJvcFR5cGVzKGNvbnRleHRUeXBlcyxjb250ZXh0LCdjb250ZXh0JyxuYW1lKTt9Ly8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG5pZihpbnN0YW5jZSl7Y2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLHVubWFza2VkQ29udGV4dCxjb250ZXh0KTt9cmV0dXJuIGNvbnRleHQ7fX1mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpe3tyZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O319ZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSl7e3ZhciBjaGlsZENvbnRleHRUeXBlcz10eXBlLmNoaWxkQ29udGV4dFR5cGVzO3JldHVybiBjaGlsZENvbnRleHRUeXBlcyE9PW51bGwmJmNoaWxkQ29udGV4dFR5cGVzIT09dW5kZWZpbmVkO319ZnVuY3Rpb24gcG9wQ29udGV4dChmaWJlcil7e3BvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLGZpYmVyKTtwb3AoY29udGV4dFN0YWNrQ3Vyc29yLGZpYmVyKTt9fWZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcil7e3BvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLGZpYmVyKTtwb3AoY29udGV4dFN0YWNrQ3Vyc29yLGZpYmVyKTt9fWZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsY29udGV4dCxkaWRDaGFuZ2Upe3tpZihjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCE9PWVtcHR5Q29udGV4dE9iamVjdCl7dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suICcrJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXB1c2goY29udGV4dFN0YWNrQ3Vyc29yLGNvbnRleHQsZmliZXIpO3B1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcixkaWRDaGFuZ2UsZmliZXIpO319ZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlcix0eXBlLHBhcmVudENvbnRleHQpe3t2YXIgaW5zdGFuY2U9ZmliZXIuc3RhdGVOb2RlO3ZhciBjaGlsZENvbnRleHRUeXBlcz10eXBlLmNoaWxkQ29udGV4dFR5cGVzOy8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4vLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG5pZih0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0IT09J2Z1bmN0aW9uJyl7e3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnVW5rbm93bic7aWYoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSl7d2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdPXRydWU7ZXJyb3IoJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcrJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnKydjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsY29tcG9uZW50TmFtZSxjb21wb25lbnROYW1lKTt9fXJldHVybiBwYXJlbnRDb250ZXh0O312YXIgY2hpbGRDb250ZXh0PWluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO2Zvcih2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpe2lmKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpe3Rocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdVbmtub3duJykrXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIrY29udGV4dEtleStcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIpO319e3ZhciBuYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnVW5rbm93bic7Y2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsY2hpbGRDb250ZXh0LCdjaGlsZCBjb250ZXh0JyxuYW1lKTt9cmV0dXJuIGFzc2lnbih7fSxwYXJlbnRDb250ZXh0LGNoaWxkQ29udGV4dCk7fX1mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKXt7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4vLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbi8vIGFuZCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBsYXRlciB3aGVuIGludmFsaWRhdGluZyB0aGUgY29udGV4dC5cbnZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1pbnN0YW5jZSYmaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fGVtcHR5Q29udGV4dE9iamVjdDsvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4vLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cbnByZXZpb3VzQ29udGV4dD1jb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtwdXNoKGNvbnRleHRTdGFja0N1cnNvcixtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCx3b3JrSW5Qcm9ncmVzcyk7cHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIHRydWU7fX1mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLHR5cGUsZGlkQ2hhbmdlKXt7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtpZighaW5zdGFuY2Upe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31pZihkaWRDaGFuZ2Upey8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4vLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4vLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbnZhciBtZXJnZWRDb250ZXh0PXByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsdHlwZSxwcmV2aW91c0NvbnRleHQpO2luc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0PW1lcmdlZENvbnRleHQ7Ly8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbnBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLHdvcmtJblByb2dyZXNzKTtwb3AoY29udGV4dFN0YWNrQ3Vyc29yLHdvcmtJblByb2dyZXNzKTsvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbnB1c2goY29udGV4dFN0YWNrQ3Vyc29yLG1lcmdlZENvbnRleHQsd29ya0luUHJvZ3Jlc3MpO3B1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcixkaWRDaGFuZ2Usd29ya0luUHJvZ3Jlc3MpO31lbHNle3BvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLHdvcmtJblByb2dyZXNzKTtwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsZGlkQ2hhbmdlLHdvcmtJblByb2dyZXNzKTt9fX1mdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcil7ey8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuLy8gbWFrZXMgc2Vuc2UgZWxzZXdoZXJlXG5pZighaXNGaWJlck1vdW50ZWQoZmliZXIpfHxmaWJlci50YWchPT1DbGFzc0NvbXBvbmVudCl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO312YXIgbm9kZT1maWJlcjtkb3tzd2l0Y2gobm9kZS50YWcpe2Nhc2UgSG9zdFJvb3Q6cmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIENvbXBvbmVudD1ub2RlLnR5cGU7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7cmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O31icmVhazt9fW5vZGU9bm9kZS5yZXR1cm47fXdoaWxlKG5vZGUhPT1udWxsKTt0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuICcrJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX12YXIgTGVnYWN5Um9vdD0wO3ZhciBDb25jdXJyZW50Um9vdD0xO3ZhciBzeW5jUXVldWU9bnVsbDt2YXIgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzPWZhbHNlO3ZhciBpc0ZsdXNoaW5nU3luY1F1ZXVlPWZhbHNlO2Z1bmN0aW9uIHNjaGVkdWxlU3luY0NhbGxiYWNrKGNhbGxiYWNrKXsvLyBQdXNoIHRoaXMgY2FsbGJhY2sgaW50byBhbiBpbnRlcm5hbCBxdWV1ZS4gV2UnbGwgZmx1c2ggdGhlc2UgZWl0aGVyIGluXG4vLyB0aGUgbmV4dCB0aWNrLCBvciBlYXJsaWVyIGlmIHNvbWV0aGluZyBjYWxscyBgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZWAuXG5pZihzeW5jUXVldWU9PT1udWxsKXtzeW5jUXVldWU9W2NhbGxiYWNrXTt9ZWxzZXsvLyBQdXNoIG9udG8gZXhpc3RpbmcgcXVldWUuIERvbid0IG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFjayBiZWNhdXNlXG4vLyB3ZSBhbHJlYWR5IHNjaGVkdWxlZCBvbmUgd2hlbiB3ZSBjcmVhdGVkIHRoZSBxdWV1ZS5cbnN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTt9fWZ1bmN0aW9uIHNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrKGNhbGxiYWNrKXtpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3M9dHJ1ZTtzY2hlZHVsZVN5bmNDYWxsYmFjayhjYWxsYmFjayk7fWZ1bmN0aW9uIGZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUoKXsvLyBPbmx5IGZsdXNoZXMgdGhlIHF1ZXVlIGlmIHRoZXJlJ3MgYSBsZWdhY3kgc3luYyBjYWxsYmFjayBzY2hlZHVsZWQuXG4vLyBUT0RPOiBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgdHlwZSBvZiBjYWxsYmFjazogcGVyZm9ybVN5bmNPbldvcmtPblJvb3QuIFNvXG4vLyBpdCBtaWdodCBtYWtlIG1vcmUgc2Vuc2UgZm9yIHRoZSBxdWV1ZSB0byBiZSBhIGxpc3Qgb2Ygcm9vdHMgaW5zdGVhZCBvZiBhXG4vLyBsaXN0IG9mIGdlbmVyaWMgY2FsbGJhY2tzLiBUaGVuIHdlIGNhbiBoYXZlIHR3bzogb25lIGZvciBsZWdhY3kgcm9vdHMsIG9uZVxuLy8gZm9yIGNvbmN1cnJlbnQgcm9vdHMuIEFuZCB0aGlzIG1ldGhvZCB3b3VsZCBvbmx5IGZsdXNoIHRoZSBsZWdhY3kgb25lcy5cbmlmKGluY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcyl7Zmx1c2hTeW5jQ2FsbGJhY2tzKCk7fX1mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja3MoKXtpZighaXNGbHVzaGluZ1N5bmNRdWV1ZSYmc3luY1F1ZXVlIT09bnVsbCl7Ly8gUHJldmVudCByZS1lbnRyYW5jZS5cbmlzRmx1c2hpbmdTeW5jUXVldWU9dHJ1ZTt2YXIgaT0wO3ZhciBwcmV2aW91c1VwZGF0ZVByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3RyeXt2YXIgaXNTeW5jPXRydWU7dmFyIHF1ZXVlPXN5bmNRdWV1ZTsvLyBUT0RPOiBJcyB0aGlzIG5lY2Vzc2FyeSBhbnltb3JlPyBUaGUgb25seSB1c2VyIGNvZGUgdGhhdCBydW5zIGluIHRoaXNcbi8vIHF1ZXVlIGlzIGluIHRoZSByZW5kZXIgb3IgY29tbWl0IHBoYXNlcy5cbnNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO2Zvcig7aTxxdWV1ZS5sZW5ndGg7aSsrKXt2YXIgY2FsbGJhY2s9cXVldWVbaV07ZG97Y2FsbGJhY2s9Y2FsbGJhY2soaXNTeW5jKTt9d2hpbGUoY2FsbGJhY2shPT1udWxsKTt9c3luY1F1ZXVlPW51bGw7aW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzPWZhbHNlO31jYXRjaChlcnJvcil7Ly8gSWYgc29tZXRoaW5nIHRocm93cywgbGVhdmUgdGhlIHJlbWFpbmluZyBjYWxsYmFja3Mgb24gdGhlIHF1ZXVlLlxuaWYoc3luY1F1ZXVlIT09bnVsbCl7c3luY1F1ZXVlPXN5bmNRdWV1ZS5zbGljZShpKzEpO30vLyBSZXN1bWUgZmx1c2hpbmcgaW4gdGhlIG5leHQgdGlja1xuc2NoZWR1bGVDYWxsYmFjayhJbW1lZGlhdGVQcmlvcml0eSxmbHVzaFN5bmNDYWxsYmFja3MpO3Rocm93IGVycm9yO31maW5hbGx5e3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZVByaW9yaXR5KTtpc0ZsdXNoaW5nU3luY1F1ZXVlPWZhbHNlO319cmV0dXJuIG51bGw7fS8vIFRPRE86IFVzZSB0aGUgdW5pZmllZCBmaWJlciBzdGFjayBtb2R1bGUgaW5zdGVhZCBvZiB0aGlzIGxvY2FsIG9uZT9cbi8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGl0IHlldCB0byBkZXJpc2sgdGhlIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIGJlY2F1c2Vcbi8vIHRoZSB3YXkgd2UgcHVzaC9wb3AgdGhlc2UgdmFsdWVzIGlzIGEgYml0IHVudXN1YWwuIElmIHRoZXJlJ3MgYSBtaXN0YWtlLCBJJ2Rcbi8vIHJhdGhlciB0aGUgaWRzIGJlIHdyb25nIHRoYW4gY3Jhc2ggdGhlIHdob2xlIHJlY29uY2lsZXIuXG52YXIgZm9ya1N0YWNrPVtdO3ZhciBmb3JrU3RhY2tJbmRleD0wO3ZhciB0cmVlRm9ya1Byb3ZpZGVyPW51bGw7dmFyIHRyZWVGb3JrQ291bnQ9MDt2YXIgaWRTdGFjaz1bXTt2YXIgaWRTdGFja0luZGV4PTA7dmFyIHRyZWVDb250ZXh0UHJvdmlkZXI9bnVsbDt2YXIgdHJlZUNvbnRleHRJZD0xO3ZhciB0cmVlQ29udGV4dE92ZXJmbG93PScnO2Z1bmN0aW9uIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3Mpe3dhcm5JZk5vdEh5ZHJhdGluZygpO3JldHVybih3b3JrSW5Qcm9ncmVzcy5mbGFncyZGb3JrZWQpIT09Tm9GbGFnczt9ZnVuY3Rpb24gZ2V0Rm9ya3NBdExldmVsKHdvcmtJblByb2dyZXNzKXt3YXJuSWZOb3RIeWRyYXRpbmcoKTtyZXR1cm4gdHJlZUZvcmtDb3VudDt9ZnVuY3Rpb24gZ2V0VHJlZUlkKCl7dmFyIG92ZXJmbG93PXRyZWVDb250ZXh0T3ZlcmZsb3c7dmFyIGlkV2l0aExlYWRpbmdCaXQ9dHJlZUNvbnRleHRJZDt2YXIgaWQ9aWRXaXRoTGVhZGluZ0JpdCZ+Z2V0TGVhZGluZ0JpdChpZFdpdGhMZWFkaW5nQml0KTtyZXR1cm4gaWQudG9TdHJpbmcoMzIpK292ZXJmbG93O31mdW5jdGlvbiBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsdG90YWxDaGlsZHJlbil7Ly8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgd2UgcmVjb25jaWxlIGFuIGFycmF5IChvciBpdGVyYXRvcikgb2YgY2hpbGRcbi8vIGZpYmVycywgYmVjYXVzZSB0aGF0J3MgdGhlIG9ubHkgcGxhY2Ugd2hlcmUgd2Uga25vdyBob3cgbWFueSBjaGlsZHJlbiBpblxuLy8gdGhlIHdob2xlIHNldCB3aXRob3V0IGRvaW5nIGV4dHJhIHdvcmsgbGF0ZXIsIG9yIHN0b3JpbmcgYWRkdGlvbmFsXG4vLyBpbmZvcm1hdGlvbiBvbiB0aGUgZmliZXIuXG4vL1xuLy8gVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGlzIHNlcGFyYXRlIGZyb20gcHVzaFRyZWVJZCDigJQgaXQncyBjYWxsZWQgZHVyaW5nXG4vLyB0aGUgcmVuZGVyIHBoYXNlIG9mIHRoZSBmb3JrIHBhcmVudCwgbm90IHRoZSBjaGlsZCwgd2hpY2ggaXMgd2hlcmUgd2UgcHVzaFxuLy8gdGhlIG90aGVyIGNvbnRleHQgdmFsdWVzLlxuLy9cbi8vIEluIHRoZSBGaXp6IGltcGxlbWVudGF0aW9uIHRoaXMgaXMgbXVjaCBzaW1wbGVyIGJlY2F1c2UgdGhlIGNoaWxkIGlzXG4vLyByZW5kZXJlZCBpbiB0aGUgc2FtZSBjYWxsc3RhY2sgYXMgdGhlIHBhcmVudC5cbi8vXG4vLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCBhZGQgYSBgZm9ya3NgIGZpZWxkIHRvIHRoZSBGaWJlciB0eXBlLiBJdCB3b3VsZFxuLy8gbWFrZSB0aGlzIG1vZHVsZSBzaW1wbGVyLlxud2FybklmTm90SHlkcmF0aW5nKCk7Zm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdPXRyZWVGb3JrQ291bnQ7Zm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdPXRyZWVGb3JrUHJvdmlkZXI7dHJlZUZvcmtQcm92aWRlcj13b3JrSW5Qcm9ncmVzczt0cmVlRm9ya0NvdW50PXRvdGFsQ2hpbGRyZW47fWZ1bmN0aW9uIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsdG90YWxDaGlsZHJlbixpbmRleCl7d2FybklmTm90SHlkcmF0aW5nKCk7aWRTdGFja1tpZFN0YWNrSW5kZXgrK109dHJlZUNvbnRleHRJZDtpZFN0YWNrW2lkU3RhY2tJbmRleCsrXT10cmVlQ29udGV4dE92ZXJmbG93O2lkU3RhY2tbaWRTdGFja0luZGV4KytdPXRyZWVDb250ZXh0UHJvdmlkZXI7dHJlZUNvbnRleHRQcm92aWRlcj13b3JrSW5Qcm9ncmVzczt2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQ9dHJlZUNvbnRleHRJZDt2YXIgYmFzZU92ZXJmbG93PXRyZWVDb250ZXh0T3ZlcmZsb3c7Ly8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbi8vIG9mIHRoZSBpZDsgd2UgdXNlIGl0IHRvIGFjY291bnQgZm9yIGxlYWRpbmcgMHMuXG52YXIgYmFzZUxlbmd0aD1nZXRCaXRMZW5ndGgoYmFzZUlkV2l0aExlYWRpbmdCaXQpLTE7dmFyIGJhc2VJZD1iYXNlSWRXaXRoTGVhZGluZ0JpdCZ+KDE8PGJhc2VMZW5ndGgpO3ZhciBzbG90PWluZGV4KzE7dmFyIGxlbmd0aD1nZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikrYmFzZUxlbmd0aDsvLyAzMCBpcyB0aGUgbWF4IGxlbmd0aCB3ZSBjYW4gc3RvcmUgd2l0aG91dCBvdmVyZmxvd2luZywgdGFraW5nIGludG9cbi8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbmlmKGxlbmd0aD4zMCl7Ly8gV2Ugb3ZlcmZsb3dlZCB0aGUgYml0d2lzZS1zYWZlIHJhbmdlLiBGYWxsIGJhY2sgdG8gc2xvd2VyIGFsZ29yaXRobS5cbi8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3Rcbi8vIHdvcmsgZm9yIHNtYWxsZXIgaWRzLCBiZWNhdXNlIHlvdSBuZWVkIDUgYml0cyBwZXIgY2hhcmFjdGVyLlxuLy9cbi8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuLy8gcmVtYWluaW5nIGRpZ2l0cy5cbi8vXG4vLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3Jcbi8vIGV4YW1wbGUsIGlmIHRoZSBjdXJyZW50IGlkIGlzIDIzIGJpdHMgbG9uZywgd2UgY2FuIGNvbnZlcnQgMjAgb2YgdGhvc2Vcbi8vIGJpdHMgaW50byBhIHN0cmluZyBvZiA0IGNoYXJhY3RlcnMsIHdpdGggMyBiaXRzIGxlZnQgb3Zlci5cbi8vXG4vLyBGaXJzdCBjYWxjdWxhdGUgaG93IG1hbnkgYml0cyBpbiB0aGUgYmFzZSBpZCByZXByZXNlbnQgYSBjb21wbGV0ZVxuLy8gc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy5cbnZhciBudW1iZXJPZk92ZXJmbG93Qml0cz1iYXNlTGVuZ3RoLWJhc2VMZW5ndGglNTsvLyBUaGVuIGNyZWF0ZSBhIGJpdG1hc2sgdGhhdCBzZWxlY3RzIG9ubHkgdGhvc2UgYml0cy5cbnZhciBuZXdPdmVyZmxvd0JpdHM9KDE8PG51bWJlck9mT3ZlcmZsb3dCaXRzKS0xOy8vIFNlbGVjdCB0aGUgYml0cywgYW5kIGNvbnZlcnQgdGhlbSB0byBhIGJhc2UgMzIgc3RyaW5nLlxudmFyIG5ld092ZXJmbG93PShiYXNlSWQmbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7Ly8gTm93IHdlIGNhbiByZW1vdmUgdGhvc2UgYml0cyBmcm9tIHRoZSBiYXNlIGlkLlxudmFyIHJlc3RPZkJhc2VJZD1iYXNlSWQ+Pm51bWJlck9mT3ZlcmZsb3dCaXRzO3ZhciByZXN0T2ZCYXNlTGVuZ3RoPWJhc2VMZW5ndGgtbnVtYmVyT2ZPdmVyZmxvd0JpdHM7Ly8gRmluYWxseSwgZW5jb2RlIHRoZSByZXN0IG9mIHRoZSBiaXRzIHVzaW5nIHRoZSBub3JtYWwgYWxnb3JpdGhtLiBCZWNhdXNlXG4vLyB3ZSBtYWRlIG1vcmUgcm9vbSwgdGhpcyB0aW1lIGl0IHdvbid0IG92ZXJmbG93LlxudmFyIHJlc3RPZkxlbmd0aD1nZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikrcmVzdE9mQmFzZUxlbmd0aDt2YXIgcmVzdE9mTmV3Qml0cz1zbG90PDxyZXN0T2ZCYXNlTGVuZ3RoO3ZhciBpZD1yZXN0T2ZOZXdCaXRzfHJlc3RPZkJhc2VJZDt2YXIgb3ZlcmZsb3c9bmV3T3ZlcmZsb3crYmFzZU92ZXJmbG93O3RyZWVDb250ZXh0SWQ9MTw8cmVzdE9mTGVuZ3RofGlkO3RyZWVDb250ZXh0T3ZlcmZsb3c9b3ZlcmZsb3c7fWVsc2V7Ly8gTm9ybWFsIHBhdGhcbnZhciBuZXdCaXRzPXNsb3Q8PGJhc2VMZW5ndGg7dmFyIF9pZD1uZXdCaXRzfGJhc2VJZDt2YXIgX292ZXJmbG93PWJhc2VPdmVyZmxvdzt0cmVlQ29udGV4dElkPTE8PGxlbmd0aHxfaWQ7dHJlZUNvbnRleHRPdmVyZmxvdz1fb3ZlcmZsb3c7fX1mdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKXt3YXJuSWZOb3RIeWRyYXRpbmcoKTsvLyBUaGlzIGNvbXBvbmVudCBtYXRlcmlhbGl6ZWQgYW4gaWQuIFRoaXMgd2lsbCBhZmZlY3QgYW55IGlkcyB0aGF0IGFwcGVhclxuLy8gaW4gaXRzIGNoaWxkcmVuLlxudmFyIHJldHVybkZpYmVyPXdvcmtJblByb2dyZXNzLnJldHVybjtpZihyZXR1cm5GaWJlciE9PW51bGwpe3ZhciBudW1iZXJPZkZvcmtzPTE7dmFyIHNsb3RJbmRleD0wO3B1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcyxudW1iZXJPZkZvcmtzKTtwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLG51bWJlck9mRm9ya3Msc2xvdEluZGV4KTt9fWZ1bmN0aW9uIGdldEJpdExlbmd0aChudW1iZXIpe3JldHVybiAzMi1jbHozMihudW1iZXIpO31mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKXtyZXR1cm4gMTw8Z2V0Qml0TGVuZ3RoKGlkKS0xO31mdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyl7Ly8gUmVzdG9yZSB0aGUgcHJldmlvdXMgdmFsdWVzLlxuLy8gVGhpcyBpcyBhIGJpdCBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gb3RoZXIgY29udGV4dC1saWtlIG1vZHVsZXMgaW4gRmliZXJcbi8vIGJlY2F1c2UgdGhlIHNhbWUgRmliZXIgbWF5IGFwcGVhciBvbiB0aGUgc3RhY2sgbXVsdGlwbGUgdGltZXMgYW5kIGZvclxuLy8gZGlmZmVyZW50IHJlYXNvbnMuIFdlIGhhdmUgdG8ga2VlcCBwb3BwaW5nIHVudGlsIHRoZSB3b3JrLWluLXByb2dyZXNzIGlzXG4vLyBubyBsb25nZXIgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2suXG53aGlsZSh3b3JrSW5Qcm9ncmVzcz09PXRyZWVGb3JrUHJvdmlkZXIpe3RyZWVGb3JrUHJvdmlkZXI9Zm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdO2ZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF09bnVsbDt0cmVlRm9ya0NvdW50PWZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XTtmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdPW51bGw7fXdoaWxlKHdvcmtJblByb2dyZXNzPT09dHJlZUNvbnRleHRQcm92aWRlcil7dHJlZUNvbnRleHRQcm92aWRlcj1pZFN0YWNrWy0taWRTdGFja0luZGV4XTtpZFN0YWNrW2lkU3RhY2tJbmRleF09bnVsbDt0cmVlQ29udGV4dE92ZXJmbG93PWlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO2lkU3RhY2tbaWRTdGFja0luZGV4XT1udWxsO3RyZWVDb250ZXh0SWQ9aWRTdGFja1stLWlkU3RhY2tJbmRleF07aWRTdGFja1tpZFN0YWNrSW5kZXhdPW51bGw7fX1mdW5jdGlvbiBnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCgpe3dhcm5JZk5vdEh5ZHJhdGluZygpO2lmKHRyZWVDb250ZXh0UHJvdmlkZXIhPT1udWxsKXtyZXR1cm57aWQ6dHJlZUNvbnRleHRJZCxvdmVyZmxvdzp0cmVlQ29udGV4dE92ZXJmbG93fTt9ZWxzZXtyZXR1cm4gbnVsbDt9fWZ1bmN0aW9uIHJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzdXNwZW5kZWRDb250ZXh0KXt3YXJuSWZOb3RIeWRyYXRpbmcoKTtpZFN0YWNrW2lkU3RhY2tJbmRleCsrXT10cmVlQ29udGV4dElkO2lkU3RhY2tbaWRTdGFja0luZGV4KytdPXRyZWVDb250ZXh0T3ZlcmZsb3c7aWRTdGFja1tpZFN0YWNrSW5kZXgrK109dHJlZUNvbnRleHRQcm92aWRlcjt0cmVlQ29udGV4dElkPXN1c3BlbmRlZENvbnRleHQuaWQ7dHJlZUNvbnRleHRPdmVyZmxvdz1zdXNwZW5kZWRDb250ZXh0Lm92ZXJmbG93O3RyZWVDb250ZXh0UHJvdmlkZXI9d29ya0luUHJvZ3Jlc3M7fWZ1bmN0aW9uIHdhcm5JZk5vdEh5ZHJhdGluZygpe3tpZighZ2V0SXNIeWRyYXRpbmcoKSl7ZXJyb3IoJ0V4cGVjdGVkIHRvIGJlIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgJysnYW4gaXNzdWUuJyk7fX19Ly8gVGhpcyBtYXkgaGF2ZSBiZWVuIGFuIGluc2VydGlvbiBvciBhIGh5ZHJhdGlvbi5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlcj1udWxsO3ZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlPW51bGw7dmFyIGlzSHlkcmF0aW5nPWZhbHNlOy8vIFRoaXMgZmxhZyBhbGxvd3MgZm9yIHdhcm5pbmcgc3VwcmVzc2lvbiB3aGVuIHdlIGV4cGVjdCB0aGVyZSB0byBiZSBtaXNtYXRjaGVzXG4vLyBkdWUgdG8gZWFybGllciBtaXNtYXRjaGVzIG9yIGEgc3VzcGVuZGVkIGZpYmVyLlxudmFyIGRpZFN1c3BlbmRPckVycm9yREVWPWZhbHNlOy8vIEh5ZHJhdGlvbiBlcnJvcnMgdGhhdCB3ZXJlIHRocm93biBpbnNpZGUgdGhpcyBib3VuZGFyeVxudmFyIGh5ZHJhdGlvbkVycm9ycz1udWxsO2Z1bmN0aW9uIHdhcm5JZkh5ZHJhdGluZygpe3tpZihpc0h5ZHJhdGluZyl7ZXJyb3IoJ1dlIHNob3VsZCBub3QgYmUgaHlkcmF0aW5nIGhlcmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGEgYnVnLicpO319fWZ1bmN0aW9uIG1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWKCl7e2RpZFN1c3BlbmRPckVycm9yREVWPXRydWU7fX1mdW5jdGlvbiBkaWRTdXNwZW5kT3JFcnJvcldoaWxlSHlkcmF0aW5nREVWKCl7e3JldHVybiBkaWRTdXNwZW5kT3JFcnJvckRFVjt9fWZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpe3ZhciBwYXJlbnRJbnN0YW5jZT1maWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztuZXh0SHlkcmF0YWJsZUluc3RhbmNlPWdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyKHBhcmVudEluc3RhbmNlKTtoeWRyYXRpb25QYXJlbnRGaWJlcj1maWJlcjtpc0h5ZHJhdGluZz10cnVlO2h5ZHJhdGlvbkVycm9ycz1udWxsO2RpZFN1c3BlbmRPckVycm9yREVWPWZhbHNlO3JldHVybiB0cnVlO31mdW5jdGlvbiByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIsc3VzcGVuc2VJbnN0YW5jZSx0cmVlQ29udGV4dCl7bmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7aHlkcmF0aW9uUGFyZW50RmliZXI9ZmliZXI7aXNIeWRyYXRpbmc9dHJ1ZTtoeWRyYXRpb25FcnJvcnM9bnVsbDtkaWRTdXNwZW5kT3JFcnJvckRFVj1mYWxzZTtpZih0cmVlQ29udGV4dCE9PW51bGwpe3Jlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dChmaWJlcix0cmVlQ29udGV4dCk7fXJldHVybiB0cnVlO31mdW5jdGlvbiB3YXJuVW5oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLGluc3RhbmNlKXt7c3dpdGNoKHJldHVybkZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp7ZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLGluc3RhbmNlKTticmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgaXNDb25jdXJyZW50TW9kZT0ocmV0dXJuRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7ZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUscmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcyxyZXR1cm5GaWJlci5zdGF0ZU5vZGUsaW5zdGFuY2UsLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbmlzQ29uY3VycmVudE1vZGUpO2JyZWFrO31jYXNlIFN1c3BlbnNlQ29tcG9uZW50Ont2YXIgc3VzcGVuc2VTdGF0ZT1yZXR1cm5GaWJlci5tZW1vaXplZFN0YXRlO2lmKHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCE9PW51bGwpZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQsaW5zdGFuY2UpO2JyZWFrO319fX1mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsaW5zdGFuY2Upe3dhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsaW5zdGFuY2UpO3ZhciBjaGlsZFRvRGVsZXRlPWNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7Y2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGU9aW5zdGFuY2U7Y2hpbGRUb0RlbGV0ZS5yZXR1cm49cmV0dXJuRmliZXI7dmFyIGRlbGV0aW9ucz1yZXR1cm5GaWJlci5kZWxldGlvbnM7aWYoZGVsZXRpb25zPT09bnVsbCl7cmV0dXJuRmliZXIuZGVsZXRpb25zPVtjaGlsZFRvRGVsZXRlXTtyZXR1cm5GaWJlci5mbGFnc3w9Q2hpbGREZWxldGlvbjt9ZWxzZXtkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTt9fWZ1bmN0aW9uIHdhcm5Ob25oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLGZpYmVyKXt7aWYoZGlkU3VzcGVuZE9yRXJyb3JERVYpey8vIEluc2lkZSBhIGJvdW5kYXJ5IHRoYXQgYWxyZWFkeSBzdXNwZW5kZWQuIFdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgdGhlXG4vLyBzaWJsaW5ncyBvZiBhIHN1c3BlbmRlZCBub2RlLiBUaGUgbWlzbWF0Y2ggbWF5IGJlIGR1ZSB0byB0aGUgbWlzc2luZ1xuLy8gZGF0YSwgc28gaXQncyBwcm9iYWJseSBhIGZhbHNlIHBvc2l0aXZlLlxucmV0dXJuO31zd2l0Y2gocmV0dXJuRmliZXIudGFnKXtjYXNlIEhvc3RSb290Ont2YXIgcGFyZW50Q29udGFpbmVyPXJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO3N3aXRjaChmaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDp2YXIgdHlwZT1maWJlci50eXBlO3ZhciBwcm9wcz1maWJlci5wZW5kaW5nUHJvcHM7ZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIsdHlwZSk7YnJlYWs7Y2FzZSBIb3N0VGV4dDp2YXIgdGV4dD1maWJlci5wZW5kaW5nUHJvcHM7ZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyLHRleHQpO2JyZWFrO31icmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgcGFyZW50VHlwZT1yZXR1cm5GaWJlci50eXBlO3ZhciBwYXJlbnRQcm9wcz1yZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO3ZhciBwYXJlbnRJbnN0YW5jZT1yZXR1cm5GaWJlci5zdGF0ZU5vZGU7c3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgX3R5cGU9ZmliZXIudHlwZTt2YXIgX3Byb3BzPWZpYmVyLnBlbmRpbmdQcm9wczt2YXIgaXNDb25jdXJyZW50TW9kZT0ocmV0dXJuRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7ZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLF90eXBlLF9wcm9wcywvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuaXNDb25jdXJyZW50TW9kZSk7YnJlYWs7fWNhc2UgSG9zdFRleHQ6e3ZhciBfdGV4dD1maWJlci5wZW5kaW5nUHJvcHM7dmFyIF9pc0NvbmN1cnJlbnRNb2RlPShyZXR1cm5GaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZTtkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLF90ZXh0LC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG5faXNDb25jdXJyZW50TW9kZSk7YnJlYWs7fX1icmVhazt9Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDp7dmFyIHN1c3BlbnNlU3RhdGU9cmV0dXJuRmliZXIubWVtb2l6ZWRTdGF0ZTt2YXIgX3BhcmVudEluc3RhbmNlPXN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtpZihfcGFyZW50SW5zdGFuY2UhPT1udWxsKXN3aXRjaChmaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDp2YXIgX3R5cGUyPWZpYmVyLnR5cGU7dmFyIF9wcm9wczI9ZmliZXIucGVuZGluZ1Byb3BzO2RpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKF9wYXJlbnRJbnN0YW5jZSxfdHlwZTIpO2JyZWFrO2Nhc2UgSG9zdFRleHQ6dmFyIF90ZXh0Mj1maWJlci5wZW5kaW5nUHJvcHM7ZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKF9wYXJlbnRJbnN0YW5jZSxfdGV4dDIpO2JyZWFrO31icmVhazt9ZGVmYXVsdDpyZXR1cm47fX19ZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlcixmaWJlcil7ZmliZXIuZmxhZ3M9ZmliZXIuZmxhZ3Mmfkh5ZHJhdGluZ3xQbGFjZW1lbnQ7d2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsZmliZXIpO31mdW5jdGlvbiB0cnlIeWRyYXRlKGZpYmVyLG5leHRJbnN0YW5jZSl7c3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgdHlwZT1maWJlci50eXBlO3ZhciBwcm9wcz1maWJlci5wZW5kaW5nUHJvcHM7dmFyIGluc3RhbmNlPWNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsdHlwZSk7aWYoaW5zdGFuY2UhPT1udWxsKXtmaWJlci5zdGF0ZU5vZGU9aW5zdGFuY2U7aHlkcmF0aW9uUGFyZW50RmliZXI9ZmliZXI7bmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChpbnN0YW5jZSk7cmV0dXJuIHRydWU7fXJldHVybiBmYWxzZTt9Y2FzZSBIb3N0VGV4dDp7dmFyIHRleHQ9ZmliZXIucGVuZGluZ1Byb3BzO3ZhciB0ZXh0SW5zdGFuY2U9Y2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsdGV4dCk7aWYodGV4dEluc3RhbmNlIT09bnVsbCl7ZmliZXIuc3RhdGVOb2RlPXRleHRJbnN0YW5jZTtoeWRyYXRpb25QYXJlbnRGaWJlcj1maWJlcjsvLyBUZXh0IEluc3RhbmNlcyBkb24ndCBoYXZlIGNoaWxkcmVuIHNvIHRoZXJlJ3Mgbm90aGluZyB0byBoeWRyYXRlLlxubmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1udWxsO3JldHVybiB0cnVlO31yZXR1cm4gZmFsc2U7fWNhc2UgU3VzcGVuc2VDb21wb25lbnQ6e3ZhciBzdXNwZW5zZUluc3RhbmNlPWNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSk7aWYoc3VzcGVuc2VJbnN0YW5jZSE9PW51bGwpe3ZhciBzdXNwZW5zZVN0YXRlPXtkZWh5ZHJhdGVkOnN1c3BlbnNlSW5zdGFuY2UsdHJlZUNvbnRleHQ6Z2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSxyZXRyeUxhbmU6T2Zmc2NyZWVuTGFuZX07ZmliZXIubWVtb2l6ZWRTdGF0ZT1zdXNwZW5zZVN0YXRlOy8vIFN0b3JlIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50IGFzIGEgY2hpbGQgZmliZXIuXG4vLyBUaGlzIHNpbXBsaWZpZXMgdGhlIGNvZGUgZm9yIGdldEhvc3RTaWJsaW5nIGFuZCBkZWxldGluZyBub2Rlcyxcbi8vIHNpbmNlIGl0IGRvZXNuJ3QgaGF2ZSB0byBjb25zaWRlciBhbGwgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbi8vIGNoZWNrIGlmIHRoZXkncmUgZGVoeWRyYXRlZCBvbmVzIG9yIG5vdC5cbnZhciBkZWh5ZHJhdGVkRnJhZ21lbnQ9Y3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50KHN1c3BlbnNlSW5zdGFuY2UpO2RlaHlkcmF0ZWRGcmFnbWVudC5yZXR1cm49ZmliZXI7ZmliZXIuY2hpbGQ9ZGVoeWRyYXRlZEZyYWdtZW50O2h5ZHJhdGlvblBhcmVudEZpYmVyPWZpYmVyOy8vIFdoaWxlIGEgU3VzcGVuc2UgSW5zdGFuY2UgZG9lcyBoYXZlIGNoaWxkcmVuLCB3ZSB3b24ndCBzdGVwIGludG9cbi8vIGl0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSW5zdGVhZCwgd2UnbGwgcmVlbnRlciBpdCBsYXRlci5cbm5leHRIeWRyYXRhYmxlSW5zdGFuY2U9bnVsbDtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO31kZWZhdWx0OnJldHVybiBmYWxzZTt9fWZ1bmN0aW9uIHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpe3JldHVybihmaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZSYmKGZpYmVyLmZsYWdzJkRpZENhcHR1cmUpPT09Tm9GbGFnczt9ZnVuY3Rpb24gdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKXt0aHJvdyBuZXcgRXJyb3IoJ0h5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyAnKydyZW5kZXJlZCBvbiB0aGUgc2VydmVyLicpO31mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcil7aWYoIWlzSHlkcmF0aW5nKXtyZXR1cm47fXZhciBuZXh0SW5zdGFuY2U9bmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtpZighbmV4dEluc3RhbmNlKXtpZihzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoKGZpYmVyKSl7d2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsZmliZXIpO3Rocm93T25IeWRyYXRpb25NaXNtYXRjaCgpO30vLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlcixmaWJlcik7aXNIeWRyYXRpbmc9ZmFsc2U7aHlkcmF0aW9uUGFyZW50RmliZXI9ZmliZXI7cmV0dXJuO312YXIgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZT1uZXh0SW5zdGFuY2U7aWYoIXRyeUh5ZHJhdGUoZmliZXIsbmV4dEluc3RhbmNlKSl7aWYoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpe3dhcm5Ob25oeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLGZpYmVyKTt0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTt9Ly8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4vLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4vLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG5uZXh0SW5zdGFuY2U9Z2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO3ZhciBwcmV2SHlkcmF0aW9uUGFyZW50RmliZXI9aHlkcmF0aW9uUGFyZW50RmliZXI7aWYoIW5leHRJbnN0YW5jZXx8IXRyeUh5ZHJhdGUoZmliZXIsbmV4dEluc3RhbmNlKSl7Ly8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbmluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsZmliZXIpO2lzSHlkcmF0aW5nPWZhbHNlO2h5ZHJhdGlvblBhcmVudEZpYmVyPWZpYmVyO3JldHVybjt9Ly8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbi8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbi8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbmRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShwcmV2SHlkcmF0aW9uUGFyZW50RmliZXIsZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7fX1mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCl7dmFyIGluc3RhbmNlPWZpYmVyLnN0YXRlTm9kZTt2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXY9IWRpZFN1c3BlbmRPckVycm9yREVWO3ZhciB1cGRhdGVQYXlsb2FkPWh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSxmaWJlci50eXBlLGZpYmVyLm1lbW9pemVkUHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlLGhvc3RDb250ZXh0LGZpYmVyLHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KTsvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbmZpYmVyLnVwZGF0ZVF1ZXVlPXVwZGF0ZVBheWxvYWQ7Ly8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4vLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbmlmKHVwZGF0ZVBheWxvYWQhPT1udWxsKXtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZShmaWJlcil7dmFyIHRleHRJbnN0YW5jZT1maWJlci5zdGF0ZU5vZGU7dmFyIHRleHRDb250ZW50PWZpYmVyLm1lbW9pemVkUHJvcHM7dmFyIHNob3VsZFVwZGF0ZT1oeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSx0ZXh0Q29udGVudCxmaWJlcik7aWYoc2hvdWxkVXBkYXRlKXsvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxudmFyIHJldHVybkZpYmVyPWh5ZHJhdGlvblBhcmVudEZpYmVyO2lmKHJldHVybkZpYmVyIT09bnVsbCl7c3dpdGNoKHJldHVybkZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp7dmFyIHBhcmVudENvbnRhaW5lcj1yZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzt2YXIgaXNDb25jdXJyZW50TW9kZT0ocmV0dXJuRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7ZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsdGV4dEluc3RhbmNlLHRleHRDb250ZW50LC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG5pc0NvbmN1cnJlbnRNb2RlKTticmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgcGFyZW50VHlwZT1yZXR1cm5GaWJlci50eXBlO3ZhciBwYXJlbnRQcm9wcz1yZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO3ZhciBwYXJlbnRJbnN0YW5jZT1yZXR1cm5GaWJlci5zdGF0ZU5vZGU7dmFyIF9pc0NvbmN1cnJlbnRNb2RlMj0ocmV0dXJuRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7ZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLHRleHRJbnN0YW5jZSx0ZXh0Q29udGVudCwvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuX2lzQ29uY3VycmVudE1vZGUyKTticmVhazt9fX19cmV0dXJuIHNob3VsZFVwZGF0ZTt9ZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKGZpYmVyKXt2YXIgc3VzcGVuc2VTdGF0ZT1maWJlci5tZW1vaXplZFN0YXRlO3ZhciBzdXNwZW5zZUluc3RhbmNlPXN1c3BlbnNlU3RhdGUhPT1udWxsP3N1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDpudWxsO2lmKCFzdXNwZW5zZUluc3RhbmNlKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gJysnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9aHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSxmaWJlcik7fWZ1bmN0aW9uIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpe3ZhciBzdXNwZW5zZVN0YXRlPWZpYmVyLm1lbW9pemVkU3RhdGU7dmFyIHN1c3BlbnNlSW5zdGFuY2U9c3VzcGVuc2VTdGF0ZSE9PW51bGw/c3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkOm51bGw7aWYoIXN1c3BlbnNlSW5zdGFuY2Upe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31yZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTt9ZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcil7dmFyIHBhcmVudD1maWJlci5yZXR1cm47d2hpbGUocGFyZW50IT09bnVsbCYmcGFyZW50LnRhZyE9PUhvc3RDb21wb25lbnQmJnBhcmVudC50YWchPT1Ib3N0Um9vdCYmcGFyZW50LnRhZyE9PVN1c3BlbnNlQ29tcG9uZW50KXtwYXJlbnQ9cGFyZW50LnJldHVybjt9aHlkcmF0aW9uUGFyZW50RmliZXI9cGFyZW50O31mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcil7aWYoZmliZXIhPT1oeWRyYXRpb25QYXJlbnRGaWJlcil7Ly8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuLy8gdHJlZS5cbnJldHVybiBmYWxzZTt9aWYoIWlzSHlkcmF0aW5nKXsvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbi8vIHNpYmxpbmdzLlxucG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7aXNIeWRyYXRpbmc9dHJ1ZTtyZXR1cm4gZmFsc2U7fS8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbi8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4vLyBzaWRlIG9mIHRoZW0uIFdlIGFsc28gZG9uJ3QgZGVsZXRlIGFueXRoaW5nIGluc2lkZSB0aGUgcm9vdCBjb250YWluZXIuXG5pZihmaWJlci50YWchPT1Ib3N0Um9vdCYmKGZpYmVyLnRhZyE9PUhvc3RDb21wb25lbnR8fHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpJiYhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSxmaWJlci5tZW1vaXplZFByb3BzKSkpe3ZhciBuZXh0SW5zdGFuY2U9bmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtpZihuZXh0SW5zdGFuY2Upe2lmKHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpKXt3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzKGZpYmVyKTt0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTt9ZWxzZXt3aGlsZShuZXh0SW5zdGFuY2Upe2RlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcixuZXh0SW5zdGFuY2UpO25leHRJbnN0YW5jZT1nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTt9fX19cG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7aWYoZmliZXIudGFnPT09U3VzcGVuc2VDb21wb25lbnQpe25leHRIeWRyYXRhYmxlSW5zdGFuY2U9c2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7fWVsc2V7bmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1oeWRyYXRpb25QYXJlbnRGaWJlcj9nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKTpudWxsO31yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gaGFzVW5oeWRyYXRlZFRhaWxOb2Rlcygpe3JldHVybiBpc0h5ZHJhdGluZyYmbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSE9PW51bGw7fWZ1bmN0aW9uIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpe3ZhciBuZXh0SW5zdGFuY2U9bmV4dEh5ZHJhdGFibGVJbnN0YW5jZTt3aGlsZShuZXh0SW5zdGFuY2Upe3dhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsbmV4dEluc3RhbmNlKTtuZXh0SW5zdGFuY2U9Z2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7fX1mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCl7aHlkcmF0aW9uUGFyZW50RmliZXI9bnVsbDtuZXh0SHlkcmF0YWJsZUluc3RhbmNlPW51bGw7aXNIeWRyYXRpbmc9ZmFsc2U7ZGlkU3VzcGVuZE9yRXJyb3JERVY9ZmFsc2U7fWZ1bmN0aW9uIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCl7aWYoaHlkcmF0aW9uRXJyb3JzIT09bnVsbCl7Ly8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLiBUaGUgZXJyb3JzIHRoYXQgb2NjdXJyZWRcbi8vIGR1cmluZyB0aGUgaHlkcmF0aW9uIGF0dGVtcHQgYXJlIG5vdyByZWNvdmVyZWQuIFdlIHdpbGwgbG9nIHRoZW0gaW5cbi8vIGNvbW1pdCBwaGFzZSwgb25jZSB0aGUgZW50aXJlIHRyZWUgaGFzIGZpbmlzaGVkLlxucXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpO2h5ZHJhdGlvbkVycm9ycz1udWxsO319ZnVuY3Rpb24gZ2V0SXNIeWRyYXRpbmcoKXtyZXR1cm4gaXNIeWRyYXRpbmc7fWZ1bmN0aW9uIHF1ZXVlSHlkcmF0aW9uRXJyb3IoZXJyb3Ipe2lmKGh5ZHJhdGlvbkVycm9ycz09PW51bGwpe2h5ZHJhdGlvbkVycm9ycz1bZXJyb3JdO31lbHNle2h5ZHJhdGlvbkVycm9ycy5wdXNoKGVycm9yKTt9fXZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO3ZhciBOb1RyYW5zaXRpb249bnVsbDtmdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKXtyZXR1cm4gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO312YXIgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3M9e3JlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOmZ1bmN0aW9uKGZpYmVyLGluc3RhbmNlKXt9LGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOmZ1bmN0aW9uKCl7fSxyZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZzpmdW5jdGlvbihmaWJlcixpbnN0YW5jZSl7fSxmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOmZ1bmN0aW9uKCl7fSxkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOmZ1bmN0aW9uKCl7fX07e3ZhciBmaW5kU3RyaWN0Um9vdD1mdW5jdGlvbihmaWJlcil7dmFyIG1heWJlU3RyaWN0Um9vdD1udWxsO3ZhciBub2RlPWZpYmVyO3doaWxlKG5vZGUhPT1udWxsKXtpZihub2RlLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7bWF5YmVTdHJpY3RSb290PW5vZGU7fW5vZGU9bm9kZS5yZXR1cm47fXJldHVybiBtYXliZVN0cmljdFJvb3Q7fTt2YXIgc2V0VG9Tb3J0ZWRTdHJpbmc9ZnVuY3Rpb24oc2V0KXt2YXIgYXJyYXk9W107c2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpe2FycmF5LnB1c2godmFsdWUpO30pO3JldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTt9O3ZhciBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3M9W107dmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3M9W107dmFyIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3M9W107dmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzPVtdO3ZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzPVtdO3ZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncz1bXTsvLyBUcmFja3MgY29tcG9uZW50cyB3ZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0LlxudmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXM9bmV3IFNldCgpO1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzPWZ1bmN0aW9uKGZpYmVyLGluc3RhbmNlKXsvLyBEZWR1cGUgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuaWYoZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpe3JldHVybjt9aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbicmJi8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmchPT10cnVlKXtwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7fWlmKGZpYmVyLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSYmdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nKXtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicmJmluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyE9PXRydWUpe3BlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7fWlmKGZpYmVyLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSYmdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyl7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlPT09J2Z1bmN0aW9uJyYmaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIT09dHJ1ZSl7cGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTt9aWYoZmliZXIubW9kZSZTdHJpY3RMZWdhY3lNb2RlJiZ0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU9PT0nZnVuY3Rpb24nKXtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTt9fTtSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncz1mdW5jdGlvbigpey8vIFdlIGRvIGFuIGluaXRpYWwgcGFzcyB0byBnYXRoZXIgY29tcG9uZW50IG5hbWVzXG52YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXM9bmV3IFNldCgpO2lmKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGg+MCl7cGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpe2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCcpO2RpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO30pO3BlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncz1bXTt9dmFyIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcz1uZXcgU2V0KCk7aWYocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGg+MCl7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXtVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnQ29tcG9uZW50Jyk7ZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7fSk7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncz1bXTt9dmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcz1uZXcgU2V0KCk7aWYocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGg+MCl7cGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXtjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnQ29tcG9uZW50Jyk7ZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7fSk7cGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncz1bXTt9dmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXM9bmV3IFNldCgpO2lmKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aD4wKXtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXtVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCcpO2RpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO30pO3BlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzPVtdO312YXIgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzPW5ldyBTZXQoKTtpZihwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aD4wKXtwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpe2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdDb21wb25lbnQnKTtkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTt9KTtwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzPVtdO312YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcz1uZXcgU2V0KCk7aWYocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoPjApe3BlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpe1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnQ29tcG9uZW50Jyk7ZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7fSk7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3M9W107fS8vIEZpbmFsbHksIHdlIGZsdXNoIGFsbCB0aGUgd2FybmluZ3Ncbi8vIFVOU0FGRV8gb25lcyBiZWZvcmUgdGhlIGRlcHJlY2F0ZWQgb25lcywgc2luY2UgdGhleSdsbCBiZSAnbG91ZGVyJ1xuaWYoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemU+MCl7dmFyIHNvcnRlZE5hbWVzPXNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7ZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicrJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicrJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsc29ydGVkTmFtZXMpO31pZihVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemU+MCl7dmFyIF9zb3J0ZWROYW1lcz1zZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcrJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicrJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nK1wiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCBcIisncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJysnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nKydcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLF9zb3J0ZWROYW1lcyk7fWlmKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZT4wKXt2YXIgX3NvcnRlZE5hbWVzMj1zZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcrJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicrJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nKydcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLF9zb3J0ZWROYW1lczIpO31pZihjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplPjApe3ZhciBfc29ydGVkTmFtZXMzPXNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTt3YXJuKCdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnKydTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nKycqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nKycqIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyAnKyd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnKydUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcrJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicrJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsX3NvcnRlZE5hbWVzMyk7fWlmKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplPjApe3ZhciBfc29ydGVkTmFtZXM0PXNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7d2FybignY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicrJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nK1wiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIFwiKydjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJysnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nKycqIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzICcrJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcrJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJysnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJysnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyxfc29ydGVkTmFtZXM0KTt9aWYoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemU+MCl7dmFyIF9zb3J0ZWROYW1lczU9c2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTt3YXJuKCdjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJysnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJysnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicrJyogUmVuYW1lIGNvbXBvbmVudFdpbGxVcGRhdGUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgdG8gc3VwcHJlc3MgJysndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJysnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnKydgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nKydcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLF9zb3J0ZWROYW1lczUpO319O3ZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmc9bmV3IE1hcCgpOy8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG52YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dD1uZXcgU2V0KCk7UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc9ZnVuY3Rpb24oZmliZXIsaW5zdGFuY2Upe3ZhciBzdHJpY3RSb290PWZpbmRTdHJpY3RSb290KGZpYmVyKTtpZihzdHJpY3RSb290PT09bnVsbCl7ZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcrJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7cmV0dXJuO30vLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG5pZihkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSl7cmV0dXJuO312YXIgd2FybmluZ3NGb3JSb290PXBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCk7aWYoZmliZXIudHlwZS5jb250ZXh0VHlwZXMhPW51bGx8fGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMhPW51bGx8fGluc3RhbmNlIT09bnVsbCYmdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dD09PSdmdW5jdGlvbicpe2lmKHdhcm5pbmdzRm9yUm9vdD09PXVuZGVmaW5lZCl7d2FybmluZ3NGb3JSb290PVtdO3BlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCx3YXJuaW5nc0ZvclJvb3QpO313YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7fX07UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZz1mdW5jdGlvbigpe3BlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyQXJyYXksc3RyaWN0Um9vdCl7aWYoZmliZXJBcnJheS5sZW5ndGg9PT0wKXtyZXR1cm47fXZhciBmaXJzdEZpYmVyPWZpYmVyQXJyYXlbMF07dmFyIHVuaXF1ZU5hbWVzPW5ldyBTZXQoKTtmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24oZmliZXIpe3VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCcpO2RpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO30pO3ZhciBzb3J0ZWROYW1lcz1zZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7dHJ5e3NldEN1cnJlbnRGaWJlcihmaXJzdEZpYmVyKTtlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJysnXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgJysndXNpbmcgaXQgc2hvdWxkIG1pZ3JhdGUgdG8gdGhlIG5ldyB2ZXJzaW9uLicrJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycrJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsc29ydGVkTmFtZXMpO31maW5hbGx5e3Jlc2V0Q3VycmVudEZpYmVyKCk7fX0pO307UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncz1mdW5jdGlvbigpe3BlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncz1bXTtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzPVtdO3BlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3M9W107cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3M9W107cGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncz1bXTtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncz1bXTtwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmc9bmV3IE1hcCgpO307fWZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LGJhc2VQcm9wcyl7aWYoQ29tcG9uZW50JiZDb21wb25lbnQuZGVmYXVsdFByb3BzKXsvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHMuIFRha2VuIGZyb20gUmVhY3RFbGVtZW50XG52YXIgcHJvcHM9YXNzaWduKHt9LGJhc2VQcm9wcyk7dmFyIGRlZmF1bHRQcm9wcz1Db21wb25lbnQuZGVmYXVsdFByb3BzO2Zvcih2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKXtpZihwcm9wc1twcm9wTmFtZV09PT11bmRlZmluZWQpe3Byb3BzW3Byb3BOYW1lXT1kZWZhdWx0UHJvcHNbcHJvcE5hbWVdO319cmV0dXJuIHByb3BzO31yZXR1cm4gYmFzZVByb3BzO312YXIgdmFsdWVDdXJzb3I9Y3JlYXRlQ3Vyc29yKG51bGwpO3ZhciByZW5kZXJlclNpZ2lsO3svLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbnJlbmRlcmVyU2lnaWw9e307fXZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcj1udWxsO3ZhciBsYXN0Q29udGV4dERlcGVuZGVuY3k9bnVsbDt2YXIgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0PW51bGw7dmFyIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVY9ZmFsc2U7ZnVuY3Rpb24gcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCl7Ly8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4vLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbmN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyPW51bGw7bGFzdENvbnRleHREZXBlbmRlbmN5PW51bGw7bGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0PW51bGw7e2lzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVY9ZmFsc2U7fX1mdW5jdGlvbiBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCl7e2lzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVY9dHJ1ZTt9fWZ1bmN0aW9uIGV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpe3tpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWPWZhbHNlO319ZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsY29udGV4dCxuZXh0VmFsdWUpe3twdXNoKHZhbHVlQ3Vyc29yLGNvbnRleHQuX2N1cnJlbnRWYWx1ZSxwcm92aWRlckZpYmVyKTtjb250ZXh0Ll9jdXJyZW50VmFsdWU9bmV4dFZhbHVlO3tpZihjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIhPT11bmRlZmluZWQmJmNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciE9PW51bGwmJmNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciE9PXJlbmRlcmVyU2lnaWwpe2Vycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJysnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTt9Y29udGV4dC5fY3VycmVudFJlbmRlcmVyPXJlbmRlcmVyU2lnaWw7fX19ZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCxwcm92aWRlckZpYmVyKXt2YXIgY3VycmVudFZhbHVlPXZhbHVlQ3Vyc29yLmN1cnJlbnQ7cG9wKHZhbHVlQ3Vyc29yLHByb3ZpZGVyRmliZXIpO3t7Y29udGV4dC5fY3VycmVudFZhbHVlPWN1cnJlbnRWYWx1ZTt9fX1mdW5jdGlvbiBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKHBhcmVudCxyZW5kZXJMYW5lcyxwcm9wYWdhdGlvblJvb3Qpey8vIFVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMgb2YgYWxsIHRoZSBhbmNlc3RvcnMsIGluY2x1ZGluZyB0aGUgYWx0ZXJuYXRlcy5cbnZhciBub2RlPXBhcmVudDt3aGlsZShub2RlIT09bnVsbCl7dmFyIGFsdGVybmF0ZT1ub2RlLmFsdGVybmF0ZTtpZighaXNTdWJzZXRPZkxhbmVzKG5vZGUuY2hpbGRMYW5lcyxyZW5kZXJMYW5lcykpe25vZGUuY2hpbGRMYW5lcz1tZXJnZUxhbmVzKG5vZGUuY2hpbGRMYW5lcyxyZW5kZXJMYW5lcyk7aWYoYWx0ZXJuYXRlIT09bnVsbCl7YWx0ZXJuYXRlLmNoaWxkTGFuZXM9bWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcyxyZW5kZXJMYW5lcyk7fX1lbHNlIGlmKGFsdGVybmF0ZSE9PW51bGwmJiFpc1N1YnNldE9mTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMscmVuZGVyTGFuZXMpKXthbHRlcm5hdGUuY2hpbGRMYW5lcz1tZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLHJlbmRlckxhbmVzKTt9aWYobm9kZT09PXByb3BhZ2F0aW9uUm9vdCl7YnJlYWs7fW5vZGU9bm9kZS5yZXR1cm47fXtpZihub2RlIT09cHJvcGFnYXRpb25Sb290KXtlcnJvcignRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJvcGFnYXRpb24gcm9vdCB3aGVuIHNjaGVkdWxpbmcgY29udGV4dCB3b3JrLiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319fWZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsY29udGV4dCxyZW5kZXJMYW5lcyl7e3Byb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIod29ya0luUHJvZ3Jlc3MsY29udGV4dCxyZW5kZXJMYW5lcyk7fX1mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLGNvbnRleHQscmVuZGVyTGFuZXMpe3ZhciBmaWJlcj13b3JrSW5Qcm9ncmVzcy5jaGlsZDtpZihmaWJlciE9PW51bGwpey8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuZmliZXIucmV0dXJuPXdvcmtJblByb2dyZXNzO313aGlsZShmaWJlciE9PW51bGwpe3ZhciBuZXh0RmliZXI9dm9pZCAwOy8vIFZpc2l0IHRoaXMgZmliZXIuXG52YXIgbGlzdD1maWJlci5kZXBlbmRlbmNpZXM7aWYobGlzdCE9PW51bGwpe25leHRGaWJlcj1maWJlci5jaGlsZDt2YXIgZGVwZW5kZW5jeT1saXN0LmZpcnN0Q29udGV4dDt3aGlsZShkZXBlbmRlbmN5IT09bnVsbCl7Ly8gQ2hlY2sgaWYgdGhlIGNvbnRleHQgbWF0Y2hlcy5cbmlmKGRlcGVuZGVuY3kuY29udGV4dD09PWNvbnRleHQpey8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cbmlmKGZpYmVyLnRhZz09PUNsYXNzQ29tcG9uZW50KXsvLyBTY2hlZHVsZSBhIGZvcmNlIHVwZGF0ZSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcy5cbnZhciBsYW5lPXBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTt2YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCxsYW5lKTt1cGRhdGUudGFnPUZvcmNlVXBkYXRlOy8vIFRPRE86IEJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHdvcmstaW4tcHJvZ3Jlc3MsIHRoaXMgd2lsbCBhZGQgdGhlXG4vLyB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgZmliZXIsIHRvbywgd2hpY2ggbWVhbnMgaXQgd2lsbCBwZXJzaXN0IGV2ZW4gaWZcbi8vIHRoaXMgcmVuZGVyIGlzIHRocm93biBhd2F5LiBTaW5jZSBpdCdzIGEgcmFjZSBjb25kaXRpb24sIG5vdCBzdXJlIGl0J3Ncbi8vIHdvcnRoIGZpeGluZy5cbi8vIElubGluZWQgYGVucXVldWVVcGRhdGVgIHRvIHJlbW92ZSBpbnRlcmxlYXZlZCB1cGRhdGUgY2hlY2tcbnZhciB1cGRhdGVRdWV1ZT1maWJlci51cGRhdGVRdWV1ZTtpZih1cGRhdGVRdWV1ZT09PW51bGwpO2Vsc2V7dmFyIHNoYXJlZFF1ZXVlPXVwZGF0ZVF1ZXVlLnNoYXJlZDt2YXIgcGVuZGluZz1zaGFyZWRRdWV1ZS5wZW5kaW5nO2lmKHBlbmRpbmc9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG51cGRhdGUubmV4dD11cGRhdGU7fWVsc2V7dXBkYXRlLm5leHQ9cGVuZGluZy5uZXh0O3BlbmRpbmcubmV4dD11cGRhdGU7fXNoYXJlZFF1ZXVlLnBlbmRpbmc9dXBkYXRlO319ZmliZXIubGFuZXM9bWVyZ2VMYW5lcyhmaWJlci5sYW5lcyxyZW5kZXJMYW5lcyk7dmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGU7aWYoYWx0ZXJuYXRlIT09bnVsbCl7YWx0ZXJuYXRlLmxhbmVzPW1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLHJlbmRlckxhbmVzKTt9c2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChmaWJlci5yZXR1cm4scmVuZGVyTGFuZXMsd29ya0luUHJvZ3Jlc3MpOy8vIE1hcmsgdGhlIHVwZGF0ZWQgbGFuZXMgb24gdGhlIGxpc3QsIHRvby5cbmxpc3QubGFuZXM9bWVyZ2VMYW5lcyhsaXN0LmxhbmVzLHJlbmRlckxhbmVzKTsvLyBTaW5jZSB3ZSBhbHJlYWR5IGZvdW5kIGEgbWF0Y2gsIHdlIGNhbiBzdG9wIHRyYXZlcnNpbmcgdGhlXG4vLyBkZXBlbmRlbmN5IGxpc3QuXG5icmVhazt9ZGVwZW5kZW5jeT1kZXBlbmRlbmN5Lm5leHQ7fX1lbHNlIGlmKGZpYmVyLnRhZz09PUNvbnRleHRQcm92aWRlcil7Ly8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG5uZXh0RmliZXI9ZmliZXIudHlwZT09PXdvcmtJblByb2dyZXNzLnR5cGU/bnVsbDpmaWJlci5jaGlsZDt9ZWxzZSBpZihmaWJlci50YWc9PT1EZWh5ZHJhdGVkRnJhZ21lbnQpey8vIElmIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBpcyBpbiB0aGlzIHN1YnRyZWUsIHdlIGRvbid0IGtub3dcbi8vIGlmIGl0IHdpbGwgaGF2ZSBhbnkgY29udGV4dCBjb25zdW1lcnMgaW4gaXQuIFRoZSBiZXN0IHdlIGNhbiBkbyBpc1xuLy8gbWFyayBpdCBhcyBoYXZpbmcgdXBkYXRlcy5cbnZhciBwYXJlbnRTdXNwZW5zZT1maWJlci5yZXR1cm47aWYocGFyZW50U3VzcGVuc2U9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1dlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7fXBhcmVudFN1c3BlbnNlLmxhbmVzPW1lcmdlTGFuZXMocGFyZW50U3VzcGVuc2UubGFuZXMscmVuZGVyTGFuZXMpO3ZhciBfYWx0ZXJuYXRlPXBhcmVudFN1c3BlbnNlLmFsdGVybmF0ZTtpZihfYWx0ZXJuYXRlIT09bnVsbCl7X2FsdGVybmF0ZS5sYW5lcz1tZXJnZUxhbmVzKF9hbHRlcm5hdGUubGFuZXMscmVuZGVyTGFuZXMpO30vLyBUaGlzIGlzIGludGVudGlvbmFsbHkgcGFzc2luZyB0aGlzIGZpYmVyIGFzIHRoZSBwYXJlbnRcbi8vIGJlY2F1c2Ugd2Ugd2FudCB0byBzY2hlZHVsZSB0aGlzIGZpYmVyIGFzIGhhdmluZyB3b3JrXG4vLyBvbiBpdHMgY2hpbGRyZW4uIFdlJ2xsIHVzZSB0aGUgY2hpbGRMYW5lcyBvblxuLy8gdGhpcyBmaWJlciB0byBpbmRpY2F0ZSB0aGF0IGEgY29udGV4dCBoYXMgY2hhbmdlZC5cbnNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgocGFyZW50U3VzcGVuc2UscmVuZGVyTGFuZXMsd29ya0luUHJvZ3Jlc3MpO25leHRGaWJlcj1maWJlci5zaWJsaW5nO31lbHNley8vIFRyYXZlcnNlIGRvd24uXG5uZXh0RmliZXI9ZmliZXIuY2hpbGQ7fWlmKG5leHRGaWJlciE9PW51bGwpey8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxubmV4dEZpYmVyLnJldHVybj1maWJlcjt9ZWxzZXsvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxubmV4dEZpYmVyPWZpYmVyO3doaWxlKG5leHRGaWJlciE9PW51bGwpe2lmKG5leHRGaWJlcj09PXdvcmtJblByb2dyZXNzKXsvLyBXZSdyZSBiYWNrIHRvIHRoZSByb290IG9mIHRoaXMgc3VidHJlZS4gRXhpdC5cbm5leHRGaWJlcj1udWxsO2JyZWFrO312YXIgc2libGluZz1uZXh0RmliZXIuc2libGluZztpZihzaWJsaW5nIT09bnVsbCl7Ly8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbnNpYmxpbmcucmV0dXJuPW5leHRGaWJlci5yZXR1cm47bmV4dEZpYmVyPXNpYmxpbmc7YnJlYWs7fS8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxubmV4dEZpYmVyPW5leHRGaWJlci5yZXR1cm47fX1maWJlcj1uZXh0RmliZXI7fX1mdW5jdGlvbiBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7Y3VycmVudGx5UmVuZGVyaW5nRmliZXI9d29ya0luUHJvZ3Jlc3M7bGFzdENvbnRleHREZXBlbmRlbmN5PW51bGw7bGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0PW51bGw7dmFyIGRlcGVuZGVuY2llcz13b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7aWYoZGVwZW5kZW5jaWVzIT09bnVsbCl7e3ZhciBmaXJzdENvbnRleHQ9ZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtpZihmaXJzdENvbnRleHQhPT1udWxsKXtpZihpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcyxyZW5kZXJMYW5lcykpey8vIENvbnRleHQgbGlzdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS4gTWFyayB0aGF0IHRoaXMgZmliZXIgcGVyZm9ybWVkIHdvcmsuXG5tYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO30vLyBSZXNldCB0aGUgd29yay1pbi1wcm9ncmVzcyBsaXN0XG5kZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0PW51bGw7fX19fWZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpe3svLyBUaGlzIHdhcm5pbmcgd291bGQgZmlyZSBpZiB5b3UgcmVhZCBjb250ZXh0IGluc2lkZSBhIEhvb2sgbGlrZSB1c2VNZW1vLlxuLy8gVW5saWtlIHRoZSBjbGFzcyBjaGVjayBiZWxvdywgaXQncyBub3QgZW5mb3JjZWQgaW4gcHJvZHVjdGlvbiBmb3IgcGVyZi5cbmlmKGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYpe2Vycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnKydJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnKydJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJysnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTt9fXZhciB2YWx1ZT1jb250ZXh0Ll9jdXJyZW50VmFsdWU7aWYobGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0PT09Y29udGV4dCk7ZWxzZXt2YXIgY29udGV4dEl0ZW09e2NvbnRleHQ6Y29udGV4dCxtZW1vaXplZFZhbHVlOnZhbHVlLG5leHQ6bnVsbH07aWYobGFzdENvbnRleHREZXBlbmRlbmN5PT09bnVsbCl7aWYoY3VycmVudGx5UmVuZGVyaW5nRmliZXI9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcrJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcrJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnKydpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO30vLyBUaGlzIGlzIHRoZSBmaXJzdCBkZXBlbmRlbmN5IGZvciB0aGlzIGNvbXBvbmVudC4gQ3JlYXRlIGEgbmV3IGxpc3QuXG5sYXN0Q29udGV4dERlcGVuZGVuY3k9Y29udGV4dEl0ZW07Y3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzPXtsYW5lczpOb0xhbmVzLGZpcnN0Q29udGV4dDpjb250ZXh0SXRlbX07fWVsc2V7Ly8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbmxhc3RDb250ZXh0RGVwZW5kZW5jeT1sYXN0Q29udGV4dERlcGVuZGVuY3kubmV4dD1jb250ZXh0SXRlbTt9fXJldHVybiB2YWx1ZTt9Ly8gcmVuZGVyLiBXaGVuIHRoaXMgcmVuZGVyIGV4aXRzLCBlaXRoZXIgYmVjYXVzZSBpdCBmaW5pc2hlcyBvciBiZWNhdXNlIGl0IGlzXG4vLyBpbnRlcnJ1cHRlZCwgdGhlIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbCBiZSB0cmFuc2ZlcnJlZCBvbnRvIHRoZSBtYWluIHBhcnRcbi8vIG9mIHRoZSBxdWV1ZS5cbnZhciBjb25jdXJyZW50UXVldWVzPW51bGw7ZnVuY3Rpb24gcHVzaENvbmN1cnJlbnRVcGRhdGVRdWV1ZShxdWV1ZSl7aWYoY29uY3VycmVudFF1ZXVlcz09PW51bGwpe2NvbmN1cnJlbnRRdWV1ZXM9W3F1ZXVlXTt9ZWxzZXtjb25jdXJyZW50UXVldWVzLnB1c2gocXVldWUpO319ZnVuY3Rpb24gZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpey8vIFRyYW5zZmVyIHRoZSBpbnRlcmxlYXZlZCB1cGRhdGVzIG9udG8gdGhlIG1haW4gcXVldWUuIEVhY2ggcXVldWUgaGFzIGFcbi8vIGBwZW5kaW5nYCBmaWVsZCBhbmQgYW4gYGludGVybGVhdmVkYCBmaWVsZC4gV2hlbiB0aGV5IGFyZSBub3QgbnVsbCwgdGhleVxuLy8gcG9pbnQgdG8gdGhlIGxhc3Qgbm9kZSBpbiBhIGNpcmN1bGFyIGxpbmtlZCBsaXN0LiBXZSBuZWVkIHRvIGFwcGVuZCB0aGVcbi8vIGludGVybGVhdmVkIGxpc3QgdG8gdGhlIGVuZCBvZiB0aGUgcGVuZGluZyBsaXN0IGJ5IGpvaW5pbmcgdGhlbSBpbnRvIGFcbi8vIHNpbmdsZSwgY2lyY3VsYXIgbGlzdC5cbmlmKGNvbmN1cnJlbnRRdWV1ZXMhPT1udWxsKXtmb3IodmFyIGk9MDtpPGNvbmN1cnJlbnRRdWV1ZXMubGVuZ3RoO2krKyl7dmFyIHF1ZXVlPWNvbmN1cnJlbnRRdWV1ZXNbaV07dmFyIGxhc3RJbnRlcmxlYXZlZFVwZGF0ZT1xdWV1ZS5pbnRlcmxlYXZlZDtpZihsYXN0SW50ZXJsZWF2ZWRVcGRhdGUhPT1udWxsKXtxdWV1ZS5pbnRlcmxlYXZlZD1udWxsO3ZhciBmaXJzdEludGVybGVhdmVkVXBkYXRlPWxhc3RJbnRlcmxlYXZlZFVwZGF0ZS5uZXh0O3ZhciBsYXN0UGVuZGluZ1VwZGF0ZT1xdWV1ZS5wZW5kaW5nO2lmKGxhc3RQZW5kaW5nVXBkYXRlIT09bnVsbCl7dmFyIGZpcnN0UGVuZGluZ1VwZGF0ZT1sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ9Zmlyc3RJbnRlcmxlYXZlZFVwZGF0ZTtsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dD1maXJzdFBlbmRpbmdVcGRhdGU7fXF1ZXVlLnBlbmRpbmc9bGFzdEludGVybGVhdmVkVXBkYXRlO319Y29uY3VycmVudFF1ZXVlcz1udWxsO319ZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLHF1ZXVlLHVwZGF0ZSxsYW5lKXt2YXIgaW50ZXJsZWF2ZWQ9cXVldWUuaW50ZXJsZWF2ZWQ7aWYoaW50ZXJsZWF2ZWQ9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG51cGRhdGUubmV4dD11cGRhdGU7Ly8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbi8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxucHVzaENvbmN1cnJlbnRVcGRhdGVRdWV1ZShxdWV1ZSk7fWVsc2V7dXBkYXRlLm5leHQ9aW50ZXJsZWF2ZWQubmV4dDtpbnRlcmxlYXZlZC5uZXh0PXVwZGF0ZTt9cXVldWUuaW50ZXJsZWF2ZWQ9dXBkYXRlO3JldHVybiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlcixsYW5lKTt9ZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlQW5kRWFnZXJseUJhaWxvdXQoZmliZXIscXVldWUsdXBkYXRlLGxhbmUpe3ZhciBpbnRlcmxlYXZlZD1xdWV1ZS5pbnRlcmxlYXZlZDtpZihpbnRlcmxlYXZlZD09PW51bGwpey8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbnVwZGF0ZS5uZXh0PXVwZGF0ZTsvLyBBdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHJlbmRlciwgdGhpcyBxdWV1ZSdzIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbFxuLy8gYmUgdHJhbnNmZXJyZWQgdG8gdGhlIHBlbmRpbmcgcXVldWUuXG5wdXNoQ29uY3VycmVudFVwZGF0ZVF1ZXVlKHF1ZXVlKTt9ZWxzZXt1cGRhdGUubmV4dD1pbnRlcmxlYXZlZC5uZXh0O2ludGVybGVhdmVkLm5leHQ9dXBkYXRlO31xdWV1ZS5pbnRlcmxlYXZlZD11cGRhdGU7fWZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUoZmliZXIscXVldWUsdXBkYXRlLGxhbmUpe3ZhciBpbnRlcmxlYXZlZD1xdWV1ZS5pbnRlcmxlYXZlZDtpZihpbnRlcmxlYXZlZD09PW51bGwpey8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbnVwZGF0ZS5uZXh0PXVwZGF0ZTsvLyBBdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHJlbmRlciwgdGhpcyBxdWV1ZSdzIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbFxuLy8gYmUgdHJhbnNmZXJyZWQgdG8gdGhlIHBlbmRpbmcgcXVldWUuXG5wdXNoQ29uY3VycmVudFVwZGF0ZVF1ZXVlKHF1ZXVlKTt9ZWxzZXt1cGRhdGUubmV4dD1pbnRlcmxlYXZlZC5uZXh0O2ludGVybGVhdmVkLm5leHQ9dXBkYXRlO31xdWV1ZS5pbnRlcmxlYXZlZD11cGRhdGU7cmV0dXJuIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLGxhbmUpO31mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsbGFuZSl7cmV0dXJuIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLGxhbmUpO30vLyBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSBzaG91bGQgb25seSBiZSBkb25lIGZvciBiYWNrd2FyZHNcbi8vIGNvbXBhdGliaWxpdHkgYW5kIHNob3VsZCBhbHdheXMgYmUgYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nLlxudmFyIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdD1tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdDtmdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlcixsYW5lKXsvLyBVcGRhdGUgdGhlIHNvdXJjZSBmaWJlcidzIGxhbmVzXG5zb3VyY2VGaWJlci5sYW5lcz1tZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLGxhbmUpO3ZhciBhbHRlcm5hdGU9c291cmNlRmliZXIuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZSE9PW51bGwpe2FsdGVybmF0ZS5sYW5lcz1tZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcyxsYW5lKTt9e2lmKGFsdGVybmF0ZT09PW51bGwmJihzb3VyY2VGaWJlci5mbGFncyYoUGxhY2VtZW50fEh5ZHJhdGluZykpIT09Tm9GbGFncyl7d2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7fX0vLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIHRoZSBjaGlsZCBsYW5lcy5cbnZhciBub2RlPXNvdXJjZUZpYmVyO3ZhciBwYXJlbnQ9c291cmNlRmliZXIucmV0dXJuO3doaWxlKHBhcmVudCE9PW51bGwpe3BhcmVudC5jaGlsZExhbmVzPW1lcmdlTGFuZXMocGFyZW50LmNoaWxkTGFuZXMsbGFuZSk7YWx0ZXJuYXRlPXBhcmVudC5hbHRlcm5hdGU7aWYoYWx0ZXJuYXRlIT09bnVsbCl7YWx0ZXJuYXRlLmNoaWxkTGFuZXM9bWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcyxsYW5lKTt9ZWxzZXt7aWYoKHBhcmVudC5mbGFncyYoUGxhY2VtZW50fEh5ZHJhdGluZykpIT09Tm9GbGFncyl7d2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7fX19bm9kZT1wYXJlbnQ7cGFyZW50PXBhcmVudC5yZXR1cm47fWlmKG5vZGUudGFnPT09SG9zdFJvb3Qpe3ZhciByb290PW5vZGUuc3RhdGVOb2RlO3JldHVybiByb290O31lbHNle3JldHVybiBudWxsO319dmFyIFVwZGF0ZVN0YXRlPTA7dmFyIFJlcGxhY2VTdGF0ZT0xO3ZhciBGb3JjZVVwZGF0ZT0yO3ZhciBDYXB0dXJlVXBkYXRlPTM7Ly8gR2xvYmFsIHN0YXRlIHRoYXQgaXMgcmVzZXQgYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLlxuLy8gSXQgc2hvdWxkIG9ubHkgYmUgcmVhZCByaWdodCBhZnRlciBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLCB2aWFcbi8vIGBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nYC5cbnZhciBoYXNGb3JjZVVwZGF0ZT1mYWxzZTt2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZTt2YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO3tkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlPWZhbHNlO2N1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZT1udWxsO31mdW5jdGlvbiBpbml0aWFsaXplVXBkYXRlUXVldWUoZmliZXIpe3ZhciBxdWV1ZT17YmFzZVN0YXRlOmZpYmVyLm1lbW9pemVkU3RhdGUsZmlyc3RCYXNlVXBkYXRlOm51bGwsbGFzdEJhc2VVcGRhdGU6bnVsbCxzaGFyZWQ6e3BlbmRpbmc6bnVsbCxpbnRlcmxlYXZlZDpudWxsLGxhbmVzOk5vTGFuZXN9LGVmZmVjdHM6bnVsbH07ZmliZXIudXBkYXRlUXVldWU9cXVldWU7fWZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyl7Ly8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbnZhciBxdWV1ZT13b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTt2YXIgY3VycmVudFF1ZXVlPWN1cnJlbnQudXBkYXRlUXVldWU7aWYocXVldWU9PT1jdXJyZW50UXVldWUpe3ZhciBjbG9uZT17YmFzZVN0YXRlOmN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUsbGFzdEJhc2VVcGRhdGU6Y3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlLHNoYXJlZDpjdXJyZW50UXVldWUuc2hhcmVkLGVmZmVjdHM6Y3VycmVudFF1ZXVlLmVmZmVjdHN9O3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPWNsb25lO319ZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSxsYW5lKXt2YXIgdXBkYXRlPXtldmVudFRpbWU6ZXZlbnRUaW1lLGxhbmU6bGFuZSx0YWc6VXBkYXRlU3RhdGUscGF5bG9hZDpudWxsLGNhbGxiYWNrOm51bGwsbmV4dDpudWxsfTtyZXR1cm4gdXBkYXRlO31mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLHVwZGF0ZSxsYW5lKXt2YXIgdXBkYXRlUXVldWU9ZmliZXIudXBkYXRlUXVldWU7aWYodXBkYXRlUXVldWU9PT1udWxsKXsvLyBPbmx5IG9jY3VycyBpZiB0aGUgZmliZXIgaGFzIGJlZW4gdW5tb3VudGVkLlxucmV0dXJuIG51bGw7fXZhciBzaGFyZWRRdWV1ZT11cGRhdGVRdWV1ZS5zaGFyZWQ7e2lmKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZT09PXNoYXJlZFF1ZXVlJiYhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSl7ZXJyb3IoJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJysnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnKyd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnKydjYWxsYmFjay4nKTtkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlPXRydWU7fX1pZihpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUoKSl7Ly8gVGhpcyBpcyBhbiB1bnNhZmUgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gQWRkIGRpcmVjdGx5IHRvIHRoZSB1cGRhdGVcbi8vIHF1ZXVlIHNvIHdlIGNhbiBwcm9jZXNzIGl0IGltbWVkaWF0ZWx5IGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIuXG52YXIgcGVuZGluZz1zaGFyZWRRdWV1ZS5wZW5kaW5nO2lmKHBlbmRpbmc9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG51cGRhdGUubmV4dD11cGRhdGU7fWVsc2V7dXBkYXRlLm5leHQ9cGVuZGluZy5uZXh0O3BlbmRpbmcubmV4dD11cGRhdGU7fXNoYXJlZFF1ZXVlLnBlbmRpbmc9dXBkYXRlOy8vIFVwZGF0ZSB0aGUgY2hpbGRMYW5lcyBldmVuIHRob3VnaCB3ZSdyZSBtb3N0IGxpa2VseSBhbHJlYWR5IHJlbmRlcmluZ1xuLy8gdGhpcyBmaWJlci4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgaW4gdGhlIGNhc2Ugd2hlcmUgeW91XG4vLyB1cGRhdGUgYSBkaWZmZXJlbnQgY29tcG9uZW50IGR1cmluZyByZW5kZXIgcGhhc2UgdGhhbiB0aGUgb25lIHRoYXQgaXNcbi8vIGN1cnJlbnRseSByZW5kZXJpbmdzIChhIHBhdHRlcm4gdGhhdCBpcyBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcpLlxucmV0dXJuIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlcixsYW5lKTt9ZWxzZXtyZXR1cm4gZW5xdWV1ZUNvbmN1cnJlbnRDbGFzc1VwZGF0ZShmaWJlcixzaGFyZWRRdWV1ZSx1cGRhdGUsbGFuZSk7fX1mdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsZmliZXIsbGFuZSl7dmFyIHVwZGF0ZVF1ZXVlPWZpYmVyLnVwZGF0ZVF1ZXVlO2lmKHVwZGF0ZVF1ZXVlPT09bnVsbCl7Ly8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbnJldHVybjt9dmFyIHNoYXJlZFF1ZXVlPXVwZGF0ZVF1ZXVlLnNoYXJlZDtpZihpc1RyYW5zaXRpb25MYW5lKGxhbmUpKXt2YXIgcXVldWVMYW5lcz1zaGFyZWRRdWV1ZS5sYW5lczsvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5IG11c3Rcbi8vIGhhdmUgZmluaXNoZWQuIFdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBzaGFyZWQgcXVldWUsIHdoaWNoIHJlcHJlc2VudHNcbi8vIGEgc3VwZXJzZXQgb2YgdGhlIGFjdHVhbGx5IHBlbmRpbmcgbGFuZXMuIEluIHNvbWUgY2FzZXMgd2UgbWF5IGVudGFuZ2xlXG4vLyBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmIHdlICpkb24ndCpcbi8vIGVudGFuZ2xlIHdoZW4gd2Ugc2hvdWxkLlxucXVldWVMYW5lcz1pbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLHJvb3QucGVuZGluZ0xhbmVzKTsvLyBFbnRhbmdsZSB0aGUgbmV3IHRyYW5zaXRpb24gbGFuZSB3aXRoIHRoZSBvdGhlciB0cmFuc2l0aW9uIGxhbmVzLlxudmFyIG5ld1F1ZXVlTGFuZXM9bWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLGxhbmUpO3NoYXJlZFF1ZXVlLmxhbmVzPW5ld1F1ZXVlTGFuZXM7Ly8gRXZlbiBpZiBxdWV1ZS5sYW5lcyBhbHJlYWR5IGluY2x1ZGUgbGFuZSwgd2UgZG9uJ3Qga25vdyBmb3IgY2VydGFpbiBpZlxuLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbi8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5tYXJrUm9vdEVudGFuZ2xlZChyb290LG5ld1F1ZXVlTGFuZXMpO319ZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLGNhcHR1cmVkVXBkYXRlKXsvLyBDYXB0dXJlZCB1cGRhdGVzIGFyZSB1cGRhdGVzIHRoYXQgYXJlIHRocm93biBieSBhIGNoaWxkIGR1cmluZyB0aGUgcmVuZGVyXG4vLyBwaGFzZS4gVGhleSBzaG91bGQgYmUgZGlzY2FyZGVkIGlmIHRoZSByZW5kZXIgaXMgYWJvcnRlZC4gVGhlcmVmb3JlLFxuLy8gd2Ugc2hvdWxkIG9ubHkgcHV0IHRoZW0gb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIG5vdCB0aGUgY3VycmVudCBvbmUuXG52YXIgcXVldWU9d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7Ly8gQ2hlY2sgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYSBjbG9uZS5cbnZhciBjdXJyZW50PXdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtpZihjdXJyZW50IT09bnVsbCl7dmFyIGN1cnJlbnRRdWV1ZT1jdXJyZW50LnVwZGF0ZVF1ZXVlO2lmKHF1ZXVlPT09Y3VycmVudFF1ZXVlKXsvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlblxuLy8gd2UgYmFpbCBvdXQgb24gYSBwYXJlbnQgZmliZXIgdGhhdCB0aGVuIGNhcHR1cmVzIGFuIGVycm9yIHRocm93biBieVxuLy8gYSBjaGlsZC4gU2luY2Ugd2Ugd2FudCB0byBhcHBlbmQgdGhlIHVwZGF0ZSBvbmx5IHRvIHRoZSB3b3JrLWluXG4vLyAtcHJvZ3Jlc3MgcXVldWUsIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHVwZGF0ZXMuIFdlIHVzdWFsbHkgY2xvbmUgZHVyaW5nXG4vLyBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCB0aGF0IGRpZG4ndCBoYXBwZW4gaW4gdGhpcyBjYXNlIGJlY2F1c2Ugd2Vcbi8vIHNraXBwZWQgb3ZlciB0aGUgcGFyZW50IHdoZW4gd2UgYmFpbGVkIG91dC5cbnZhciBuZXdGaXJzdD1udWxsO3ZhciBuZXdMYXN0PW51bGw7dmFyIGZpcnN0QmFzZVVwZGF0ZT1xdWV1ZS5maXJzdEJhc2VVcGRhdGU7aWYoZmlyc3RCYXNlVXBkYXRlIT09bnVsbCl7Ly8gTG9vcCB0aHJvdWdoIHRoZSB1cGRhdGVzIGFuZCBjbG9uZSB0aGVtLlxudmFyIHVwZGF0ZT1maXJzdEJhc2VVcGRhdGU7ZG97dmFyIGNsb25lPXtldmVudFRpbWU6dXBkYXRlLmV2ZW50VGltZSxsYW5lOnVwZGF0ZS5sYW5lLHRhZzp1cGRhdGUudGFnLHBheWxvYWQ6dXBkYXRlLnBheWxvYWQsY2FsbGJhY2s6dXBkYXRlLmNhbGxiYWNrLG5leHQ6bnVsbH07aWYobmV3TGFzdD09PW51bGwpe25ld0ZpcnN0PW5ld0xhc3Q9Y2xvbmU7fWVsc2V7bmV3TGFzdC5uZXh0PWNsb25lO25ld0xhc3Q9Y2xvbmU7fXVwZGF0ZT11cGRhdGUubmV4dDt9d2hpbGUodXBkYXRlIT09bnVsbCk7Ly8gQXBwZW5kIHRoZSBjYXB0dXJlZCB1cGRhdGUgdGhlIGVuZCBvZiB0aGUgY2xvbmVkIGxpc3QuXG5pZihuZXdMYXN0PT09bnVsbCl7bmV3Rmlyc3Q9bmV3TGFzdD1jYXB0dXJlZFVwZGF0ZTt9ZWxzZXtuZXdMYXN0Lm5leHQ9Y2FwdHVyZWRVcGRhdGU7bmV3TGFzdD1jYXB0dXJlZFVwZGF0ZTt9fWVsc2V7Ly8gVGhlcmUgYXJlIG5vIGJhc2UgdXBkYXRlcy5cbm5ld0ZpcnN0PW5ld0xhc3Q9Y2FwdHVyZWRVcGRhdGU7fXF1ZXVlPXtiYXNlU3RhdGU6Y3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6bmV3Rmlyc3QsbGFzdEJhc2VVcGRhdGU6bmV3TGFzdCxzaGFyZWQ6Y3VycmVudFF1ZXVlLnNoYXJlZCxlZmZlY3RzOmN1cnJlbnRRdWV1ZS5lZmZlY3RzfTt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1xdWV1ZTtyZXR1cm47fX0vLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxudmFyIGxhc3RCYXNlVXBkYXRlPXF1ZXVlLmxhc3RCYXNlVXBkYXRlO2lmKGxhc3RCYXNlVXBkYXRlPT09bnVsbCl7cXVldWUuZmlyc3RCYXNlVXBkYXRlPWNhcHR1cmVkVXBkYXRlO31lbHNle2xhc3RCYXNlVXBkYXRlLm5leHQ9Y2FwdHVyZWRVcGRhdGU7fXF1ZXVlLmxhc3RCYXNlVXBkYXRlPWNhcHR1cmVkVXBkYXRlO31mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MscXVldWUsdXBkYXRlLHByZXZTdGF0ZSxuZXh0UHJvcHMsaW5zdGFuY2Upe3N3aXRjaCh1cGRhdGUudGFnKXtjYXNlIFJlcGxhY2VTdGF0ZTp7dmFyIHBheWxvYWQ9dXBkYXRlLnBheWxvYWQ7aWYodHlwZW9mIHBheWxvYWQ9PT0nZnVuY3Rpb24nKXsvLyBVcGRhdGVyIGZ1bmN0aW9uXG57ZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO312YXIgbmV4dFN0YXRlPXBheWxvYWQuY2FsbChpbnN0YW5jZSxwcmV2U3RhdGUsbmV4dFByb3BzKTt7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTt0cnl7cGF5bG9hZC5jYWxsKGluc3RhbmNlLHByZXZTdGF0ZSxuZXh0UHJvcHMpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fWV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO31yZXR1cm4gbmV4dFN0YXRlO30vLyBTdGF0ZSBvYmplY3RcbnJldHVybiBwYXlsb2FkO31jYXNlIENhcHR1cmVVcGRhdGU6e3dvcmtJblByb2dyZXNzLmZsYWdzPXdvcmtJblByb2dyZXNzLmZsYWdzJn5TaG91bGRDYXB0dXJlfERpZENhcHR1cmU7fS8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5jYXNlIFVwZGF0ZVN0YXRlOnt2YXIgX3BheWxvYWQ9dXBkYXRlLnBheWxvYWQ7dmFyIHBhcnRpYWxTdGF0ZTtpZih0eXBlb2YgX3BheWxvYWQ9PT0nZnVuY3Rpb24nKXsvLyBVcGRhdGVyIGZ1bmN0aW9uXG57ZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO31wYXJ0aWFsU3RhdGU9X3BheWxvYWQuY2FsbChpbnN0YW5jZSxwcmV2U3RhdGUsbmV4dFByb3BzKTt7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTt0cnl7X3BheWxvYWQuY2FsbChpbnN0YW5jZSxwcmV2U3RhdGUsbmV4dFByb3BzKTt9ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX1leGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTt9fWVsc2V7Ly8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbnBhcnRpYWxTdGF0ZT1fcGF5bG9hZDt9aWYocGFydGlhbFN0YXRlPT09bnVsbHx8cGFydGlhbFN0YXRlPT09dW5kZWZpbmVkKXsvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxucmV0dXJuIHByZXZTdGF0ZTt9Ly8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cbnJldHVybiBhc3NpZ24oe30scHJldlN0YXRlLHBhcnRpYWxTdGF0ZSk7fWNhc2UgRm9yY2VVcGRhdGU6e2hhc0ZvcmNlVXBkYXRlPXRydWU7cmV0dXJuIHByZXZTdGF0ZTt9fXJldHVybiBwcmV2U3RhdGU7fWZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyxwcm9wcyxpbnN0YW5jZSxyZW5kZXJMYW5lcyl7Ly8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxudmFyIHF1ZXVlPXdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO2hhc0ZvcmNlVXBkYXRlPWZhbHNlO3tjdXJyZW50bHlQcm9jZXNzaW5nUXVldWU9cXVldWUuc2hhcmVkO312YXIgZmlyc3RCYXNlVXBkYXRlPXF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTt2YXIgbGFzdEJhc2VVcGRhdGU9cXVldWUubGFzdEJhc2VVcGRhdGU7Ly8gQ2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gSWYgc28sIHRyYW5zZmVyIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG52YXIgcGVuZGluZ1F1ZXVlPXF1ZXVlLnNoYXJlZC5wZW5kaW5nO2lmKHBlbmRpbmdRdWV1ZSE9PW51bGwpe3F1ZXVlLnNoYXJlZC5wZW5kaW5nPW51bGw7Ly8gVGhlIHBlbmRpbmcgcXVldWUgaXMgY2lyY3VsYXIuIERpc2Nvbm5lY3QgdGhlIHBvaW50ZXIgYmV0d2VlbiBmaXJzdFxuLy8gYW5kIGxhc3Qgc28gdGhhdCBpdCdzIG5vbi1jaXJjdWxhci5cbnZhciBsYXN0UGVuZGluZ1VwZGF0ZT1wZW5kaW5nUXVldWU7dmFyIGZpcnN0UGVuZGluZ1VwZGF0ZT1sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ9bnVsbDsvLyBBcHBlbmQgcGVuZGluZyB1cGRhdGVzIHRvIGJhc2UgcXVldWVcbmlmKGxhc3RCYXNlVXBkYXRlPT09bnVsbCl7Zmlyc3RCYXNlVXBkYXRlPWZpcnN0UGVuZGluZ1VwZGF0ZTt9ZWxzZXtsYXN0QmFzZVVwZGF0ZS5uZXh0PWZpcnN0UGVuZGluZ1VwZGF0ZTt9bGFzdEJhc2VVcGRhdGU9bGFzdFBlbmRpbmdVcGRhdGU7Ly8gSWYgdGhlcmUncyBhIGN1cnJlbnQgcXVldWUsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBiYXNlIHF1ZXVlLCB0aGVuXG4vLyB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZSB1cGRhdGVzIHRvIHRoYXQgcXVldWUsIHRvby4gQmVjYXVzZSB0aGUgYmFzZVxuLy8gcXVldWUgaXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgd2l0aCBubyBjeWNsZXMsIHdlIGNhbiBhcHBlbmQgdG8gYm90aFxuLy8gbGlzdHMgYW5kIHRha2UgYWR2YW50YWdlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy5cbi8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50XG52YXIgY3VycmVudD13b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7aWYoY3VycmVudCE9PW51bGwpey8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbnZhciBjdXJyZW50UXVldWU9Y3VycmVudC51cGRhdGVRdWV1ZTt2YXIgY3VycmVudExhc3RCYXNlVXBkYXRlPWN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZTtpZihjdXJyZW50TGFzdEJhc2VVcGRhdGUhPT1sYXN0QmFzZVVwZGF0ZSl7aWYoY3VycmVudExhc3RCYXNlVXBkYXRlPT09bnVsbCl7Y3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZT1maXJzdFBlbmRpbmdVcGRhdGU7fWVsc2V7Y3VycmVudExhc3RCYXNlVXBkYXRlLm5leHQ9Zmlyc3RQZW5kaW5nVXBkYXRlO31jdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGU9bGFzdFBlbmRpbmdVcGRhdGU7fX19Ly8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG5pZihmaXJzdEJhc2VVcGRhdGUhPT1udWxsKXsvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG52YXIgbmV3U3RhdGU9cXVldWUuYmFzZVN0YXRlOy8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlIHJlbmRlckxhbmVzXG4vLyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cbnZhciBuZXdMYW5lcz1Ob0xhbmVzO3ZhciBuZXdCYXNlU3RhdGU9bnVsbDt2YXIgbmV3Rmlyc3RCYXNlVXBkYXRlPW51bGw7dmFyIG5ld0xhc3RCYXNlVXBkYXRlPW51bGw7dmFyIHVwZGF0ZT1maXJzdEJhc2VVcGRhdGU7ZG97dmFyIHVwZGF0ZUxhbmU9dXBkYXRlLmxhbmU7dmFyIHVwZGF0ZUV2ZW50VGltZT11cGRhdGUuZXZlbnRUaW1lO2lmKCFpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsdXBkYXRlTGFuZSkpey8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3Rcbi8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuLy8gdXBkYXRlL3N0YXRlLlxudmFyIGNsb25lPXtldmVudFRpbWU6dXBkYXRlRXZlbnRUaW1lLGxhbmU6dXBkYXRlTGFuZSx0YWc6dXBkYXRlLnRhZyxwYXlsb2FkOnVwZGF0ZS5wYXlsb2FkLGNhbGxiYWNrOnVwZGF0ZS5jYWxsYmFjayxuZXh0Om51bGx9O2lmKG5ld0xhc3RCYXNlVXBkYXRlPT09bnVsbCl7bmV3Rmlyc3RCYXNlVXBkYXRlPW5ld0xhc3RCYXNlVXBkYXRlPWNsb25lO25ld0Jhc2VTdGF0ZT1uZXdTdGF0ZTt9ZWxzZXtuZXdMYXN0QmFzZVVwZGF0ZT1uZXdMYXN0QmFzZVVwZGF0ZS5uZXh0PWNsb25lO30vLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG5uZXdMYW5lcz1tZXJnZUxhbmVzKG5ld0xhbmVzLHVwZGF0ZUxhbmUpO31lbHNley8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuaWYobmV3TGFzdEJhc2VVcGRhdGUhPT1udWxsKXt2YXIgX2Nsb25lPXtldmVudFRpbWU6dXBkYXRlRXZlbnRUaW1lLC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4vLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4vLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG5sYW5lOk5vTGFuZSx0YWc6dXBkYXRlLnRhZyxwYXlsb2FkOnVwZGF0ZS5wYXlsb2FkLGNhbGxiYWNrOnVwZGF0ZS5jYWxsYmFjayxuZXh0Om51bGx9O25ld0xhc3RCYXNlVXBkYXRlPW5ld0xhc3RCYXNlVXBkYXRlLm5leHQ9X2Nsb25lO30vLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxubmV3U3RhdGU9Z2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLHF1ZXVlLHVwZGF0ZSxuZXdTdGF0ZSxwcm9wcyxpbnN0YW5jZSk7dmFyIGNhbGxiYWNrPXVwZGF0ZS5jYWxsYmFjaztpZihjYWxsYmFjayE9PW51bGwmJi8vIElmIHRoZSB1cGRhdGUgd2FzIGFscmVhZHkgY29tbWl0dGVkLCB3ZSBzaG91bGQgbm90IHF1ZXVlIGl0c1xuLy8gY2FsbGJhY2sgYWdhaW4uXG51cGRhdGUubGFuZSE9PU5vTGFuZSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PUNhbGxiYWNrO3ZhciBlZmZlY3RzPXF1ZXVlLmVmZmVjdHM7aWYoZWZmZWN0cz09PW51bGwpe3F1ZXVlLmVmZmVjdHM9W3VwZGF0ZV07fWVsc2V7ZWZmZWN0cy5wdXNoKHVwZGF0ZSk7fX19dXBkYXRlPXVwZGF0ZS5uZXh0O2lmKHVwZGF0ZT09PW51bGwpe3BlbmRpbmdRdWV1ZT1xdWV1ZS5zaGFyZWQucGVuZGluZztpZihwZW5kaW5nUXVldWU9PT1udWxsKXticmVhazt9ZWxzZXsvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhIHJlZHVjZXIuIEFkZCB0aGUgbmV3XG4vLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxudmFyIF9sYXN0UGVuZGluZ1VwZGF0ZT1wZW5kaW5nUXVldWU7Ly8gSW50ZW50aW9uYWxseSB1bnNvdW5kLiBQZW5kaW5nIHVwZGF0ZXMgZm9ybSBhIGNpcmN1bGFyIGxpc3QsIGJ1dCB3ZVxuLy8gdW5yYXZlbCB0aGVtIHdoZW4gdHJhbnNmZXJyaW5nIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG52YXIgX2ZpcnN0UGVuZGluZ1VwZGF0ZT1fbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtfbGFzdFBlbmRpbmdVcGRhdGUubmV4dD1udWxsO3VwZGF0ZT1fZmlyc3RQZW5kaW5nVXBkYXRlO3F1ZXVlLmxhc3RCYXNlVXBkYXRlPV9sYXN0UGVuZGluZ1VwZGF0ZTtxdWV1ZS5zaGFyZWQucGVuZGluZz1udWxsO319fXdoaWxlKHRydWUpO2lmKG5ld0xhc3RCYXNlVXBkYXRlPT09bnVsbCl7bmV3QmFzZVN0YXRlPW5ld1N0YXRlO31xdWV1ZS5iYXNlU3RhdGU9bmV3QmFzZVN0YXRlO3F1ZXVlLmZpcnN0QmFzZVVwZGF0ZT1uZXdGaXJzdEJhc2VVcGRhdGU7cXVldWUubGFzdEJhc2VVcGRhdGU9bmV3TGFzdEJhc2VVcGRhdGU7Ly8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuLy8gcHJvY2VzcyB0aGVtIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHdlIGRvIG5lZWQgdG8gdHJhY2sgd2hpY2ggbGFuZXNcbi8vIGFyZSByZW1haW5pbmcuXG52YXIgbGFzdEludGVybGVhdmVkPXF1ZXVlLnNoYXJlZC5pbnRlcmxlYXZlZDtpZihsYXN0SW50ZXJsZWF2ZWQhPT1udWxsKXt2YXIgaW50ZXJsZWF2ZWQ9bGFzdEludGVybGVhdmVkO2Rve25ld0xhbmVzPW1lcmdlTGFuZXMobmV3TGFuZXMsaW50ZXJsZWF2ZWQubGFuZSk7aW50ZXJsZWF2ZWQ9aW50ZXJsZWF2ZWQubmV4dDt9d2hpbGUoaW50ZXJsZWF2ZWQhPT1sYXN0SW50ZXJsZWF2ZWQpO31lbHNlIGlmKGZpcnN0QmFzZVVwZGF0ZT09PW51bGwpey8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4vLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxucXVldWUuc2hhcmVkLmxhbmVzPU5vTGFuZXM7fS8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuLy8gVGhpcyBzaG91bGQgYmUgZmluZSBiZWNhdXNlIHRoZSBvbmx5IHR3byBvdGhlciB0aGluZ3MgdGhhdCBjb250cmlidXRlIHRvXG4vLyBleHBpcmF0aW9uIHRpbWUgYXJlIHByb3BzIGFuZCBjb250ZXh0LiBXZSdyZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgdGhlXG4vLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuLy8gZGVhbHQgd2l0aCB0aGUgcHJvcHMuIENvbnRleHQgaW4gY29tcG9uZW50cyB0aGF0IHNwZWNpZnlcbi8vIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB0cmlja3k7IGJ1dCB3ZSdsbCBoYXZlIHRvIGFjY291bnQgZm9yXG4vLyB0aGF0IHJlZ2FyZGxlc3MuXG5tYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKG5ld0xhbmVzKTt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1uZXdMYW5lczt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW5ld1N0YXRlO317Y3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlPW51bGw7fX1mdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssY29udGV4dCl7aWYodHlwZW9mIGNhbGxiYWNrIT09J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCAnKyhcInJlY2VpdmVkOiBcIitjYWxsYmFjaykpO31jYWxsYmFjay5jYWxsKGNvbnRleHQpO31mdW5jdGlvbiByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpe2hhc0ZvcmNlVXBkYXRlPWZhbHNlO31mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCl7cmV0dXJuIGhhc0ZvcmNlVXBkYXRlO31mdW5jdGlvbiBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssZmluaXNoZWRRdWV1ZSxpbnN0YW5jZSl7Ly8gQ29tbWl0IHRoZSBlZmZlY3RzXG52YXIgZWZmZWN0cz1maW5pc2hlZFF1ZXVlLmVmZmVjdHM7ZmluaXNoZWRRdWV1ZS5lZmZlY3RzPW51bGw7aWYoZWZmZWN0cyE9PW51bGwpe2Zvcih2YXIgaT0wO2k8ZWZmZWN0cy5sZW5ndGg7aSsrKXt2YXIgZWZmZWN0PWVmZmVjdHNbaV07dmFyIGNhbGxiYWNrPWVmZmVjdC5jYWxsYmFjaztpZihjYWxsYmFjayE9PW51bGwpe2VmZmVjdC5jYWxsYmFjaz1udWxsO2NhbGxDYWxsYmFjayhjYWxsYmFjayxpbnN0YW5jZSk7fX19fXZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZT17fTsvLyBSZWFjdC5Db21wb25lbnQgdXNlcyBhIHNoYXJlZCBmcm96ZW4gb2JqZWN0IGJ5IGRlZmF1bHQuXG4vLyBXZSdsbCB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UgbmVlZCB0byBpbml0aWFsaXplIGxlZ2FjeSByZWZzLlxudmFyIGVtcHR5UmVmc09iamVjdD1uZXcgUmVhY3QuQ29tcG9uZW50KCkucmVmczt2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50O3ZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7dmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTt2YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZTt2YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO3ZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGU7dmFyIHdhcm5PbkludmFsaWRDYWxsYmFjazt2YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGU7dmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzO3ZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7e2RpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudD1uZXcgU2V0KCk7ZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGU9bmV3IFNldCgpO2RpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU9bmV3IFNldCgpO2RpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGU9bmV3IFNldCgpO2RpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU9bmV3IFNldCgpO3ZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2s9bmV3IFNldCgpO3dhcm5PbkludmFsaWRDYWxsYmFjaz1mdW5jdGlvbihjYWxsYmFjayxjYWxsZXJOYW1lKXtpZihjYWxsYmFjaz09PW51bGx8fHR5cGVvZiBjYWxsYmFjaz09PSdmdW5jdGlvbicpe3JldHVybjt9dmFyIGtleT1jYWxsZXJOYW1lKydfJytjYWxsYmFjaztpZighZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKXtkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7ZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnKydmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJyxjYWxsZXJOYW1lLGNhbGxiYWNrKTt9fTt3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGU9ZnVuY3Rpb24odHlwZSxwYXJ0aWFsU3RhdGUpe2lmKHBhcnRpYWxTdGF0ZT09PXVuZGVmaW5lZCl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSl7ZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnKydZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJyxjb21wb25lbnROYW1lKTt9fX07Ly8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4vLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4vLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4vLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4vLyBleGNlcHRpb24uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jyx7ZW51bWVyYWJsZTpmYWxzZSx2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcignX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5ICcrJ21lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCAnKydhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyAnK1widW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzbid0IHN1cHBvcnRlZC4gVHJ5IFwiKyd0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCAnKyd0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO319KTtPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTt9ZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsY3RvcixnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsbmV4dFByb3BzKXt2YXIgcHJldlN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7dmFyIHBhcnRpYWxTdGF0ZT1nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLHByZXZTdGF0ZSk7e2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5ey8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5wYXJ0aWFsU3RhdGU9Z2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcyxwcmV2U3RhdGUpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fXdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZShjdG9yLHBhcnRpYWxTdGF0ZSk7fS8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG52YXIgbWVtb2l6ZWRTdGF0ZT1wYXJ0aWFsU3RhdGU9PT1udWxsfHxwYXJ0aWFsU3RhdGU9PT11bmRlZmluZWQ/cHJldlN0YXRlOmFzc2lnbih7fSxwcmV2U3RhdGUscGFydGlhbFN0YXRlKTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW1lbW9pemVkU3RhdGU7Ly8gT25jZSB0aGUgdXBkYXRlIHF1ZXVlIGlzIGVtcHR5LCBwZXJzaXN0IHRoZSBkZXJpdmVkIHN0YXRlIG9udG8gdGhlXG4vLyBiYXNlIHN0YXRlLlxuaWYod29ya0luUHJvZ3Jlc3MubGFuZXM9PT1Ob0xhbmVzKXsvLyBRdWV1ZSBpcyBhbHdheXMgbm9uLW51bGwgZm9yIGNsYXNzZXNcbnZhciB1cGRhdGVRdWV1ZT13b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTt1cGRhdGVRdWV1ZS5iYXNlU3RhdGU9bWVtb2l6ZWRTdGF0ZTt9fXZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXI9e2lzTW91bnRlZDppc01vdW50ZWQsZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKGluc3QscGF5bG9hZCxjYWxsYmFjayl7dmFyIGZpYmVyPWdldChpbnN0KTt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTt2YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoZXZlbnRUaW1lLGxhbmUpO3VwZGF0ZS5wYXlsb2FkPXBheWxvYWQ7aWYoY2FsbGJhY2shPT11bmRlZmluZWQmJmNhbGxiYWNrIT09bnVsbCl7e3dhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywnc2V0U3RhdGUnKTt9dXBkYXRlLmNhbGxiYWNrPWNhbGxiYWNrO312YXIgcm9vdD1lbnF1ZXVlVXBkYXRlKGZpYmVyLHVwZGF0ZSxsYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsbGFuZSxldmVudFRpbWUpO2VudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCxmaWJlcixsYW5lKTt9e21hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKTt9fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGluc3QscGF5bG9hZCxjYWxsYmFjayl7dmFyIGZpYmVyPWdldChpbnN0KTt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTt2YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoZXZlbnRUaW1lLGxhbmUpO3VwZGF0ZS50YWc9UmVwbGFjZVN0YXRlO3VwZGF0ZS5wYXlsb2FkPXBheWxvYWQ7aWYoY2FsbGJhY2shPT11bmRlZmluZWQmJmNhbGxiYWNrIT09bnVsbCl7e3dhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywncmVwbGFjZVN0YXRlJyk7fXVwZGF0ZS5jYWxsYmFjaz1jYWxsYmFjazt9dmFyIHJvb3Q9ZW5xdWV1ZVVwZGF0ZShmaWJlcix1cGRhdGUsbGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLGxhbmUsZXZlbnRUaW1lKTtlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsZmliZXIsbGFuZSk7fXttYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsbGFuZSk7fX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGluc3QsY2FsbGJhY2spe3ZhciBmaWJlcj1nZXQoaW5zdCk7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7dmFyIGxhbmU9cmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO3ZhciB1cGRhdGU9Y3JlYXRlVXBkYXRlKGV2ZW50VGltZSxsYW5lKTt1cGRhdGUudGFnPUZvcmNlVXBkYXRlO2lmKGNhbGxiYWNrIT09dW5kZWZpbmVkJiZjYWxsYmFjayE9PW51bGwpe3t3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssJ2ZvcmNlVXBkYXRlJyk7fXVwZGF0ZS5jYWxsYmFjaz1jYWxsYmFjazt9dmFyIHJvb3Q9ZW5xdWV1ZVVwZGF0ZShmaWJlcix1cGRhdGUsbGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLGxhbmUsZXZlbnRUaW1lKTtlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsZmliZXIsbGFuZSk7fXttYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsbGFuZSk7fX19O2Z1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLGN0b3Isb2xkUHJvcHMsbmV3UHJvcHMsb2xkU3RhdGUsbmV3U3RhdGUsbmV4dENvbnRleHQpe3ZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aWYodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZT09PSdmdW5jdGlvbicpe3ZhciBzaG91bGRVcGRhdGU9aW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLG5ld1N0YXRlLG5leHRDb250ZXh0KTt7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTt0cnl7Ly8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbnNob3VsZFVwZGF0ZT1pbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsbmV3U3RhdGUsbmV4dENvbnRleHQpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fWlmKHNob3VsZFVwZGF0ZT09PXVuZGVmaW5lZCl7ZXJyb3IoJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcrJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKXx8J0NvbXBvbmVudCcpO319cmV0dXJuIHNob3VsZFVwZGF0ZTt9aWYoY3Rvci5wcm90b3R5cGUmJmN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KXtyZXR1cm4hc2hhbGxvd0VxdWFsKG9sZFByb3BzLG5ld1Byb3BzKXx8IXNoYWxsb3dFcXVhbChvbGRTdGF0ZSxuZXdTdGF0ZSk7fXJldHVybiB0cnVlO31mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsY3RvcixuZXdQcm9wcyl7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTt7dmFyIG5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50Jzt2YXIgcmVuZGVyUHJlc2VudD1pbnN0YW5jZS5yZW5kZXI7aWYoIXJlbmRlclByZXNlbnQpe2lmKGN0b3IucHJvdG90eXBlJiZ0eXBlb2YgY3Rvci5wcm90b3R5cGUucmVuZGVyPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcrJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsbmFtZSk7fWVsc2V7ZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcrJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLG5hbWUpO319aWYoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlJiYhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkJiYhaW5zdGFuY2Uuc3RhdGUpe2Vycm9yKCdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJysnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnKydEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLG5hbWUpO31pZihpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMmJiFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpe2Vycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJysnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnKydVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsbmFtZSk7fWlmKGluc3RhbmNlLnByb3BUeXBlcyl7ZXJyb3IoJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcrJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLG5hbWUpO31pZihpbnN0YW5jZS5jb250ZXh0VHlwZSl7ZXJyb3IoJ2NvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJysncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJyxuYW1lKTt9e2lmKGluc3RhbmNlLmNvbnRleHRUeXBlcyl7ZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcrJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLG5hbWUpO31pZihjdG9yLmNvbnRleHRUeXBlJiZjdG9yLmNvbnRleHRUeXBlcyYmIWRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmhhcyhjdG9yKSl7ZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO2Vycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcrJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLG5hbWUpO319aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZT09PSdmdW5jdGlvbicpe2Vycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcrJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcrJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnKydleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLG5hbWUpO31pZihjdG9yLnByb3RvdHlwZSYmY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQmJnR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUhPT0ndW5kZWZpbmVkJyl7ZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcrJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJysnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3Rvcil8fCdBIHB1cmUgY29tcG9uZW50Jyk7fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50PT09J2Z1bmN0aW9uJyl7ZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJysnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnKydEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJysnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcrJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnKyd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnKydydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcz09PSdmdW5jdGlvbicpe2Vycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcrJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHM9PT0nZnVuY3Rpb24nKXtlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnKydVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLG5hbWUpO312YXIgaGFzTXV0YXRlZFByb3BzPWluc3RhbmNlLnByb3BzIT09bmV3UHJvcHM7aWYoaW5zdGFuY2UucHJvcHMhPT11bmRlZmluZWQmJmhhc011dGF0ZWRQcm9wcyl7ZXJyb3IoJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcrXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIixuYW1lLG5hbWUpO31pZihpbnN0YW5jZS5kZWZhdWx0UHJvcHMpe2Vycm9yKCdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJysnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJyxuYW1lLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nJiZ0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIT09J2Z1bmN0aW9uJyYmIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3Rvcikpe2RpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoY3Rvcik7ZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcrJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpKTt9aWYodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz09PSdmdW5jdGlvbicpe2Vycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJysnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJyxuYW1lKTt9aWYodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcj09PSdmdW5jdGlvbicpe2Vycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJysnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJyxuYW1lKTt9aWYodHlwZW9mIGN0b3IuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nKXtlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJysnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJyxuYW1lKTt9dmFyIF9zdGF0ZT1pbnN0YW5jZS5zdGF0ZTtpZihfc3RhdGUmJih0eXBlb2YgX3N0YXRlIT09J29iamVjdCd8fGlzQXJyYXkoX3N0YXRlKSkpe2Vycm9yKCclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0PT09J2Z1bmN0aW9uJyYmdHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMhPT0nb2JqZWN0Jyl7ZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJysndXNlIGdldENoaWxkQ29udGV4dCgpLicsbmFtZSk7fX19ZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLGluc3RhbmNlKXtpbnN0YW5jZS51cGRhdGVyPWNsYXNzQ29tcG9uZW50VXBkYXRlcjt3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU9aW5zdGFuY2U7Ly8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuc2V0KGluc3RhbmNlLHdvcmtJblByb2dyZXNzKTt7aW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZT1mYWtlSW50ZXJuYWxJbnN0YW5jZTt9fWZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsY3Rvcixwcm9wcyl7dmFyIGlzTGVnYWN5Q29udGV4dENvbnN1bWVyPWZhbHNlO3ZhciB1bm1hc2tlZENvbnRleHQ9ZW1wdHlDb250ZXh0T2JqZWN0O3ZhciBjb250ZXh0PWVtcHR5Q29udGV4dE9iamVjdDt2YXIgY29udGV4dFR5cGU9Y3Rvci5jb250ZXh0VHlwZTt7aWYoJ2NvbnRleHRUeXBlJ2luIGN0b3Ipe3ZhciBpc1ZhbGlkPS8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG5jb250ZXh0VHlwZT09PW51bGx8fGNvbnRleHRUeXBlIT09dW5kZWZpbmVkJiZjb250ZXh0VHlwZS4kJHR5cGVvZj09PVJFQUNUX0NPTlRFWFRfVFlQRSYmY29udGV4dFR5cGUuX2NvbnRleHQ9PT11bmRlZmluZWQ7Ly8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5pZighaXNWYWxpZCYmIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3Rvcikpe2RpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoY3Rvcik7dmFyIGFkZGVuZHVtPScnO2lmKGNvbnRleHRUeXBlPT09dW5kZWZpbmVkKXthZGRlbmR1bT0nIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuICcrJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcrJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcrJ3RyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS4nO31lbHNlIGlmKHR5cGVvZiBjb250ZXh0VHlwZSE9PSdvYmplY3QnKXthZGRlbmR1bT0nIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcrdHlwZW9mIGNvbnRleHRUeXBlKycuJzt9ZWxzZSBpZihjb250ZXh0VHlwZS4kJHR5cGVvZj09PVJFQUNUX1BST1ZJREVSX1RZUEUpe2FkZGVuZHVtPScgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7fWVsc2UgaWYoY29udGV4dFR5cGUuX2NvbnRleHQhPT11bmRlZmluZWQpey8vIDxDb250ZXh0LkNvbnN1bWVyPlxuYWRkZW5kdW09JyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/Jzt9ZWxzZXthZGRlbmR1bT0nIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnK09iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpKyd9Lic7fWVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcrJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3Rvcil8fCdDb21wb25lbnQnLGFkZGVuZHVtKTt9fX1pZih0eXBlb2YgY29udGV4dFR5cGU9PT0nb2JqZWN0JyYmY29udGV4dFR5cGUhPT1udWxsKXtjb250ZXh0PXJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTt9ZWxzZXt1bm1hc2tlZENvbnRleHQ9Z2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLGN0b3IsdHJ1ZSk7dmFyIGNvbnRleHRUeXBlcz1jdG9yLmNvbnRleHRUeXBlcztpc0xlZ2FjeUNvbnRleHRDb25zdW1lcj1jb250ZXh0VHlwZXMhPT1udWxsJiZjb250ZXh0VHlwZXMhPT11bmRlZmluZWQ7Y29udGV4dD1pc0xlZ2FjeUNvbnRleHRDb25zdW1lcj9nZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLHVubWFza2VkQ29udGV4dCk6ZW1wdHlDb250ZXh0T2JqZWN0O312YXIgaW5zdGFuY2U9bmV3IGN0b3IocHJvcHMsY29udGV4dCk7Ly8gSW5zdGFudGlhdGUgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxue2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e2luc3RhbmNlPW5ldyBjdG9yKHByb3BzLGNvbnRleHQpOy8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG59ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX19dmFyIHN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9aW5zdGFuY2Uuc3RhdGUhPT1udWxsJiZpbnN0YW5jZS5zdGF0ZSE9PXVuZGVmaW5lZD9pbnN0YW5jZS5zdGF0ZTpudWxsO2Fkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSk7e2lmKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz09PSdmdW5jdGlvbicmJnN0YXRlPT09bnVsbCl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSl7ZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnKyclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnKydhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gJysnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsY29tcG9uZW50TmFtZSxpbnN0YW5jZS5zdGF0ZT09PW51bGw/J251bGwnOid1bmRlZmluZWQnLGNvbXBvbmVudE5hbWUpO319Ly8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuLy8gV2FybiBhYm91dCB0aGVzZSBsaWZlY3ljbGVzIGlmIHRoZXkgYXJlIHByZXNlbnQuXG4vLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5pZih0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nfHx0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nKXt2YXIgZm91bmRXaWxsTW91bnROYW1lPW51bGw7dmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWU9bnVsbDt2YXIgZm91bmRXaWxsVXBkYXRlTmFtZT1udWxsO2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nJiZpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyE9PXRydWUpe2ZvdW5kV2lsbE1vdW50TmFtZT0nY29tcG9uZW50V2lsbE1vdW50Jzt9ZWxzZSBpZih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbicpe2ZvdW5kV2lsbE1vdW50TmFtZT0nVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCc7fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyYmaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIT09dHJ1ZSl7Zm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZT0nY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7fWVsc2UgaWYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyl7Zm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZT0nVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZT09PSdmdW5jdGlvbicmJmluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyE9PXRydWUpe2ZvdW5kV2lsbFVwZGF0ZU5hbWU9J2NvbXBvbmVudFdpbGxVcGRhdGUnO31lbHNlIGlmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZT09PSdmdW5jdGlvbicpe2ZvdW5kV2lsbFVwZGF0ZU5hbWU9J1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJzt9aWYoZm91bmRXaWxsTW91bnROYW1lIT09bnVsbHx8Zm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSE9PW51bGx8fGZvdW5kV2lsbFVwZGF0ZU5hbWUhPT1udWxsKXt2YXIgX2NvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50Jzt2YXIgbmV3QXBpTmFtZT10eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nPydnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSc6J2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO2lmKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpe2RpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJysnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicrJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLF9jb21wb25lbnROYW1lLG5ld0FwaU5hbWUsZm91bmRXaWxsTW91bnROYW1lIT09bnVsbD9cIlxcbiAgXCIrZm91bmRXaWxsTW91bnROYW1lOicnLGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUhPT1udWxsP1wiXFxuICBcIitmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lOicnLGZvdW5kV2lsbFVwZGF0ZU5hbWUhPT1udWxsP1wiXFxuICBcIitmb3VuZFdpbGxVcGRhdGVOYW1lOicnKTt9fX19Ly8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cbmlmKGlzTGVnYWN5Q29udGV4dENvbnN1bWVyKXtjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsdW5tYXNrZWRDb250ZXh0LGNvbnRleHQpO31yZXR1cm4gaW5zdGFuY2U7fWZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsaW5zdGFuY2Upe3ZhciBvbGRTdGF0ZT1pbnN0YW5jZS5zdGF0ZTtpZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJyl7aW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7fWlmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJyl7aW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO31pZihvbGRTdGF0ZSE9PWluc3RhbmNlLnN0YXRlKXt7ZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnK1wiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiKydjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcyl8fCdDb21wb25lbnQnKTt9Y2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsaW5zdGFuY2Uuc3RhdGUsbnVsbCk7fX1mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSxuZXdQcm9wcyxuZXh0Q29udGV4dCl7dmFyIG9sZFN0YXRlPWluc3RhbmNlLnN0YXRlO2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyl7aW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcyxuZXh0Q29udGV4dCk7fWlmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicpe2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLG5leHRDb250ZXh0KTt9aWYoaW5zdGFuY2Uuc3RhdGUhPT1vbGRTdGF0ZSl7e3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSl7ZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtlcnJvcignJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJytcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiKydjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsY29tcG9uZW50TmFtZSk7fX1jbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSxpbnN0YW5jZS5zdGF0ZSxudWxsKTt9fS8vIEludm9rZXMgdGhlIG1vdW50IGxpZmUtY3ljbGVzIG9uIGEgcHJldmlvdXNseSBuZXZlciByZW5kZXJlZCBpbnN0YW5jZS5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG5ld1Byb3BzLHJlbmRlckxhbmVzKXt7Y2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLGN0b3IsbmV3UHJvcHMpO312YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO2luc3RhbmNlLnByb3BzPW5ld1Byb3BzO2luc3RhbmNlLnN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aW5zdGFuY2UucmVmcz1lbXB0eVJlZnNPYmplY3Q7aW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTt2YXIgY29udGV4dFR5cGU9Y3Rvci5jb250ZXh0VHlwZTtpZih0eXBlb2YgY29udGV4dFR5cGU9PT0nb2JqZWN0JyYmY29udGV4dFR5cGUhPT1udWxsKXtpbnN0YW5jZS5jb250ZXh0PXJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTt9ZWxzZXt2YXIgdW5tYXNrZWRDb250ZXh0PWdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxjdG9yLHRydWUpO2luc3RhbmNlLmNvbnRleHQ9Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQpO317aWYoaW5zdGFuY2Uuc3RhdGU9PT1uZXdQcm9wcyl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKXtkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7ZXJyb3IoJyVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlICcrXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIisnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLGNvbXBvbmVudE5hbWUpO319aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSk7fXtSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSk7fX1pbnN0YW5jZS5zdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO3ZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9Y3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7aWYodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz09PSdmdW5jdGlvbicpe2FwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLGN0b3IsZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLG5ld1Byb3BzKTtpbnN0YW5jZS5zdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO30vLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbi8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5pZih0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMhPT0nZnVuY3Rpb24nJiZ0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUhPT0nZnVuY3Rpb24nJiYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nfHx0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJykpe2NhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsaW5zdGFuY2UpOy8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3Ncbi8vIHByb2Nlc3MgdGhlbSBub3cuXG5wcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsbmV3UHJvcHMsaW5zdGFuY2UscmVuZGVyTGFuZXMpO2luc3RhbmNlLnN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudD09PSdmdW5jdGlvbicpe3ZhciBmaWJlckZsYWdzPVVwZGF0ZTt7ZmliZXJGbGFnc3w9TGF5b3V0U3RhdGljO31pZigod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe2ZpYmVyRmxhZ3N8PU1vdW50TGF5b3V0RGV2O313b3JrSW5Qcm9ncmVzcy5mbGFnc3w9ZmliZXJGbGFnczt9fWZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG5ld1Byb3BzLHJlbmRlckxhbmVzKXt2YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3ZhciBvbGRQcm9wcz13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO2luc3RhbmNlLnByb3BzPW9sZFByb3BzO3ZhciBvbGRDb250ZXh0PWluc3RhbmNlLmNvbnRleHQ7dmFyIGNvbnRleHRUeXBlPWN0b3IuY29udGV4dFR5cGU7dmFyIG5leHRDb250ZXh0PWVtcHR5Q29udGV4dE9iamVjdDtpZih0eXBlb2YgY29udGV4dFR5cGU9PT0nb2JqZWN0JyYmY29udGV4dFR5cGUhPT1udWxsKXtuZXh0Q29udGV4dD1yZWFkQ29udGV4dChjb250ZXh0VHlwZSk7fWVsc2V7dmFyIG5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQ9Z2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLGN0b3IsdHJ1ZSk7bmV4dENvbnRleHQ9Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTt9dmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz1jdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczt2YXIgaGFzTmV3TGlmZWN5Y2xlcz10eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJzsvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4vLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbi8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbmlmKCFoYXNOZXdMaWZlY3ljbGVzJiYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM9PT0nZnVuY3Rpb24nKSl7aWYob2xkUHJvcHMhPT1uZXdQcm9wc3x8b2xkQ29udGV4dCE9PW5leHRDb250ZXh0KXtjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSxuZXdQcm9wcyxuZXh0Q29udGV4dCk7fX1yZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO3ZhciBvbGRTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO3ZhciBuZXdTdGF0ZT1pbnN0YW5jZS5zdGF0ZT1vbGRTdGF0ZTtwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsbmV3UHJvcHMsaW5zdGFuY2UscmVuZGVyTGFuZXMpO25ld1N0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYob2xkUHJvcHM9PT1uZXdQcm9wcyYmb2xkU3RhdGU9PT1uZXdTdGF0ZSYmIWhhc0NvbnRleHRDaGFuZ2VkKCkmJiFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpey8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbmlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudD09PSdmdW5jdGlvbicpe3ZhciBmaWJlckZsYWdzPVVwZGF0ZTt7ZmliZXJGbGFnc3w9TGF5b3V0U3RhdGljO31pZigod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe2ZpYmVyRmxhZ3N8PU1vdW50TGF5b3V0RGV2O313b3JrSW5Qcm9ncmVzcy5mbGFnc3w9ZmliZXJGbGFnczt9cmV0dXJuIGZhbHNlO31pZih0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJyl7YXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsY3RvcixnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsbmV3UHJvcHMpO25ld1N0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7fXZhciBzaG91bGRVcGRhdGU9Y2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpfHxjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG9sZFByb3BzLG5ld1Byb3BzLG9sZFN0YXRlLG5ld1N0YXRlLG5leHRDb250ZXh0KTtpZihzaG91bGRVcGRhdGUpey8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbmlmKCFoYXNOZXdMaWZlY3ljbGVzJiYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nfHx0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJykpe2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nKXtpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTt9aWYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nKXtpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7fX1pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQ9PT0nZnVuY3Rpb24nKXt2YXIgX2ZpYmVyRmxhZ3M9VXBkYXRlO3tfZmliZXJGbGFnc3w9TGF5b3V0U3RhdGljO31pZigod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe19maWJlckZsYWdzfD1Nb3VudExheW91dERldjt9d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PV9maWJlckZsYWdzO319ZWxzZXsvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbi8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG5pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQ9PT0nZnVuY3Rpb24nKXt2YXIgX2ZpYmVyRmxhZ3MyPVVwZGF0ZTt7X2ZpYmVyRmxhZ3MyfD1MYXlvdXRTdGF0aWM7fWlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdEVmZmVjdHNNb2RlKSE9PU5vTW9kZSl7X2ZpYmVyRmxhZ3MyfD1Nb3VudExheW91dERldjt9d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PV9maWJlckZsYWdzMjt9Ly8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM9bmV3UHJvcHM7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTt9Ly8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5pbnN0YW5jZS5wcm9wcz1uZXdQcm9wcztpbnN0YW5jZS5zdGF0ZT1uZXdTdGF0ZTtpbnN0YW5jZS5jb250ZXh0PW5leHRDb250ZXh0O3JldHVybiBzaG91bGRVcGRhdGU7fS8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsY3RvcixuZXdQcm9wcyxyZW5kZXJMYW5lcyl7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO3ZhciB1bnJlc29sdmVkT2xkUHJvcHM9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wczt2YXIgb2xkUHJvcHM9d29ya0luUHJvZ3Jlc3MudHlwZT09PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlP3VucmVzb2x2ZWRPbGRQcm9wczpyZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsdW5yZXNvbHZlZE9sZFByb3BzKTtpbnN0YW5jZS5wcm9wcz1vbGRQcm9wczt2YXIgdW5yZXNvbHZlZE5ld1Byb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgb2xkQ29udGV4dD1pbnN0YW5jZS5jb250ZXh0O3ZhciBjb250ZXh0VHlwZT1jdG9yLmNvbnRleHRUeXBlO3ZhciBuZXh0Q29udGV4dD1lbXB0eUNvbnRleHRPYmplY3Q7aWYodHlwZW9mIGNvbnRleHRUeXBlPT09J29iamVjdCcmJmNvbnRleHRUeXBlIT09bnVsbCl7bmV4dENvbnRleHQ9cmVhZENvbnRleHQoY29udGV4dFR5cGUpO31lbHNle3ZhciBuZXh0VW5tYXNrZWRDb250ZXh0PWdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxjdG9yLHRydWUpO25leHRDb250ZXh0PWdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsbmV4dFVubWFza2VkQ29udGV4dCk7fXZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9Y3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7dmFyIGhhc05ld0xpZmVjeWNsZXM9dHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz09PSdmdW5jdGlvbid8fHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZT09PSdmdW5jdGlvbic7Ly8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbi8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG4vLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbi8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5pZighaGFzTmV3TGlmZWN5Y2xlcyYmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbid8fHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJykpe2lmKHVucmVzb2x2ZWRPbGRQcm9wcyE9PXVucmVzb2x2ZWROZXdQcm9wc3x8b2xkQ29udGV4dCE9PW5leHRDb250ZXh0KXtjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSxuZXdQcm9wcyxuZXh0Q29udGV4dCk7fX1yZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO3ZhciBvbGRTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO3ZhciBuZXdTdGF0ZT1pbnN0YW5jZS5zdGF0ZT1vbGRTdGF0ZTtwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsbmV3UHJvcHMsaW5zdGFuY2UscmVuZGVyTGFuZXMpO25ld1N0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYodW5yZXNvbHZlZE9sZFByb3BzPT09dW5yZXNvbHZlZE5ld1Byb3BzJiZvbGRTdGF0ZT09PW5ld1N0YXRlJiYhaGFzQ29udGV4dENoYW5nZWQoKSYmIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSYmIWVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24pey8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbmlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGU9PT0nZnVuY3Rpb24nKXtpZih1bnJlc29sdmVkT2xkUHJvcHMhPT1jdXJyZW50Lm1lbW9pemVkUHJvcHN8fG9sZFN0YXRlIT09Y3VycmVudC5tZW1vaXplZFN0YXRlKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO319aWYodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJyl7aWYodW5yZXNvbHZlZE9sZFByb3BzIT09Y3VycmVudC5tZW1vaXplZFByb3BzfHxvbGRTdGF0ZSE9PWN1cnJlbnQubWVtb2l6ZWRTdGF0ZSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVNuYXBzaG90O319cmV0dXJuIGZhbHNlO31pZih0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJyl7YXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsY3RvcixnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsbmV3UHJvcHMpO25ld1N0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7fXZhciBzaG91bGRVcGRhdGU9Y2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpfHxjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG9sZFByb3BzLG5ld1Byb3BzLG9sZFN0YXRlLG5ld1N0YXRlLG5leHRDb250ZXh0KXx8Ly8gVE9ETzogSW4gc29tZSBjYXNlcywgd2UnbGwgZW5kIHVwIGNoZWNraW5nIGlmIGNvbnRleHQgaGFzIGNoYW5nZWQgdHdpY2UsXG4vLyBib3RoIGJlZm9yZSBhbmQgYWZ0ZXIgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaGFzIGJlZW4gY2FsbGVkLiBOb3QgaWRlYWwsXG4vLyBidXQgSSdtIGxvYXRoIHRvIHJlZmFjdG9yIHRoaXMgZnVuY3Rpb24uIFRoaXMgb25seSBoYXBwZW5zIGZvciBtZW1vaXplZFxuLy8gY29tcG9uZW50cyBzbyBpdCdzIG5vdCB0aGF0IGNvbW1vbi5cbmVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb247aWYoc2hvdWxkVXBkYXRlKXsvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbi8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5pZighaGFzTmV3TGlmZWN5Y2xlcyYmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZT09PSdmdW5jdGlvbid8fHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlPT09J2Z1bmN0aW9uJykpe2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlPT09J2Z1bmN0aW9uJyl7aW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcyxuZXdTdGF0ZSxuZXh0Q29udGV4dCk7fWlmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZT09PSdmdW5jdGlvbicpe2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLG5ld1N0YXRlLG5leHRDb250ZXh0KTt9fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGU9PT0nZnVuY3Rpb24nKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO31pZih0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9U25hcHNob3Q7fX1lbHNley8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbmlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGU9PT0nZnVuY3Rpb24nKXtpZih1bnJlc29sdmVkT2xkUHJvcHMhPT1jdXJyZW50Lm1lbW9pemVkUHJvcHN8fG9sZFN0YXRlIT09Y3VycmVudC5tZW1vaXplZFN0YXRlKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO319aWYodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJyl7aWYodW5yZXNvbHZlZE9sZFByb3BzIT09Y3VycmVudC5tZW1vaXplZFByb3BzfHxvbGRTdGF0ZSE9PWN1cnJlbnQubWVtb2l6ZWRTdGF0ZSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVNuYXBzaG90O319Ly8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM9bmV3UHJvcHM7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTt9Ly8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5pbnN0YW5jZS5wcm9wcz1uZXdQcm9wcztpbnN0YW5jZS5zdGF0ZT1uZXdTdGF0ZTtpbnN0YW5jZS5jb250ZXh0PW5leHRDb250ZXh0O3JldHVybiBzaG91bGRVcGRhdGU7fXZhciBkaWRXYXJuQWJvdXRNYXBzO3ZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzO3ZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO3ZhciBvd25lckhhc0tleVVzZVdhcm5pbmc7dmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZzt2YXIgd2FybkZvck1pc3NpbmdLZXk9ZnVuY3Rpb24oY2hpbGQscmV0dXJuRmliZXIpe307e2RpZFdhcm5BYm91dE1hcHM9ZmFsc2U7ZGlkV2FybkFib3V0R2VuZXJhdG9ycz1mYWxzZTtkaWRXYXJuQWJvdXRTdHJpbmdSZWZzPXt9Oy8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9vd25lckhhc0tleVVzZVdhcm5pbmc9e307b3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nPXt9O3dhcm5Gb3JNaXNzaW5nS2V5PWZ1bmN0aW9uKGNoaWxkLHJldHVybkZpYmVyKXtpZihjaGlsZD09PW51bGx8fHR5cGVvZiBjaGlsZCE9PSdvYmplY3QnKXtyZXR1cm47fWlmKCFjaGlsZC5fc3RvcmV8fGNoaWxkLl9zdG9yZS52YWxpZGF0ZWR8fGNoaWxkLmtleSE9bnVsbCl7cmV0dXJuO31pZih0eXBlb2YgY2hpbGQuX3N0b3JlIT09J29iamVjdCcpe3Rocm93IG5ldyBFcnJvcignUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31jaGlsZC5fc3RvcmUudmFsaWRhdGVkPXRydWU7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcil8fCdDb21wb25lbnQnO2lmKG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSl7cmV0dXJuO31vd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV09dHJ1ZTtlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgJysnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgJysnbW9yZSBpbmZvcm1hdGlvbi4nKTt9O31mdW5jdGlvbiBjb2VyY2VSZWYocmV0dXJuRmliZXIsY3VycmVudCxlbGVtZW50KXt2YXIgbWl4ZWRSZWY9ZWxlbWVudC5yZWY7aWYobWl4ZWRSZWYhPT1udWxsJiZ0eXBlb2YgbWl4ZWRSZWYhPT0nZnVuY3Rpb24nJiZ0eXBlb2YgbWl4ZWRSZWYhPT0nb2JqZWN0Jyl7ey8vIFRPRE86IENsZWFuIHRoaXMgdXAgb25jZSB3ZSB0dXJuIG9uIHRoZSBzdHJpbmcgcmVmIHdhcm5pbmcgZm9yXG4vLyBldmVyeW9uZSwgYmVjYXVzZSB0aGUgc3RyaWN0IG1vZGUgY2FzZSB3aWxsIG5vIGxvbmdlciBiZSByZWxldmFudFxuaWYoKHJldHVybkZpYmVyLm1vZGUmU3RyaWN0TGVnYWN5TW9kZXx8d2FybkFib3V0U3RyaW5nUmVmcykmJi8vIFdlIHdhcm4gaW4gUmVhY3RFbGVtZW50LmpzIGlmIG93bmVyIGFuZCBzZWxmIGFyZSBlcXVhbCBmb3Igc3RyaW5nIHJlZnNcbi8vIGJlY2F1c2UgdGhlc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uXG4vLyB1c2luZyBhIGNvZGVtb2QuIFRoZXJlZm9yZSwgd2UgZG9uJ3QgaGF2ZSB0byB3YXJuIGFib3V0IHN0cmluZyByZWZzIGFnYWluLlxuIShlbGVtZW50Ll9vd25lciYmZWxlbWVudC5fc2VsZiYmZWxlbWVudC5fb3duZXIuc3RhdGVOb2RlIT09ZWxlbWVudC5fc2VsZikpe3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSl7e2Vycm9yKCdBIHN0cmluZyByZWYsIFwiJXNcIiwgaGFzIGJlZW4gZm91bmQgd2l0aGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJysnU3RyaW5nIHJlZnMgYXJlIGEgc291cmNlIG9mIHBvdGVudGlhbCBidWdzIGFuZCBzaG91bGQgYmUgYXZvaWRlZC4gJysnV2UgcmVjb21tZW5kIHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcrJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLG1peGVkUmVmKTt9ZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXT10cnVlO319fWlmKGVsZW1lbnQuX293bmVyKXt2YXIgb3duZXI9ZWxlbWVudC5fb3duZXI7dmFyIGluc3Q7aWYob3duZXIpe3ZhciBvd25lckZpYmVyPW93bmVyO2lmKG93bmVyRmliZXIudGFnIT09Q2xhc3NDb21wb25lbnQpe3Rocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSBzdHJpbmcgcmVmcy4gJysnV2UgcmVjb21tZW5kIHVzaW5nIHVzZVJlZigpIGluc3RlYWQuICcrJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnKTt9aW5zdD1vd25lckZpYmVyLnN0YXRlTm9kZTt9aWYoIWluc3Qpe3Rocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIrbWl4ZWRSZWYrXCIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIFwiKydidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO30vLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0IHNvIEZsb3cga25vd3MgaXQgd29uJ3QgY2hhbmdlIGluIHRoZSBjbG9zdXJlXG52YXIgcmVzb2x2ZWRJbnN0PWluc3Q7e2NoZWNrUHJvcFN0cmluZ0NvZXJjaW9uKG1peGVkUmVmLCdyZWYnKTt9dmFyIHN0cmluZ1JlZj0nJyttaXhlZFJlZjsvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbmlmKGN1cnJlbnQhPT1udWxsJiZjdXJyZW50LnJlZiE9PW51bGwmJnR5cGVvZiBjdXJyZW50LnJlZj09PSdmdW5jdGlvbicmJmN1cnJlbnQucmVmLl9zdHJpbmdSZWY9PT1zdHJpbmdSZWYpe3JldHVybiBjdXJyZW50LnJlZjt9dmFyIHJlZj1mdW5jdGlvbih2YWx1ZSl7dmFyIHJlZnM9cmVzb2x2ZWRJbnN0LnJlZnM7aWYocmVmcz09PWVtcHR5UmVmc09iamVjdCl7Ly8gVGhpcyBpcyBhIGxhenkgcG9vbGVkIGZyb3plbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZS5cbnJlZnM9cmVzb2x2ZWRJbnN0LnJlZnM9e307fWlmKHZhbHVlPT09bnVsbCl7ZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTt9ZWxzZXtyZWZzW3N0cmluZ1JlZl09dmFsdWU7fX07cmVmLl9zdHJpbmdSZWY9c3RyaW5nUmVmO3JldHVybiByZWY7fWVsc2V7aWYodHlwZW9mIG1peGVkUmVmIT09J3N0cmluZycpe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGEgc3RyaW5nLCBhbiBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlUmVmKCksIG9yIG51bGwuJyk7fWlmKCFlbGVtZW50Ll9vd25lcil7dGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoXCIrbWl4ZWRSZWYrXCIpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mXCIrJyB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJysnMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbiBjb21wb25lbnRcXG4nK1wiMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50J3MgcmVuZGVyIG1ldGhvZFxcblwiKyczLiBZb3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkXFxuJysnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWZzLW11c3QtaGF2ZS1vd25lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTt9fX1yZXR1cm4gbWl4ZWRSZWY7fWZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlcixuZXdDaGlsZCl7dmFyIGNoaWxkU3RyaW5nPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCk7dGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIisoY2hpbGRTdHJpbmc9PT0nW29iamVjdCBPYmplY3RdJz8nb2JqZWN0IHdpdGgga2V5cyB7JytPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSsnfSc6Y2hpbGRTdHJpbmcpK1wiKS4gXCIrJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJysnaW5zdGVhZC4nKTt9ZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKXt7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcil8fCdDb21wb25lbnQnO2lmKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSl7cmV0dXJuO31vd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY29tcG9uZW50TmFtZV09dHJ1ZTtlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcrJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnKydPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTt9fWZ1bmN0aW9uIHJlc29sdmVMYXp5KGxhenlUeXBlKXt2YXIgcGF5bG9hZD1sYXp5VHlwZS5fcGF5bG9hZDt2YXIgaW5pdD1sYXp5VHlwZS5faW5pdDtyZXR1cm4gaW5pdChwYXlsb2FkKTt9Ly8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKXtmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlcixjaGlsZFRvRGVsZXRlKXtpZighc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7Ly8gTm9vcC5cbnJldHVybjt9dmFyIGRlbGV0aW9ucz1yZXR1cm5GaWJlci5kZWxldGlvbnM7aWYoZGVsZXRpb25zPT09bnVsbCl7cmV0dXJuRmliZXIuZGVsZXRpb25zPVtjaGlsZFRvRGVsZXRlXTtyZXR1cm5GaWJlci5mbGFnc3w9Q2hpbGREZWxldGlvbjt9ZWxzZXtkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTt9fWZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkKXtpZighc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7Ly8gTm9vcC5cbnJldHVybiBudWxsO30vLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4vLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG52YXIgY2hpbGRUb0RlbGV0ZT1jdXJyZW50Rmlyc3RDaGlsZDt3aGlsZShjaGlsZFRvRGVsZXRlIT09bnVsbCl7ZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsY2hpbGRUb0RlbGV0ZSk7Y2hpbGRUb0RlbGV0ZT1jaGlsZFRvRGVsZXRlLnNpYmxpbmc7fXJldHVybiBudWxsO31mdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCl7Ly8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuLy8gaW5zdGVhZC5cbnZhciBleGlzdGluZ0NoaWxkcmVuPW5ldyBNYXAoKTt2YXIgZXhpc3RpbmdDaGlsZD1jdXJyZW50Rmlyc3RDaGlsZDt3aGlsZShleGlzdGluZ0NoaWxkIT09bnVsbCl7aWYoZXhpc3RpbmdDaGlsZC5rZXkhPT1udWxsKXtleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSxleGlzdGluZ0NoaWxkKTt9ZWxzZXtleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LGV4aXN0aW5nQ2hpbGQpO31leGlzdGluZ0NoaWxkPWV4aXN0aW5nQ2hpbGQuc2libGluZzt9cmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47fWZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLHBlbmRpbmdQcm9wcyl7Ly8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbi8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG52YXIgY2xvbmU9Y3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIscGVuZGluZ1Byb3BzKTtjbG9uZS5pbmRleD0wO2Nsb25lLnNpYmxpbmc9bnVsbDtyZXR1cm4gY2xvbmU7fWZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsbGFzdFBsYWNlZEluZGV4LG5ld0luZGV4KXtuZXdGaWJlci5pbmRleD1uZXdJbmRleDtpZighc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIHVzZUlkIGFsZ29yaXRobSBuZWVkcyB0byBrbm93IHdoaWNoIGZpYmVycyBhcmVcbi8vIHBhcnQgb2YgYSBsaXN0IG9mIGNoaWxkcmVuIChhcnJheXMsIGl0ZXJhdG9ycykuXG5uZXdGaWJlci5mbGFnc3w9Rm9ya2VkO3JldHVybiBsYXN0UGxhY2VkSW5kZXg7fXZhciBjdXJyZW50PW5ld0ZpYmVyLmFsdGVybmF0ZTtpZihjdXJyZW50IT09bnVsbCl7dmFyIG9sZEluZGV4PWN1cnJlbnQuaW5kZXg7aWYob2xkSW5kZXg8bGFzdFBsYWNlZEluZGV4KXsvLyBUaGlzIGlzIGEgbW92ZS5cbm5ld0ZpYmVyLmZsYWdzfD1QbGFjZW1lbnQ7cmV0dXJuIGxhc3RQbGFjZWRJbmRleDt9ZWxzZXsvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG5yZXR1cm4gb2xkSW5kZXg7fX1lbHNley8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxubmV3RmliZXIuZmxhZ3N8PVBsYWNlbWVudDtyZXR1cm4gbGFzdFBsYWNlZEluZGV4O319ZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcil7Ly8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4vLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG5pZihzaG91bGRUcmFja1NpZGVFZmZlY3RzJiZuZXdGaWJlci5hbHRlcm5hdGU9PT1udWxsKXtuZXdGaWJlci5mbGFnc3w9UGxhY2VtZW50O31yZXR1cm4gbmV3RmliZXI7fWZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLGN1cnJlbnQsdGV4dENvbnRlbnQsbGFuZXMpe2lmKGN1cnJlbnQ9PT1udWxsfHxjdXJyZW50LnRhZyE9PUhvc3RUZXh0KXsvLyBJbnNlcnRcbnZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7Y3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGNyZWF0ZWQ7fWVsc2V7Ly8gVXBkYXRlXG52YXIgZXhpc3Rpbmc9dXNlRmliZXIoY3VycmVudCx0ZXh0Q29udGVudCk7ZXhpc3RpbmcucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBleGlzdGluZzt9fWZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsY3VycmVudCxlbGVtZW50LGxhbmVzKXt2YXIgZWxlbWVudFR5cGU9ZWxlbWVudC50eXBlO2lmKGVsZW1lbnRUeXBlPT09UkVBQ1RfRlJBR01FTlRfVFlQRSl7cmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLGN1cnJlbnQsZWxlbWVudC5wcm9wcy5jaGlsZHJlbixsYW5lcyxlbGVtZW50LmtleSk7fWlmKGN1cnJlbnQhPT1udWxsKXtpZihjdXJyZW50LmVsZW1lbnRUeXBlPT09ZWxlbWVudFR5cGV8fC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsZWxlbWVudCl8fC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuLy8gYmVjYXVzZSBob3QgcmVsb2FkaW5nIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gcHJvZCBiZWNhdXNlXG4vLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG50eXBlb2YgZWxlbWVudFR5cGU9PT0nb2JqZWN0JyYmZWxlbWVudFR5cGUhPT1udWxsJiZlbGVtZW50VHlwZS4kJHR5cGVvZj09PVJFQUNUX0xBWllfVFlQRSYmcmVzb2x2ZUxhenkoZWxlbWVudFR5cGUpPT09Y3VycmVudC50eXBlKXsvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG52YXIgZXhpc3Rpbmc9dXNlRmliZXIoY3VycmVudCxlbGVtZW50LnByb3BzKTtleGlzdGluZy5yZWY9Y29lcmNlUmVmKHJldHVybkZpYmVyLGN1cnJlbnQsZWxlbWVudCk7ZXhpc3RpbmcucmV0dXJuPXJldHVybkZpYmVyO3tleGlzdGluZy5fZGVidWdTb3VyY2U9ZWxlbWVudC5fc291cmNlO2V4aXN0aW5nLl9kZWJ1Z093bmVyPWVsZW1lbnQuX293bmVyO31yZXR1cm4gZXhpc3Rpbmc7fX0vLyBJbnNlcnRcbnZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtjcmVhdGVkLnJlZj1jb2VyY2VSZWYocmV0dXJuRmliZXIsY3VycmVudCxlbGVtZW50KTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9ZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLGN1cnJlbnQscG9ydGFsLGxhbmVzKXtpZihjdXJyZW50PT09bnVsbHx8Y3VycmVudC50YWchPT1Ib3N0UG9ydGFsfHxjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09cG9ydGFsLmNvbnRhaW5lckluZm98fGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09cG9ydGFsLmltcGxlbWVudGF0aW9uKXsvLyBJbnNlcnRcbnZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7Y3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGNyZWF0ZWQ7fWVsc2V7Ly8gVXBkYXRlXG52YXIgZXhpc3Rpbmc9dXNlRmliZXIoY3VycmVudCxwb3J0YWwuY2hpbGRyZW58fFtdKTtleGlzdGluZy5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGV4aXN0aW5nO319ZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsY3VycmVudCxmcmFnbWVudCxsYW5lcyxrZXkpe2lmKGN1cnJlbnQ9PT1udWxsfHxjdXJyZW50LnRhZyE9PUZyYWdtZW50KXsvLyBJbnNlcnRcbnZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LHJldHVybkZpYmVyLm1vZGUsbGFuZXMsa2V5KTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9ZWxzZXsvLyBVcGRhdGVcbnZhciBleGlzdGluZz11c2VGaWJlcihjdXJyZW50LGZyYWdtZW50KTtleGlzdGluZy5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGV4aXN0aW5nO319ZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsbmV3Q2hpbGQsbGFuZXMpe2lmKHR5cGVvZiBuZXdDaGlsZD09PSdzdHJpbmcnJiZuZXdDaGlsZCE9PScnfHx0eXBlb2YgbmV3Q2hpbGQ9PT0nbnVtYmVyJyl7Ly8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbi8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4vLyBub2RlLlxudmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tVGV4dCgnJytuZXdDaGlsZCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9aWYodHlwZW9mIG5ld0NoaWxkPT09J29iamVjdCcmJm5ld0NoaWxkIT09bnVsbCl7c3dpdGNoKG5ld0NoaWxkLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTp7dmFyIF9jcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7X2NyZWF0ZWQucmVmPWNvZXJjZVJlZihyZXR1cm5GaWJlcixudWxsLG5ld0NoaWxkKTtfY3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIF9jcmVhdGVkO31jYXNlIFJFQUNUX1BPUlRBTF9UWVBFOnt2YXIgX2NyZWF0ZWQyPWNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtfY3JlYXRlZDIucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBfY3JlYXRlZDI7fWNhc2UgUkVBQ1RfTEFaWV9UWVBFOnt2YXIgcGF5bG9hZD1uZXdDaGlsZC5fcGF5bG9hZDt2YXIgaW5pdD1uZXdDaGlsZC5faW5pdDtyZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsaW5pdChwYXlsb2FkKSxsYW5lcyk7fX1pZihpc0FycmF5KG5ld0NoaWxkKXx8Z2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpe3ZhciBfY3JlYXRlZDM9Y3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQscmV0dXJuRmliZXIubW9kZSxsYW5lcyxudWxsKTtfY3JlYXRlZDMucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBfY3JlYXRlZDM7fXRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlcixuZXdDaGlsZCk7fXtpZih0eXBlb2YgbmV3Q2hpbGQ9PT0nZnVuY3Rpb24nKXt3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO319cmV0dXJuIG51bGw7fWZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsb2xkRmliZXIsbmV3Q2hpbGQsbGFuZXMpey8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbnZhciBrZXk9b2xkRmliZXIhPT1udWxsP29sZEZpYmVyLmtleTpudWxsO2lmKHR5cGVvZiBuZXdDaGlsZD09PSdzdHJpbmcnJiZuZXdDaGlsZCE9PScnfHx0eXBlb2YgbmV3Q2hpbGQ9PT0nbnVtYmVyJyl7Ly8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbi8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4vLyBub2RlLlxuaWYoa2V5IT09bnVsbCl7cmV0dXJuIG51bGw7fXJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlcixvbGRGaWJlciwnJytuZXdDaGlsZCxsYW5lcyk7fWlmKHR5cGVvZiBuZXdDaGlsZD09PSdvYmplY3QnJiZuZXdDaGlsZCE9PW51bGwpe3N3aXRjaChuZXdDaGlsZC4kJHR5cGVvZil7Y2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6e2lmKG5ld0NoaWxkLmtleT09PWtleSl7cmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsb2xkRmliZXIsbmV3Q2hpbGQsbGFuZXMpO31lbHNle3JldHVybiBudWxsO319Y2FzZSBSRUFDVF9QT1JUQUxfVFlQRTp7aWYobmV3Q2hpbGQua2V5PT09a2V5KXtyZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLG9sZEZpYmVyLG5ld0NoaWxkLGxhbmVzKTt9ZWxzZXtyZXR1cm4gbnVsbDt9fWNhc2UgUkVBQ1RfTEFaWV9UWVBFOnt2YXIgcGF5bG9hZD1uZXdDaGlsZC5fcGF5bG9hZDt2YXIgaW5pdD1uZXdDaGlsZC5faW5pdDtyZXR1cm4gdXBkYXRlU2xvdChyZXR1cm5GaWJlcixvbGRGaWJlcixpbml0KHBheWxvYWQpLGxhbmVzKTt9fWlmKGlzQXJyYXkobmV3Q2hpbGQpfHxnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSl7aWYoa2V5IT09bnVsbCl7cmV0dXJuIG51bGw7fXJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlcixvbGRGaWJlcixuZXdDaGlsZCxsYW5lcyxudWxsKTt9dGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLG5ld0NoaWxkKTt9e2lmKHR5cGVvZiBuZXdDaGlsZD09PSdmdW5jdGlvbicpe3dhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7fX1yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLHJldHVybkZpYmVyLG5ld0lkeCxuZXdDaGlsZCxsYW5lcyl7aWYodHlwZW9mIG5ld0NoaWxkPT09J3N0cmluZycmJm5ld0NoaWxkIT09Jyd8fHR5cGVvZiBuZXdDaGlsZD09PSdudW1iZXInKXsvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4vLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbnZhciBtYXRjaGVkRmliZXI9ZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KXx8bnVsbDtyZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsbWF0Y2hlZEZpYmVyLCcnK25ld0NoaWxkLGxhbmVzKTt9aWYodHlwZW9mIG5ld0NoaWxkPT09J29iamVjdCcmJm5ld0NoaWxkIT09bnVsbCl7c3dpdGNoKG5ld0NoaWxkLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTp7dmFyIF9tYXRjaGVkRmliZXI9ZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5PT09bnVsbD9uZXdJZHg6bmV3Q2hpbGQua2V5KXx8bnVsbDtyZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlcixfbWF0Y2hlZEZpYmVyLG5ld0NoaWxkLGxhbmVzKTt9Y2FzZSBSRUFDVF9QT1JUQUxfVFlQRTp7dmFyIF9tYXRjaGVkRmliZXIyPWV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleT09PW51bGw/bmV3SWR4Om5ld0NoaWxkLmtleSl8fG51bGw7cmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlcixfbWF0Y2hlZEZpYmVyMixuZXdDaGlsZCxsYW5lcyk7fWNhc2UgUkVBQ1RfTEFaWV9UWVBFOnZhciBwYXlsb2FkPW5ld0NoaWxkLl9wYXlsb2FkO3ZhciBpbml0PW5ld0NoaWxkLl9pbml0O3JldHVybiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4scmV0dXJuRmliZXIsbmV3SWR4LGluaXQocGF5bG9hZCksbGFuZXMpO31pZihpc0FycmF5KG5ld0NoaWxkKXx8Z2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpe3ZhciBfbWF0Y2hlZEZpYmVyMz1leGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpfHxudWxsO3JldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlcixfbWF0Y2hlZEZpYmVyMyxuZXdDaGlsZCxsYW5lcyxudWxsKTt9dGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLG5ld0NoaWxkKTt9e2lmKHR5cGVvZiBuZXdDaGlsZD09PSdmdW5jdGlvbicpe3dhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7fX1yZXR1cm4gbnVsbDt9LyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL2Z1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsa25vd25LZXlzLHJldHVybkZpYmVyKXt7aWYodHlwZW9mIGNoaWxkIT09J29iamVjdCd8fGNoaWxkPT09bnVsbCl7cmV0dXJuIGtub3duS2V5czt9c3dpdGNoKGNoaWxkLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOndhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkLHJldHVybkZpYmVyKTt2YXIga2V5PWNoaWxkLmtleTtpZih0eXBlb2Yga2V5IT09J3N0cmluZycpe2JyZWFrO31pZihrbm93bktleXM9PT1udWxsKXtrbm93bktleXM9bmV3IFNldCgpO2tub3duS2V5cy5hZGQoa2V5KTticmVhazt9aWYoIWtub3duS2V5cy5oYXMoa2V5KSl7a25vd25LZXlzLmFkZChrZXkpO2JyZWFrO31lcnJvcignRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnKydLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcrJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcrJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJysnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJyxrZXkpO2JyZWFrO2Nhc2UgUkVBQ1RfTEFaWV9UWVBFOnZhciBwYXlsb2FkPWNoaWxkLl9wYXlsb2FkO3ZhciBpbml0PWNoaWxkLl9pbml0O3dhcm5PbkludmFsaWRLZXkoaW5pdChwYXlsb2FkKSxrbm93bktleXMscmV0dXJuRmliZXIpO2JyZWFrO319cmV0dXJuIGtub3duS2V5czt9ZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxuZXdDaGlsZHJlbixsYW5lcyl7Ly8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aCBlbmRzIHNpbmNlIHdlXG4vLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbi8vIGFkZCBpdCBsYXRlci5cbi8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2Vcbi8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4vLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbi8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4vLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cbi8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG4vLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4vLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cbnsvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbnZhciBrbm93bktleXM9bnVsbDtmb3IodmFyIGk9MDtpPG5ld0NoaWxkcmVuLmxlbmd0aDtpKyspe3ZhciBjaGlsZD1uZXdDaGlsZHJlbltpXTtrbm93bktleXM9d2Fybk9uSW52YWxpZEtleShjaGlsZCxrbm93bktleXMscmV0dXJuRmliZXIpO319dmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ9bnVsbDt2YXIgcHJldmlvdXNOZXdGaWJlcj1udWxsO3ZhciBvbGRGaWJlcj1jdXJyZW50Rmlyc3RDaGlsZDt2YXIgbGFzdFBsYWNlZEluZGV4PTA7dmFyIG5ld0lkeD0wO3ZhciBuZXh0T2xkRmliZXI9bnVsbDtmb3IoO29sZEZpYmVyIT09bnVsbCYmbmV3SWR4PG5ld0NoaWxkcmVuLmxlbmd0aDtuZXdJZHgrKyl7aWYob2xkRmliZXIuaW5kZXg+bmV3SWR4KXtuZXh0T2xkRmliZXI9b2xkRmliZXI7b2xkRmliZXI9bnVsbDt9ZWxzZXtuZXh0T2xkRmliZXI9b2xkRmliZXIuc2libGluZzt9dmFyIG5ld0ZpYmVyPXVwZGF0ZVNsb3QocmV0dXJuRmliZXIsb2xkRmliZXIsbmV3Q2hpbGRyZW5bbmV3SWR4XSxsYW5lcyk7aWYobmV3RmliZXI9PT1udWxsKXsvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4vLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbmlmKG9sZEZpYmVyPT09bnVsbCl7b2xkRmliZXI9bmV4dE9sZEZpYmVyO31icmVhazt9aWYoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7aWYob2xkRmliZXImJm5ld0ZpYmVyLmFsdGVybmF0ZT09PW51bGwpey8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsb2xkRmliZXIpO319bGFzdFBsYWNlZEluZGV4PXBsYWNlQ2hpbGQobmV3RmliZXIsbGFzdFBsYWNlZEluZGV4LG5ld0lkeCk7aWYocHJldmlvdXNOZXdGaWJlcj09PW51bGwpey8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbnJlc3VsdGluZ0ZpcnN0Q2hpbGQ9bmV3RmliZXI7fWVsc2V7Ly8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxucHJldmlvdXNOZXdGaWJlci5zaWJsaW5nPW5ld0ZpYmVyO31wcmV2aW91c05ld0ZpYmVyPW5ld0ZpYmVyO29sZEZpYmVyPW5leHRPbGRGaWJlcjt9aWYobmV3SWR4PT09bmV3Q2hpbGRyZW4ubGVuZ3RoKXsvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbmRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLG9sZEZpYmVyKTtpZihnZXRJc0h5ZHJhdGluZygpKXt2YXIgbnVtYmVyT2ZGb3Jrcz1uZXdJZHg7cHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLG51bWJlck9mRm9ya3MpO31yZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDt9aWYob2xkRmliZXI9PT1udWxsKXsvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbi8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG5mb3IoO25ld0lkeDxuZXdDaGlsZHJlbi5sZW5ndGg7bmV3SWR4Kyspe3ZhciBfbmV3RmliZXI9Y3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsbmV3Q2hpbGRyZW5bbmV3SWR4XSxsYW5lcyk7aWYoX25ld0ZpYmVyPT09bnVsbCl7Y29udGludWU7fWxhc3RQbGFjZWRJbmRleD1wbGFjZUNoaWxkKF9uZXdGaWJlcixsYXN0UGxhY2VkSW5kZXgsbmV3SWR4KTtpZihwcmV2aW91c05ld0ZpYmVyPT09bnVsbCl7Ly8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxucmVzdWx0aW5nRmlyc3RDaGlsZD1fbmV3RmliZXI7fWVsc2V7cHJldmlvdXNOZXdGaWJlci5zaWJsaW5nPV9uZXdGaWJlcjt9cHJldmlvdXNOZXdGaWJlcj1fbmV3RmliZXI7fWlmKGdldElzSHlkcmF0aW5nKCkpe3ZhciBfbnVtYmVyT2ZGb3Jrcz1uZXdJZHg7cHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLF9udW1iZXJPZkZvcmtzKTt9cmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7fS8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxudmFyIGV4aXN0aW5nQ2hpbGRyZW49bWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsb2xkRmliZXIpOy8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbmZvcig7bmV3SWR4PG5ld0NoaWxkcmVuLmxlbmd0aDtuZXdJZHgrKyl7dmFyIF9uZXdGaWJlcjI9dXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLHJldHVybkZpYmVyLG5ld0lkeCxuZXdDaGlsZHJlbltuZXdJZHhdLGxhbmVzKTtpZihfbmV3RmliZXIyIT09bnVsbCl7aWYoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7aWYoX25ld0ZpYmVyMi5hbHRlcm5hdGUhPT1udWxsKXsvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4vLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbi8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4vLyBsaXN0LlxuZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXk9PT1udWxsP25ld0lkeDpfbmV3RmliZXIyLmtleSk7fX1sYXN0UGxhY2VkSW5kZXg9cGxhY2VDaGlsZChfbmV3RmliZXIyLGxhc3RQbGFjZWRJbmRleCxuZXdJZHgpO2lmKHByZXZpb3VzTmV3RmliZXI9PT1udWxsKXtyZXN1bHRpbmdGaXJzdENoaWxkPV9uZXdGaWJlcjI7fWVsc2V7cHJldmlvdXNOZXdGaWJlci5zaWJsaW5nPV9uZXdGaWJlcjI7fXByZXZpb3VzTmV3RmliZXI9X25ld0ZpYmVyMjt9fWlmKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpey8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4vLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbmV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCl7cmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLGNoaWxkKTt9KTt9aWYoZ2V0SXNIeWRyYXRpbmcoKSl7dmFyIF9udW1iZXJPZkZvcmtzMj1uZXdJZHg7cHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLF9udW1iZXJPZkZvcmtzMik7fXJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO31mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLG5ld0NoaWxkcmVuSXRlcmFibGUsbGFuZXMpey8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuLy8gYnV0IHVzaW5nIHRoZSBpdGVyYXRvciBpbnN0ZWFkLlxudmFyIGl0ZXJhdG9yRm49Z2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtpZih0eXBlb2YgaXRlcmF0b3JGbiE9PSdmdW5jdGlvbicpe3Rocm93IG5ldyBFcnJvcignQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluICcrJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9ey8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuaWYodHlwZW9mIFN5bWJvbD09PSdmdW5jdGlvbicmJi8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgdG9TdHJpbmdUYWdcbm5ld0NoaWxkcmVuSXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXT09PSdHZW5lcmF0b3InKXtpZighZGlkV2FybkFib3V0R2VuZXJhdG9ycyl7ZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcrJ3VuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuICcrJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnKydgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnKyd5b3UgbWlnaHQgbmVlZCB0byBwb2x5ZmlsbCB0aGVzZSBmZWF0dXJlcyBmb3Igb2xkZXIgYnJvd3NlcnMuJyk7fWRpZFdhcm5BYm91dEdlbmVyYXRvcnM9dHJ1ZTt9Ly8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG5pZihuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXM9PT1pdGVyYXRvckZuKXtpZighZGlkV2FybkFib3V0TWFwcyl7ZXJyb3IoJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJysnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTt9ZGlkV2FybkFib3V0TWFwcz10cnVlO30vLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbi8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cbnZhciBfbmV3Q2hpbGRyZW49aXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO2lmKF9uZXdDaGlsZHJlbil7dmFyIGtub3duS2V5cz1udWxsO3ZhciBfc3RlcD1fbmV3Q2hpbGRyZW4ubmV4dCgpO2Zvcig7IV9zdGVwLmRvbmU7X3N0ZXA9X25ld0NoaWxkcmVuLm5leHQoKSl7dmFyIGNoaWxkPV9zdGVwLnZhbHVlO2tub3duS2V5cz13YXJuT25JbnZhbGlkS2V5KGNoaWxkLGtub3duS2V5cyxyZXR1cm5GaWJlcik7fX19dmFyIG5ld0NoaWxkcmVuPWl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtpZihuZXdDaGlsZHJlbj09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJyk7fXZhciByZXN1bHRpbmdGaXJzdENoaWxkPW51bGw7dmFyIHByZXZpb3VzTmV3RmliZXI9bnVsbDt2YXIgb2xkRmliZXI9Y3VycmVudEZpcnN0Q2hpbGQ7dmFyIGxhc3RQbGFjZWRJbmRleD0wO3ZhciBuZXdJZHg9MDt2YXIgbmV4dE9sZEZpYmVyPW51bGw7dmFyIHN0ZXA9bmV3Q2hpbGRyZW4ubmV4dCgpO2Zvcig7b2xkRmliZXIhPT1udWxsJiYhc3RlcC5kb25lO25ld0lkeCsrLHN0ZXA9bmV3Q2hpbGRyZW4ubmV4dCgpKXtpZihvbGRGaWJlci5pbmRleD5uZXdJZHgpe25leHRPbGRGaWJlcj1vbGRGaWJlcjtvbGRGaWJlcj1udWxsO31lbHNle25leHRPbGRGaWJlcj1vbGRGaWJlci5zaWJsaW5nO312YXIgbmV3RmliZXI9dXBkYXRlU2xvdChyZXR1cm5GaWJlcixvbGRGaWJlcixzdGVwLnZhbHVlLGxhbmVzKTtpZihuZXdGaWJlcj09PW51bGwpey8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4vLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4vLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbi8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuaWYob2xkRmliZXI9PT1udWxsKXtvbGRGaWJlcj1uZXh0T2xkRmliZXI7fWJyZWFrO31pZihzaG91bGRUcmFja1NpZGVFZmZlY3RzKXtpZihvbGRGaWJlciYmbmV3RmliZXIuYWx0ZXJuYXRlPT09bnVsbCl7Ly8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4vLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG5kZWxldGVDaGlsZChyZXR1cm5GaWJlcixvbGRGaWJlcik7fX1sYXN0UGxhY2VkSW5kZXg9cGxhY2VDaGlsZChuZXdGaWJlcixsYXN0UGxhY2VkSW5kZXgsbmV3SWR4KTtpZihwcmV2aW91c05ld0ZpYmVyPT09bnVsbCl7Ly8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxucmVzdWx0aW5nRmlyc3RDaGlsZD1uZXdGaWJlcjt9ZWxzZXsvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4vLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4vLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4vLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG5wcmV2aW91c05ld0ZpYmVyLnNpYmxpbmc9bmV3RmliZXI7fXByZXZpb3VzTmV3RmliZXI9bmV3RmliZXI7b2xkRmliZXI9bmV4dE9sZEZpYmVyO31pZihzdGVwLmRvbmUpey8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsb2xkRmliZXIpO2lmKGdldElzSHlkcmF0aW5nKCkpe3ZhciBudW1iZXJPZkZvcmtzPW5ld0lkeDtwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsbnVtYmVyT2ZGb3Jrcyk7fXJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO31pZihvbGRGaWJlcj09PW51bGwpey8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbmZvcig7IXN0ZXAuZG9uZTtuZXdJZHgrKyxzdGVwPW5ld0NoaWxkcmVuLm5leHQoKSl7dmFyIF9uZXdGaWJlcjM9Y3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsc3RlcC52YWx1ZSxsYW5lcyk7aWYoX25ld0ZpYmVyMz09PW51bGwpe2NvbnRpbnVlO31sYXN0UGxhY2VkSW5kZXg9cGxhY2VDaGlsZChfbmV3RmliZXIzLGxhc3RQbGFjZWRJbmRleCxuZXdJZHgpO2lmKHByZXZpb3VzTmV3RmliZXI9PT1udWxsKXsvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG5yZXN1bHRpbmdGaXJzdENoaWxkPV9uZXdGaWJlcjM7fWVsc2V7cHJldmlvdXNOZXdGaWJlci5zaWJsaW5nPV9uZXdGaWJlcjM7fXByZXZpb3VzTmV3RmliZXI9X25ld0ZpYmVyMzt9aWYoZ2V0SXNIeWRyYXRpbmcoKSl7dmFyIF9udW1iZXJPZkZvcmtzMz1uZXdJZHg7cHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLF9udW1iZXJPZkZvcmtzMyk7fXJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO30vLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbnZhciBleGlzdGluZ0NoaWxkcmVuPW1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLG9sZEZpYmVyKTsvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG5mb3IoOyFzdGVwLmRvbmU7bmV3SWR4Kyssc3RlcD1uZXdDaGlsZHJlbi5uZXh0KCkpe3ZhciBfbmV3RmliZXI0PXVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbixyZXR1cm5GaWJlcixuZXdJZHgsc3RlcC52YWx1ZSxsYW5lcyk7aWYoX25ld0ZpYmVyNCE9PW51bGwpe2lmKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpe2lmKF9uZXdGaWJlcjQuYWx0ZXJuYXRlIT09bnVsbCl7Ly8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4vLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuLy8gbGlzdC5cbmV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5PT09bnVsbD9uZXdJZHg6X25ld0ZpYmVyNC5rZXkpO319bGFzdFBsYWNlZEluZGV4PXBsYWNlQ2hpbGQoX25ld0ZpYmVyNCxsYXN0UGxhY2VkSW5kZXgsbmV3SWR4KTtpZihwcmV2aW91c05ld0ZpYmVyPT09bnVsbCl7cmVzdWx0aW5nRmlyc3RDaGlsZD1fbmV3RmliZXI0O31lbHNle3ByZXZpb3VzTmV3RmliZXIuc2libGluZz1fbmV3RmliZXI0O31wcmV2aW91c05ld0ZpYmVyPV9uZXdGaWJlcjQ7fX1pZihzaG91bGRUcmFja1NpZGVFZmZlY3RzKXsvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG5leGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpe3JldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlcixjaGlsZCk7fSk7fWlmKGdldElzSHlkcmF0aW5nKCkpe3ZhciBfbnVtYmVyT2ZGb3JrczQ9bmV3SWR4O3B1c2hUcmVlRm9yayhyZXR1cm5GaWJlcixfbnVtYmVyT2ZGb3JrczQpO31yZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDt9ZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsdGV4dENvbnRlbnQsbGFuZXMpey8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuaWYoY3VycmVudEZpcnN0Q2hpbGQhPT1udWxsJiZjdXJyZW50Rmlyc3RDaGlsZC50YWc9PT1Ib3N0VGV4dCl7Ly8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuLy8gdGhlIHJlc3QuXG5kZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTt2YXIgZXhpc3Rpbmc9dXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsdGV4dENvbnRlbnQpO2V4aXN0aW5nLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gZXhpc3Rpbmc7fS8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4vLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQpO3ZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7Y3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGNyZWF0ZWQ7fWZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsZWxlbWVudCxsYW5lcyl7dmFyIGtleT1lbGVtZW50LmtleTt2YXIgY2hpbGQ9Y3VycmVudEZpcnN0Q2hpbGQ7d2hpbGUoY2hpbGQhPT1udWxsKXsvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG5pZihjaGlsZC5rZXk9PT1rZXkpe3ZhciBlbGVtZW50VHlwZT1lbGVtZW50LnR5cGU7aWYoZWxlbWVudFR5cGU9PT1SRUFDVF9GUkFHTUVOVF9UWVBFKXtpZihjaGlsZC50YWc9PT1GcmFnbWVudCl7ZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsY2hpbGQuc2libGluZyk7dmFyIGV4aXN0aW5nPXVzZUZpYmVyKGNoaWxkLGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO2V4aXN0aW5nLnJldHVybj1yZXR1cm5GaWJlcjt7ZXhpc3RpbmcuX2RlYnVnU291cmNlPWVsZW1lbnQuX3NvdXJjZTtleGlzdGluZy5fZGVidWdPd25lcj1lbGVtZW50Ll9vd25lcjt9cmV0dXJuIGV4aXN0aW5nO319ZWxzZXtpZihjaGlsZC5lbGVtZW50VHlwZT09PWVsZW1lbnRUeXBlfHwvLyBLZWVwIHRoaXMgY2hlY2sgaW5saW5lIHNvIGl0IG9ubHkgcnVucyBvbiB0aGUgZmFsc2UgcGF0aDpcbmlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjaGlsZCxlbGVtZW50KXx8Ly8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4vLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG4vLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2Vcbi8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbnR5cGVvZiBlbGVtZW50VHlwZT09PSdvYmplY3QnJiZlbGVtZW50VHlwZSE9PW51bGwmJmVsZW1lbnRUeXBlLiQkdHlwZW9mPT09UkVBQ1RfTEFaWV9UWVBFJiZyZXNvbHZlTGF6eShlbGVtZW50VHlwZSk9PT1jaGlsZC50eXBlKXtkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjaGlsZC5zaWJsaW5nKTt2YXIgX2V4aXN0aW5nPXVzZUZpYmVyKGNoaWxkLGVsZW1lbnQucHJvcHMpO19leGlzdGluZy5yZWY9Y29lcmNlUmVmKHJldHVybkZpYmVyLGNoaWxkLGVsZW1lbnQpO19leGlzdGluZy5yZXR1cm49cmV0dXJuRmliZXI7e19leGlzdGluZy5fZGVidWdTb3VyY2U9ZWxlbWVudC5fc291cmNlO19leGlzdGluZy5fZGVidWdPd25lcj1lbGVtZW50Ll9vd25lcjt9cmV0dXJuIF9leGlzdGluZzt9fS8vIERpZG4ndCBtYXRjaC5cbmRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGNoaWxkKTticmVhazt9ZWxzZXtkZWxldGVDaGlsZChyZXR1cm5GaWJlcixjaGlsZCk7fWNoaWxkPWNoaWxkLnNpYmxpbmc7fWlmKGVsZW1lbnQudHlwZT09PVJFQUNUX0ZSQUdNRU5UX1RZUEUpe3ZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4scmV0dXJuRmliZXIubW9kZSxsYW5lcyxlbGVtZW50LmtleSk7Y3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGNyZWF0ZWQ7fWVsc2V7dmFyIF9jcmVhdGVkND1jcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7X2NyZWF0ZWQ0LnJlZj1jb2VyY2VSZWYocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsZWxlbWVudCk7X2NyZWF0ZWQ0LnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gX2NyZWF0ZWQ0O319ZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLHBvcnRhbCxsYW5lcyl7dmFyIGtleT1wb3J0YWwua2V5O3ZhciBjaGlsZD1jdXJyZW50Rmlyc3RDaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpey8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4vLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbmlmKGNoaWxkLmtleT09PWtleSl7aWYoY2hpbGQudGFnPT09SG9zdFBvcnRhbCYmY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm89PT1wb3J0YWwuY29udGFpbmVySW5mbyYmY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uPT09cG9ydGFsLmltcGxlbWVudGF0aW9uKXtkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjaGlsZC5zaWJsaW5nKTt2YXIgZXhpc3Rpbmc9dXNlRmliZXIoY2hpbGQscG9ydGFsLmNoaWxkcmVufHxbXSk7ZXhpc3RpbmcucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBleGlzdGluZzt9ZWxzZXtkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjaGlsZCk7YnJlYWs7fX1lbHNle2RlbGV0ZUNoaWxkKHJldHVybkZpYmVyLGNoaWxkKTt9Y2hpbGQ9Y2hpbGQuc2libGluZzt9dmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9Ly8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuLy8gaXRzZWxmLiBUaGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNpZGUtZWZmZWN0IGxpc3QgYXMgd2UgcGFzcyB0aHJvdWdoIHRoZVxuLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG5mdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxuZXdDaGlsZCxsYW5lcyl7Ly8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuLy8gSWYgdGhlIHRvcCBsZXZlbCBpdGVtIGlzIGFuIGFycmF5LCB3ZSB0cmVhdCBpdCBhcyBhIHNldCBvZiBjaGlsZHJlbixcbi8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cbi8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbi8vIFRoaXMgbGVhZHMgdG8gYW4gYW1iaWd1aXR5IGJldHdlZW4gPD57Wy4uLl19PC8+IGFuZCA8Pi4uLjwvPi5cbi8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG52YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudD10eXBlb2YgbmV3Q2hpbGQ9PT0nb2JqZWN0JyYmbmV3Q2hpbGQhPT1udWxsJiZuZXdDaGlsZC50eXBlPT09UkVBQ1RfRlJBR01FTlRfVFlQRSYmbmV3Q2hpbGQua2V5PT09bnVsbDtpZihpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KXtuZXdDaGlsZD1uZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjt9Ly8gSGFuZGxlIG9iamVjdCB0eXBlc1xuaWYodHlwZW9mIG5ld0NoaWxkPT09J29iamVjdCcmJm5ld0NoaWxkIT09bnVsbCl7c3dpdGNoKG5ld0NoaWxkLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpyZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLG5ld0NoaWxkLGxhbmVzKSk7Y2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpyZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsbmV3Q2hpbGQsbGFuZXMpKTtjYXNlIFJFQUNUX0xBWllfVFlQRTp2YXIgcGF5bG9hZD1uZXdDaGlsZC5fcGF5bG9hZDt2YXIgaW5pdD1uZXdDaGlsZC5faW5pdDsvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIG5vbi1yZWN1cnNpdmUuXG5yZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnMocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsaW5pdChwYXlsb2FkKSxsYW5lcyk7fWlmKGlzQXJyYXkobmV3Q2hpbGQpKXtyZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxuZXdDaGlsZCxsYW5lcyk7fWlmKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKXtyZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxuZXdDaGlsZCxsYW5lcyk7fXRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlcixuZXdDaGlsZCk7fWlmKHR5cGVvZiBuZXdDaGlsZD09PSdzdHJpbmcnJiZuZXdDaGlsZCE9PScnfHx0eXBlb2YgbmV3Q2hpbGQ9PT0nbnVtYmVyJyl7cmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsJycrbmV3Q2hpbGQsbGFuZXMpKTt9e2lmKHR5cGVvZiBuZXdDaGlsZD09PSdmdW5jdGlvbicpe3dhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7fX0vLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxucmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkKTt9cmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO312YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnM9Q2hpbGRSZWNvbmNpbGVyKHRydWUpO3ZhciBtb3VudENoaWxkRmliZXJzPUNoaWxkUmVjb25jaWxlcihmYWxzZSk7ZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LHdvcmtJblByb2dyZXNzKXtpZihjdXJyZW50IT09bnVsbCYmd29ya0luUHJvZ3Jlc3MuY2hpbGQhPT1jdXJyZW50LmNoaWxkKXt0aHJvdyBuZXcgRXJyb3IoJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKTt9aWYod29ya0luUHJvZ3Jlc3MuY2hpbGQ9PT1udWxsKXtyZXR1cm47fXZhciBjdXJyZW50Q2hpbGQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7dmFyIG5ld0NoaWxkPWNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCxjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1uZXdDaGlsZDtuZXdDaGlsZC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7d2hpbGUoY3VycmVudENoaWxkLnNpYmxpbmchPT1udWxsKXtjdXJyZW50Q2hpbGQ9Y3VycmVudENoaWxkLnNpYmxpbmc7bmV3Q2hpbGQ9bmV3Q2hpbGQuc2libGluZz1jcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7bmV3Q2hpbGQucmV0dXJuPXdvcmtJblByb2dyZXNzO31uZXdDaGlsZC5zaWJsaW5nPW51bGw7fS8vIFJlc2V0IGEgd29ya0luUHJvZ3Jlc3MgY2hpbGQgc2V0IHRvIHByZXBhcmUgaXQgZm9yIGEgc2Vjb25kIHBhc3MuXG5mdW5jdGlvbiByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLGxhbmVzKXt2YXIgY2hpbGQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7d2hpbGUoY2hpbGQhPT1udWxsKXtyZXNldFdvcmtJblByb2dyZXNzKGNoaWxkLGxhbmVzKTtjaGlsZD1jaGlsZC5zaWJsaW5nO319dmFyIE5PX0NPTlRFWFQ9e307dmFyIGNvbnRleHRTdGFja0N1cnNvciQxPWNyZWF0ZUN1cnNvcihOT19DT05URVhUKTt2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3I9Y3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO3ZhciByb290SW5zdGFuY2VTdGFja0N1cnNvcj1jcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7ZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0KGMpe2lmKGM9PT1OT19DT05URVhUKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcrJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9cmV0dXJuIGM7fWZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCl7dmFyIHJvb3RJbnN0YW5jZT1yZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7cmV0dXJuIHJvb3RJbnN0YW5jZTt9ZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsbmV4dFJvb3RJbnN0YW5jZSl7Ly8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4vLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxucHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvcixuZXh0Um9vdEluc3RhbmNlLGZpYmVyKTsvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4vLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5wdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLGZpYmVyLGZpYmVyKTsvLyBGaW5hbGx5LCB3ZSBuZWVkIHRvIHB1c2ggdGhlIGhvc3QgY29udGV4dCB0byB0aGUgc3RhY2suXG4vLyBIb3dldmVyLCB3ZSBjYW4ndCBqdXN0IGNhbGwgZ2V0Um9vdEhvc3RDb250ZXh0KCkgYW5kIHB1c2ggaXQgYmVjYXVzZVxuLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbi8vIHdoZXRoZXIgZ2V0Um9vdEhvc3RDb250ZXh0KCkgdGhyb3dzIHNvbWV3aGVyZSBpbiByZW5kZXJlciBjb2RlIG9yIG5vdC5cbi8vIFNvIHdlIHB1c2ggYW4gZW1wdHkgdmFsdWUgZmlyc3QuIFRoaXMgbGV0cyB1cyBzYWZlbHkgdW53aW5kIG9uIGVycm9ycy5cbnB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsTk9fQ09OVEVYVCxmaWJlcik7dmFyIG5leHRSb290Q29udGV4dD1nZXRSb290SG9zdENvbnRleHQobmV4dFJvb3RJbnN0YW5jZSk7Ly8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG5wb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsZmliZXIpO3B1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsbmV4dFJvb3RDb250ZXh0LGZpYmVyKTt9ZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcil7cG9wKGNvbnRleHRTdGFja0N1cnNvciQxLGZpYmVyKTtwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsZmliZXIpO3BvcChyb290SW5zdGFuY2VTdGFja0N1cnNvcixmaWJlcik7fWZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCl7dmFyIGNvbnRleHQ9cmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO3JldHVybiBjb250ZXh0O31mdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpe3ZhciByb290SW5zdGFuY2U9cmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO3ZhciBjb250ZXh0PXJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTt2YXIgbmV4dENvbnRleHQ9Z2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LGZpYmVyLnR5cGUpOy8vIERvbid0IHB1c2ggdGhpcyBGaWJlcidzIGNvbnRleHQgdW5sZXNzIGl0J3MgdW5pcXVlLlxuaWYoY29udGV4dD09PW5leHRDb250ZXh0KXtyZXR1cm47fS8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbi8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbnB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsZmliZXIsZmliZXIpO3B1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsbmV4dENvbnRleHQsZmliZXIpO31mdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcil7Ly8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5pZihjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50IT09ZmliZXIpe3JldHVybjt9cG9wKGNvbnRleHRTdGFja0N1cnNvciQxLGZpYmVyKTtwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsZmliZXIpO312YXIgRGVmYXVsdFN1c3BlbnNlQ29udGV4dD0wOy8vIFRoZSBTdXNwZW5zZSBDb250ZXh0IGlzIHNwbGl0IGludG8gdHdvIHBhcnRzLiBUaGUgbG93ZXIgYml0cyBpc1xuLy8gaW5oZXJpdGVkIGRlZXBseSBkb3duIHRoZSBzdWJ0cmVlLiBUaGUgdXBwZXIgYml0cyBvbmx5IGFmZmVjdFxuLy8gdGhpcyBpbW1lZGlhdGUgc3VzcGVuc2UgYm91bmRhcnkgYW5kIGdldHMgcmVzZXQgZWFjaCBuZXdcbi8vIGJvdW5kYXJ5IG9yIHN1c3BlbnNlIGxpc3QuXG52YXIgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s9MTsvLyBTdWJ0cmVlIEZsYWdzOlxuLy8gSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0IGluZGljYXRlcyB0aGF0IG9uZSBvZiBvdXIgcGFyZW50IFN1c3BlbnNlXG4vLyBib3VuZGFyaWVzIGlzIG5vdCBjdXJyZW50bHkgc2hvd2luZyB2aXNpYmxlIG1haW4gY29udGVudC5cbi8vIEVpdGhlciBiZWNhdXNlIGl0IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIG9yIGlzIG5vdCBtb3VudGVkIGF0IGFsbC5cbi8vIFdlIGNhbiB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgaXQgaXMgZGVzaXJhYmxlIHRvIHRyaWdnZXIgYSBmYWxsYmFjayBhdFxuLy8gdGhlIHBhcmVudC4gSWYgbm90LCB0aGVuIHdlIG1pZ2h0IG5lZWQgdG8gdHJpZ2dlciB1bmRlc2lyYWJsZSBib3VuZGFyaWVzXG4vLyBhbmQvb3Igc3VzcGVuZCB0aGUgY29tbWl0IHRvIGF2b2lkIGhpZGluZyB0aGUgcGFyZW50IGNvbnRlbnQuXG52YXIgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0PTE7Ly8gU2hhbGxvdyBGbGFnczpcbi8vIEZvcmNlU3VzcGVuc2VGYWxsYmFjayBjYW4gYmUgdXNlZCBieSBTdXNwZW5zZUxpc3QgdG8gZm9yY2UgbmV3bHkgYWRkZWRcbi8vIGl0ZW1zIGludG8gdGhlaXIgZmFsbGJhY2sgc3RhdGUgZHVyaW5nIG9uZSBvZiB0aGUgcmVuZGVyIHBhc3Nlcy5cbnZhciBGb3JjZVN1c3BlbnNlRmFsbGJhY2s9Mjt2YXIgc3VzcGVuc2VTdGFja0N1cnNvcj1jcmVhdGVDdXJzb3IoRGVmYXVsdFN1c3BlbnNlQ29udGV4dCk7ZnVuY3Rpb24gaGFzU3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsZmxhZyl7cmV0dXJuKHBhcmVudENvbnRleHQmZmxhZykhPT0wO31mdW5jdGlvbiBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0KXtyZXR1cm4gcGFyZW50Q29udGV4dCZTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzazt9ZnVuY3Rpb24gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LHNoYWxsb3dDb250ZXh0KXtyZXR1cm4gcGFyZW50Q29udGV4dCZTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFza3xzaGFsbG93Q29udGV4dDt9ZnVuY3Rpb24gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LHN1YnRyZWVDb250ZXh0KXtyZXR1cm4gcGFyZW50Q29udGV4dHxzdWJ0cmVlQ29udGV4dDt9ZnVuY3Rpb24gcHVzaFN1c3BlbnNlQ29udGV4dChmaWJlcixuZXdDb250ZXh0KXtwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsbmV3Q29udGV4dCxmaWJlcik7fWZ1bmN0aW9uIHBvcFN1c3BlbnNlQ29udGV4dChmaWJlcil7cG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsZmliZXIpO31mdW5jdGlvbiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uod29ya0luUHJvZ3Jlc3MsaGFzSW52aXNpYmxlUGFyZW50KXsvLyBJZiBpdCB3YXMgdGhlIHByaW1hcnkgY2hpbGRyZW4gdGhhdCBqdXN0IHN1c3BlbmRlZCwgY2FwdHVyZSBhbmQgcmVuZGVyIHRoZVxuLy8gZmFsbGJhY2suIE90aGVyd2lzZSwgZG9uJ3QgY2FwdHVyZSBhbmQgYnViYmxlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxudmFyIG5leHRTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO2lmKG5leHRTdGF0ZSE9PW51bGwpe2lmKG5leHRTdGF0ZS5kZWh5ZHJhdGVkIT09bnVsbCl7Ly8gQSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGFsd2F5cyBjYXB0dXJlcy5cbnJldHVybiB0cnVlO31yZXR1cm4gZmFsc2U7fXZhciBwcm9wcz13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzOy8vIFJlZ3VsYXIgYm91bmRhcmllcyBhbHdheXMgY2FwdHVyZS5cbntyZXR1cm4gdHJ1ZTt9Ly8gSWYgaXQncyBhIGJvdW5kYXJ5IHdlIHNob3VsZCBhdm9pZCwgdGhlbiB3ZSBwcmVmZXIgdG8gYnViYmxlIHVwIHRvIHRoZVxufWZ1bmN0aW9uIGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpe3ZhciBub2RlPXJvdzt3aGlsZShub2RlIT09bnVsbCl7aWYobm9kZS50YWc9PT1TdXNwZW5zZUNvbXBvbmVudCl7dmFyIHN0YXRlPW5vZGUubWVtb2l6ZWRTdGF0ZTtpZihzdGF0ZSE9PW51bGwpe3ZhciBkZWh5ZHJhdGVkPXN0YXRlLmRlaHlkcmF0ZWQ7aWYoZGVoeWRyYXRlZD09PW51bGx8fGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCl8fGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGRlaHlkcmF0ZWQpKXtyZXR1cm4gbm9kZTt9fX1lbHNlIGlmKG5vZGUudGFnPT09U3VzcGVuc2VMaXN0Q29tcG9uZW50JiYvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4vLyBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgaXQgc3VzcGVuZGVkIG9yIG5vdC5cbm5vZGUubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlciE9PXVuZGVmaW5lZCl7dmFyIGRpZFN1c3BlbmQ9KG5vZGUuZmxhZ3MmRGlkQ2FwdHVyZSkhPT1Ob0ZsYWdzO2lmKGRpZFN1c3BlbmQpe3JldHVybiBub2RlO319ZWxzZSBpZihub2RlLmNoaWxkIT09bnVsbCl7bm9kZS5jaGlsZC5yZXR1cm49bm9kZTtub2RlPW5vZGUuY2hpbGQ7Y29udGludWU7fWlmKG5vZGU9PT1yb3cpe3JldHVybiBudWxsO313aGlsZShub2RlLnNpYmxpbmc9PT1udWxsKXtpZihub2RlLnJldHVybj09PW51bGx8fG5vZGUucmV0dXJuPT09cm93KXtyZXR1cm4gbnVsbDt9bm9kZT1ub2RlLnJldHVybjt9bm9kZS5zaWJsaW5nLnJldHVybj1ub2RlLnJldHVybjtub2RlPW5vZGUuc2libGluZzt9cmV0dXJuIG51bGw7fXZhciBOb0ZsYWdzJDE9LyogICAqLzA7Ly8gUmVwcmVzZW50cyB3aGV0aGVyIGVmZmVjdCBzaG91bGQgZmlyZS5cbnZhciBIYXNFZmZlY3Q9LyogKi8xOy8vIFJlcHJlc2VudHMgdGhlIHBoYXNlIGluIHdoaWNoIHRoZSBlZmZlY3QgKG5vdCB0aGUgY2xlYW4tdXApIGZpcmVzLlxudmFyIEluc2VydGlvbj0vKiAgKi8yO3ZhciBMYXlvdXQ9LyogICAgKi80O3ZhciBQYXNzaXZlJDE9LyogICAqLzg7Ly8gYW5kIHNob3VsZCBiZSByZXNldCBiZWZvcmUgc3RhcnRpbmcgYSBuZXcgcmVuZGVyLlxuLy8gVGhpcyB0cmFja3Mgd2hpY2ggbXV0YWJsZSBzb3VyY2VzIG5lZWQgdG8gYmUgcmVzZXQgYWZ0ZXIgYSByZW5kZXIuXG52YXIgd29ya0luUHJvZ3Jlc3NTb3VyY2VzPVtdO2Z1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpe2Zvcih2YXIgaT0wO2k8d29ya0luUHJvZ3Jlc3NTb3VyY2VzLmxlbmd0aDtpKyspe3ZhciBtdXRhYmxlU291cmNlPXdvcmtJblByb2dyZXNzU291cmNlc1tpXTt7bXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeT1udWxsO319d29ya0luUHJvZ3Jlc3NTb3VyY2VzLmxlbmd0aD0wO30vLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdmVyc2lvbiB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nIG1hdGNoZXMgdGhlIG9uZVxuLy8gdGhhdCBpcyBldmVudHVhbGx5IHJlYWQgZHVyaW5nIGh5ZHJhdGlvbi5cbi8vIElmIHRoZXkgZG9uJ3QgbWF0Y2ggdGhlcmUncyBhIHBvdGVudGlhbCB0ZWFyIGFuZCBhIGZ1bGwgZGVvcHQgcmVuZGVyIGlzIHJlcXVpcmVkLlxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsbXV0YWJsZVNvdXJjZSl7dmFyIGdldFZlcnNpb249bXV0YWJsZVNvdXJjZS5fZ2V0VmVyc2lvbjt2YXIgdmVyc2lvbj1nZXRWZXJzaW9uKG11dGFibGVTb3VyY2UuX3NvdXJjZSk7Ly8gVE9ETyBDbGVhciB0aGlzIGRhdGEgb25jZSBhbGwgcGVuZGluZyBoeWRyYXRpb24gd29yayBpcyBmaW5pc2hlZC5cbi8vIFJldGFpbmluZyBpdCBmb3JldmVyIG1heSBpbnRlcmZlcmUgd2l0aCBHQy5cbmlmKHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT09bnVsbCl7cm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPVttdXRhYmxlU291cmNlLHZlcnNpb25dO31lbHNle3Jvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YS5wdXNoKG11dGFibGVTb3VyY2UsdmVyc2lvbik7fX12YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMj1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZzt2YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50O3ZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdDt7ZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50PW5ldyBTZXQoKTt9Ly8gVGhlc2UgYXJlIHNldCByaWdodCBiZWZvcmUgY2FsbGluZyB0aGUgY29tcG9uZW50LlxudmFyIHJlbmRlckxhbmVzPU5vTGFuZXM7Ly8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIEkndmUgbmFtZWQgaXQgZGlmZmVyZW50bHkgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuLy8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxPW51bGw7Ly8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbnZhciBjdXJyZW50SG9vaz1udWxsO3ZhciB3b3JrSW5Qcm9ncmVzc0hvb2s9bnVsbDsvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlPWZhbHNlOy8vIFdoZXJlIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9ubHkgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlciBwYXNzLiBUaGlzXG4vLyBnZXRzIHJlc2V0IGFmdGVyIGVhY2ggYXR0ZW1wdC5cbi8vIFRPRE86IE1heWJlIHRoZXJlJ3Mgc29tZSB3YXkgdG8gY29uc29saWRhdGUgdGhpcyB3aXRoXG4vLyBgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZWAuIE9yIHdpdGggYG51bWJlck9mUmVSZW5kZXJzYC5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3M9ZmFsc2U7Ly8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlSWQgaG9va3MgaW4gdGhpcyBjb21wb25lbnQuXG52YXIgbG9jYWxJZENvdW50ZXI9MDsvLyBVc2VkIGZvciBpZHMgdGhhdCBhcmUgZ2VuZXJhdGVkIGNvbXBsZXRlbHkgY2xpZW50LXNpZGUgKGkuZS4gbm90IGR1cmluZ1xuLy8gaHlkcmF0aW9uKS4gVGhpcyBjb3VudGVyIGlzIGdsb2JhbCwgc28gY2xpZW50IGlkcyBhcmUgbm90IHN0YWJsZSBhY3Jvc3Ncbi8vIHJlbmRlciBhdHRlbXB0cy5cbnZhciBnbG9iYWxDbGllbnRJZENvdW50ZXI9MDt2YXIgUkVfUkVOREVSX0xJTUlUPTI1Oy8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2PW51bGw7Ly8gSW4gREVWLCB0aGlzIGxpc3QgZW5zdXJlcyB0aGF0IGhvb2tzIGFyZSBjYWxsZWQgaW4gdGhlIHNhbWUgb3JkZXIgYmV0d2VlbiByZW5kZXJzLlxuLy8gVGhlIGxpc3Qgc3RvcmVzIHRoZSBvcmRlciBvZiBob29rcyB1c2VkIGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXIgKG1vdW50KS5cbi8vIFN1YnNlcXVlbnQgcmVuZGVycyAodXBkYXRlcykgcmVmZXJlbmNlIHRoaXMgbGlzdC5cbnZhciBob29rVHlwZXNEZXY9bnVsbDt2YXIgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY9LTE7Ly8gSW4gREVWLCB0aGlzIHRyYWNrcyB3aGV0aGVyIGN1cnJlbnRseSByZW5kZXJpbmcgY29tcG9uZW50IG5lZWRzIHRvIGlnbm9yZVxuLy8gdGhlIGRlcGVuZGVuY2llcyBmb3IgSG9va3MgdGhhdCBuZWVkIHRoZW0gKGUuZy4gdXNlRWZmZWN0IG9yIHVzZU1lbW8pLlxuLy8gV2hlbiB0cnVlLCBzdWNoIEhvb2tzIHdpbGwgYWx3YXlzIGJlIFwicmVtb3VudGVkXCIuIE9ubHkgdXNlZCBkdXJpbmcgaG90IHJlbG9hZC5cbnZhciBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcz1mYWxzZTtmdW5jdGlvbiBtb3VudEhvb2tUeXBlc0Rldigpe3t2YXIgaG9va05hbWU9Y3VycmVudEhvb2tOYW1lSW5EZXY7aWYoaG9va1R5cGVzRGV2PT09bnVsbCl7aG9va1R5cGVzRGV2PVtob29rTmFtZV07fWVsc2V7aG9va1R5cGVzRGV2LnB1c2goaG9va05hbWUpO319fWZ1bmN0aW9uIHVwZGF0ZUhvb2tUeXBlc0Rldigpe3t2YXIgaG9va05hbWU9Y3VycmVudEhvb2tOYW1lSW5EZXY7aWYoaG9va1R5cGVzRGV2IT09bnVsbCl7aG9va1R5cGVzVXBkYXRlSW5kZXhEZXYrKztpZihob29rVHlwZXNEZXZbaG9va1R5cGVzVXBkYXRlSW5kZXhEZXZdIT09aG9va05hbWUpe3dhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGhvb2tOYW1lKTt9fX19ZnVuY3Rpb24gY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyl7e2lmKGRlcHMhPT11bmRlZmluZWQmJmRlcHMhPT1udWxsJiYhaXNBcnJheShkZXBzKSl7Ly8gVmVyaWZ5IGRlcHMsIGJ1dCBvbmx5IG9uIG1vdW50IHRvIGF2b2lkIGV4dHJhIGNoZWNrcy5cbi8vIEl0J3MgdW5saWtlbHkgdGhlaXIgdHlwZSB3b3VsZCBjaGFuZ2UgYXMgdXN1YWxseSB5b3UgZGVmaW5lIHRoZW0gaW5saW5lLlxuZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgdGhhdCBpcyBub3QgYW4gYXJyYXkgKGluc3RlYWQsIHJlY2VpdmVkIGAlc2ApLiBXaGVuICcrJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJyxjdXJyZW50SG9va05hbWVJbkRldix0eXBlb2YgZGVwcyk7fX19ZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKXt7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtpZighZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSl7ZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtpZihob29rVHlwZXNEZXYhPT1udWxsKXt2YXIgdGFibGU9Jyc7dmFyIHNlY29uZENvbHVtblN0YXJ0PTMwO2Zvcih2YXIgaT0wO2k8PWhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2O2krKyl7dmFyIG9sZEhvb2tOYW1lPWhvb2tUeXBlc0RldltpXTt2YXIgbmV3SG9va05hbWU9aT09PWhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2P2N1cnJlbnRIb29rTmFtZTpvbGRIb29rTmFtZTt2YXIgcm93PWkrMStcIi4gXCIrb2xkSG9va05hbWU7Ly8gRXh0cmEgc3BhY2Ugc28gc2Vjb25kIGNvbHVtbiBsaW5lcyB1cFxuLy8gbG9sIEAgSUUgbm90IHN1cHBvcnRpbmcgU3RyaW5nI3JlcGVhdFxud2hpbGUocm93Lmxlbmd0aDxzZWNvbmRDb2x1bW5TdGFydCl7cm93Kz0nICc7fXJvdys9bmV3SG9va05hbWUrJ1xcbic7dGFibGUrPXJvdzt9ZXJyb3IoJ1JlYWN0IGhhcyBkZXRlY3RlZCBhIGNoYW5nZSBpbiB0aGUgb3JkZXIgb2YgSG9va3MgY2FsbGVkIGJ5ICVzLiAnKydUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiAnKydGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbicrJyAgIFByZXZpb3VzIHJlbmRlciAgICAgICAgICAgIE5leHQgcmVuZGVyXFxuJysnICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJysnJXMnKycgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cXG4nLGNvbXBvbmVudE5hbWUsdGFibGUpO319fX1mdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKXt0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InKycgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nKycxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nKycyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJysnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO31mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMscHJldkRlcHMpe3tpZihpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyl7Ly8gT25seSB0cnVlIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYmVpbmcgaG90IHJlbG9hZGVkLlxucmV0dXJuIGZhbHNlO319aWYocHJldkRlcHM9PT1udWxsKXt7ZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnKyd0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsICcrJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsY3VycmVudEhvb2tOYW1lSW5EZXYpO31yZXR1cm4gZmFsc2U7fXsvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbi8vIHBhc3NlZCBpbmxpbmUuXG5pZihuZXh0RGVwcy5sZW5ndGghPT1wcmV2RGVwcy5sZW5ndGgpe2Vycm9yKCdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnKydvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicrJ1ByZXZpb3VzOiAlc1xcbicrJ0luY29taW5nOiAlcycsY3VycmVudEhvb2tOYW1lSW5EZXYsXCJbXCIrcHJldkRlcHMuam9pbignLCAnKStcIl1cIixcIltcIituZXh0RGVwcy5qb2luKCcsICcpK1wiXVwiKTt9fWZvcih2YXIgaT0wO2k8cHJldkRlcHMubGVuZ3RoJiZpPG5leHREZXBzLmxlbmd0aDtpKyspe2lmKG9iamVjdElzKG5leHREZXBzW2ldLHByZXZEZXBzW2ldKSl7Y29udGludWU7fXJldHVybiBmYWxzZTt9cmV0dXJuIHRydWU7fWZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxwcm9wcyxzZWNvbmRBcmcsbmV4dFJlbmRlckxhbmVzKXtyZW5kZXJMYW5lcz1uZXh0UmVuZGVyTGFuZXM7Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMT13b3JrSW5Qcm9ncmVzczt7aG9va1R5cGVzRGV2PWN1cnJlbnQhPT1udWxsP2N1cnJlbnQuX2RlYnVnSG9va1R5cGVzOm51bGw7aG9va1R5cGVzVXBkYXRlSW5kZXhEZXY9LTE7Ly8gVXNlZCBmb3IgaG90IHJlbG9hZGluZzpcbmlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzPWN1cnJlbnQhPT1udWxsJiZjdXJyZW50LnR5cGUhPT13b3JrSW5Qcm9ncmVzcy50eXBlO313b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW51bGw7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9bnVsbDt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1Ob0xhbmVzOy8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG4vLyBjdXJyZW50SG9vayA9IG51bGw7XG4vLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuLy8gVE9ETyBXYXJuIGlmIG5vIGhvb2tzIGFyZSB1c2VkIGF0IGFsbCBkdXJpbmcgbW91bnQsIHRoZW4gc29tZSBhcmUgdXNlZCBkdXJpbmcgdXBkYXRlLlxuLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG4vLyBUaGlzIGlzIHRyaWNreSBiZWNhdXNlIGl0J3MgdmFsaWQgZm9yIGNlcnRhaW4gdHlwZXMgb2YgY29tcG9uZW50cyAoZS5nLiBSZWFjdC5sYXp5KVxuLy8gVXNpbmcgbWVtb2l6ZWRTdGF0ZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbW91bnQvdXBkYXRlIG9ubHkgd29ya3MgaWYgYXQgbGVhc3Qgb25lIHN0YXRlZnVsIGhvb2sgaXMgdXNlZC5cbi8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcbi8vIHNvIG1lbW9pemVkU3RhdGUgd291bGQgYmUgbnVsbCBkdXJpbmcgdXBkYXRlcyBhbmQgbW91bnRzLlxue2lmKGN1cnJlbnQhPT1udWxsJiZjdXJyZW50Lm1lbW9pemVkU3RhdGUhPT1udWxsKXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1Ib29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO31lbHNlIGlmKGhvb2tUeXBlc0RldiE9PW51bGwpey8vIFRoaXMgZGlzcGF0Y2hlciBoYW5kbGVzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNvbXBvbmVudCBpcyB1cGRhdGluZyxcbi8vIGJ1dCBubyBzdGF0ZWZ1bCBob29rcyBoYXZlIGJlZW4gdXNlZC5cbi8vIFdlIHdhbnQgdG8gbWF0Y2ggdGhlIHByb2R1Y3Rpb24gY29kZSBiZWhhdmlvciAod2hpY2ggd2lsbCB1c2UgSG9va3NEaXNwYXRjaGVyT25Nb3VudCksXG4vLyBidXQgd2l0aCB0aGUgZXh0cmEgREVWIHZhbGlkYXRpb24gdG8gZW5zdXJlIGhvb2tzIG9yZGVyaW5nIGhhc24ndCBjaGFuZ2VkLlxuLy8gVGhpcyBkaXNwYXRjaGVyIGRvZXMgdGhhdC5cblJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7fWVsc2V7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO319dmFyIGNoaWxkcmVuPUNvbXBvbmVudChwcm9wcyxzZWNvbmRBcmcpOy8vIENoZWNrIGlmIHRoZXJlIHdhcyBhIHJlbmRlciBwaGFzZSB1cGRhdGVcbmlmKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyl7Ly8gS2VlcCByZW5kZXJpbmcgaW4gYSBsb29wIGZvciBhcyBsb25nIGFzIHJlbmRlciBwaGFzZSB1cGRhdGVzIGNvbnRpbnVlIHRvXG4vLyBiZSBzY2hlZHVsZWQuIFVzZSBhIGNvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbnZhciBudW1iZXJPZlJlUmVuZGVycz0wO2Rve2RpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcz1mYWxzZTtsb2NhbElkQ291bnRlcj0wO2lmKG51bWJlck9mUmVSZW5kZXJzPj1SRV9SRU5ERVJfTElNSVQpe3Rocm93IG5ldyBFcnJvcignVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50ICcrJ2FuIGluZmluaXRlIGxvb3AuJyk7fW51bWJlck9mUmVSZW5kZXJzKz0xO3svLyBFdmVuIHdoZW4gaG90IHJlbG9hZGluZywgYWxsb3cgZGVwZW5kZW5jaWVzIHRvIHN0YWJpbGl6ZVxuLy8gYWZ0ZXIgZmlyc3QgcmVuZGVyIHRvIHByZXZlbnQgaW5maW5pdGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuXG5pZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcz1mYWxzZTt9Ly8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcbmN1cnJlbnRIb29rPW51bGw7d29ya0luUHJvZ3Jlc3NIb29rPW51bGw7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9bnVsbDt7Ly8gQWxzbyB2YWxpZGF0ZSBob29rIG9yZGVyIGZvciBjYXNjYWRpbmcgdXBkYXRlcy5cbmhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2PS0xO31SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1Ib29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7Y2hpbGRyZW49Q29tcG9uZW50KHByb3BzLHNlY29uZEFyZyk7fXdoaWxlKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7fS8vIFdlIGNhbiBhc3N1bWUgdGhlIHByZXZpb3VzIGRpc3BhdGNoZXIgaXMgYWx3YXlzIHRoaXMgb25lLCBzaW5jZSB3ZSBzZXQgaXRcbi8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jZS5cblJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUNvbnRleHRPbmx5RGlzcGF0Y2hlcjt7d29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzPWhvb2tUeXBlc0Rldjt9Ly8gVGhpcyBjaGVjayB1c2VzIGN1cnJlbnRIb29rIHNvIHRoYXQgaXQgd29ya3MgdGhlIHNhbWUgaW4gREVWIGFuZCBwcm9kIGJ1bmRsZXMuXG4vLyBob29rVHlwZXNEZXYgY291bGQgY2F0Y2ggbW9yZSBjYXNlcyAoZS5nLiBjb250ZXh0KSBidXQgb25seSBpbiBERVYgYnVuZGxlcy5cbnZhciBkaWRSZW5kZXJUb29GZXdIb29rcz1jdXJyZW50SG9vayE9PW51bGwmJmN1cnJlbnRIb29rLm5leHQhPT1udWxsO3JlbmRlckxhbmVzPU5vTGFuZXM7Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMT1udWxsO2N1cnJlbnRIb29rPW51bGw7d29ya0luUHJvZ3Jlc3NIb29rPW51bGw7e2N1cnJlbnRIb29rTmFtZUluRGV2PW51bGw7aG9va1R5cGVzRGV2PW51bGw7aG9va1R5cGVzVXBkYXRlSW5kZXhEZXY9LTE7Ly8gQ29uZmlybSB0aGF0IGEgc3RhdGljIGZsYWcgd2FzIG5vdCBhZGRlZCBvciByZW1vdmVkIHNpbmNlIHRoZSBsYXN0XG4vLyByZW5kZXIuIElmIHRoaXMgZmlyZXMsIGl0IHN1Z2dlc3RzIHRoYXQgd2UgaW5jb3JyZWN0bHkgcmVzZXQgdGhlIHN0YXRpY1xuLy8gZmxhZ3MgaW4gc29tZSBvdGhlciBwYXJ0IG9mIHRoZSBjb2RlYmFzZS4gVGhpcyBoYXMgaGFwcGVuZWQgYmVmb3JlLCBmb3Jcbi8vIGV4YW1wbGUsIGluIHRoZSBTdXNwZW5zZUxpc3QgaW1wbGVtZW50YXRpb24uXG5pZihjdXJyZW50IT09bnVsbCYmKGN1cnJlbnQuZmxhZ3MmU3RhdGljTWFzaykhPT0od29ya0luUHJvZ3Jlc3MuZmxhZ3MmU3RhdGljTWFzaykmJi8vIERpc2FibGUgdGhpcyB3YXJuaW5nIGluIGxlZ2FjeSBtb2RlLCBiZWNhdXNlIGxlZ2FjeSBTdXNwZW5zZSBpcyB3ZWlyZFxuLy8gYW5kIGNyZWF0ZXMgZmFsc2UgcG9zaXRpdmVzLiBUbyBtYWtlIHRoaXMgd29yayBpbiBsZWdhY3kgbW9kZSwgd2UnZFxuLy8gbmVlZCB0byBtYXJrIGZpYmVycyB0aGF0IGNvbW1pdCBpbiBhbiBpbmNvbXBsZXRlIHN0YXRlLCBzb21laG93LiBGb3Jcbi8vIG5vdyBJJ2xsIGRpc2FibGUgdGhlIHdhcm5pbmcgdGhhdCBtb3N0IG9mIHRoZSBidWdzIHRoYXQgd291bGQgdHJpZ2dlclxuLy8gaXQgYXJlIGVpdGhlciBleGNsdXNpdmUgdG8gY29uY3VycmVudCBtb2RlIG9yIGV4aXN0IGluIGJvdGguXG4oY3VycmVudC5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZSl7ZXJyb3IoJ0ludGVybmFsIFJlYWN0IGVycm9yOiBFeHBlY3RlZCBzdGF0aWMgZmxhZyB3YXMgbWlzc2luZy4gUGxlYXNlICcrJ25vdGlmeSB0aGUgUmVhY3QgdGVhbS4nKTt9fWRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGU9ZmFsc2U7Ly8gVGhpcyBpcyByZXNldCBieSBjaGVja0RpZFJlbmRlcklkSG9va1xuLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuaWYoZGlkUmVuZGVyVG9vRmV3SG9va3Mpe3Rocm93IG5ldyBFcnJvcignUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgJysnZWFybHkgcmV0dXJuIHN0YXRlbWVudC4nKTt9cmV0dXJuIGNoaWxkcmVuO31mdW5jdGlvbiBjaGVja0RpZFJlbmRlcklkSG9vaygpey8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSByZW5kZXJXaXRoSG9va3MgY2FsbC5cbi8vIENvbmNlcHR1YWxseSwgaXQncyBwYXJ0IG9mIHRoZSByZXR1cm4gdmFsdWUgb2YgcmVuZGVyV2l0aEhvb2tzOyBpdCdzIG9ubHkgYVxuLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG52YXIgZGlkUmVuZGVySWRIb29rPWxvY2FsSWRDb3VudGVyIT09MDtsb2NhbElkQ291bnRlcj0wO3JldHVybiBkaWRSZW5kZXJJZEhvb2s7fWZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LHdvcmtJblByb2dyZXNzLGxhbmVzKXt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1jdXJyZW50LnVwZGF0ZVF1ZXVlOy8vIFRPRE86IERvbid0IG5lZWQgdG8gcmVzZXQgdGhlIGZsYWdzIGhlcmUsIGJlY2F1c2UgdGhleSdyZSByZXNldCBpbiB0aGVcbi8vIGNvbXBsZXRlIHBoYXNlIChidWJibGVQcm9wZXJ0aWVzKS5cbmlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdEVmZmVjdHNNb2RlKSE9PU5vTW9kZSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3MmPX4oTW91bnRQYXNzaXZlRGV2fE1vdW50TGF5b3V0RGV2fFBhc3NpdmV8VXBkYXRlKTt9ZWxzZXt3b3JrSW5Qcm9ncmVzcy5mbGFncyY9fihQYXNzaXZlfFVwZGF0ZSk7fWN1cnJlbnQubGFuZXM9cmVtb3ZlTGFuZXMoY3VycmVudC5sYW5lcyxsYW5lcyk7fWZ1bmN0aW9uIHJlc2V0SG9va3NBZnRlclRocm93KCl7Ly8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmNlLlxuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9Q29udGV4dE9ubHlEaXNwYXRjaGVyO2lmKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpey8vIFRoZXJlIHdlcmUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuIFRoZXNlIGFyZSBvbmx5IHZhbGlkIGZvciB0aGlzIHJlbmRlclxuLy8gcGhhc2UsIHdoaWNoIHdlIGFyZSBub3cgYWJvcnRpbmcuIFJlbW92ZSB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZXMgc29cbi8vIHRoZXkgZG8gbm90IHBlcnNpc3QgdG8gdGhlIG5leHQgcmVuZGVyLiBEbyBub3QgcmVtb3ZlIHVwZGF0ZXMgZnJvbSBob29rc1xuLy8gdGhhdCB3ZXJlbid0IHByb2Nlc3NlZC5cbi8vXG4vLyBPbmx5IHJlc2V0IHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlIGlmIGl0IGhhcyBhIGNsb25lLiBJZiBpdCBkb2VzXG4vLyBub3QgaGF2ZSBhIGNsb25lLCB0aGF0IG1lYW5zIGl0IHdhc24ndCBwcm9jZXNzZWQsIGFuZCB0aGUgdXBkYXRlcyB3ZXJlXG4vLyBzY2hlZHVsZWQgYmVmb3JlIHdlIGVudGVyZWQgdGhlIHJlbmRlciBwaGFzZS5cbnZhciBob29rPWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTt3aGlsZShob29rIT09bnVsbCl7dmFyIHF1ZXVlPWhvb2sucXVldWU7aWYocXVldWUhPT1udWxsKXtxdWV1ZS5wZW5kaW5nPW51bGw7fWhvb2s9aG9vay5uZXh0O31kaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlPWZhbHNlO31yZW5kZXJMYW5lcz1Ob0xhbmVzO2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE9bnVsbDtjdXJyZW50SG9vaz1udWxsO3dvcmtJblByb2dyZXNzSG9vaz1udWxsO3tob29rVHlwZXNEZXY9bnVsbDtob29rVHlwZXNVcGRhdGVJbmRleERldj0tMTtjdXJyZW50SG9va05hbWVJbkRldj1udWxsO2lzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2U9ZmFsc2U7fWRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcz1mYWxzZTtsb2NhbElkQ291bnRlcj0wO31mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpe3ZhciBob29rPXttZW1vaXplZFN0YXRlOm51bGwsYmFzZVN0YXRlOm51bGwsYmFzZVF1ZXVlOm51bGwscXVldWU6bnVsbCxuZXh0Om51bGx9O2lmKHdvcmtJblByb2dyZXNzSG9vaz09PW51bGwpey8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbmN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZT13b3JrSW5Qcm9ncmVzc0hvb2s9aG9vazt9ZWxzZXsvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxud29ya0luUHJvZ3Jlc3NIb29rPXdvcmtJblByb2dyZXNzSG9vay5uZXh0PWhvb2s7fXJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7fWZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpey8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBib3RoIGZvciB1cGRhdGVzIGFuZCBmb3IgcmUtcmVuZGVycyB0cmlnZ2VyZWQgYnkgYVxuLy8gcmVuZGVyIHBoYXNlIHVwZGF0ZS4gSXQgYXNzdW1lcyB0aGVyZSBpcyBlaXRoZXIgYSBjdXJyZW50IGhvb2sgd2UgY2FuXG4vLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4vLyB1c2UgYXMgYSBiYXNlLiBXaGVuIHdlIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGJhc2UgbGlzdCwgd2UgbXVzdCBzd2l0Y2ggdG9cbi8vIHRoZSBkaXNwYXRjaGVyIHVzZWQgZm9yIG1vdW50cy5cbnZhciBuZXh0Q3VycmVudEhvb2s7aWYoY3VycmVudEhvb2s9PT1udWxsKXt2YXIgY3VycmVudD1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtpZihjdXJyZW50IT09bnVsbCl7bmV4dEN1cnJlbnRIb29rPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTt9ZWxzZXtuZXh0Q3VycmVudEhvb2s9bnVsbDt9fWVsc2V7bmV4dEN1cnJlbnRIb29rPWN1cnJlbnRIb29rLm5leHQ7fXZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rO2lmKHdvcmtJblByb2dyZXNzSG9vaz09PW51bGwpe25leHRXb3JrSW5Qcm9ncmVzc0hvb2s9Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO31lbHNle25leHRXb3JrSW5Qcm9ncmVzc0hvb2s9d29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7fWlmKG5leHRXb3JrSW5Qcm9ncmVzc0hvb2shPT1udWxsKXsvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbndvcmtJblByb2dyZXNzSG9vaz1uZXh0V29ya0luUHJvZ3Jlc3NIb29rO25leHRXb3JrSW5Qcm9ncmVzc0hvb2s9d29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7Y3VycmVudEhvb2s9bmV4dEN1cnJlbnRIb29rO31lbHNley8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbmlmKG5leHRDdXJyZW50SG9vaz09PW51bGwpe3Rocm93IG5ldyBFcnJvcignUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLicpO31jdXJyZW50SG9vaz1uZXh0Q3VycmVudEhvb2s7dmFyIG5ld0hvb2s9e21lbW9pemVkU3RhdGU6Y3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxiYXNlU3RhdGU6Y3VycmVudEhvb2suYmFzZVN0YXRlLGJhc2VRdWV1ZTpjdXJyZW50SG9vay5iYXNlUXVldWUscXVldWU6Y3VycmVudEhvb2sucXVldWUsbmV4dDpudWxsfTtpZih3b3JrSW5Qcm9ncmVzc0hvb2s9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0LlxuY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlPXdvcmtJblByb2dyZXNzSG9vaz1uZXdIb29rO31lbHNley8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0Llxud29ya0luUHJvZ3Jlc3NIb29rPXdvcmtJblByb2dyZXNzSG9vay5uZXh0PW5ld0hvb2s7fX1yZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO31mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCl7cmV0dXJue2xhc3RFZmZlY3Q6bnVsbCxzdG9yZXM6bnVsbH07fWZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLGFjdGlvbil7Ly8gJEZsb3dGaXhNZTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbnJldHVybiB0eXBlb2YgYWN0aW9uPT09J2Z1bmN0aW9uJz9hY3Rpb24oc3RhdGUpOmFjdGlvbjt9ZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBpbml0aWFsU3RhdGU7aWYoaW5pdCE9PXVuZGVmaW5lZCl7aW5pdGlhbFN0YXRlPWluaXQoaW5pdGlhbEFyZyk7fWVsc2V7aW5pdGlhbFN0YXRlPWluaXRpYWxBcmc7fWhvb2subWVtb2l6ZWRTdGF0ZT1ob29rLmJhc2VTdGF0ZT1pbml0aWFsU3RhdGU7dmFyIHF1ZXVlPXtwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczpOb0xhbmVzLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpyZWR1Y2VyLGxhc3RSZW5kZXJlZFN0YXRlOmluaXRpYWxTdGF0ZX07aG9vay5xdWV1ZT1xdWV1ZTt2YXIgZGlzcGF0Y2g9cXVldWUuZGlzcGF0Y2g9ZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uLmJpbmQobnVsbCxjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLHF1ZXVlKTtyZXR1cm5baG9vay5tZW1vaXplZFN0YXRlLGRpc3BhdGNoXTt9ZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIHF1ZXVlPWhvb2sucXVldWU7aWYocXVldWU9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9cXVldWUubGFzdFJlbmRlcmVkUmVkdWNlcj1yZWR1Y2VyO3ZhciBjdXJyZW50PWN1cnJlbnRIb29rOy8vIFRoZSBsYXN0IHJlYmFzZSB1cGRhdGUgdGhhdCBpcyBOT1QgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cbnZhciBiYXNlUXVldWU9Y3VycmVudC5iYXNlUXVldWU7Ly8gVGhlIGxhc3QgcGVuZGluZyB1cGRhdGUgdGhhdCBoYXNuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxudmFyIHBlbmRpbmdRdWV1ZT1xdWV1ZS5wZW5kaW5nO2lmKHBlbmRpbmdRdWV1ZSE9PW51bGwpey8vIFdlIGhhdmUgbmV3IHVwZGF0ZXMgdGhhdCBoYXZlbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cbi8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuaWYoYmFzZVF1ZXVlIT09bnVsbCl7Ly8gTWVyZ2UgdGhlIHBlbmRpbmcgcXVldWUgYW5kIHRoZSBiYXNlIHF1ZXVlLlxudmFyIGJhc2VGaXJzdD1iYXNlUXVldWUubmV4dDt2YXIgcGVuZGluZ0ZpcnN0PXBlbmRpbmdRdWV1ZS5uZXh0O2Jhc2VRdWV1ZS5uZXh0PXBlbmRpbmdGaXJzdDtwZW5kaW5nUXVldWUubmV4dD1iYXNlRmlyc3Q7fXtpZihjdXJyZW50LmJhc2VRdWV1ZSE9PWJhc2VRdWV1ZSl7Ly8gSW50ZXJuYWwgaW52YXJpYW50IHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGZlYXNpYmx5IGNvdWxkIGluXG4vLyB0aGUgZnV0dXJlIGlmIHdlIGltcGxlbWVudCByZXN1bWluZywgb3Igc29tZSBmb3JtIG9mIHRoYXQuXG5lcnJvcignSW50ZXJuYWwgZXJyb3I6IEV4cGVjdGVkIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgdG8gYmUgYSBjbG9uZS4gJysnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTt9fWN1cnJlbnQuYmFzZVF1ZXVlPWJhc2VRdWV1ZT1wZW5kaW5nUXVldWU7cXVldWUucGVuZGluZz1udWxsO31pZihiYXNlUXVldWUhPT1udWxsKXsvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbnZhciBmaXJzdD1iYXNlUXVldWUubmV4dDt2YXIgbmV3U3RhdGU9Y3VycmVudC5iYXNlU3RhdGU7dmFyIG5ld0Jhc2VTdGF0ZT1udWxsO3ZhciBuZXdCYXNlUXVldWVGaXJzdD1udWxsO3ZhciBuZXdCYXNlUXVldWVMYXN0PW51bGw7dmFyIHVwZGF0ZT1maXJzdDtkb3t2YXIgdXBkYXRlTGFuZT11cGRhdGUubGFuZTtpZighaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLHVwZGF0ZUxhbmUpKXsvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4vLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2Vcbi8vIHVwZGF0ZS9zdGF0ZS5cbnZhciBjbG9uZT17bGFuZTp1cGRhdGVMYW5lLGFjdGlvbjp1cGRhdGUuYWN0aW9uLGhhc0VhZ2VyU3RhdGU6dXBkYXRlLmhhc0VhZ2VyU3RhdGUsZWFnZXJTdGF0ZTp1cGRhdGUuZWFnZXJTdGF0ZSxuZXh0Om51bGx9O2lmKG5ld0Jhc2VRdWV1ZUxhc3Q9PT1udWxsKXtuZXdCYXNlUXVldWVGaXJzdD1uZXdCYXNlUXVldWVMYXN0PWNsb25lO25ld0Jhc2VTdGF0ZT1uZXdTdGF0ZTt9ZWxzZXtuZXdCYXNlUXVldWVMYXN0PW5ld0Jhc2VRdWV1ZUxhc3QubmV4dD1jbG9uZTt9Ly8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbi8vIHJlbmRlckxhbmVzIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcz1tZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsdXBkYXRlTGFuZSk7bWFya1NraXBwZWRVcGRhdGVMYW5lcyh1cGRhdGVMYW5lKTt9ZWxzZXsvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbmlmKG5ld0Jhc2VRdWV1ZUxhc3QhPT1udWxsKXt2YXIgX2Nsb25lPXsvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxubGFuZTpOb0xhbmUsYWN0aW9uOnVwZGF0ZS5hY3Rpb24saGFzRWFnZXJTdGF0ZTp1cGRhdGUuaGFzRWFnZXJTdGF0ZSxlYWdlclN0YXRlOnVwZGF0ZS5lYWdlclN0YXRlLG5leHQ6bnVsbH07bmV3QmFzZVF1ZXVlTGFzdD1uZXdCYXNlUXVldWVMYXN0Lm5leHQ9X2Nsb25lO30vLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuaWYodXBkYXRlLmhhc0VhZ2VyU3RhdGUpey8vIElmIHRoaXMgdXBkYXRlIGlzIGEgc3RhdGUgdXBkYXRlIChub3QgYSByZWR1Y2VyKSBhbmQgd2FzIHByb2Nlc3NlZCBlYWdlcmx5LFxuLy8gd2UgY2FuIHVzZSB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZVxubmV3U3RhdGU9dXBkYXRlLmVhZ2VyU3RhdGU7fWVsc2V7dmFyIGFjdGlvbj11cGRhdGUuYWN0aW9uO25ld1N0YXRlPXJlZHVjZXIobmV3U3RhdGUsYWN0aW9uKTt9fXVwZGF0ZT11cGRhdGUubmV4dDt9d2hpbGUodXBkYXRlIT09bnVsbCYmdXBkYXRlIT09Zmlyc3QpO2lmKG5ld0Jhc2VRdWV1ZUxhc3Q9PT1udWxsKXtuZXdCYXNlU3RhdGU9bmV3U3RhdGU7fWVsc2V7bmV3QmFzZVF1ZXVlTGFzdC5uZXh0PW5ld0Jhc2VRdWV1ZUZpcnN0O30vLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4vLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cbmlmKCFvYmplY3RJcyhuZXdTdGF0ZSxob29rLm1lbW9pemVkU3RhdGUpKXttYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO31ob29rLm1lbW9pemVkU3RhdGU9bmV3U3RhdGU7aG9vay5iYXNlU3RhdGU9bmV3QmFzZVN0YXRlO2hvb2suYmFzZVF1ZXVlPW5ld0Jhc2VRdWV1ZUxhc3Q7cXVldWUubGFzdFJlbmRlcmVkU3RhdGU9bmV3U3RhdGU7fS8vIEludGVybGVhdmVkIHVwZGF0ZXMgYXJlIHN0b3JlZCBvbiBhIHNlcGFyYXRlIHF1ZXVlLiBXZSBhcmVuJ3QgZ29pbmcgdG9cbi8vIHByb2Nlc3MgdGhlbSBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCB3ZSBkbyBuZWVkIHRvIHRyYWNrIHdoaWNoIGxhbmVzXG4vLyBhcmUgcmVtYWluaW5nLlxudmFyIGxhc3RJbnRlcmxlYXZlZD1xdWV1ZS5pbnRlcmxlYXZlZDtpZihsYXN0SW50ZXJsZWF2ZWQhPT1udWxsKXt2YXIgaW50ZXJsZWF2ZWQ9bGFzdEludGVybGVhdmVkO2Rve3ZhciBpbnRlcmxlYXZlZExhbmU9aW50ZXJsZWF2ZWQubGFuZTtjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzPW1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyxpbnRlcmxlYXZlZExhbmUpO21hcmtTa2lwcGVkVXBkYXRlTGFuZXMoaW50ZXJsZWF2ZWRMYW5lKTtpbnRlcmxlYXZlZD1pbnRlcmxlYXZlZC5uZXh0O313aGlsZShpbnRlcmxlYXZlZCE9PWxhc3RJbnRlcmxlYXZlZCk7fWVsc2UgaWYoYmFzZVF1ZXVlPT09bnVsbCl7Ly8gYHF1ZXVlLmxhbmVzYCBpcyB1c2VkIGZvciBlbnRhbmdsaW5nIHRyYW5zaXRpb25zLiBXZSBjYW4gc2V0IGl0IGJhY2sgdG9cbi8vIHplcm8gb25jZSB0aGUgcXVldWUgaXMgZW1wdHkuXG5xdWV1ZS5sYW5lcz1Ob0xhbmVzO312YXIgZGlzcGF0Y2g9cXVldWUuZGlzcGF0Y2g7cmV0dXJuW2hvb2subWVtb2l6ZWRTdGF0ZSxkaXNwYXRjaF07fWZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIHF1ZXVlPWhvb2sucXVldWU7aWYocXVldWU9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9cXVldWUubGFzdFJlbmRlcmVkUmVkdWNlcj1yZWR1Y2VyOy8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4vLyB3b3JrLWluLXByb2dyZXNzIGhvb2suXG52YXIgZGlzcGF0Y2g9cXVldWUuZGlzcGF0Y2g7dmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZT1xdWV1ZS5wZW5kaW5nO3ZhciBuZXdTdGF0ZT1ob29rLm1lbW9pemVkU3RhdGU7aWYobGFzdFJlbmRlclBoYXNlVXBkYXRlIT09bnVsbCl7Ly8gVGhlIHF1ZXVlIGRvZXNuJ3QgcGVyc2lzdCBwYXN0IHRoaXMgcmVuZGVyIHBhc3MuXG5xdWV1ZS5wZW5kaW5nPW51bGw7dmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU9bGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7dmFyIHVwZGF0ZT1maXJzdFJlbmRlclBoYXNlVXBkYXRlO2Rvey8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuLy8gcmVuZGVyJ3MuXG52YXIgYWN0aW9uPXVwZGF0ZS5hY3Rpb247bmV3U3RhdGU9cmVkdWNlcihuZXdTdGF0ZSxhY3Rpb24pO3VwZGF0ZT11cGRhdGUubmV4dDt9d2hpbGUodXBkYXRlIT09Zmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7Ly8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5pZighb2JqZWN0SXMobmV3U3RhdGUsaG9vay5tZW1vaXplZFN0YXRlKSl7bWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTt9aG9vay5tZW1vaXplZFN0YXRlPW5ld1N0YXRlOy8vIERvbid0IHBlcnNpc3QgdGhlIHN0YXRlIGFjY3VtdWxhdGVkIGZyb20gdGhlIHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvXG4vLyB0aGUgYmFzZSBzdGF0ZSB1bmxlc3MgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuLy8gVE9ETzogTm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgZGVzaXJlZCBzZW1hbnRpY3MsIGJ1dCBpdCdzIHdoYXQgd2Vcbi8vIGRvIGZvciBnRFNGUC4gSSBjYW4ndCByZW1lbWJlciB3aHkuXG5pZihob29rLmJhc2VRdWV1ZT09PW51bGwpe2hvb2suYmFzZVN0YXRlPW5ld1N0YXRlO31xdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZT1uZXdTdGF0ZTt9cmV0dXJuW25ld1N0YXRlLGRpc3BhdGNoXTt9ZnVuY3Rpb24gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSxnZXRTbmFwc2hvdCxzdWJzY3JpYmUpe3tyZXR1cm4gdW5kZWZpbmVkO319ZnVuY3Rpb24gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsZ2V0U25hcHNob3Qsc3Vic2NyaWJlKXt7cmV0dXJuIHVuZGVmaW5lZDt9fWZ1bmN0aW9uIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KXt2YXIgZmliZXI9Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBuZXh0U25hcHNob3Q7dmFyIGlzSHlkcmF0aW5nPWdldElzSHlkcmF0aW5nKCk7aWYoaXNIeWRyYXRpbmcpe2lmKGdldFNlcnZlclNuYXBzaG90PT09dW5kZWZpbmVkKXt0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciAnKydzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTt9bmV4dFNuYXBzaG90PWdldFNlcnZlclNuYXBzaG90KCk7e2lmKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCl7aWYobmV4dFNuYXBzaG90IT09Z2V0U2VydmVyU25hcHNob3QoKSl7ZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U2VydmVyU25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7ZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Q9dHJ1ZTt9fX19ZWxzZXtuZXh0U25hcHNob3Q9Z2V0U25hcHNob3QoKTt7aWYoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KXt2YXIgY2FjaGVkU25hcHNob3Q9Z2V0U25hcHNob3QoKTtpZighb2JqZWN0SXMobmV4dFNuYXBzaG90LGNhY2hlZFNuYXBzaG90KSl7ZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7ZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Q9dHJ1ZTt9fX0vLyBVbmxlc3Mgd2UncmUgcmVuZGVyaW5nIGEgYmxvY2tpbmcgbGFuZSwgc2NoZWR1bGUgYSBjb25zaXN0ZW5jeSBjaGVjay5cbi8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbi8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQuXG4vL1xuLy8gV2Ugd29uJ3QgZG8gdGhpcyBpZiB3ZSdyZSBoeWRyYXRpbmcgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQsIGJlY2F1c2UgaWZcbi8vIHRoZSBjb250ZW50IGlzIHN0YWxlLCBpdCdzIGFscmVhZHkgdmlzaWJsZSBhbnl3YXkuIEluc3RlYWQgd2UnbGwgcGF0Y2hcbi8vIGl0IHVwIGluIGEgcGFzc2l2ZSBlZmZlY3QuXG52YXIgcm9vdD1nZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtpZihyb290PT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fWlmKCFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LHJlbmRlckxhbmVzKSl7cHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlcixnZXRTbmFwc2hvdCxuZXh0U25hcHNob3QpO319Ly8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIFRoaXMgYnJlYWtzIHRoZVxuLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4vLyBhbHdheXMgc3luY2hyb25vdXMuXG5ob29rLm1lbW9pemVkU3RhdGU9bmV4dFNuYXBzaG90O3ZhciBpbnN0PXt2YWx1ZTpuZXh0U25hcHNob3QsZ2V0U25hcHNob3Q6Z2V0U25hcHNob3R9O2hvb2sucXVldWU9aW5zdDsvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gc3Vic2NyaWJlIHRvIHRoZSBzdG9yZS5cbm1vdW50RWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLGZpYmVyLGluc3Qsc3Vic2NyaWJlKSxbc3Vic2NyaWJlXSk7Ly8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIHVwZGF0ZSB0aGUgbXV0YWJsZSBpbnN0YW5jZSBmaWVsZHMuIFdlIHdpbGwgdXBkYXRlXG4vLyB0aGlzIHdoZW5ldmVyIHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIG9yIHZhbHVlIGNoYW5nZXMuIEJlY2F1c2UgdGhlcmUncyBub1xuLy8gY2xlYW4tdXAgZnVuY3Rpb24sIGFuZCB3ZSB0cmFjayB0aGUgZGVwcyBjb3JyZWN0bHksIHdlIGNhbiBjYWxsIHB1c2hFZmZlY3Rcbi8vIGRpcmVjdGx5LCB3aXRob3V0IHN0b3JpbmcgYW55IGFkZGl0aW9uYWwgc3RhdGUuIEZvciB0aGUgc2FtZSByZWFzb24sIHdlXG4vLyBkb24ndCBuZWVkIHRvIHNldCBhIHN0YXRpYyBmbGFnLCBlaXRoZXIuXG4vLyBUT0RPOiBXZSBjYW4gbW92ZSB0aGlzIHRvIHRoZSBwYXNzaXZlIHBoYXNlIG9uY2Ugd2UgYWRkIGEgcHJlLWNvbW1pdFxuLy8gY29uc2lzdGVuY3kgY2hlY2suIFNlZSB0aGUgbmV4dCBjb21tZW50LlxuZmliZXIuZmxhZ3N8PVBhc3NpdmU7cHVzaEVmZmVjdChIYXNFZmZlY3R8UGFzc2l2ZSQxLHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLGZpYmVyLGluc3QsbmV4dFNuYXBzaG90LGdldFNuYXBzaG90KSx1bmRlZmluZWQsbnVsbCk7cmV0dXJuIG5leHRTbmFwc2hvdDt9ZnVuY3Rpb24gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KXt2YXIgZmliZXI9Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTsvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gVGhpcyBicmVha3MgdGhlXG4vLyBub3JtYWwgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGJlY2F1c2Ugc3RvcmUgdXBkYXRlcyBhcmVcbi8vIGFsd2F5cyBzeW5jaHJvbm91cy5cbnZhciBuZXh0U25hcHNob3Q9Z2V0U25hcHNob3QoKTt7aWYoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KXt2YXIgY2FjaGVkU25hcHNob3Q9Z2V0U25hcHNob3QoKTtpZighb2JqZWN0SXMobmV4dFNuYXBzaG90LGNhY2hlZFNuYXBzaG90KSl7ZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7ZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Q9dHJ1ZTt9fX12YXIgcHJldlNuYXBzaG90PWhvb2subWVtb2l6ZWRTdGF0ZTt2YXIgc25hcHNob3RDaGFuZ2VkPSFvYmplY3RJcyhwcmV2U25hcHNob3QsbmV4dFNuYXBzaG90KTtpZihzbmFwc2hvdENoYW5nZWQpe2hvb2subWVtb2l6ZWRTdGF0ZT1uZXh0U25hcHNob3Q7bWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTt9dmFyIGluc3Q9aG9vay5xdWV1ZTt1cGRhdGVFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsZmliZXIsaW5zdCxzdWJzY3JpYmUpLFtzdWJzY3JpYmVdKTsvLyBXaGVuZXZlciBnZXRTbmFwc2hvdCBvciBzdWJzY3JpYmUgY2hhbmdlcywgd2UgbmVlZCB0byBjaGVjayBpbiB0aGVcbi8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuLy8gZWZmZWN0IG1heSBoYXZlIG11dGF0ZWQgdGhlIHN0b3JlLlxuaWYoaW5zdC5nZXRTbmFwc2hvdCE9PWdldFNuYXBzaG90fHxzbmFwc2hvdENoYW5nZWR8fC8vIENoZWNrIGlmIHRoZSBzdXNiY3JpYmUgZnVuY3Rpb24gY2hhbmdlZC4gV2UgY2FuIHNhdmUgc29tZSBtZW1vcnkgYnlcbi8vIGNoZWNraW5nIHdoZXRoZXIgd2Ugc2NoZWR1bGVkIGEgc3Vic2NyaXB0aW9uIGVmZmVjdCBhYm92ZS5cbndvcmtJblByb2dyZXNzSG9vayE9PW51bGwmJndvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLnRhZyZIYXNFZmZlY3Qpe2ZpYmVyLmZsYWdzfD1QYXNzaXZlO3B1c2hFZmZlY3QoSGFzRWZmZWN0fFBhc3NpdmUkMSx1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQobnVsbCxmaWJlcixpbnN0LG5leHRTbmFwc2hvdCxnZXRTbmFwc2hvdCksdW5kZWZpbmVkLG51bGwpOy8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuLy8gUmlnaHQgYmVmb3JlIGNvbW1pdHRpbmcsIHdlIHdpbGwgd2FsayB0aGUgdHJlZSBhbmQgY2hlY2sgaWYgYW55IG9mIHRoZVxuLy8gc3RvcmVzIHdlcmUgbXV0YXRlZC5cbnZhciByb290PWdldFdvcmtJblByb2dyZXNzUm9vdCgpO2lmKHJvb3Q9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9aWYoIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QscmVuZGVyTGFuZXMpKXtwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLGdldFNuYXBzaG90LG5leHRTbmFwc2hvdCk7fX1yZXR1cm4gbmV4dFNuYXBzaG90O31mdW5jdGlvbiBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLGdldFNuYXBzaG90LHJlbmRlcmVkU25hcHNob3Qpe2ZpYmVyLmZsYWdzfD1TdG9yZUNvbnNpc3RlbmN5O3ZhciBjaGVjaz17Z2V0U25hcHNob3Q6Z2V0U25hcHNob3QsdmFsdWU6cmVuZGVyZWRTbmFwc2hvdH07dmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlPWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7aWYoY29tcG9uZW50VXBkYXRlUXVldWU9PT1udWxsKXtjb21wb25lbnRVcGRhdGVRdWV1ZT1jcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZT1jb21wb25lbnRVcGRhdGVRdWV1ZTtjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXM9W2NoZWNrXTt9ZWxzZXt2YXIgc3RvcmVzPWNvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3JlcztpZihzdG9yZXM9PT1udWxsKXtjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXM9W2NoZWNrXTt9ZWxzZXtzdG9yZXMucHVzaChjaGVjayk7fX19ZnVuY3Rpb24gdXBkYXRlU3RvcmVJbnN0YW5jZShmaWJlcixpbnN0LG5leHRTbmFwc2hvdCxnZXRTbmFwc2hvdCl7Ly8gVGhlc2UgYXJlIHVwZGF0ZWQgaW4gdGhlIHBhc3NpdmUgcGhhc2Vcbmluc3QudmFsdWU9bmV4dFNuYXBzaG90O2luc3QuZ2V0U25hcHNob3Q9Z2V0U25hcHNob3Q7Ly8gU29tZXRoaW5nIG1heSBoYXZlIGJlZW4gbXV0YXRlZCBpbiBiZXR3ZWVuIHJlbmRlciBhbmQgY29tbWl0LiBUaGlzIGNvdWxkXG4vLyBoYXZlIGJlZW4gaW4gYW4gZXZlbnQgdGhhdCBmaXJlZCBiZWZvcmUgdGhlIHBhc3NpdmUgZWZmZWN0cywgb3IgaXQgY291bGRcbi8vIGhhdmUgYmVlbiBpbiBhIGxheW91dCBlZmZlY3QuIEluIHRoYXQgY2FzZSwgd2Ugd291bGQgaGF2ZSB1c2VkIHRoZSBvbGRcbi8vIHNuYXBzaG8gYW5kIGdldFNuYXBzaG90IHZhbHVlcyB0byBiYWlsIG91dC4gV2UgbmVlZCB0byBjaGVjayBvbmUgbW9yZSB0aW1lLlxuaWYoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSl7Ly8gRm9yY2UgYSByZS1yZW5kZXIuXG5mb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO319ZnVuY3Rpb24gc3Vic2NyaWJlVG9TdG9yZShmaWJlcixpbnN0LHN1YnNjcmliZSl7dmFyIGhhbmRsZVN0b3JlQ2hhbmdlPWZ1bmN0aW9uKCl7Ly8gVGhlIHN0b3JlIGNoYW5nZWQuIENoZWNrIGlmIHRoZSBzbmFwc2hvdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Vcbi8vIHJlYWQgZnJvbSB0aGUgc3RvcmUuXG5pZihjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKXsvLyBGb3JjZSBhIHJlLXJlbmRlci5cbmZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7fX07Ly8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG5yZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTt9ZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KXt2YXIgbGF0ZXN0R2V0U25hcHNob3Q9aW5zdC5nZXRTbmFwc2hvdDt2YXIgcHJldlZhbHVlPWluc3QudmFsdWU7dHJ5e3ZhciBuZXh0VmFsdWU9bGF0ZXN0R2V0U25hcHNob3QoKTtyZXR1cm4hb2JqZWN0SXMocHJldlZhbHVlLG5leHRWYWx1ZSk7fWNhdGNoKGVycm9yKXtyZXR1cm4gdHJ1ZTt9fWZ1bmN0aW9uIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcil7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsU3luY0xhbmUsTm9UaW1lc3RhbXApO319ZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpe3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7aWYodHlwZW9mIGluaXRpYWxTdGF0ZT09PSdmdW5jdGlvbicpey8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG5pbml0aWFsU3RhdGU9aW5pdGlhbFN0YXRlKCk7fWhvb2subWVtb2l6ZWRTdGF0ZT1ob29rLmJhc2VTdGF0ZT1pbml0aWFsU3RhdGU7dmFyIHF1ZXVlPXtwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczpOb0xhbmVzLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpiYXNpY1N0YXRlUmVkdWNlcixsYXN0UmVuZGVyZWRTdGF0ZTppbml0aWFsU3RhdGV9O2hvb2sucXVldWU9cXVldWU7dmFyIGRpc3BhdGNoPXF1ZXVlLmRpc3BhdGNoPWRpc3BhdGNoU2V0U3RhdGUuYmluZChudWxsLGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEscXVldWUpO3JldHVybltob29rLm1lbW9pemVkU3RhdGUsZGlzcGF0Y2hdO31mdW5jdGlvbiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpe3JldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTt9ZnVuY3Rpb24gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpe3JldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO31mdW5jdGlvbiBwdXNoRWZmZWN0KHRhZyxjcmVhdGUsZGVzdHJveSxkZXBzKXt2YXIgZWZmZWN0PXt0YWc6dGFnLGNyZWF0ZTpjcmVhdGUsZGVzdHJveTpkZXN0cm95LGRlcHM6ZGVwcywvLyBDaXJjdWxhclxubmV4dDpudWxsfTt2YXIgY29tcG9uZW50VXBkYXRlUXVldWU9Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtpZihjb21wb25lbnRVcGRhdGVRdWV1ZT09PW51bGwpe2NvbXBvbmVudFVwZGF0ZVF1ZXVlPWNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlPWNvbXBvbmVudFVwZGF0ZVF1ZXVlO2NvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q9ZWZmZWN0Lm5leHQ9ZWZmZWN0O31lbHNle3ZhciBsYXN0RWZmZWN0PWNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7aWYobGFzdEVmZmVjdD09PW51bGwpe2NvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q9ZWZmZWN0Lm5leHQ9ZWZmZWN0O31lbHNle3ZhciBmaXJzdEVmZmVjdD1sYXN0RWZmZWN0Lm5leHQ7bGFzdEVmZmVjdC5uZXh0PWVmZmVjdDtlZmZlY3QubmV4dD1maXJzdEVmZmVjdDtjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0PWVmZmVjdDt9fXJldHVybiBlZmZlY3Q7fWZ1bmN0aW9uIG1vdW50UmVmKGluaXRpYWxWYWx1ZSl7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTt7dmFyIF9yZWYyPXtjdXJyZW50OmluaXRpYWxWYWx1ZX07aG9vay5tZW1vaXplZFN0YXRlPV9yZWYyO3JldHVybiBfcmVmMjt9fWZ1bmN0aW9uIHVwZGF0ZVJlZihpbml0aWFsVmFsdWUpe3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3JldHVybiBob29rLm1lbW9pemVkU3RhdGU7fWZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLGhvb2tGbGFncyxjcmVhdGUsZGVwcyl7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgbmV4dERlcHM9ZGVwcz09PXVuZGVmaW5lZD9udWxsOmRlcHM7Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFnc3w9ZmliZXJGbGFncztob29rLm1lbW9pemVkU3RhdGU9cHVzaEVmZmVjdChIYXNFZmZlY3R8aG9va0ZsYWdzLGNyZWF0ZSx1bmRlZmluZWQsbmV4dERlcHMpO31mdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsaG9va0ZsYWdzLGNyZWF0ZSxkZXBzKXt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgbmV4dERlcHM9ZGVwcz09PXVuZGVmaW5lZD9udWxsOmRlcHM7dmFyIGRlc3Ryb3k9dW5kZWZpbmVkO2lmKGN1cnJlbnRIb29rIT09bnVsbCl7dmFyIHByZXZFZmZlY3Q9Y3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtkZXN0cm95PXByZXZFZmZlY3QuZGVzdHJveTtpZihuZXh0RGVwcyE9PW51bGwpe3ZhciBwcmV2RGVwcz1wcmV2RWZmZWN0LmRlcHM7aWYoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLHByZXZEZXBzKSl7aG9vay5tZW1vaXplZFN0YXRlPXB1c2hFZmZlY3QoaG9va0ZsYWdzLGNyZWF0ZSxkZXN0cm95LG5leHREZXBzKTtyZXR1cm47fX19Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFnc3w9ZmliZXJGbGFncztob29rLm1lbW9pemVkU3RhdGU9cHVzaEVmZmVjdChIYXNFZmZlY3R8aG9va0ZsYWdzLGNyZWF0ZSxkZXN0cm95LG5leHREZXBzKTt9ZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLGRlcHMpe2lmKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUmU3RyaWN0RWZmZWN0c01vZGUpIT09Tm9Nb2RlKXtyZXR1cm4gbW91bnRFZmZlY3RJbXBsKE1vdW50UGFzc2l2ZURldnxQYXNzaXZlfFBhc3NpdmVTdGF0aWMsUGFzc2l2ZSQxLGNyZWF0ZSxkZXBzKTt9ZWxzZXtyZXR1cm4gbW91bnRFZmZlY3RJbXBsKFBhc3NpdmV8UGFzc2l2ZVN0YXRpYyxQYXNzaXZlJDEsY3JlYXRlLGRlcHMpO319ZnVuY3Rpb24gdXBkYXRlRWZmZWN0KGNyZWF0ZSxkZXBzKXtyZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChQYXNzaXZlLFBhc3NpdmUkMSxjcmVhdGUsZGVwcyk7fWZ1bmN0aW9uIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSxkZXBzKXtyZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSxJbnNlcnRpb24sY3JlYXRlLGRlcHMpO31mdW5jdGlvbiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLGRlcHMpe3JldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSxJbnNlcnRpb24sY3JlYXRlLGRlcHMpO31mdW5jdGlvbiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsZGVwcyl7dmFyIGZpYmVyRmxhZ3M9VXBkYXRlO3tmaWJlckZsYWdzfD1MYXlvdXRTdGF0aWM7fWlmKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUmU3RyaWN0RWZmZWN0c01vZGUpIT09Tm9Nb2RlKXtmaWJlckZsYWdzfD1Nb3VudExheW91dERldjt9cmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLExheW91dCxjcmVhdGUsZGVwcyk7fWZ1bmN0aW9uIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsZGVwcyl7cmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLExheW91dCxjcmVhdGUsZGVwcyk7fWZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLHJlZil7aWYodHlwZW9mIHJlZj09PSdmdW5jdGlvbicpe3ZhciByZWZDYWxsYmFjaz1yZWY7dmFyIF9pbnN0PWNyZWF0ZSgpO3JlZkNhbGxiYWNrKF9pbnN0KTtyZXR1cm4gZnVuY3Rpb24oKXtyZWZDYWxsYmFjayhudWxsKTt9O31lbHNlIGlmKHJlZiE9PW51bGwmJnJlZiE9PXVuZGVmaW5lZCl7dmFyIHJlZk9iamVjdD1yZWY7e2lmKCFyZWZPYmplY3QuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSl7ZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSAnKydyZWYgY2FsbGJhY2sgb3IgUmVhY3QuY3JlYXRlUmVmKCkgb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnK09iamVjdC5rZXlzKHJlZk9iamVjdCkuam9pbignLCAnKSsnfScpO319dmFyIF9pbnN0Mj1jcmVhdGUoKTtyZWZPYmplY3QuY3VycmVudD1faW5zdDI7cmV0dXJuIGZ1bmN0aW9uKCl7cmVmT2JqZWN0LmN1cnJlbnQ9bnVsbDt9O319ZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZixjcmVhdGUsZGVwcyl7e2lmKHR5cGVvZiBjcmVhdGUhPT0nZnVuY3Rpb24nKXtlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcrJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJyxjcmVhdGUhPT1udWxsP3R5cGVvZiBjcmVhdGU6J251bGwnKTt9fS8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG52YXIgZWZmZWN0RGVwcz1kZXBzIT09bnVsbCYmZGVwcyE9PXVuZGVmaW5lZD9kZXBzLmNvbmNhdChbcmVmXSk6bnVsbDt2YXIgZmliZXJGbGFncz1VcGRhdGU7e2ZpYmVyRmxhZ3N8PUxheW91dFN0YXRpYzt9aWYoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe2ZpYmVyRmxhZ3N8PU1vdW50TGF5b3V0RGV2O31yZXR1cm4gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsTGF5b3V0LGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLGNyZWF0ZSxyZWYpLGVmZmVjdERlcHMpO31mdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZixjcmVhdGUsZGVwcyl7e2lmKHR5cGVvZiBjcmVhdGUhPT0nZnVuY3Rpb24nKXtlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcrJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJyxjcmVhdGUhPT1udWxsP3R5cGVvZiBjcmVhdGU6J251bGwnKTt9fS8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG52YXIgZWZmZWN0RGVwcz1kZXBzIT09bnVsbCYmZGVwcyE9PXVuZGVmaW5lZD9kZXBzLmNvbmNhdChbcmVmXSk6bnVsbDtyZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsTGF5b3V0LGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLGNyZWF0ZSxyZWYpLGVmZmVjdERlcHMpO31mdW5jdGlvbiBtb3VudERlYnVnVmFsdWUodmFsdWUsZm9ybWF0dGVyRm4pey8vIFRoaXMgaG9vayBpcyBub3JtYWxseSBhIG5vLW9wLlxuLy8gVGhlIHJlYWN0LWRlYnVnLWhvb2tzIHBhY2thZ2UgaW5qZWN0cyBpdHMgb3duIGltcGxlbWVudGF0aW9uXG4vLyBzbyB0aGF0IGUuZy4gRGV2VG9vbHMgY2FuIGRpc3BsYXkgY3VzdG9tIGhvb2sgdmFsdWVzLlxufXZhciB1cGRhdGVEZWJ1Z1ZhbHVlPW1vdW50RGVidWdWYWx1ZTtmdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLGRlcHMpe3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIG5leHREZXBzPWRlcHM9PT11bmRlZmluZWQ/bnVsbDpkZXBzO2hvb2subWVtb2l6ZWRTdGF0ZT1bY2FsbGJhY2ssbmV4dERlcHNdO3JldHVybiBjYWxsYmFjazt9ZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssZGVwcyl7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIG5leHREZXBzPWRlcHM9PT11bmRlZmluZWQ/bnVsbDpkZXBzO3ZhciBwcmV2U3RhdGU9aG9vay5tZW1vaXplZFN0YXRlO2lmKHByZXZTdGF0ZSE9PW51bGwpe2lmKG5leHREZXBzIT09bnVsbCl7dmFyIHByZXZEZXBzPXByZXZTdGF0ZVsxXTtpZihhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMscHJldkRlcHMpKXtyZXR1cm4gcHJldlN0YXRlWzBdO319fWhvb2subWVtb2l6ZWRTdGF0ZT1bY2FsbGJhY2ssbmV4dERlcHNdO3JldHVybiBjYWxsYmFjazt9ZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsZGVwcyl7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgbmV4dERlcHM9ZGVwcz09PXVuZGVmaW5lZD9udWxsOmRlcHM7dmFyIG5leHRWYWx1ZT1uZXh0Q3JlYXRlKCk7aG9vay5tZW1vaXplZFN0YXRlPVtuZXh0VmFsdWUsbmV4dERlcHNdO3JldHVybiBuZXh0VmFsdWU7fWZ1bmN0aW9uIHVwZGF0ZU1lbW8obmV4dENyZWF0ZSxkZXBzKXt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgbmV4dERlcHM9ZGVwcz09PXVuZGVmaW5lZD9udWxsOmRlcHM7dmFyIHByZXZTdGF0ZT1ob29rLm1lbW9pemVkU3RhdGU7aWYocHJldlN0YXRlIT09bnVsbCl7Ly8gQXNzdW1lIHRoZXNlIGFyZSBkZWZpbmVkLiBJZiB0aGV5J3JlIG5vdCwgYXJlSG9va0lucHV0c0VxdWFsIHdpbGwgd2Fybi5cbmlmKG5leHREZXBzIT09bnVsbCl7dmFyIHByZXZEZXBzPXByZXZTdGF0ZVsxXTtpZihhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMscHJldkRlcHMpKXtyZXR1cm4gcHJldlN0YXRlWzBdO319fXZhciBuZXh0VmFsdWU9bmV4dENyZWF0ZSgpO2hvb2subWVtb2l6ZWRTdGF0ZT1bbmV4dFZhbHVlLG5leHREZXBzXTtyZXR1cm4gbmV4dFZhbHVlO31mdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpe3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7aG9vay5tZW1vaXplZFN0YXRlPXZhbHVlO3JldHVybiB2YWx1ZTt9ZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSl7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIHJlc29sdmVkQ3VycmVudEhvb2s9Y3VycmVudEhvb2s7dmFyIHByZXZWYWx1ZT1yZXNvbHZlZEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7cmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2sscHJldlZhbHVlLHZhbHVlKTt9ZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKXt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtpZihjdXJyZW50SG9vaz09PW51bGwpey8vIFRoaXMgaXMgYSByZXJlbmRlciBkdXJpbmcgYSBtb3VudC5cbmhvb2subWVtb2l6ZWRTdGF0ZT12YWx1ZTtyZXR1cm4gdmFsdWU7fWVsc2V7Ly8gVGhpcyBpcyBhIHJlcmVuZGVyIGR1cmluZyBhbiB1cGRhdGUuXG52YXIgcHJldlZhbHVlPWN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7cmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2sscHJldlZhbHVlLHZhbHVlKTt9fWZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2sscHJldlZhbHVlLHZhbHVlKXt2YXIgc2hvdWxkRGVmZXJWYWx1ZT0haW5jbHVkZXNPbmx5Tm9uVXJnZW50TGFuZXMocmVuZGVyTGFuZXMpO2lmKHNob3VsZERlZmVyVmFsdWUpey8vIFRoaXMgaXMgYW4gdXJnZW50IHVwZGF0ZS4gSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBrZWVwIHVzaW5nIHRoZVxuLy8gcHJldmlvdXMgdmFsdWUgYW5kIHNwYXduIGEgZGVmZXJyZWQgcmVuZGVyIHRvIHVwZGF0ZSBpdCBsYXRlci5cbmlmKCFvYmplY3RJcyh2YWx1ZSxwcmV2VmFsdWUpKXsvLyBTY2hlZHVsZSBhIGRlZmVycmVkIHJlbmRlclxudmFyIGRlZmVycmVkTGFuZT1jbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpO2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXM9bWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLGRlZmVycmVkTGFuZSk7bWFya1NraXBwZWRVcGRhdGVMYW5lcyhkZWZlcnJlZExhbmUpOy8vIFNldCB0aGlzIHRvIHRydWUgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcmVuZGVyZWQgdmFsdWUgaXMgaW5jb25zaXN0ZW50XG4vLyBmcm9tIHRoZSBsYXRlc3QgdmFsdWUuIFRoZSBuYW1lIFwiYmFzZVN0YXRlXCIgZG9lc24ndCByZWFsbHkgbWF0Y2ggaG93IHdlXG4vLyB1c2UgaXQgYmVjYXVzZSB3ZSdyZSByZXVzaW5nIGEgc3RhdGUgaG9vayBmaWVsZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGFcbi8vIG5ldyBvbmUuXG5ob29rLmJhc2VTdGF0ZT10cnVlO30vLyBSZXVzZSB0aGUgcHJldmlvdXMgdmFsdWVcbnJldHVybiBwcmV2VmFsdWU7fWVsc2V7Ly8gVGhpcyBpcyBub3QgYW4gdXJnZW50IHVwZGF0ZSwgc28gd2UgY2FuIHVzZSB0aGUgbGF0ZXN0IHZhbHVlIHJlZ2FyZGxlc3Ncbi8vIG9mIHdoYXQgaXQgaXMuIE5vIG5lZWQgdG8gZGVmZXIgaXQuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgc3Bhd25lZCByZW5kZXIsIHRoZW4gd2UgbmVlZCB0byBtYXJrXG4vLyB0aGlzIGFzIGFuIHVwZGF0ZSB0byBwcmV2ZW50IHRoZSBmaWJlciBmcm9tIGJhaWxpbmcgb3V0LlxuLy9cbi8vIGBiYXNlU3RhdGVgIGlzIHRydWUgd2hlbiB0aGUgY3VycmVudCB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgcmVuZGVyZWRcbi8vIHZhbHVlLiBUaGUgbmFtZSBkb2Vzbid0IHJlYWxseSBtYXRjaCBob3cgd2UgdXNlIGl0IGJlY2F1c2Ugd2UncmUgcmV1c2luZ1xuLy8gYSBzdGF0ZSBob29rIGZpZWxkIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lLlxuaWYoaG9vay5iYXNlU3RhdGUpey8vIEZsaXAgdGhpcyBiYWNrIHRvIGZhbHNlLlxuaG9vay5iYXNlU3RhdGU9ZmFsc2U7bWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTt9aG9vay5tZW1vaXplZFN0YXRlPXZhbHVlO3JldHVybiB2YWx1ZTt9fWZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzZXRQZW5kaW5nLGNhbGxiYWNrLG9wdGlvbnMpe3ZhciBwcmV2aW91c1ByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShoaWdoZXJFdmVudFByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHksQ29udGludW91c0V2ZW50UHJpb3JpdHkpKTtzZXRQZW5kaW5nKHRydWUpO3ZhciBwcmV2VHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uPXt9O3ZhciBjdXJyZW50VHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247e1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycz1uZXcgU2V0KCk7fXRyeXtzZXRQZW5kaW5nKGZhbHNlKTtjYWxsYmFjaygpO31maW5hbGx5e3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247e2lmKHByZXZUcmFuc2l0aW9uPT09bnVsbCYmY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpe3ZhciB1cGRhdGVkRmliZXJzQ291bnQ9Y3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZTtpZih1cGRhdGVkRmliZXJzQ291bnQ+MTApe3dhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJysnSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gJysnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO31jdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpO319fX1mdW5jdGlvbiBtb3VudFRyYW5zaXRpb24oKXt2YXIgX21vdW50U3RhdGU9bW91bnRTdGF0ZShmYWxzZSksaXNQZW5kaW5nPV9tb3VudFN0YXRlWzBdLHNldFBlbmRpbmc9X21vdW50U3RhdGVbMV07Ly8gVGhlIGBzdGFydGAgbWV0aG9kIG5ldmVyIGNoYW5nZXMuXG52YXIgc3RhcnQ9c3RhcnRUcmFuc2l0aW9uLmJpbmQobnVsbCxzZXRQZW5kaW5nKTt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO2hvb2subWVtb2l6ZWRTdGF0ZT1zdGFydDtyZXR1cm5baXNQZW5kaW5nLHN0YXJ0XTt9ZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpe3ZhciBfdXBkYXRlU3RhdGU9dXBkYXRlU3RhdGUoKSxpc1BlbmRpbmc9X3VwZGF0ZVN0YXRlWzBdO3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBzdGFydD1ob29rLm1lbW9pemVkU3RhdGU7cmV0dXJuW2lzUGVuZGluZyxzdGFydF07fWZ1bmN0aW9uIHJlcmVuZGVyVHJhbnNpdGlvbigpe3ZhciBfcmVyZW5kZXJTdGF0ZT1yZXJlbmRlclN0YXRlKCksaXNQZW5kaW5nPV9yZXJlbmRlclN0YXRlWzBdO3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBzdGFydD1ob29rLm1lbW9pemVkU3RhdGU7cmV0dXJuW2lzUGVuZGluZyxzdGFydF07fXZhciBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlPWZhbHNlO2Z1bmN0aW9uIGdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpe3tyZXR1cm4gaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZTt9fWZ1bmN0aW9uIG1vdW50SWQoKXt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO3ZhciByb290PWdldFdvcmtJblByb2dyZXNzUm9vdCgpOy8vIFRPRE86IEluIEZpenosIGlkIGdlbmVyYXRpb24gaXMgc3BlY2lmaWMgdG8gZWFjaCBzZXJ2ZXIgY29uZmlnLiBNYXliZSB3ZVxuLy8gc2hvdWxkIGRvIHRoaXMgaW4gRmliZXIsIHRvbz8gRGVmZXJyaW5nIHRoaXMgZGVjaXNpb24gZm9yIG5vdyBiZWNhdXNlXG4vLyB0aGVyZSdzIG5vIG90aGVyIHBsYWNlIHRvIHN0b3JlIHRoZSBwcmVmaXggZXhjZXB0IGZvciBhbiBpbnRlcm5hbCBmaWVsZCBvblxuLy8gdGhlIHB1YmxpYyBjcmVhdGVSb290IG9iamVjdCwgd2hpY2ggdGhlIGZpYmVyIHRyZWUgZG9lcyBub3QgY3VycmVudGx5IGhhdmVcbi8vIGEgcmVmZXJlbmNlIHRvLlxudmFyIGlkZW50aWZpZXJQcmVmaXg9cm9vdC5pZGVudGlmaWVyUHJlZml4O3ZhciBpZDtpZihnZXRJc0h5ZHJhdGluZygpKXt2YXIgdHJlZUlkPWdldFRyZWVJZCgpOy8vIFVzZSBhIGNhcHRpYWwgUiBwcmVmaXggZm9yIHNlcnZlci1nZW5lcmF0ZWQgaWRzLlxuaWQ9JzonK2lkZW50aWZpZXJQcmVmaXgrJ1InK3RyZWVJZDsvLyBVbmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgaWQgYXQgdGhpcyBsZXZlbCwgYXBwZW5kIGEgbnVtYmVyIGF0IHRoZSBlbmRcbi8vIHRoYXQgcmVwcmVzZW50cyB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VJZCBob29rIGFtb25nIGFsbCB0aGUgdXNlSWRcbi8vIGhvb2tzIGZvciB0aGlzIGZpYmVyLlxudmFyIGxvY2FsSWQ9bG9jYWxJZENvdW50ZXIrKztpZihsb2NhbElkPjApe2lkKz0nSCcrbG9jYWxJZC50b1N0cmluZygzMik7fWlkKz0nOic7fWVsc2V7Ly8gVXNlIGEgbG93ZXJjYXNlIHIgcHJlZml4IGZvciBjbGllbnQtZ2VuZXJhdGVkIGlkcy5cbnZhciBnbG9iYWxDbGllbnRJZD1nbG9iYWxDbGllbnRJZENvdW50ZXIrKztpZD0nOicraWRlbnRpZmllclByZWZpeCsncicrZ2xvYmFsQ2xpZW50SWQudG9TdHJpbmcoMzIpKyc6Jzt9aG9vay5tZW1vaXplZFN0YXRlPWlkO3JldHVybiBpZDt9ZnVuY3Rpb24gdXBkYXRlSWQoKXt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgaWQ9aG9vay5tZW1vaXplZFN0YXRlO3JldHVybiBpZDt9ZnVuY3Rpb24gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uKGZpYmVyLHF1ZXVlLGFjdGlvbil7e2lmKHR5cGVvZiBhcmd1bWVudHNbM109PT0nZnVuY3Rpb24nKXtlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiKydzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnKydyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7fX12YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7dmFyIHVwZGF0ZT17bGFuZTpsYW5lLGFjdGlvbjphY3Rpb24saGFzRWFnZXJTdGF0ZTpmYWxzZSxlYWdlclN0YXRlOm51bGwsbmV4dDpudWxsfTtpZihpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSl7ZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLHVwZGF0ZSk7fWVsc2V7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLHF1ZXVlLHVwZGF0ZSxsYW5lKTtpZihyb290IT09bnVsbCl7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsbGFuZSxldmVudFRpbWUpO2VudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LHF1ZXVlLGxhbmUpO319bWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsbGFuZSk7fWZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGUoZmliZXIscXVldWUsYWN0aW9uKXt7aWYodHlwZW9mIGFyZ3VtZW50c1szXT09PSdmdW5jdGlvbicpe2Vycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIrJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcrJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTt9fXZhciBsYW5lPXJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTt2YXIgdXBkYXRlPXtsYW5lOmxhbmUsYWN0aW9uOmFjdGlvbixoYXNFYWdlclN0YXRlOmZhbHNlLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9O2lmKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKXtlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsdXBkYXRlKTt9ZWxzZXt2YXIgYWx0ZXJuYXRlPWZpYmVyLmFsdGVybmF0ZTtpZihmaWJlci5sYW5lcz09PU5vTGFuZXMmJihhbHRlcm5hdGU9PT1udWxsfHxhbHRlcm5hdGUubGFuZXM9PT1Ob0xhbmVzKSl7Ly8gVGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBlbXB0eSwgd2hpY2ggbWVhbnMgd2UgY2FuIGVhZ2VybHkgY29tcHV0ZSB0aGVcbi8vIG5leHQgc3RhdGUgYmVmb3JlIGVudGVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIElmIHRoZSBuZXcgc3RhdGUgaXMgdGhlXG4vLyBzYW1lIGFzIHRoZSBjdXJyZW50IHN0YXRlLCB3ZSBtYXkgYmUgYWJsZSB0byBiYWlsIG91dCBlbnRpcmVseS5cbnZhciBsYXN0UmVuZGVyZWRSZWR1Y2VyPXF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXI7aWYobGFzdFJlbmRlcmVkUmVkdWNlciE9PW51bGwpe3ZhciBwcmV2RGlzcGF0Y2hlcjt7cHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7fXRyeXt2YXIgY3VycmVudFN0YXRlPXF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlO3ZhciBlYWdlclN0YXRlPWxhc3RSZW5kZXJlZFJlZHVjZXIoY3VycmVudFN0YXRlLGFjdGlvbik7Ly8gU3Rhc2ggdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGUsIGFuZCB0aGUgcmVkdWNlciB1c2VkIHRvIGNvbXB1dGVcbi8vIGl0LCBvbiB0aGUgdXBkYXRlIG9iamVjdC4gSWYgdGhlIHJlZHVjZXIgaGFzbid0IGNoYW5nZWQgYnkgdGhlXG4vLyB0aW1lIHdlIGVudGVyIHRoZSByZW5kZXIgcGhhc2UsIHRoZW4gdGhlIGVhZ2VyIHN0YXRlIGNhbiBiZSB1c2VkXG4vLyB3aXRob3V0IGNhbGxpbmcgdGhlIHJlZHVjZXIgYWdhaW4uXG51cGRhdGUuaGFzRWFnZXJTdGF0ZT10cnVlO3VwZGF0ZS5lYWdlclN0YXRlPWVhZ2VyU3RhdGU7aWYob2JqZWN0SXMoZWFnZXJTdGF0ZSxjdXJyZW50U3RhdGUpKXsvLyBGYXN0IHBhdGguIFdlIGNhbiBiYWlsIG91dCB3aXRob3V0IHNjaGVkdWxpbmcgUmVhY3QgdG8gcmUtcmVuZGVyLlxuLy8gSXQncyBzdGlsbCBwb3NzaWJsZSB0aGF0IHdlJ2xsIG5lZWQgdG8gcmViYXNlIHRoaXMgdXBkYXRlIGxhdGVyLFxuLy8gaWYgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzIGZvciBhIGRpZmZlcmVudCByZWFzb24gYW5kIGJ5IHRoYXRcbi8vIHRpbWUgdGhlIHJlZHVjZXIgaGFzIGNoYW5nZWQuXG4vLyBUT0RPOiBEbyB3ZSBzdGlsbCBuZWVkIHRvIGVudGFuZ2xlIHRyYW5zaXRpb25zIGluIHRoaXMgY2FzZT9cbmVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZUFuZEVhZ2VybHlCYWlsb3V0KGZpYmVyLHF1ZXVlLHVwZGF0ZSxsYW5lKTtyZXR1cm47fX1jYXRjaChlcnJvcil7Ly8gU3VwcHJlc3MgdGhlIGVycm9yLiBJdCB3aWxsIHRocm93IGFnYWluIGluIHRoZSByZW5kZXIgcGhhc2UuXG59ZmluYWxseXt7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX19fXZhciByb290PWVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlcixxdWV1ZSx1cGRhdGUsbGFuZSk7aWYocm9vdCE9PW51bGwpe3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLGxhbmUsZXZlbnRUaW1lKTtlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCxxdWV1ZSxsYW5lKTt9fW1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLGxhbmUpO31mdW5jdGlvbiBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKXt2YXIgYWx0ZXJuYXRlPWZpYmVyLmFsdGVybmF0ZTtyZXR1cm4gZmliZXI9PT1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxfHxhbHRlcm5hdGUhPT1udWxsJiZhbHRlcm5hdGU9PT1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO31mdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsdXBkYXRlKXsvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2Zcbi8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbi8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzPWRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGU9dHJ1ZTt2YXIgcGVuZGluZz1xdWV1ZS5wZW5kaW5nO2lmKHBlbmRpbmc9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG51cGRhdGUubmV4dD11cGRhdGU7fWVsc2V7dXBkYXRlLm5leHQ9cGVuZGluZy5uZXh0O3BlbmRpbmcubmV4dD11cGRhdGU7fXF1ZXVlLnBlbmRpbmc9dXBkYXRlO30vLyBUT0RPOiBNb3ZlIHRvIFJlYWN0RmliZXJDb25jdXJyZW50VXBkYXRlcz9cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LHF1ZXVlLGxhbmUpe2lmKGlzVHJhbnNpdGlvbkxhbmUobGFuZSkpe3ZhciBxdWV1ZUxhbmVzPXF1ZXVlLmxhbmVzOy8vIElmIGFueSBlbnRhbmdsZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBwZW5kaW5nIG9uIHRoZSByb290LCB0aGVuIHRoZXlcbi8vIG11c3QgaGF2ZSBmaW5pc2hlZC4gV2UgY2FuIHJlbW92ZSB0aGVtIGZyb20gdGhlIHNoYXJlZCBxdWV1ZSwgd2hpY2hcbi8vIHJlcHJlc2VudHMgYSBzdXBlcnNldCBvZiB0aGUgYWN0dWFsbHkgcGVuZGluZyBsYW5lcy4gSW4gc29tZSBjYXNlcyB3ZVxuLy8gbWF5IGVudGFuZ2xlIG1vcmUgdGhhbiB3ZSBuZWVkIHRvLCBidXQgdGhhdCdzIE9LLiBJbiBmYWN0IGl0J3Mgd29yc2UgaWZcbi8vIHdlICpkb24ndCogZW50YW5nbGUgd2hlbiB3ZSBzaG91bGQuXG5xdWV1ZUxhbmVzPWludGVyc2VjdExhbmVzKHF1ZXVlTGFuZXMscm9vdC5wZW5kaW5nTGFuZXMpOy8vIEVudGFuZ2xlIHRoZSBuZXcgdHJhbnNpdGlvbiBsYW5lIHdpdGggdGhlIG90aGVyIHRyYW5zaXRpb24gbGFuZXMuXG52YXIgbmV3UXVldWVMYW5lcz1tZXJnZUxhbmVzKHF1ZXVlTGFuZXMsbGFuZSk7cXVldWUubGFuZXM9bmV3UXVldWVMYW5lczsvLyBFdmVuIGlmIHF1ZXVlLmxhbmVzIGFscmVhZHkgaW5jbHVkZSBsYW5lLCB3ZSBkb24ndCBrbm93IGZvciBjZXJ0YWluIGlmXG4vLyB0aGUgbGFuZSBmaW5pc2hlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIGVudGFuZ2xlZCBpdC4gU28gd2UgbmVlZCB0b1xuLy8gZW50YW5nbGUgaXQgYWdhaW4sIGp1c3QgdG8gYmUgc3VyZS5cbm1hcmtSb290RW50YW5nbGVkKHJvb3QsbmV3UXVldWVMYW5lcyk7fX1mdW5jdGlvbiBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlcixsYW5lLGFjdGlvbil7e21hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKTt9fXZhciBDb250ZXh0T25seURpc3BhdGNoZXI9e3JlYWRDb250ZXh0OnJlYWRDb250ZXh0LHVzZUNhbGxiYWNrOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VDb250ZXh0OnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VFZmZlY3Q6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZUltcGVyYXRpdmVIYW5kbGU6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZUluc2VydGlvbkVmZmVjdDp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlTGF5b3V0RWZmZWN0OnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VNZW1vOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VSZWR1Y2VyOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VSZWY6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZVN0YXRlOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VEZWJ1Z1ZhbHVlOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VEZWZlcnJlZFZhbHVlOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VUcmFuc2l0aW9uOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VNdXRhYmxlU291cmNlOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VTeW5jRXh0ZXJuYWxTdG9yZTp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlSWQ6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjplbmFibGVOZXdSZWNvbmNpbGVyfTt2YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWPW51bGw7dmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY9bnVsbDt2YXIgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVj1udWxsO3ZhciBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY9bnVsbDt2YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVj1udWxsO3ZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVj1udWxsO3ZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWPW51bGw7e3ZhciB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3M9ZnVuY3Rpb24oKXtlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJysnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJysnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcrJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7fTt2YXIgd2FybkludmFsaWRIb29rQWNjZXNzPWZ1bmN0aW9uKCl7ZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJysnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnKydGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO307SG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWPXtyZWFkQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VDYWxsYmFjazpmdW5jdGlvbihjYWxsYmFjayxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ2FsbGJhY2snO21vdW50SG9va1R5cGVzRGV2KCk7Y2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7cmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssZGVwcyk7fSx1c2VDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDb250ZXh0Jzttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUVmZmVjdCc7bW91bnRIb29rVHlwZXNEZXYoKTtjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtyZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlSW1wZXJhdGl2ZUhhbmRsZTpmdW5jdGlvbihyZWYsY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbXBlcmF0aXZlSGFuZGxlJzttb3VudEhvb2tUeXBlc0RldigpO2NoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO3JldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLGNyZWF0ZSxkZXBzKTt9LHVzZUluc2VydGlvbkVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUluc2VydGlvbkVmZmVjdCc7bW91bnRIb29rVHlwZXNEZXYoKTtjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtyZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTGF5b3V0RWZmZWN0Jzttb3VudEhvb2tUeXBlc0RldigpO2NoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO3JldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VNZW1vOmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTWVtbyc7bW91bnRIb29rVHlwZXNEZXYoKTtjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt0cnl7cmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsZGVwcyk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVkdWNlcjpmdW5jdGlvbihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZHVjZXInO21vdW50SG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7dHJ5e3JldHVybiBtb3VudFJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZjpmdW5jdGlvbihpbml0aWFsVmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWYnO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7fSx1c2VTdGF0ZTpmdW5jdGlvbihpbml0aWFsU3RhdGUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTdGF0ZSc7bW91bnRIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt0cnl7cmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VEZWJ1Z1ZhbHVlOmZ1bmN0aW9uKHZhbHVlLGZvcm1hdHRlckZuKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVidWdWYWx1ZSc7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7fSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKHZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVmZXJyZWRWYWx1ZSc7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTt9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlVHJhbnNpdGlvbic7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7fSx1c2VNdXRhYmxlU291cmNlOmZ1bmN0aW9uKHNvdXJjZSxnZXRTbmFwc2hvdCxzdWJzY3JpYmUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNdXRhYmxlU291cmNlJzttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTt9LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZ1bmN0aW9uKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN5bmNFeHRlcm5hbFN0b3JlJzttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCk7fSx1c2VJZDpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJZCc7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRJZCgpO30sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOmVuYWJsZU5ld1JlY29uY2lsZXJ9O0hvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY9e3JlYWRDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGNhbGxiYWNrLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDYWxsYmFjayc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssZGVwcyk7fSx1c2VDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDb250ZXh0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VFZmZlY3QnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VJbXBlcmF0aXZlSGFuZGxlOmZ1bmN0aW9uKHJlZixjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUltcGVyYXRpdmVIYW5kbGUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLGNyZWF0ZSxkZXBzKTt9LHVzZUluc2VydGlvbkVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUluc2VydGlvbkVmZmVjdCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUxheW91dEVmZmVjdCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZU1lbW86ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNZW1vJzt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt0cnl7cmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsZGVwcyk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVkdWNlcjpmdW5jdGlvbihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZHVjZXInO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO3RyeXtyZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWY6ZnVuY3Rpb24oaW5pdGlhbFZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVmJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTt9LHVzZVN0YXRlOmZ1bmN0aW9uKGluaXRpYWxTdGF0ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN0YXRlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt0cnl7cmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VEZWJ1Z1ZhbHVlOmZ1bmN0aW9uKHZhbHVlLGZvcm1hdHRlckZuKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVidWdWYWx1ZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO30sdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbih2YWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlZmVycmVkVmFsdWUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VUcmFuc2l0aW9uJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7fSx1c2VNdXRhYmxlU291cmNlOmZ1bmN0aW9uKHNvdXJjZSxnZXRTbmFwc2hvdCxzdWJzY3JpYmUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNdXRhYmxlU291cmNlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKCk7fSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpmdW5jdGlvbihzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3Qpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KTt9LHVzZUlkOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUlkJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRJZCgpO30sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOmVuYWJsZU5ld1JlY29uY2lsZXJ9O0hvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY9e3JlYWRDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGNhbGxiYWNrLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDYWxsYmFjayc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLGRlcHMpO30sdXNlQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ29udGV4dCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRWZmZWN0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24ocmVmLGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW1wZXJhdGl2ZUhhbmRsZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLGNyZWF0ZSxkZXBzKTt9LHVzZUluc2VydGlvbkVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUluc2VydGlvbkVmZmVjdCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VMYXlvdXRFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VMYXlvdXRFZmZlY3QnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTWVtbzpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU1lbW8nO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt0cnl7cmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLGRlcHMpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZHVjZXI6ZnVuY3Rpb24ocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWR1Y2VyJzt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7dHJ5e3JldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWY6ZnVuY3Rpb24oaW5pdGlhbFZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVmJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlUmVmKCk7fSx1c2VTdGF0ZTpmdW5jdGlvbihpbml0aWFsU3RhdGUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTdGF0ZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO3RyeXtyZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VEZWJ1Z1ZhbHVlOmZ1bmN0aW9uKHZhbHVlLGZvcm1hdHRlckZuKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVidWdWYWx1ZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTt9LHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24odmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWZlcnJlZFZhbHVlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7fSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVRyYW5zaXRpb24nO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7fSx1c2VNdXRhYmxlU291cmNlOmZ1bmN0aW9uKHNvdXJjZSxnZXRTbmFwc2hvdCxzdWJzY3JpYmUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNdXRhYmxlU291cmNlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZSgpO30sdXNlU3luY0V4dGVybmFsU3RvcmU6ZnVuY3Rpb24oc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3luY0V4dGVybmFsU3RvcmUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsZ2V0U25hcHNob3QpO30sdXNlSWQ6ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSWQnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJZCgpO30sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOmVuYWJsZU5ld1JlY29uY2lsZXJ9O0hvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVj17cmVhZENvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oY2FsbGJhY2ssZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNhbGxiYWNrJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssZGVwcyk7fSx1c2VDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDb250ZXh0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VFZmZlY3QnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlSW1wZXJhdGl2ZUhhbmRsZTpmdW5jdGlvbihyZWYsY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbXBlcmF0aXZlSGFuZGxlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsY3JlYXRlLGRlcHMpO30sdXNlSW5zZXJ0aW9uRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW5zZXJ0aW9uRWZmZWN0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUxheW91dEVmZmVjdCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VNZW1vOmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTWVtbyc7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7dHJ5e3JldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSxkZXBzKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVkdWNlcic7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7dHJ5e3JldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZjpmdW5jdGlvbihpbml0aWFsVmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWYnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVSZWYoKTt9LHVzZVN0YXRlOmZ1bmN0aW9uKGluaXRpYWxTdGF0ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN0YXRlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjt0cnl7cmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VEZWJ1Z1ZhbHVlOmZ1bmN0aW9uKHZhbHVlLGZvcm1hdHRlckZuKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVidWdWYWx1ZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTt9LHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24odmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWZlcnJlZFZhbHVlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKTt9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlVHJhbnNpdGlvbic7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO30sdXNlTXV0YWJsZVNvdXJjZTpmdW5jdGlvbihzb3VyY2UsZ2V0U25hcHNob3Qsc3Vic2NyaWJlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTXV0YWJsZVNvdXJjZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2UoKTt9LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZ1bmN0aW9uKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN5bmNFeHRlcm5hbFN0b3JlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLGdldFNuYXBzaG90KTt9LHVzZUlkOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUlkJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSWQoKTt9LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjplbmFibGVOZXdSZWNvbmNpbGVyfTtJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWPXtyZWFkQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXt3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VDYWxsYmFjazpmdW5jdGlvbihjYWxsYmFjayxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ2FsbGJhY2snO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssZGVwcyk7fSx1c2VDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDb250ZXh0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUVmZmVjdCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlSW1wZXJhdGl2ZUhhbmRsZTpmdW5jdGlvbihyZWYsY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbXBlcmF0aXZlSGFuZGxlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLGNyZWF0ZSxkZXBzKTt9LHVzZUluc2VydGlvbkVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUluc2VydGlvbkVmZmVjdCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTGF5b3V0RWZmZWN0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VNZW1vOmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTWVtbyc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt0cnl7cmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsZGVwcyk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVkdWNlcjpmdW5jdGlvbihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZHVjZXInO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7dHJ5e3JldHVybiBtb3VudFJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZjpmdW5jdGlvbihpbml0aWFsVmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWYnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7fSx1c2VTdGF0ZTpmdW5jdGlvbihpbml0aWFsU3RhdGUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTdGF0ZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt0cnl7cmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VEZWJ1Z1ZhbHVlOmZ1bmN0aW9uKHZhbHVlLGZvcm1hdHRlckZuKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVidWdWYWx1ZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7fSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKHZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVmZXJyZWRWYWx1ZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTt9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlVHJhbnNpdGlvbic7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7fSx1c2VNdXRhYmxlU291cmNlOmZ1bmN0aW9uKHNvdXJjZSxnZXRTbmFwc2hvdCxzdWJzY3JpYmUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNdXRhYmxlU291cmNlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTt9LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZ1bmN0aW9uKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN5bmNFeHRlcm5hbFN0b3JlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCk7fSx1c2VJZDpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJZCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRJZCgpO30sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOmVuYWJsZU5ld1JlY29uY2lsZXJ9O0ludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWPXtyZWFkQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXt3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VDYWxsYmFjazpmdW5jdGlvbihjYWxsYmFjayxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ2FsbGJhY2snO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjayxkZXBzKTt9LHVzZUNvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNvbnRleHQnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUVmZmVjdCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VJbXBlcmF0aXZlSGFuZGxlOmZ1bmN0aW9uKHJlZixjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUltcGVyYXRpdmVIYW5kbGUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZixjcmVhdGUsZGVwcyk7fSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbnNlcnRpb25FZmZlY3QnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTGF5b3V0RWZmZWN0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZU1lbW86ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNZW1vJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7dHJ5e3JldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSxkZXBzKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVkdWNlcic7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO3RyeXtyZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVmOmZ1bmN0aW9uKGluaXRpYWxWYWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZic7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVJlZigpO30sdXNlU3RhdGU6ZnVuY3Rpb24oaW5pdGlhbFN0YXRlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3RhdGUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt0cnl7cmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlRGVidWdWYWx1ZTpmdW5jdGlvbih2YWx1ZSxmb3JtYXR0ZXJGbil7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlYnVnVmFsdWUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7fSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKHZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVmZXJyZWRWYWx1ZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VUcmFuc2l0aW9uJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO30sdXNlTXV0YWJsZVNvdXJjZTpmdW5jdGlvbihzb3VyY2UsZ2V0U25hcHNob3Qsc3Vic2NyaWJlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTXV0YWJsZVNvdXJjZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2UoKTt9LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZ1bmN0aW9uKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN5bmNFeHRlcm5hbFN0b3JlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLGdldFNuYXBzaG90KTt9LHVzZUlkOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUlkJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSWQoKTt9LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjplbmFibGVOZXdSZWNvbmNpbGVyfTtJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWPXtyZWFkQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXt3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VDYWxsYmFjazpmdW5jdGlvbihjYWxsYmFjayxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ2FsbGJhY2snO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjayxkZXBzKTt9LHVzZUNvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNvbnRleHQnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUVmZmVjdCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VJbXBlcmF0aXZlSGFuZGxlOmZ1bmN0aW9uKHJlZixjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUltcGVyYXRpdmVIYW5kbGUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZixjcmVhdGUsZGVwcyk7fSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbnNlcnRpb25FZmZlY3QnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTGF5b3V0RWZmZWN0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZU1lbW86ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNZW1vJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7dHJ5e3JldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSxkZXBzKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVkdWNlcic7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO3RyeXtyZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWY6ZnVuY3Rpb24oaW5pdGlhbFZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVmJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlUmVmKCk7fSx1c2VTdGF0ZTpmdW5jdGlvbihpbml0aWFsU3RhdGUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTdGF0ZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO3RyeXtyZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZURlYnVnVmFsdWU6ZnVuY3Rpb24odmFsdWUsZm9ybWF0dGVyRm4pe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWJ1Z1ZhbHVlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO30sdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbih2YWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlZmVycmVkVmFsdWUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VUcmFuc2l0aW9uJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7fSx1c2VNdXRhYmxlU291cmNlOmZ1bmN0aW9uKHNvdXJjZSxnZXRTbmFwc2hvdCxzdWJzY3JpYmUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNdXRhYmxlU291cmNlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZSgpO30sdXNlU3luY0V4dGVybmFsU3RvcmU6ZnVuY3Rpb24oc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3luY0V4dGVybmFsU3RvcmUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsZ2V0U25hcHNob3QpO30sdXNlSWQ6ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSWQnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJZCgpO30sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOmVuYWJsZU5ld1JlY29uY2lsZXJ9O312YXIgbm93JDE9U2NoZWR1bGVyLnVuc3RhYmxlX25vdzt2YXIgY29tbWl0VGltZT0wO3ZhciBsYXlvdXRFZmZlY3RTdGFydFRpbWU9LTE7dmFyIHByb2ZpbGVyU3RhcnRUaW1lPS0xO3ZhciBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lPS0xOy8qKlxuICogVHJhY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXBkYXRlIHdhcyBhIG5lc3RlZC9jYXNjYWRpbmcgdXBkYXRlIChzY2hlZHVsZWQgZnJvbSBhIGxheW91dCBlZmZlY3QpLlxuICpcbiAqIFRoZSBvdmVyYWxsIHNlcXVlbmNlIGlzOlxuICogICAxLiByZW5kZXJcbiAqICAgMi4gY29tbWl0IChhbmQgY2FsbCBgb25SZW5kZXJgLCBgb25Db21taXRgKVxuICogICAzLiBjaGVjayBmb3IgbmVzdGVkIHVwZGF0ZXNcbiAqICAgNC4gZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIChhbmQgY2FsbCBgb25Qb3N0Q29tbWl0YClcbiAqXG4gKiBOZXN0ZWQgdXBkYXRlcyBhcmUgaWRlbnRpZmllZCBpbiBzdGVwIDMgYWJvdmUsXG4gKiBidXQgc3RlcCA0IHN0aWxsIGFwcGxpZXMgdG8gdGhlIHdvcmsgdGhhdCB3YXMganVzdCBjb21taXR0ZWQuXG4gKiBXZSB1c2UgdHdvIGZsYWdzIHRvIHRyYWNrIG5lc3RlZCB1cGRhdGVzIHRoZW46XG4gKiBvbmUgdHJhY2tzIHdoZXRoZXIgdGhlIHVwY29taW5nIHVwZGF0ZSBpcyBhIG5lc3RlZCB1cGRhdGUsXG4gKiBhbmQgdGhlIG90aGVyIHRyYWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVwZGF0ZSB3YXMgYSBuZXN0ZWQgdXBkYXRlLlxuICogVGhlIGZpcnN0IHZhbHVlIGdldHMgc3luY2VkIHRvIHRoZSBzZWNvbmQgYXQgdGhlIHN0YXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UuXG4gKi92YXIgY3VycmVudFVwZGF0ZUlzTmVzdGVkPWZhbHNlO3ZhciBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ9ZmFsc2U7ZnVuY3Rpb24gaXNDdXJyZW50VXBkYXRlTmVzdGVkKCl7cmV0dXJuIGN1cnJlbnRVcGRhdGVJc05lc3RlZDt9ZnVuY3Rpb24gbWFya05lc3RlZFVwZGF0ZVNjaGVkdWxlZCgpe3tuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ9dHJ1ZTt9fWZ1bmN0aW9uIHJlc2V0TmVzdGVkVXBkYXRlRmxhZygpe3tjdXJyZW50VXBkYXRlSXNOZXN0ZWQ9ZmFsc2U7bmVzdGVkVXBkYXRlU2NoZWR1bGVkPWZhbHNlO319ZnVuY3Rpb24gc3luY05lc3RlZFVwZGF0ZUZsYWcoKXt7Y3VycmVudFVwZGF0ZUlzTmVzdGVkPW5lc3RlZFVwZGF0ZVNjaGVkdWxlZDtuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ9ZmFsc2U7fX1mdW5jdGlvbiBnZXRDb21taXRUaW1lKCl7cmV0dXJuIGNvbW1pdFRpbWU7fWZ1bmN0aW9uIHJlY29yZENvbW1pdFRpbWUoKXtjb21taXRUaW1lPW5vdyQxKCk7fWZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcil7cHJvZmlsZXJTdGFydFRpbWU9bm93JDEoKTtpZihmaWJlci5hY3R1YWxTdGFydFRpbWU8MCl7ZmliZXIuYWN0dWFsU3RhcnRUaW1lPW5vdyQxKCk7fX1mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcil7cHJvZmlsZXJTdGFydFRpbWU9LTE7fWZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsb3ZlcnJpZGVCYXNlVGltZSl7aWYocHJvZmlsZXJTdGFydFRpbWU+PTApe3ZhciBlbGFwc2VkVGltZT1ub3ckMSgpLXByb2ZpbGVyU3RhcnRUaW1lO2ZpYmVyLmFjdHVhbER1cmF0aW9uKz1lbGFwc2VkVGltZTtpZihvdmVycmlkZUJhc2VUaW1lKXtmaWJlci5zZWxmQmFzZUR1cmF0aW9uPWVsYXBzZWRUaW1lO31wcm9maWxlclN0YXJ0VGltZT0tMTt9fWZ1bmN0aW9uIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpYmVyKXtpZihsYXlvdXRFZmZlY3RTdGFydFRpbWU+PTApe3ZhciBlbGFwc2VkVGltZT1ub3ckMSgpLWxheW91dEVmZmVjdFN0YXJ0VGltZTtsYXlvdXRFZmZlY3RTdGFydFRpbWU9LTE7Ly8gU3RvcmUgZHVyYXRpb24gb24gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3RvclxuLy8gT3IgdGhlIHJvb3QgKGZvciB0aGUgRGV2VG9vbHMgUHJvZmlsZXIgdG8gcmVhZClcbnZhciBwYXJlbnRGaWJlcj1maWJlci5yZXR1cm47d2hpbGUocGFyZW50RmliZXIhPT1udWxsKXtzd2l0Y2gocGFyZW50RmliZXIudGFnKXtjYXNlIEhvc3RSb290OnZhciByb290PXBhcmVudEZpYmVyLnN0YXRlTm9kZTtyb290LmVmZmVjdER1cmF0aW9uKz1lbGFwc2VkVGltZTtyZXR1cm47Y2FzZSBQcm9maWxlcjp2YXIgcGFyZW50U3RhdGVOb2RlPXBhcmVudEZpYmVyLnN0YXRlTm9kZTtwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24rPWVsYXBzZWRUaW1lO3JldHVybjt9cGFyZW50RmliZXI9cGFyZW50RmliZXIucmV0dXJuO319fWZ1bmN0aW9uIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaWJlcil7aWYocGFzc2l2ZUVmZmVjdFN0YXJ0VGltZT49MCl7dmFyIGVsYXBzZWRUaW1lPW5vdyQxKCktcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZTtwYXNzaXZlRWZmZWN0U3RhcnRUaW1lPS0xOy8vIFN0b3JlIGR1cmF0aW9uIG9uIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3Jcbi8vIE9yIHRoZSByb290IChmb3IgdGhlIERldlRvb2xzIFByb2ZpbGVyIHRvIHJlYWQpXG52YXIgcGFyZW50RmliZXI9ZmliZXIucmV0dXJuO3doaWxlKHBhcmVudEZpYmVyIT09bnVsbCl7c3dpdGNoKHBhcmVudEZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp2YXIgcm9vdD1wYXJlbnRGaWJlci5zdGF0ZU5vZGU7aWYocm9vdCE9PW51bGwpe3Jvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uKz1lbGFwc2VkVGltZTt9cmV0dXJuO2Nhc2UgUHJvZmlsZXI6dmFyIHBhcmVudFN0YXRlTm9kZT1wYXJlbnRGaWJlci5zdGF0ZU5vZGU7aWYocGFyZW50U3RhdGVOb2RlIT09bnVsbCl7Ly8gRGV0YWNoZWQgZmliZXJzIGhhdmUgdGhlaXIgc3RhdGUgbm9kZSBjbGVhcmVkIG91dC5cbi8vIEluIHRoaXMgY2FzZSwgdGhlIHJldHVybiBwb2ludGVyIGlzIGFsc28gY2xlYXJlZCBvdXQsXG4vLyBzbyB3ZSB3b24ndCBiZSBhYmxlIHRvIHJlcG9ydCB0aGUgdGltZSBzcGVudCBpbiB0aGlzIFByb2ZpbGVyJ3Mgc3VidHJlZS5cbnBhcmVudFN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24rPWVsYXBzZWRUaW1lO31yZXR1cm47fXBhcmVudEZpYmVyPXBhcmVudEZpYmVyLnJldHVybjt9fX1mdW5jdGlvbiBzdGFydExheW91dEVmZmVjdFRpbWVyKCl7bGF5b3V0RWZmZWN0U3RhcnRUaW1lPW5vdyQxKCk7fWZ1bmN0aW9uIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCl7cGFzc2l2ZUVmZmVjdFN0YXJ0VGltZT1ub3ckMSgpO31mdW5jdGlvbiB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKGZpYmVyKXsvLyBUcmFuc2ZlciB0aW1lIHNwZW50IHJlbmRlcmluZyB0aGVzZSBjaGlsZHJlbiBzbyB3ZSBkb24ndCBsb3NlIGl0XG4vLyBhZnRlciB3ZSByZXJlbmRlci4gVGhpcyBpcyB1c2VkIGFzIGEgaGVscGVyIGluIHNwZWNpYWwgY2FzZXNcbi8vIHdoZXJlIHdlIHNob3VsZCBjb3VudCB0aGUgd29yayBvZiBtdWx0aXBsZSBwYXNzZXMuXG52YXIgY2hpbGQ9ZmliZXIuY2hpbGQ7d2hpbGUoY2hpbGQpe2ZpYmVyLmFjdHVhbER1cmF0aW9uKz1jaGlsZC5hY3R1YWxEdXJhdGlvbjtjaGlsZD1jaGlsZC5zaWJsaW5nO319ZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsc291cmNlKXsvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbi8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbnJldHVybnt2YWx1ZTp2YWx1ZSxzb3VyY2U6c291cmNlLHN0YWNrOmdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpLGRpZ2VzdDpudWxsfTt9ZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSxkaWdlc3Qsc3RhY2spe3JldHVybnt2YWx1ZTp2YWx1ZSxzb3VyY2U6bnVsbCxzdGFjazpzdGFjayE9bnVsbD9zdGFjazpudWxsLGRpZ2VzdDpkaWdlc3QhPW51bGw/ZGlnZXN0Om51bGx9O30vLyBUaGlzIG1vZHVsZSBpcyBmb3JrZWQgaW4gZGlmZmVyZW50IGVudmlyb25tZW50cy5cbi8vIEJ5IGRlZmF1bHQsIHJldHVybiBgdHJ1ZWAgdG8gbG9nIGVycm9ycyB0byB0aGUgY29uc29sZS5cbi8vIEZvcmtzIGNhbiByZXR1cm4gYGZhbHNlYCBpZiB0aGlzIGlzbid0IGRlc2lyYWJsZS5cbmZ1bmN0aW9uIHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSxlcnJvckluZm8pe3JldHVybiB0cnVlO31mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGJvdW5kYXJ5LGVycm9ySW5mbyl7dHJ5e3ZhciBsb2dFcnJvcj1zaG93RXJyb3JEaWFsb2coYm91bmRhcnksZXJyb3JJbmZvKTsvLyBBbGxvdyBpbmplY3RlZCBzaG93RXJyb3JEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuaWYobG9nRXJyb3I9PT1mYWxzZSl7cmV0dXJuO312YXIgZXJyb3I9ZXJyb3JJbmZvLnZhbHVlO2lmKHRydWUpe3ZhciBzb3VyY2U9ZXJyb3JJbmZvLnNvdXJjZTt2YXIgc3RhY2s9ZXJyb3JJbmZvLnN0YWNrO3ZhciBjb21wb25lbnRTdGFjaz1zdGFjayE9PW51bGw/c3RhY2s6Jyc7Ly8gQnJvd3NlcnMgc3VwcG9ydCBzaWxlbmNpbmcgdW5jYXVnaHQgZXJyb3JzIGJ5IGNhbGxpbmdcbi8vIGBwcmV2ZW50RGVmYXVsdCgpYCBpbiB3aW5kb3cgYGVycm9yYCBoYW5kbGVyLlxuLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG5pZihlcnJvciE9bnVsbCYmZXJyb3IuX3N1cHByZXNzTG9nZ2luZyl7aWYoYm91bmRhcnkudGFnPT09Q2xhc3NDb21wb25lbnQpey8vIFRoZSBlcnJvciBpcyByZWNvdmVyYWJsZSBhbmQgd2FzIHNpbGVuY2VkLlxuLy8gSWdub3JlIGl0IGFuZCBkb24ndCBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG4vLyBUaGlzIGlzIGhhbmR5IGZvciB0ZXN0aW5nIGVycm9yIGJvdW5kYXJpZXMgd2l0aG91dCBub2lzZS5cbnJldHVybjt9Ly8gVGhlIGVycm9yIGlzIGZhdGFsLiBTaW5jZSB0aGUgc2lsZW5jaW5nIG1pZ2h0IGhhdmVcbi8vIGJlZW4gYWNjaWRlbnRhbCwgd2UnbGwgc3VyZmFjZSBpdCBhbnl3YXkuXG4vLyBIb3dldmVyLCB0aGUgYnJvd3NlciB3b3VsZCBoYXZlIHNpbGVuY2VkIHRoZSBvcmlnaW5hbCBlcnJvclxuLy8gc28gd2UnbGwgcHJpbnQgaXQgZmlyc3QsIGFuZCB0aGVuIHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cbmNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOy8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuLy8gRm9yIGEgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGlzIGJsb2NrLCBzZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzM4NFxufXZhciBjb21wb25lbnROYW1lPXNvdXJjZT9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHNvdXJjZSk6bnVsbDt2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2U9Y29tcG9uZW50TmFtZT9cIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiK2NvbXBvbmVudE5hbWUrXCI+IGNvbXBvbmVudDpcIjonVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6Jzt2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2U7aWYoYm91bmRhcnkudGFnPT09SG9zdFJvb3Qpe2Vycm9yQm91bmRhcnlNZXNzYWdlPSdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nKydWaXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJzt9ZWxzZXt2YXIgZXJyb3JCb3VuZGFyeU5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSl8fCdBbm9ueW1vdXMnO2Vycm9yQm91bmRhcnlNZXNzYWdlPVwiUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggXCIrKFwidXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIrZXJyb3JCb3VuZGFyeU5hbWUrXCIuXCIpO312YXIgY29tYmluZWRNZXNzYWdlPWNvbXBvbmVudE5hbWVNZXNzYWdlK1wiXFxuXCIrY29tcG9uZW50U3RhY2srXCJcXG5cXG5cIisoXCJcIitlcnJvckJvdW5kYXJ5TWVzc2FnZSk7Ly8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG5jb25zb2xlWydlcnJvciddKGNvbWJpbmVkTWVzc2FnZSk7Ly8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG59ZWxzZXsvLyBJbiBwcm9kdWN0aW9uLCB3ZSBwcmludCB0aGUgZXJyb3IgZGlyZWN0bHkuXG4vLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgbWVzc2FnZSwgdGhlIEpTIHN0YWNrLCBhbmQgYW55dGhpbmcgdGhlIGJyb3dzZXIgd2FudHMgdG8gc2hvdy5cbi8vIFdlIHBhc3MgdGhlIGVycm9yIG9iamVjdCBpbnN0ZWFkIG9mIGN1c3RvbSBtZXNzYWdlIHNvIHRoYXQgdGhlIGJyb3dzZXIgZGlzcGxheXMgdGhlIGVycm9yIG5hdGl2ZWx5LlxuY29uc29sZVsnZXJyb3InXShlcnJvcik7Ly8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG59fWNhdGNoKGUpey8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4vLyBJZiBjb25zb2xlLmVycm9yIGlzIG92ZXJyaWRkZW4sIG9yIGxvZ0NhcHR1cmVkRXJyb3IoKSBzaG93cyBhIGRpYWxvZyB0aGF0IHRocm93cyxcbi8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZTt9KTt9fXZhciBQb3NzaWJseVdlYWtNYXAkMT10eXBlb2YgV2Vha01hcD09PSdmdW5jdGlvbic/V2Vha01hcDpNYXA7ZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLGVycm9ySW5mbyxsYW5lKXt2YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCxsYW5lKTsvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxudXBkYXRlLnRhZz1DYXB0dXJlVXBkYXRlOy8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbi8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cbnVwZGF0ZS5wYXlsb2FkPXtlbGVtZW50Om51bGx9O3ZhciBlcnJvcj1lcnJvckluZm8udmFsdWU7dXBkYXRlLmNhbGxiYWNrPWZ1bmN0aW9uKCl7b25VbmNhdWdodEVycm9yKGVycm9yKTtsb2dDYXB0dXJlZEVycm9yKGZpYmVyLGVycm9ySW5mbyk7fTtyZXR1cm4gdXBkYXRlO31mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLGVycm9ySW5mbyxsYW5lKXt2YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCxsYW5lKTt1cGRhdGUudGFnPUNhcHR1cmVVcGRhdGU7dmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcj1maWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtpZih0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yPT09J2Z1bmN0aW9uJyl7dmFyIGVycm9yJDE9ZXJyb3JJbmZvLnZhbHVlO3VwZGF0ZS5wYXlsb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvciQxKTt9O3VwZGF0ZS5jYWxsYmFjaz1mdW5jdGlvbigpe3ttYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7fWxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsZXJyb3JJbmZvKTt9O312YXIgaW5zdD1maWJlci5zdGF0ZU5vZGU7aWYoaW5zdCE9PW51bGwmJnR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoPT09J2Z1bmN0aW9uJyl7dXBkYXRlLmNhbGxiYWNrPWZ1bmN0aW9uIGNhbGxiYWNrKCl7e21hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTt9bG9nQ2FwdHVyZWRFcnJvcihmaWJlcixlcnJvckluZm8pO2lmKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IhPT0nZnVuY3Rpb24nKXsvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbi8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbi8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cbi8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzXG4vLyBub3QgZGVmaW5lZC5cbm1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQodGhpcyk7fXZhciBlcnJvciQxPWVycm9ySW5mby52YWx1ZTt2YXIgc3RhY2s9ZXJyb3JJbmZvLnN0YWNrO3RoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSx7Y29tcG9uZW50U3RhY2s6c3RhY2shPT1udWxsP3N0YWNrOicnfSk7e2lmKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IhPT0nZnVuY3Rpb24nKXsvLyBJZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZCxcbi8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGlzIHNjaGVkdWxlZCB0aGVuIHRoZSBib3VuZGFyeSB3aWxsIHN3YWxsb3cgdGhlIGVycm9yLlxuaWYoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsU3luY0xhbmUpKXtlcnJvcignJXM6IEVycm9yIGJvdW5kYXJpZXMgc2hvdWxkIGltcGxlbWVudCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKS4gJysnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J1Vua25vd24nKTt9fX19O31yZXR1cm4gdXBkYXRlO31mdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCx3YWtlYWJsZSxsYW5lcyl7Ly8gQXR0YWNoIGEgcGluZyBsaXN0ZW5lclxuLy9cbi8vIFRoZSBkYXRhIG1pZ2h0IHJlc29sdmUgYmVmb3JlIHdlIGhhdmUgYSBjaGFuY2UgdG8gY29tbWl0IHRoZSBmYWxsYmFjay4gT3IsXG4vLyBpbiB0aGUgY2FzZSBvZiBhIHJlZnJlc2gsIHdlJ2xsIG5ldmVyIGNvbW1pdCBhIGZhbGxiYWNrLiBTbyB3ZSBuZWVkIHRvXG4vLyBhdHRhY2ggYSBsaXN0ZW5lciBub3cuIFdoZW4gaXQgcmVzb2x2ZXMgKFwicGluZ3NcIiksIHdlIGNhbiBkZWNpZGUgd2hldGhlciB0b1xuLy8gdHJ5IHJlbmRlcmluZyB0aGUgdHJlZSBhZ2Fpbi5cbi8vXG4vLyBPbmx5IGF0dGFjaCBhIGxpc3RlbmVyIGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGZvciB0aGUgbGFuZXNcbi8vIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgKHdoaWNoIGFjdHMgbGlrZSBhIFwidGhyZWFkIElEXCIgaGVyZSkuXG4vL1xuLy8gV2Ugb25seSBuZWVkIHRvIGRvIHRoaXMgaW4gY29uY3VycmVudCBtb2RlLiBMZWdhY3kgU3VzcGVuc2UgYWx3YXlzXG4vLyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmUgbm8gcGluZ3MuXG52YXIgcGluZ0NhY2hlPXJvb3QucGluZ0NhY2hlO3ZhciB0aHJlYWRJRHM7aWYocGluZ0NhY2hlPT09bnVsbCl7cGluZ0NhY2hlPXJvb3QucGluZ0NhY2hlPW5ldyBQb3NzaWJseVdlYWtNYXAkMSgpO3RocmVhZElEcz1uZXcgU2V0KCk7cGluZ0NhY2hlLnNldCh3YWtlYWJsZSx0aHJlYWRJRHMpO31lbHNle3RocmVhZElEcz1waW5nQ2FjaGUuZ2V0KHdha2VhYmxlKTtpZih0aHJlYWRJRHM9PT11bmRlZmluZWQpe3RocmVhZElEcz1uZXcgU2V0KCk7cGluZ0NhY2hlLnNldCh3YWtlYWJsZSx0aHJlYWRJRHMpO319aWYoIXRocmVhZElEcy5oYXMobGFuZXMpKXsvLyBNZW1vaXplIHVzaW5nIHRoZSB0aHJlYWQgSUQgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxudGhyZWFkSURzLmFkZChsYW5lcyk7dmFyIHBpbmc9cGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLHJvb3Qsd2FrZWFibGUsbGFuZXMpO3tpZihpc0RldlRvb2xzUHJlc2VudCl7Ly8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzXG5yZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsbGFuZXMpO319d2FrZWFibGUudGhlbihwaW5nLHBpbmcpO319ZnVuY3Rpb24gYXR0YWNoUmV0cnlMaXN0ZW5lcihzdXNwZW5zZUJvdW5kYXJ5LHJvb3Qsd2FrZWFibGUsbGFuZXMpey8vIFJldHJ5IGxpc3RlbmVyXG4vL1xuLy8gSWYgdGhlIGZhbGxiYWNrIGRvZXMgY29tbWl0LCB3ZSBuZWVkIHRvIGF0dGFjaCBhIGRpZmZlcmVudCB0eXBlIG9mXG4vLyBsaXN0ZW5lci4gVGhpcyBvbmUgc2NoZWR1bGVzIGFuIHVwZGF0ZSBvbiB0aGUgU3VzcGVuc2UgYm91bmRhcnkgdG8gdHVyblxuLy8gdGhlIGZhbGxiYWNrIHN0YXRlIG9mZi5cbi8vXG4vLyBTdGFzaCB0aGUgd2FrZWFibGUgb24gdGhlIGJvdW5kYXJ5IGZpYmVyIHNvIHdlIGNhbiBhY2Nlc3MgaXQgaW4gdGhlXG4vLyBjb21taXQgcGhhc2UuXG4vL1xuLy8gV2hlbiB0aGUgd2FrZWFibGUgcmVzb2x2ZXMsIHdlJ2xsIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBib3VuZGFyeVxuLy8gYWdhaW4gKFwicmV0cnlcIikuXG52YXIgd2FrZWFibGVzPXN1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWU7aWYod2FrZWFibGVzPT09bnVsbCl7dmFyIHVwZGF0ZVF1ZXVlPW5ldyBTZXQoKTt1cGRhdGVRdWV1ZS5hZGQod2FrZWFibGUpO3N1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWU9dXBkYXRlUXVldWU7fWVsc2V7d2FrZWFibGVzLmFkZCh3YWtlYWJsZSk7fX1mdW5jdGlvbiByZXNldFN1c3BlbmRlZENvbXBvbmVudChzb3VyY2VGaWJlcixyb290UmVuZGVyTGFuZXMpey8vIEEgbGVnYWN5IG1vZGUgU3VzcGVuc2UgcXVpcmssIG9ubHkgcmVsZXZhbnQgdG8gaG9vayBjb21wb25lbnRzLlxudmFyIHRhZz1zb3VyY2VGaWJlci50YWc7aWYoKHNvdXJjZUZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlJiYodGFnPT09RnVuY3Rpb25Db21wb25lbnR8fHRhZz09PUZvcndhcmRSZWZ8fHRhZz09PVNpbXBsZU1lbW9Db21wb25lbnQpKXt2YXIgY3VycmVudFNvdXJjZT1zb3VyY2VGaWJlci5hbHRlcm5hdGU7aWYoY3VycmVudFNvdXJjZSl7c291cmNlRmliZXIudXBkYXRlUXVldWU9Y3VycmVudFNvdXJjZS51cGRhdGVRdWV1ZTtzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlPWN1cnJlbnRTb3VyY2UubWVtb2l6ZWRTdGF0ZTtzb3VyY2VGaWJlci5sYW5lcz1jdXJyZW50U291cmNlLmxhbmVzO31lbHNle3NvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlPW51bGw7c291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZT1udWxsO319fWZ1bmN0aW9uIGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKXt2YXIgbm9kZT1yZXR1cm5GaWJlcjtkb3tpZihub2RlLnRhZz09PVN1c3BlbnNlQ29tcG9uZW50JiZzaG91bGRDYXB0dXJlU3VzcGVuc2Uobm9kZSkpe3JldHVybiBub2RlO30vLyBUaGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBDb250aW51ZSB0byB0aGUgbmV4dFxuLy8gYm91bmRhcnkuXG5ub2RlPW5vZGUucmV0dXJuO313aGlsZShub2RlIT09bnVsbCk7cmV0dXJuIG51bGw7fWZ1bmN0aW9uIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LHJldHVybkZpYmVyLHNvdXJjZUZpYmVyLHJvb3Qscm9vdFJlbmRlckxhbmVzKXsvLyBUaGlzIG1hcmtzIGEgU3VzcGVuc2UgYm91bmRhcnkgc28gdGhhdCB3aGVuIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2ssXG4vLyBpdCBjYXB0dXJlcyB0aGUgc3VzcGVuZGVkIFwiZXhjZXB0aW9uXCIgYW5kIGRvZXMgYSBzZWNvbmQgKGZhbGxiYWNrKSBwYXNzLlxuaWYoKHN1c3BlbnNlQm91bmRhcnkubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpey8vIExlZ2FjeSBNb2RlIFN1c3BlbnNlXG4vL1xuLy8gSWYgdGhlIGJvdW5kYXJ5IGlzIGluIGxlZ2FjeSBtb2RlLCB3ZSBzaG91bGQgKm5vdCpcbi8vIHN1c3BlbmQgdGhlIGNvbW1pdC4gUHJldGVuZCBhcyBpZiB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCByZW5kZXJlZFxuLy8gbnVsbCBhbmQga2VlcCByZW5kZXJpbmcuIFdoZW4gdGhlIFN1c3BlbnNlIGJvdW5kYXJ5IGNvbXBsZXRlcyxcbi8vIHdlJ2xsIGRvIGEgc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjay5cbmlmKHN1c3BlbnNlQm91bmRhcnk9PT1yZXR1cm5GaWJlcil7Ly8gU3BlY2lhbCBjYXNlIHdoZXJlIHdlIHN1c3BlbmRlZCB3aGlsZSByZWNvbmNpbGluZyB0aGUgY2hpbGRyZW4gb2Zcbi8vIGEgU3VzcGVuc2UgYm91bmRhcnkncyBpbm5lciBPZmZzY3JlZW4gd3JhcHBlciBmaWJlci4gVGhpcyBoYXBwZW5zXG4vLyB3aGVuIGEgUmVhY3QubGF6eSBjb21wb25lbnQgaXMgYSBkaXJlY3QgY2hpbGQgb2YgYVxuLy8gU3VzcGVuc2UgYm91bmRhcnkuXG4vL1xuLy8gU3VzcGVuc2UgYm91bmRhcmllcyBhcmUgaW1wbGVtZW50ZWQgYXMgbXVsdGlwbGUgZmliZXJzLCBidXQgdGhleVxuLy8gYXJlIGEgc2luZ2xlIGNvbmNlcHR1YWwgdW5pdC4gVGhlIGxlZ2FjeSBtb2RlIGJlaGF2aW9yIHdoZXJlIHdlXG4vLyBwcmV0ZW5kIHRoZSBzdXNwZW5kZWQgZmliZXIgY29tbWl0dGVkIGFzIGBudWxsYCB3b24ndCB3b3JrLFxuLy8gYmVjYXVzZSBpbiB0aGlzIGNhc2UgdGhlIFwic3VzcGVuZGVkXCIgZmliZXIgaXMgdGhlIGlubmVyXG4vLyBPZmZzY3JlZW4gd3JhcHBlci5cbi8vXG4vLyBCZWNhdXNlIHRoZSBjb250ZW50cyBvZiB0aGUgYm91bmRhcnkgaGF2ZW4ndCBzdGFydGVkIHJlbmRlcmluZ1xuLy8geWV0IChpLmUuIG5vdGhpbmcgaW4gdGhlIHRyZWUgaGFzIHBhcnRpYWxseSByZW5kZXJlZCkgd2UgY2FuXG4vLyBzd2l0Y2ggdG8gdGhlIHJlZ3VsYXIsIGNvbmN1cnJlbnQgbW9kZSBiZWhhdmlvcjogbWFyayB0aGVcbi8vIGJvdW5kYXJ5IHdpdGggU2hvdWxkQ2FwdHVyZSBhbmQgZW50ZXIgdGhlIHVud2luZCBwaGFzZS5cbnN1c3BlbnNlQm91bmRhcnkuZmxhZ3N8PVNob3VsZENhcHR1cmU7fWVsc2V7c3VzcGVuc2VCb3VuZGFyeS5mbGFnc3w9RGlkQ2FwdHVyZTtzb3VyY2VGaWJlci5mbGFnc3w9Rm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZTsvLyBXZSdyZSBnb2luZyB0byBjb21taXQgdGhpcyBmaWJlciBldmVuIHRob3VnaCBpdCBkaWRuJ3QgY29tcGxldGUuXG4vLyBCdXQgd2Ugc2hvdWxkbid0IGNhbGwgYW55IGxpZmVjeWNsZSBtZXRob2RzIG9yIGNhbGxiYWNrcy4gUmVtb3ZlXG4vLyBhbGwgbGlmZWN5Y2xlIGVmZmVjdCB0YWdzLlxuc291cmNlRmliZXIuZmxhZ3MmPX4oTGlmZWN5Y2xlRWZmZWN0TWFza3xJbmNvbXBsZXRlKTtpZihzb3VyY2VGaWJlci50YWc9PT1DbGFzc0NvbXBvbmVudCl7dmFyIGN1cnJlbnRTb3VyY2VGaWJlcj1zb3VyY2VGaWJlci5hbHRlcm5hdGU7aWYoY3VycmVudFNvdXJjZUZpYmVyPT09bnVsbCl7Ly8gVGhpcyBpcyBhIG5ldyBtb3VudC4gQ2hhbmdlIHRoZSB0YWcgc28gaXQncyBub3QgbWlzdGFrZW4gZm9yIGFcbi8vIGNvbXBsZXRlZCBjbGFzcyBjb21wb25lbnQuIEZvciBleGFtcGxlLCB3ZSBzaG91bGQgbm90IGNhbGxcbi8vIGNvbXBvbmVudFdpbGxVbm1vdW50IGlmIGl0IGlzIGRlbGV0ZWQuXG5zb3VyY2VGaWJlci50YWc9SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50O31lbHNley8vIFdoZW4gd2UgdHJ5IHJlbmRlcmluZyBhZ2Fpbiwgd2Ugc2hvdWxkIG5vdCByZXVzZSB0aGUgY3VycmVudCBmaWJlcixcbi8vIHNpbmNlIGl0J3Mga25vd24gdG8gYmUgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBVc2UgYSBmb3JjZSB1cGRhdGUgdG9cbi8vIHByZXZlbnQgYSBiYWlsIG91dC5cbnZhciB1cGRhdGU9Y3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLFN5bmNMYW5lKTt1cGRhdGUudGFnPUZvcmNlVXBkYXRlO2VucXVldWVVcGRhdGUoc291cmNlRmliZXIsdXBkYXRlLFN5bmNMYW5lKTt9fS8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbi8vIGluZGljYXRlIHRoYXQgaXQgc3RpbGwgaGFzIHBlbmRpbmcgd29yay5cbnNvdXJjZUZpYmVyLmxhbmVzPW1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsU3luY0xhbmUpO31yZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTt9Ly8gQ29uZmlybWVkIHRoYXQgdGhlIGJvdW5kYXJ5IGlzIGluIGEgY29uY3VycmVudCBtb2RlIHRyZWUuIENvbnRpbnVlXG4vLyB3aXRoIHRoZSBub3JtYWwgc3VzcGVuZCBwYXRoLlxuLy9cbi8vIEFmdGVyIHRoaXMgd2UnbGwgdXNlIGEgc2V0IG9mIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpc1xuLy8gcmVuZGVyIHBhc3Mgd2lsbCBydW4gdG8gY29tcGxldGlvbiBvciByZXN0YXJ0IG9yIFwic3VzcGVuZFwiIHRoZSBjb21taXQuXG4vLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbi8vXG4vLyBUaGlzIGZpcnN0IHByaW5jaXBsZSBpcyB0aGF0IGlmIHdlJ3JlIGdvaW5nIHRvIHN1c3BlbmQgd2hlbiB3ZSBjb21wbGV0ZVxuLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbi8vIG1pZ2h0IHVuc3VzcGVuZCBpdCwgYW5kIHZpY2UgdmVyc2EuIFRoZSBvbmx5IHJlYXNvbiB0byBzdXNwZW5kIGlzXG4vLyBiZWNhdXNlIHlvdSB0aGluayB5b3UgbWlnaHQgd2FudCB0byByZXN0YXJ0IGJlZm9yZSBjb21taXR0aW5nLiBIb3dldmVyLFxuLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbi8vXG4vLyBSZXN0YXJ0aW5nIHRvbyBhZ2dyZXNzaXZlbHkgaXMgYWxzbyBub3QgZ29vZCBiZWNhdXNlIGl0IHN0YXJ2ZXMgb3V0IGFueVxuLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuLy8gU3VzcGVuc2UgSGV1cmlzdGljc1xuLy9cbi8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbi8vIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LlxuLy9cbi8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuLy8gdGhvc2UgdHJpZ2dlciBhIGZhbGxiYWNrLCB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC4gV2Ugd2FudCB0byBlbnN1cmVcbi8vIHRoYXQgd2UgY2FuIHNob3cgdGhlIGluaXRpYWwgbG9hZGluZyBzdGF0ZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuLy9cbi8vIElmIHdlIGhpdCBhIFwiRGVsYXllZFwiIGNhc2UsIHN1Y2ggYXMgd2hlbiB3ZSdkIHN3aXRjaCBmcm9tIGNvbnRlbnQgYmFjayBpbnRvXG4vLyBhIGZhbGxiYWNrLCB0aGVuIHdlIHNob3VsZCBhbHdheXMgc3VzcGVuZC9yZXN0YXJ0LiBUcmFuc2l0aW9ucyBhcHBseVxuLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4vL1xuLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgYW5kIGl0IGdldHMgXCJyZXRyaWVkXCIsIGFsbG93aW5nIHVzIHRvIHNob3dcbi8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuLy8gdGhlbiB3ZSBzdXNwZW5kL3Jlc3RhcnQgZm9yIDUwMG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc2hvd2VkIGEgZmFsbGJhY2tcbi8vIGFueXdoZXJlIGluIHRoZSB0cmVlLiBUaGlzIGVmZmVjdGl2ZWx5IHRocm90dGxlcyBwcm9ncmVzc2l2ZSBsb2FkaW5nIGludG8gYVxuLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuLy8gZ2V0IHRvIHRoZSBjb21wbGV0ZWQgc3RhdGUgc2xpZ2h0bHkgZWFybGllci5cbi8vXG4vLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuLy8gMSkgXCJkZWxheWVkXCIsIDIpIFwiaW5pdGlhbCByZW5kZXJcIiwgMykgXCJyZXRyeVwiLlxuLy9cbi8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbi8vIGVuc3VyZSB0aGF0IG5ldyBpbml0aWFsIGxvYWRpbmcgc3RhdGVzIGNhbiBjb21taXQgYXMgc29vbiBhcyBwb3NzaWJsZS5cbnN1c3BlbnNlQm91bmRhcnkuZmxhZ3N8PVNob3VsZENhcHR1cmU7Ly8gVE9ETzogSSB0aGluayB3ZSBjYW4gcmVtb3ZlIHRoaXMsIHNpbmNlIHdlIG5vdyB1c2UgYERpZENhcHR1cmVgIGluXG4vLyB0aGUgYmVnaW4gcGhhc2UgdG8gcHJldmVudCBhbiBlYXJseSBiYWlsb3V0Llxuc3VzcGVuc2VCb3VuZGFyeS5sYW5lcz1yb290UmVuZGVyTGFuZXM7cmV0dXJuIHN1c3BlbnNlQm91bmRhcnk7fWZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKHJvb3QscmV0dXJuRmliZXIsc291cmNlRmliZXIsdmFsdWUscm9vdFJlbmRlckxhbmVzKXsvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuXG5zb3VyY2VGaWJlci5mbGFnc3w9SW5jb21wbGV0ZTt7aWYoaXNEZXZUb29sc1ByZXNlbnQpey8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCByZXN0b3JlIHRoZSBvcmlnaW5hbCB1cGRhdGVyc1xucmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LHJvb3RSZW5kZXJMYW5lcyk7fX1pZih2YWx1ZSE9PW51bGwmJnR5cGVvZiB2YWx1ZT09PSdvYmplY3QnJiZ0eXBlb2YgdmFsdWUudGhlbj09PSdmdW5jdGlvbicpey8vIFRoaXMgaXMgYSB3YWtlYWJsZS4gVGhlIGNvbXBvbmVudCBzdXNwZW5kZWQuXG52YXIgd2FrZWFibGU9dmFsdWU7cmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIpO3tpZihnZXRJc0h5ZHJhdGluZygpJiZzb3VyY2VGaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKXttYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpO319dmFyIHN1c3BlbnNlQm91bmRhcnk9Z2V0TmVhcmVzdFN1c3BlbnNlQm91bmRhcnlUb0NhcHR1cmUocmV0dXJuRmliZXIpO2lmKHN1c3BlbnNlQm91bmRhcnkhPT1udWxsKXtzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzJj1+Rm9yY2VDbGllbnRSZW5kZXI7bWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKHN1c3BlbnNlQm91bmRhcnkscmV0dXJuRmliZXIsc291cmNlRmliZXIscm9vdCxyb290UmVuZGVyTGFuZXMpOy8vIFdlIG9ubHkgYXR0YWNoIHBpbmcgbGlzdGVuZXJzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuaWYoc3VzcGVuc2VCb3VuZGFyeS5tb2RlJkNvbmN1cnJlbnRNb2RlKXthdHRhY2hQaW5nTGlzdGVuZXIocm9vdCx3YWtlYWJsZSxyb290UmVuZGVyTGFuZXMpO31hdHRhY2hSZXRyeUxpc3RlbmVyKHN1c3BlbnNlQm91bmRhcnkscm9vdCx3YWtlYWJsZSk7cmV0dXJuO31lbHNley8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gVW5sZXNzIHRoaXMgaXMgYSBzeW5jIHVwZGF0ZSwgdGhpcyBpcyBPSy5cbi8vIFdlIGNhbiBzdXNwZW5kIGFuZCB3YWl0IGZvciBtb3JlIGRhdGEgdG8gYXJyaXZlLlxuaWYoIWluY2x1ZGVzU3luY0xhbmUocm9vdFJlbmRlckxhbmVzKSl7Ly8gVGhpcyBpcyBub3QgYSBzeW5jIHVwZGF0ZS4gU3VzcGVuZC4gU2luY2Ugd2UncmUgbm90IGFjdGl2YXRpbmcgYVxuLy8gU3VzcGVuc2UgYm91bmRhcnksIHRoaXMgd2lsbCB1bndpbmQgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3Qgd2l0aG91dFxuLy8gcGVyZm9ybWluZyBhIHNlY29uZCBwYXNzIHRvIHJlbmRlciBhIGZhbGxiYWNrLiAoVGhpcyBpcyBhcmd1YWJseSBob3dcbi8vIHJlZnJlc2ggdHJhbnNpdGlvbnMgc2hvdWxkIHdvcmssIHRvbywgc2luY2Ugd2UncmUgbm90IGdvaW5nIHRvIGNvbW1pdFxuLy8gdGhlIGZhbGxiYWNrcyBhbnl3YXkuKVxuLy9cbi8vIFRoaXMgY2FzZSBhbHNvIGFwcGxpZXMgdG8gaW5pdGlhbCBoeWRyYXRpb24uXG5hdHRhY2hQaW5nTGlzdGVuZXIocm9vdCx3YWtlYWJsZSxyb290UmVuZGVyTGFuZXMpO3JlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtyZXR1cm47fS8vIFRoaXMgaXMgYSBzeW5jL2Rpc2NyZXRlIHVwZGF0ZS4gV2UgdHJlYXQgdGhpcyBjYXNlIGxpa2UgYW4gZXJyb3Jcbi8vIGJlY2F1c2UgZGlzY3JldGUgcmVuZGVycyBhcmUgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIGNvbXBsZXRlIHRyZWVcbi8vIHN5bmNocm9ub3VzbHkgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3kgd2l0aCBleHRlcm5hbCBzdGF0ZS5cbnZhciB1bmNhdWdodFN1c3BlbnNlRXJyb3I9bmV3IEVycm9yKCdBIGNvbXBvbmVudCBzdXNwZW5kZWQgd2hpbGUgcmVzcG9uZGluZyB0byBzeW5jaHJvbm91cyBpbnB1dC4gVGhpcyAnKyd3aWxsIGNhdXNlIHRoZSBVSSB0byBiZSByZXBsYWNlZCB3aXRoIGEgbG9hZGluZyBpbmRpY2F0b3IuIFRvICcrJ2ZpeCwgdXBkYXRlcyB0aGF0IHN1c3BlbmQgc2hvdWxkIGJlIHdyYXBwZWQgJysnd2l0aCBzdGFydFRyYW5zaXRpb24uJyk7Ly8gSWYgd2UncmUgb3V0c2lkZSBhIHRyYW5zaXRpb24sIGZhbGwgdGhyb3VnaCB0byB0aGUgcmVndWxhciBlcnJvciBwYXRoLlxuLy8gVGhlIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IHN1c3BlbnNlIGJvdW5kYXJ5LlxudmFsdWU9dW5jYXVnaHRTdXNwZW5zZUVycm9yO319ZWxzZXsvLyBUaGlzIGlzIGEgcmVndWxhciBlcnJvciwgbm90IGEgU3VzcGVuc2Ugd2FrZWFibGUuXG5pZihnZXRJc0h5ZHJhdGluZygpJiZzb3VyY2VGaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKXttYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpO3ZhciBfc3VzcGVuc2VCb3VuZGFyeT1nZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZShyZXR1cm5GaWJlcik7Ly8gSWYgdGhlIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIGh5ZHJhdGlvbiwgd2UgbWF5IGJlIGFibGUgdG8gcmVjb3ZlciBieVxuLy8gZGlzY2FyZGluZyB0aGUgZGVoeWRyYXRlZCBjb250ZW50IGFuZCBzd2l0Y2hpbmcgdG8gYSBjbGllbnQgcmVuZGVyLlxuLy8gSW5zdGVhZCBvZiBzdXJmYWNpbmcgdGhlIGVycm9yLCBmaW5kIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5XG4vLyBhbmQgcmVuZGVyIGl0IGFnYWluIHdpdGhvdXQgaHlkcmF0aW9uLlxuaWYoX3N1c3BlbnNlQm91bmRhcnkhPT1udWxsKXtpZigoX3N1c3BlbnNlQm91bmRhcnkuZmxhZ3MmU2hvdWxkQ2FwdHVyZSk9PT1Ob0ZsYWdzKXsvLyBTZXQgYSBmbGFnIHRvIGluZGljYXRlIHRoYXQgd2Ugc2hvdWxkIHRyeSByZW5kZXJpbmcgdGhlIG5vcm1hbFxuLy8gY2hpbGRyZW4gYWdhaW4sIG5vdCB0aGUgZmFsbGJhY2suXG5fc3VzcGVuc2VCb3VuZGFyeS5mbGFnc3w9Rm9yY2VDbGllbnRSZW5kZXI7fW1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShfc3VzcGVuc2VCb3VuZGFyeSxyZXR1cm5GaWJlcixzb3VyY2VGaWJlcixyb290LHJvb3RSZW5kZXJMYW5lcyk7Ly8gRXZlbiB0aG91Z2ggdGhlIHVzZXIgbWF5IG5vdCBiZSBhZmZlY3RlZCBieSB0aGlzIGVycm9yLCB3ZSBzaG91bGRcbi8vIHN0aWxsIGxvZyBpdCBzbyBpdCBjYW4gYmUgZml4ZWQuXG5xdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLHNvdXJjZUZpYmVyKSk7cmV0dXJuO319fXZhbHVlPWNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLHNvdXJjZUZpYmVyKTtyZW5kZXJEaWRFcnJvcih2YWx1ZSk7Ly8gV2UgZGlkbid0IGZpbmQgYSBib3VuZGFyeSB0aGF0IGNvdWxkIGhhbmRsZSB0aGlzIHR5cGUgb2YgZXhjZXB0aW9uLiBTdGFydFxuLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4vLyBhcyBhbiBlcnJvci5cbnZhciB3b3JrSW5Qcm9ncmVzcz1yZXR1cm5GaWJlcjtkb3tzd2l0Y2god29ya0luUHJvZ3Jlc3MudGFnKXtjYXNlIEhvc3RSb290Ont2YXIgX2Vycm9ySW5mbz12YWx1ZTt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9U2hvdWxkQ2FwdHVyZTt2YXIgbGFuZT1waWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLmxhbmVzPW1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsbGFuZSk7dmFyIHVwZGF0ZT1jcmVhdGVSb290RXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsX2Vycm9ySW5mbyxsYW5lKTtlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsdXBkYXRlKTtyZXR1cm47fWNhc2UgQ2xhc3NDb21wb25lbnQ6Ly8gQ2FwdHVyZSBhbmQgcmV0cnlcbnZhciBlcnJvckluZm89dmFsdWU7dmFyIGN0b3I9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO2lmKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKT09PU5vRmxhZ3MmJih0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I9PT0nZnVuY3Rpb24nfHxpbnN0YW5jZSE9PW51bGwmJnR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaD09PSdmdW5jdGlvbicmJiFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1TaG91bGRDYXB0dXJlO3ZhciBfbGFuZT1waWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLmxhbmVzPW1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsX2xhbmUpOy8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxudmFyIF91cGRhdGU9Y3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxlcnJvckluZm8sX2xhbmUpO2VucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxfdXBkYXRlKTtyZXR1cm47fWJyZWFrO313b3JrSW5Qcm9ncmVzcz13b3JrSW5Qcm9ncmVzcy5yZXR1cm47fXdoaWxlKHdvcmtJblByb2dyZXNzIT09bnVsbCk7fWZ1bmN0aW9uIGdldFN1c3BlbmRlZENhY2hlKCl7e3JldHVybiBudWxsO30vLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgc3VzcGVuZHMuIEl0IHJldHVybnMgdGhlXG59dmFyIFJlYWN0Q3VycmVudE93bmVyJDE9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7dmFyIGRpZFJlY2VpdmVVcGRhdGU9ZmFsc2U7dmFyIGRpZFdhcm5BYm91dEJhZENsYXNzO3ZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50O3ZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7dmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQ7dmFyIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmczt2YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wczt2YXIgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXI7dmFyIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zO3tkaWRXYXJuQWJvdXRCYWRDbGFzcz17fTtkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50PXt9O2RpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudD17fTtkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50PXt9O2RpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcz17fTtkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzPWZhbHNlO2RpZFdhcm5BYm91dFJldmVhbE9yZGVyPXt9O2RpZFdhcm5BYm91dFRhaWxPcHRpb25zPXt9O31mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyl7aWYoY3VycmVudD09PW51bGwpey8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4vLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbi8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbndvcmtJblByb2dyZXNzLmNoaWxkPW1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsbnVsbCxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO31lbHNley8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4vLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cbi8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4vLyBsZXQncyB0aHJvdyBpdCBvdXQuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZD1yZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxjdXJyZW50LmNoaWxkLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7fX1mdW5jdGlvbiBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKXsvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuLy8gd2FudCB0byByZWNvbmNpbGUgd2l0aG91dCBtYXRjaGluZyBhZ2FpbnN0IHRoZSBleGlzdGluZyBzZXQuIFRoaXMgaGFzIHRoZVxuLy8gZWZmZWN0IG9mIGFsbCBjdXJyZW50IGNoaWxkcmVuIGJlaW5nIHVubW91bnRlZDsgZXZlbiBpZiB0aGUgdHlwZSBhbmQga2V5XG4vLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuLy9cbi8vIFRvIGRvIHRoaXMsIHdlJ3JlIGdvaW5nIHRvIGdvIHRocm91Z2ggdGhlIHJlY29uY2lsZSBhbGdvcml0aG0gdHdpY2UuIEluXG4vLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4vLyBwYXNzaW5nIG51bGwuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZD1yZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxjdXJyZW50LmNoaWxkLG51bGwscmVuZGVyTGFuZXMpOy8vIEluIHRoZSBzZWNvbmQgcGFzcywgd2UgbW91bnQgdGhlIG5ldyBjaGlsZHJlbi4gVGhlIHRyaWNrIGhlcmUgaXMgdGhhdCB3ZVxuLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4vLyB0aGUgZWZmZWN0IG9mIHJlbW91bnRpbmcgYWxsIGNoaWxkcmVuIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVpclxuLy8gaWRlbnRpdGllcyBtYXRjaC5cbndvcmtJblByb2dyZXNzLmNoaWxkPXJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLG51bGwsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTt9ZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMscmVuZGVyTGFuZXMpey8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4vLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxue2lmKHdvcmtJblByb2dyZXNzLnR5cGUhPT13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSl7Ly8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbi8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbnZhciBpbm5lclByb3BUeXBlcz1Db21wb25lbnQucHJvcFR5cGVzO2lmKGlubmVyUHJvcFR5cGVzKXtjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcyxuZXh0UHJvcHMsLy8gUmVzb2x2ZWQgcHJvcHNcbidwcm9wJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7fX19dmFyIHJlbmRlcj1Db21wb25lbnQucmVuZGVyO3ZhciByZWY9d29ya0luUHJvZ3Jlc3MucmVmOy8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxudmFyIG5leHRDaGlsZHJlbjt2YXIgaGFzSWQ7cHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO3ttYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7fXtSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQ9d29ya0luUHJvZ3Jlc3M7c2V0SXNSZW5kZXJpbmcodHJ1ZSk7bmV4dENoaWxkcmVuPXJlbmRlcldpdGhIb29rcyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlcixuZXh0UHJvcHMscmVmLHJlbmRlckxhbmVzKTtoYXNJZD1jaGVja0RpZFJlbmRlcklkSG9vaygpO2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e25leHRDaGlsZHJlbj1yZW5kZXJXaXRoSG9va3MoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXIsbmV4dFByb3BzLHJlZixyZW5kZXJMYW5lcyk7aGFzSWQ9Y2hlY2tEaWRSZW5kZXJJZEhvb2soKTt9ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX1zZXRJc1JlbmRlcmluZyhmYWxzZSk7fXttYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO31pZihjdXJyZW50IT09bnVsbCYmIWRpZFJlY2VpdmVVcGRhdGUpe2JhaWxvdXRIb29rcyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtyZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9aWYoZ2V0SXNIeWRyYXRpbmcoKSYmaGFzSWQpe3B1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO30vLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UGVyZm9ybWVkV29yaztyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyl7aWYoY3VycmVudD09PW51bGwpe3ZhciB0eXBlPUNvbXBvbmVudC50eXBlO2lmKGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkmJkNvbXBvbmVudC5jb21wYXJlPT09bnVsbCYmLy8gU2ltcGxlTWVtb0NvbXBvbmVudCBjb2RlcGF0aCBkb2Vzbid0IHJlc29sdmUgb3V0ZXIgcHJvcHMgZWl0aGVyLlxuQ29tcG9uZW50LmRlZmF1bHRQcm9wcz09PXVuZGVmaW5lZCl7dmFyIHJlc29sdmVkVHlwZT10eXBlO3tyZXNvbHZlZFR5cGU9cmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO30vLyBJZiB0aGlzIGlzIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IHdpdGhvdXQgZGVmYXVsdCBwcm9wcyxcbi8vIGFuZCB3aXRoIG9ubHkgdGhlIGRlZmF1bHQgc2hhbGxvdyBjb21wYXJpc29uLCB3ZSB1cGdyYWRlIGl0XG4vLyB0byBhIFNpbXBsZU1lbW9Db21wb25lbnQgdG8gYWxsb3cgZmFzdCBwYXRoIHVwZGF0ZXMuXG53b3JrSW5Qcm9ncmVzcy50YWc9U2ltcGxlTWVtb0NvbXBvbmVudDt3b3JrSW5Qcm9ncmVzcy50eXBlPXJlc29sdmVkVHlwZTt7dmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLHR5cGUpO31yZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlc29sdmVkVHlwZSxuZXh0UHJvcHMscmVuZGVyTGFuZXMpO317dmFyIGlubmVyUHJvcFR5cGVzPXR5cGUucHJvcFR5cGVzO2lmKGlubmVyUHJvcFR5cGVzKXsvLyBJbm5lciBtZW1vIGNvbXBvbmVudCBwcm9wcyBhcmVuJ3QgY3VycmVudGx5IHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50LlxuLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbmNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCBwcm9wc1xuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSk7fX12YXIgY2hpbGQ9Y3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKENvbXBvbmVudC50eXBlLG51bGwsbmV4dFByb3BzLHdvcmtJblByb2dyZXNzLHdvcmtJblByb2dyZXNzLm1vZGUscmVuZGVyTGFuZXMpO2NoaWxkLnJlZj13b3JrSW5Qcm9ncmVzcy5yZWY7Y2hpbGQucmV0dXJuPXdvcmtJblByb2dyZXNzO3dvcmtJblByb2dyZXNzLmNoaWxkPWNoaWxkO3JldHVybiBjaGlsZDt9e3ZhciBfdHlwZT1Db21wb25lbnQudHlwZTt2YXIgX2lubmVyUHJvcFR5cGVzPV90eXBlLnByb3BUeXBlcztpZihfaW5uZXJQcm9wVHlwZXMpey8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4vLyBXZSBjb3VsZCBtb3ZlIGl0IHRoZXJlLCBidXQgd2UnZCBzdGlsbCBuZWVkIHRoaXMgZm9yIGxhenkgY29kZSBwYXRoLlxuY2hlY2tQcm9wVHlwZXMoX2lubmVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCBwcm9wc1xuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShfdHlwZSkpO319dmFyIGN1cnJlbnRDaGlsZD1jdXJyZW50LmNoaWxkOy8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0PWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQscmVuZGVyTGFuZXMpO2lmKCFoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQpey8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4vLyB1bmxpa2UgY3VycmVudC5tZW1vaXplZFByb3BzIHdoaWNoIHdpbGwgYmUgdGhlIHVucmVzb2x2ZWQgb25lcy5cbnZhciBwcmV2UHJvcHM9Y3VycmVudENoaWxkLm1lbW9pemVkUHJvcHM7Ly8gRGVmYXVsdCB0byBzaGFsbG93IGNvbXBhcmlzb25cbnZhciBjb21wYXJlPUNvbXBvbmVudC5jb21wYXJlO2NvbXBhcmU9Y29tcGFyZSE9PW51bGw/Y29tcGFyZTpzaGFsbG93RXF1YWw7aWYoY29tcGFyZShwcmV2UHJvcHMsbmV4dFByb3BzKSYmY3VycmVudC5yZWY9PT13b3JrSW5Qcm9ncmVzcy5yZWYpe3JldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO319Ly8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBlcmZvcm1lZFdvcms7dmFyIG5ld0NoaWxkPWNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCxuZXh0UHJvcHMpO25ld0NoaWxkLnJlZj13b3JrSW5Qcm9ncmVzcy5yZWY7bmV3Q2hpbGQucmV0dXJuPXdvcmtJblByb2dyZXNzO3dvcmtJblByb2dyZXNzLmNoaWxkPW5ld0NoaWxkO3JldHVybiBuZXdDaGlsZDt9ZnVuY3Rpb24gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMscmVuZGVyTGFuZXMpey8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4vLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG4vLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG57aWYod29ya0luUHJvZ3Jlc3MudHlwZSE9PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKXsvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxudmFyIG91dGVyTWVtb1R5cGU9d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7aWYob3V0ZXJNZW1vVHlwZS4kJHR5cGVvZj09PVJFQUNUX0xBWllfVFlQRSl7Ly8gV2Ugd2FybiB3aGVuIHlvdSBkZWZpbmUgcHJvcFR5cGVzIG9uIGxhenkoKVxuLy8gc28gbGV0J3MganVzdCBza2lwIG92ZXIgaXQgdG8gZmluZCBtZW1vKCkgb3V0ZXIgd3JhcHBlci5cbi8vIElubmVyIHByb3BzIGZvciBtZW1vIGFyZSB2YWxpZGF0ZWQgbGF0ZXIuXG52YXIgbGF6eUNvbXBvbmVudD1vdXRlck1lbW9UeXBlO3ZhciBwYXlsb2FkPWxhenlDb21wb25lbnQuX3BheWxvYWQ7dmFyIGluaXQ9bGF6eUNvbXBvbmVudC5faW5pdDt0cnl7b3V0ZXJNZW1vVHlwZT1pbml0KHBheWxvYWQpO31jYXRjaCh4KXtvdXRlck1lbW9UeXBlPW51bGw7fS8vIElubmVyIHByb3BUeXBlcyB3aWxsIGJlIHZhbGlkYXRlZCBpbiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHBhdGguXG52YXIgb3V0ZXJQcm9wVHlwZXM9b3V0ZXJNZW1vVHlwZSYmb3V0ZXJNZW1vVHlwZS5wcm9wVHlwZXM7aWYob3V0ZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCAoU2ltcGxlTWVtb0NvbXBvbmVudCBoYXMgbm8gZGVmYXVsdFByb3BzKVxuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvdXRlck1lbW9UeXBlKSk7fX19fWlmKGN1cnJlbnQhPT1udWxsKXt2YXIgcHJldlByb3BzPWN1cnJlbnQubWVtb2l6ZWRQcm9wcztpZihzaGFsbG93RXF1YWwocHJldlByb3BzLG5leHRQcm9wcykmJmN1cnJlbnQucmVmPT09d29ya0luUHJvZ3Jlc3MucmVmJiYvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG53b3JrSW5Qcm9ncmVzcy50eXBlPT09Y3VycmVudC50eXBlKXtkaWRSZWNlaXZlVXBkYXRlPWZhbHNlOy8vIFRoZSBwcm9wcyBhcmUgc2hhbGxvd2x5IGVxdWFsLiBSZXVzZSB0aGUgcHJldmlvdXMgcHJvcHMgb2JqZWN0LCBsaWtlIHdlXG4vLyB3b3VsZCBkdXJpbmcgYSBub3JtYWwgZmliZXIgYmFpbG91dC5cbi8vXG4vLyBXZSBkb24ndCBoYXZlIHN0cm9uZyBndWFyYW50ZWVzIHRoYXQgdGhlIHByb3BzIG9iamVjdCBpcyByZWZlcmVudGlhbGx5XG4vLyBlcXVhbCBkdXJpbmcgdXBkYXRlcyB3aGVyZSB3ZSBjYW4ndCBiYWlsIG91dCBhbnl3YXkg4oCUIGxpa2UgaWYgdGhlIHByb3BzXG4vLyBhcmUgc2hhbGxvd2x5IGVxdWFsLCBidXQgdGhlcmUncyBhIGxvY2FsIHN0YXRlIG9yIGNvbnRleHQgdXBkYXRlIGluIHRoZVxuLy8gc2FtZSBiYXRjaC5cbi8vXG4vLyBIb3dldmVyLCBhcyBhIHByaW5jaXBsZSwgd2Ugc2hvdWxkIGFpbSB0byBtYWtlIHRoZSBiZWhhdmlvciBjb25zaXN0ZW50XG4vLyBhY3Jvc3MgZGlmZmVyZW50IHdheXMgb2YgbWVtb2l6aW5nIGEgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgUmVhY3QubWVtb1xuLy8gaGFzIGEgZGlmZmVyZW50IGludGVybmFsIEZpYmVyIGxheW91dCBpZiB5b3UgcGFzcyBhIG5vcm1hbCBmdW5jdGlvblxuLy8gY29tcG9uZW50IChTaW1wbGVNZW1vQ29tcG9uZW50KSB2ZXJzdXMgaWYgeW91IHBhc3MgYSBkaWZmZXJlbnQgdHlwZVxuLy8gbGlrZSBmb3J3YXJkUmVmIChNZW1vQ29tcG9uZW50KS4gQnV0IHRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuLy8gV3JhcHBpbmcgYSBjb21wb25lbnQgaW4gZm9yd2FyZFJlZiAob3IgUmVhY3QubGF6eSwgZXRjKSBzaG91bGRuJ3Rcbi8vIGFmZmVjdCB3aGV0aGVyIHRoZSBwcm9wcyBvYmplY3QgaXMgcmV1c2VkIGR1cmluZyBhIGJhaWxvdXQuXG53b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM9bmV4dFByb3BzPXByZXZQcm9wcztpZighY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCxyZW5kZXJMYW5lcykpey8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbi8vIGFib3V0IHRvIGJhaWwgb3V0LCBidXQgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbGFuZXMgdGhhdCB3ZXJlbid0XG4vLyBpbmNsdWRlZCBpbiB0aGUgY3VycmVudCByZW5kZXIuIFVzdWFsbHksIHRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGVcbi8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtdWxhdGVkIGR1cmluZyB0aGUgZXZhbHVhdGlvbiBvZiB0aGVcbi8vIGNvbXBvbmVudCAoaS5lLiB3aGVuIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZSkuIEJ1dCBzaW5jZSBzaW5jZVxuLy8gd2UncmUgYmFpbGluZyBvdXQgZWFybHkgKndpdGhvdXQqIGV2YWx1YXRpbmcgdGhlIGNvbXBvbmVudCwgd2UgbmVlZFxuLy8gdG8gYWNjb3VudCBmb3IgaXQgaGVyZSwgdG9vLiBSZXNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgZmliZXIuXG4vLyBOT1RFOiBUaGlzIG9ubHkgYXBwbGllcyB0byBTaW1wbGVNZW1vQ29tcG9uZW50LCBub3QgTWVtb0NvbXBvbmVudCxcbi8vIGJlY2F1c2UgYSBNZW1vQ29tcG9uZW50IGZpYmVyIGRvZXMgbm90IGhhdmUgaG9va3Mgb3IgYW4gdXBkYXRlIHF1ZXVlO1xuLy8gcmF0aGVyLCBpdCB3cmFwcyBhcm91bmQgYW4gaW5uZXIgY29tcG9uZW50LCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuLy8gY29udGFpbnMgaG9va3MuXG4vLyBUT0RPOiBNb3ZlIHRoZSByZXNldCBhdCBpbiBiZWdpbldvcmsgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBzbyB0aGF0XG4vLyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz1jdXJyZW50LmxhbmVzO3JldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO31lbHNlIGlmKChjdXJyZW50LmZsYWdzJkZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpIT09Tm9GbGFncyl7Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbmRpZFJlY2VpdmVVcGRhdGU9dHJ1ZTt9fX1yZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKTt9ZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3ZhciBuZXh0UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBuZXh0Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBwcmV2U3RhdGU9Y3VycmVudCE9PW51bGw/Y3VycmVudC5tZW1vaXplZFN0YXRlOm51bGw7aWYobmV4dFByb3BzLm1vZGU9PT0naGlkZGVuJ3x8ZW5hYmxlTGVnYWN5SGlkZGVuKXsvLyBSZW5kZXJpbmcgYSBoaWRkZW4gdHJlZS5cbmlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7Ly8gSW4gbGVnYWN5IHN5bmMgbW9kZSwgZG9uJ3QgZGVmZXIgdGhlIHN1YnRyZWUuIFJlbmRlciBpdCBub3cuXG4vLyBUT0RPOiBDb25zaWRlciBob3cgT2Zmc2NyZWVuIHNob3VsZCB3b3JrIHdpdGggdHJhbnNpdGlvbnMgaW4gdGhlIGZ1dHVyZVxudmFyIG5leHRTdGF0ZT17YmFzZUxhbmVzOk5vTGFuZXMsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH07d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1uZXh0U3RhdGU7cHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9ZWxzZSBpZighaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcyxPZmZzY3JlZW5MYW5lKSl7dmFyIHNwYXduZWRDYWNoZVBvb2w9bnVsbDsvLyBXZSdyZSBoaWRkZW4sIGFuZCB3ZSdyZSBub3QgcmVuZGVyaW5nIGF0IE9mZnNjcmVlbi4gV2Ugd2lsbCBiYWlsIG91dFxuLy8gYW5kIHJlc3VtZSB0aGlzIHRyZWUgbGF0ZXIuXG52YXIgbmV4dEJhc2VMYW5lcztpZihwcmV2U3RhdGUhPT1udWxsKXt2YXIgcHJldkJhc2VMYW5lcz1wcmV2U3RhdGUuYmFzZUxhbmVzO25leHRCYXNlTGFuZXM9bWVyZ2VMYW5lcyhwcmV2QmFzZUxhbmVzLHJlbmRlckxhbmVzKTt9ZWxzZXtuZXh0QmFzZUxhbmVzPXJlbmRlckxhbmVzO30vLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cbndvcmtJblByb2dyZXNzLmxhbmVzPXdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXM9bGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7dmFyIF9uZXh0U3RhdGU9e2Jhc2VMYW5lczpuZXh0QmFzZUxhbmVzLGNhY2hlUG9vbDpzcGF3bmVkQ2FjaGVQb29sLHRyYW5zaXRpb25zOm51bGx9O3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9X25leHRTdGF0ZTt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1udWxsOy8vIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxucHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLG5leHRCYXNlTGFuZXMpO3JldHVybiBudWxsO31lbHNley8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIuIFRoZSBzdXJyb3VuZGluZyB2aXNpYmxlIGNvbnRlbnQgaGFzIGFscmVhZHlcbi8vIGNvbW1pdHRlZC4gTm93IHdlIHJlc3VtZSByZW5kZXJpbmcgdGhlIGhpZGRlbiB0cmVlLlxuLy8gUmVuZGVyaW5nIGF0IG9mZnNjcmVlbiwgc28gd2UgY2FuIGNsZWFyIHRoZSBiYXNlIGxhbmVzLlxudmFyIF9uZXh0U3RhdGUyPXtiYXNlTGFuZXM6Tm9MYW5lcyxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpudWxsfTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPV9uZXh0U3RhdGUyOy8vIFB1c2ggdGhlIGxhbmVzIHRoYXQgd2VyZSBza2lwcGVkIHdoZW4gd2UgYmFpbGVkIG91dC5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXM9cHJldlN0YXRlIT09bnVsbD9wcmV2U3RhdGUuYmFzZUxhbmVzOnJlbmRlckxhbmVzO3B1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyxzdWJ0cmVlUmVuZGVyTGFuZXMpO319ZWxzZXsvLyBSZW5kZXJpbmcgYSB2aXNpYmxlIHRyZWUuXG52YXIgX3N1YnRyZWVSZW5kZXJMYW5lcztpZihwcmV2U3RhdGUhPT1udWxsKXsvLyBXZSdyZSBnb2luZyBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlLlxuX3N1YnRyZWVSZW5kZXJMYW5lcz1tZXJnZUxhbmVzKHByZXZTdGF0ZS5iYXNlTGFuZXMscmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDt9ZWxzZXsvLyBXZSB3ZXJlbid0IHByZXZpb3VzbHkgaGlkZGVuLCBhbmQgd2Ugc3RpbGwgYXJlbid0LCBzbyB0aGVyZSdzIG5vdGhpbmdcbi8vIHNwZWNpYWwgdG8gZG8uIE5lZWQgdG8gcHVzaCB0byB0aGUgc3RhY2sgcmVnYXJkbGVzcywgdGhvdWdoLCB0byBhdm9pZFxuLy8gYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5fc3VidHJlZVJlbmRlckxhbmVzPXJlbmRlckxhbmVzO31wdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsX3N1YnRyZWVSZW5kZXJMYW5lcyk7fXJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fS8vIE5vdGU6IFRoZXNlIGhhcHBlbiB0byBoYXZlIGlkZW50aWNhbCBiZWdpbiBwaGFzZXMsIGZvciBub3cuIFdlIHNob3VsZG4ndCBob2xkXG5mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt2YXIgbmV4dENoaWxkcmVuPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3ZhciBuZXh0Q2hpbGRyZW49d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3t3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO3svLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4vLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxudmFyIHN0YXRlTm9kZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7c3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uPTA7c3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbj0wO319dmFyIG5leHRQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIG5leHRDaGlsZHJlbj1uZXh0UHJvcHMuY2hpbGRyZW47cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3JldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LHdvcmtJblByb2dyZXNzKXt2YXIgcmVmPXdvcmtJblByb2dyZXNzLnJlZjtpZihjdXJyZW50PT09bnVsbCYmcmVmIT09bnVsbHx8Y3VycmVudCE9PW51bGwmJmN1cnJlbnQucmVmIT09cmVmKXsvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbndvcmtJblByb2dyZXNzLmZsYWdzfD1SZWY7e3dvcmtJblByb2dyZXNzLmZsYWdzfD1SZWZTdGF0aWM7fX19ZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKXt7aWYod29ya0luUHJvZ3Jlc3MudHlwZSE9PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKXsvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxudmFyIGlubmVyUHJvcFR5cGVzPUNvbXBvbmVudC5wcm9wVHlwZXM7aWYoaW5uZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCBwcm9wc1xuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpKTt9fX12YXIgY29udGV4dDt7dmFyIHVubWFza2VkQ29udGV4dD1nZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHRydWUpO2NvbnRleHQ9Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQpO312YXIgbmV4dENoaWxkcmVuO3ZhciBoYXNJZDtwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7e21hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTt9e1JlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudD13b3JrSW5Qcm9ncmVzcztzZXRJc1JlbmRlcmluZyh0cnVlKTtuZXh0Q2hpbGRyZW49cmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxjb250ZXh0LHJlbmRlckxhbmVzKTtoYXNJZD1jaGVja0RpZFJlbmRlcklkSG9vaygpO2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e25leHRDaGlsZHJlbj1yZW5kZXJXaXRoSG9va3MoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLGNvbnRleHQscmVuZGVyTGFuZXMpO2hhc0lkPWNoZWNrRGlkUmVuZGVySWRIb29rKCk7fWZpbmFsbHl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO319c2V0SXNSZW5kZXJpbmcoZmFsc2UpO317bWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTt9aWYoY3VycmVudCE9PW51bGwmJiFkaWRSZWNlaXZlVXBkYXRlKXtiYWlsb3V0SG9va3MoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7cmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fWlmKGdldElzSHlkcmF0aW5nKCkmJmhhc0lkKXtwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTt9Ly8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBlcmZvcm1lZFdvcms7cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3JldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKXt7Ly8gVGhpcyBpcyB1c2VkIGJ5IERldlRvb2xzIHRvIGZvcmNlIGEgYm91bmRhcnkgdG8gZXJyb3IuXG5zd2l0Y2goc2hvdWxkRXJyb3Iod29ya0luUHJvZ3Jlc3MpKXtjYXNlIGZhbHNlOnt2YXIgX2luc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTt2YXIgY3Rvcj13b3JrSW5Qcm9ncmVzcy50eXBlOy8vIFRPRE8gVGhpcyB3YXkgb2YgcmVzZXR0aW5nIHRoZSBlcnJvciBib3VuZGFyeSBzdGF0ZSBpcyBhIGhhY2suXG4vLyBJcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gZG8gdGhpcz9cbnZhciB0ZW1wSW5zdGFuY2U9bmV3IGN0b3Iod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxfaW5zdGFuY2UuY29udGV4dCk7dmFyIHN0YXRlPXRlbXBJbnN0YW5jZS5zdGF0ZTtfaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoX2luc3RhbmNlLHN0YXRlLG51bGwpO2JyZWFrO31jYXNlIHRydWU6e3dvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO3dvcmtJblByb2dyZXNzLmZsYWdzfD1TaG91bGRDYXB0dXJlOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG52YXIgZXJyb3IkMT1uZXcgRXJyb3IoJ1NpbXVsYXRlZCBlcnJvciBjb21pbmcgZnJvbSBEZXZUb29scycpO3ZhciBsYW5lPXBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1tZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLGxhbmUpOy8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxudmFyIHVwZGF0ZT1jcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yJDEsd29ya0luUHJvZ3Jlc3MpLGxhbmUpO2VucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyx1cGRhdGUpO2JyZWFrO319aWYod29ya0luUHJvZ3Jlc3MudHlwZSE9PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKXsvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxudmFyIGlubmVyUHJvcFR5cGVzPUNvbXBvbmVudC5wcm9wVHlwZXM7aWYoaW5uZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCBwcm9wc1xuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpKTt9fX0vLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxudmFyIGhhc0NvbnRleHQ7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7aGFzQ29udGV4dD10cnVlO3B1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO31lbHNle2hhc0NvbnRleHQ9ZmFsc2U7fXByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt2YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3ZhciBzaG91bGRVcGRhdGU7aWYoaW5zdGFuY2U9PT1udWxsKXtyZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpOy8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzKTttb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyk7c2hvdWxkVXBkYXRlPXRydWU7fWVsc2UgaWYoY3VycmVudD09PW51bGwpey8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuc2hvdWxkVXBkYXRlPXJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKTt9ZWxzZXtzaG91bGRVcGRhdGU9dXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMscmVuZGVyTGFuZXMpO312YXIgbmV4dFVuaXRPZldvcms9ZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsc2hvdWxkVXBkYXRlLGhhc0NvbnRleHQscmVuZGVyTGFuZXMpO3t2YXIgaW5zdD13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aWYoc2hvdWxkVXBkYXRlJiZpbnN0LnByb3BzIT09bmV4dFByb3BzKXtpZighZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyl7ZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnKydUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcyl8fCdhIGNvbXBvbmVudCcpO31kaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzPXRydWU7fX1yZXR1cm4gbmV4dFVuaXRPZldvcms7fWZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHNob3VsZFVwZGF0ZSxoYXNDb250ZXh0LHJlbmRlckxhbmVzKXsvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxubWFya1JlZihjdXJyZW50LHdvcmtJblByb2dyZXNzKTt2YXIgZGlkQ2FwdHVyZUVycm9yPSh3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKSE9PU5vRmxhZ3M7aWYoIXNob3VsZFVwZGF0ZSYmIWRpZENhcHR1cmVFcnJvcil7Ly8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG5pZihoYXNDb250ZXh0KXtpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxmYWxzZSk7fXJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO312YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOy8vIFJlcmVuZGVyXG5SZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQ9d29ya0luUHJvZ3Jlc3M7dmFyIG5leHRDaGlsZHJlbjtpZihkaWRDYXB0dXJlRXJyb3ImJnR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIT09J2Z1bmN0aW9uJyl7Ly8gSWYgd2UgY2FwdHVyZWQgYW4gZXJyb3IsIGJ1dCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXMgbm90IGRlZmluZWQsXG4vLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4vLyByZS1yZW5kZXIgYSBmYWxsYmFjay4gVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgd2UgbWlncmF0ZSBldmVyeW9uZSB0b1xuLy8gdGhlIG5ldyBBUEkuXG4vLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG5uZXh0Q2hpbGRyZW49bnVsbDt7c3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTt9fWVsc2V7e21hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTt9e3NldElzUmVuZGVyaW5nKHRydWUpO25leHRDaGlsZHJlbj1pbnN0YW5jZS5yZW5kZXIoKTtpZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO3RyeXtpbnN0YW5jZS5yZW5kZXIoKTt9ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX1zZXRJc1JlbmRlcmluZyhmYWxzZSk7fXttYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO319Ly8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBlcmZvcm1lZFdvcms7aWYoY3VycmVudCE9PW51bGwmJmRpZENhcHR1cmVFcnJvcil7Ly8gSWYgd2UncmUgcmVjb3ZlcmluZyBmcm9tIGFuIGVycm9yLCByZWNvbmNpbGUgd2l0aG91dCByZXVzaW5nIGFueSBvZlxuLy8gdGhlIGV4aXN0aW5nIGNoaWxkcmVuLiBDb25jZXB0dWFsbHksIHRoZSBub3JtYWwgY2hpbGRyZW4gYW5kIHRoZSBjaGlsZHJlblxuLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4vLyBub3JtYWwgY2hpbGRyZW4gZXZlbiBpZiB0aGVpciBpZGVudGl0aWVzIG1hdGNoLlxuZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7fWVsc2V7cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO30vLyBNZW1vaXplIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbi8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxud29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1pbnN0YW5jZS5zdGF0ZTsvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbmlmKGhhc0NvbnRleHQpe2ludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHRydWUpO31yZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3Mpe3ZhciByb290PXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtpZihyb290LnBlbmRpbmdDb250ZXh0KXtwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLHJvb3QucGVuZGluZ0NvbnRleHQscm9vdC5wZW5kaW5nQ29udGV4dCE9PXJvb3QuY29udGV4dCk7fWVsc2UgaWYocm9vdC5jb250ZXh0KXsvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxucHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyxyb290LmNvbnRleHQsZmFsc2UpO31wdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyxyb290LmNvbnRhaW5lckluZm8pO31mdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXtwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtpZihjdXJyZW50PT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7fXZhciBuZXh0UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBwcmV2U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTt2YXIgcHJldkNoaWxkcmVuPXByZXZTdGF0ZS5lbGVtZW50O2Nsb25lVXBkYXRlUXVldWUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7cHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLG5leHRQcm9wcyxudWxsLHJlbmRlckxhbmVzKTt2YXIgbmV4dFN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7dmFyIHJvb3Q9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOy8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cbnZhciBuZXh0Q2hpbGRyZW49bmV4dFN0YXRlLmVsZW1lbnQ7aWYocHJldlN0YXRlLmlzRGVoeWRyYXRlZCl7Ly8gVGhpcyBpcyBhIGh5ZHJhdGlvbiByb290IHdob3NlIHNoZWxsIGhhcyBub3QgeWV0IGh5ZHJhdGVkLiBXZSBzaG91bGRcbi8vIGF0dGVtcHQgdG8gaHlkcmF0ZS5cbi8vIEZsaXAgaXNEZWh5ZHJhdGVkIHRvIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgd2hlbiB0aGlzIHJlbmRlclxuLy8gZmluaXNoZXMsIHRoZSByb290IHdpbGwgbm8gbG9uZ2VyIGJlIGRlaHlkcmF0ZWQuXG52YXIgb3ZlcnJpZGVTdGF0ZT17ZWxlbWVudDpuZXh0Q2hpbGRyZW4saXNEZWh5ZHJhdGVkOmZhbHNlLGNhY2hlOm5leHRTdGF0ZS5jYWNoZSxwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOm5leHRTdGF0ZS5wZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzLHRyYW5zaXRpb25zOm5leHRTdGF0ZS50cmFuc2l0aW9uc307dmFyIHVwZGF0ZVF1ZXVlPXdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOy8vIGBiYXNlU3RhdGVgIGNhbiBhbHdheXMgYmUgdGhlIGxhc3Qgc3RhdGUgYmVjYXVzZSB0aGUgcm9vdCBkb2Vzbid0XG4vLyBoYXZlIHJlZHVjZXIgZnVuY3Rpb25zIHNvIGl0IGRvZXNuJ3QgbmVlZCByZWJhc2luZy5cbnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1vdmVycmlkZVN0YXRlO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9b3ZlcnJpZGVTdGF0ZTtpZih3b3JrSW5Qcm9ncmVzcy5mbGFncyZGb3JjZUNsaWVudFJlbmRlcil7Ly8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGEgcHJldmlvdXMgYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBzaGVsbCwgc28gd2Vcbi8vIGZvcmNlZCBhIGNsaWVudCByZW5kZXIuXG52YXIgcmVjb3ZlcmFibGVFcnJvcj1jcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcuIEJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbmVkIG91dHNpZGUgJysnb2YgYSBTdXNwZW5zZSBib3VuZGFyeSwgdGhlIGVudGlyZSByb290IHdpbGwgc3dpdGNoIHRvICcrJ2NsaWVudCByZW5kZXJpbmcuJyksd29ya0luUHJvZ3Jlc3MpO3JldHVybiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyxyZWNvdmVyYWJsZUVycm9yKTt9ZWxzZSBpZihuZXh0Q2hpbGRyZW4hPT1wcmV2Q2hpbGRyZW4pe3ZhciBfcmVjb3ZlcmFibGVFcnJvcj1jcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihuZXcgRXJyb3IoJ1RoaXMgcm9vdCByZWNlaXZlZCBhbiBlYXJseSB1cGRhdGUsIGJlZm9yZSBhbnl0aGluZyB3YXMgYWJsZSAnKydoeWRyYXRlLiBTd2l0Y2hlZCB0aGUgZW50aXJlIHJvb3QgdG8gY2xpZW50IHJlbmRlcmluZy4nKSx3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzLF9yZWNvdmVyYWJsZUVycm9yKTt9ZWxzZXsvLyBUaGUgb3V0ZXJtb3N0IHNoZWxsIGhhcyBub3QgaHlkcmF0ZWQgeWV0LiBTdGFydCBoeWRyYXRpbmcuXG5lbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTt2YXIgY2hpbGQ9bW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxudWxsLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9Y2hpbGQ7dmFyIG5vZGU9Y2hpbGQ7d2hpbGUobm9kZSl7Ly8gTWFyayBlYWNoIGNoaWxkIGFzIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGZhc3QgcGF0aCB0byBrbm93IHdoZXRoZXIgdGhpc1xuLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4vLyBDb25jZXB0dWFsbHkgdGhpcyBpcyBzaW1pbGFyIHRvIFBsYWNlbWVudCBpbiB0aGF0IGEgbmV3IHN1YnRyZWUgaXNcbi8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG5ub2RlLmZsYWdzPW5vZGUuZmxhZ3MmflBsYWNlbWVudHxIeWRyYXRpbmc7bm9kZT1ub2RlLnNpYmxpbmc7fX19ZWxzZXsvLyBSb290IGlzIG5vdCBkZWh5ZHJhdGVkLiBFaXRoZXIgdGhpcyBpcyBhIGNsaWVudC1vbmx5IHJvb3QsIG9yIGl0XG4vLyBhbHJlYWR5IGh5ZHJhdGVkLlxucmVzZXRIeWRyYXRpb25TdGF0ZSgpO2lmKG5leHRDaGlsZHJlbj09PXByZXZDaGlsZHJlbil7cmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fXJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTt9cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyxyZWNvdmVyYWJsZUVycm9yKXsvLyBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cbnJlc2V0SHlkcmF0aW9uU3RhdGUoKTtxdWV1ZUh5ZHJhdGlvbkVycm9yKHJlY292ZXJhYmxlRXJyb3IpO3dvcmtJblByb2dyZXNzLmZsYWdzfD1Gb3JjZUNsaWVudFJlbmRlcjtyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3B1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7aWYoY3VycmVudD09PW51bGwpe3RyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTt9dmFyIHR5cGU9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgbmV4dFByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgcHJldlByb3BzPWN1cnJlbnQhPT1udWxsP2N1cnJlbnQubWVtb2l6ZWRQcm9wczpudWxsO3ZhciBuZXh0Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBpc0RpcmVjdFRleHRDaGlsZD1zaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLG5leHRQcm9wcyk7aWYoaXNEaXJlY3RUZXh0Q2hpbGQpey8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4vLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4vLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXMgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbm5leHRDaGlsZHJlbj1udWxsO31lbHNlIGlmKHByZXZQcm9wcyE9PW51bGwmJnNob3VsZFNldFRleHRDb250ZW50KHR5cGUscHJldlByb3BzKSl7Ly8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbi8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9Q29udGVudFJlc2V0O31tYXJrUmVmKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Mpe2lmKGN1cnJlbnQ9PT1udWxsKXt0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7fS8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG5yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gbW91bnRMYXp5Q29tcG9uZW50KF9jdXJyZW50LHdvcmtJblByb2dyZXNzLGVsZW1lbnRUeXBlLHJlbmRlckxhbmVzKXtyZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKF9jdXJyZW50LHdvcmtJblByb2dyZXNzKTt2YXIgcHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBsYXp5Q29tcG9uZW50PWVsZW1lbnRUeXBlO3ZhciBwYXlsb2FkPWxhenlDb21wb25lbnQuX3BheWxvYWQ7dmFyIGluaXQ9bGF6eUNvbXBvbmVudC5faW5pdDt2YXIgQ29tcG9uZW50PWluaXQocGF5bG9hZCk7Ly8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG53b3JrSW5Qcm9ncmVzcy50eXBlPUNvbXBvbmVudDt2YXIgcmVzb2x2ZWRUYWc9d29ya0luUHJvZ3Jlc3MudGFnPXJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7dmFyIHJlc29sdmVkUHJvcHM9cmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQscHJvcHMpO3ZhciBjaGlsZDtzd2l0Y2gocmVzb2x2ZWRUYWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6e3t2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50KTt3b3JrSW5Qcm9ncmVzcy50eXBlPUNvbXBvbmVudD1yZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTt9Y2hpbGQ9dXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscmVzb2x2ZWRQcm9wcyxyZW5kZXJMYW5lcyk7cmV0dXJuIGNoaWxkO31jYXNlIENsYXNzQ29tcG9uZW50Ont7d29ya0luUHJvZ3Jlc3MudHlwZT1Db21wb25lbnQ9cmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7fWNoaWxkPXVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHJlc29sdmVkUHJvcHMscmVuZGVyTGFuZXMpO3JldHVybiBjaGlsZDt9Y2FzZSBGb3J3YXJkUmVmOnt7d29ya0luUHJvZ3Jlc3MudHlwZT1Db21wb25lbnQ9cmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTt9Y2hpbGQ9dXBkYXRlRm9yd2FyZFJlZihudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxyZXNvbHZlZFByb3BzLHJlbmRlckxhbmVzKTtyZXR1cm4gY2hpbGQ7fWNhc2UgTWVtb0NvbXBvbmVudDp7e2lmKHdvcmtJblByb2dyZXNzLnR5cGUhPT13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSl7dmFyIG91dGVyUHJvcFR5cGVzPUNvbXBvbmVudC5wcm9wVHlwZXM7aWYob3V0ZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLHJlc29sdmVkUHJvcHMsLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbidwcm9wJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7fX19Y2hpbGQ9dXBkYXRlTWVtb0NvbXBvbmVudChudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxyZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudC50eXBlLHJlc29sdmVkUHJvcHMpLC8vIFRoZSBpbm5lciB0eXBlIGNhbiBoYXZlIGRlZmF1bHRzIHRvb1xucmVuZGVyTGFuZXMpO3JldHVybiBjaGlsZDt9fXZhciBoaW50PScnO3tpZihDb21wb25lbnQhPT1udWxsJiZ0eXBlb2YgQ29tcG9uZW50PT09J29iamVjdCcmJkNvbXBvbmVudC4kJHR5cGVvZj09PVJFQUNUX0xBWllfVFlQRSl7aGludD0nIERpZCB5b3Ugd3JhcCBhIGNvbXBvbmVudCBpbiBSZWFjdC5sYXp5KCkgbW9yZSB0aGFuIG9uY2U/Jzt9fS8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbi8vIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCBpdCdzIGEgc2VwYXJhdGUgdHlwZSBvZiB3b3JrIGlzIGFuXG4vLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG50aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZC4gUmVjZWl2ZWQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG86IFwiK0NvbXBvbmVudCtcIi4gXCIrKFwiTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIraGludCkpO31mdW5jdGlvbiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChfY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKXtyZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKF9jdXJyZW50LHdvcmtJblByb2dyZXNzKTsvLyBQcm9tb3RlIHRoZSBmaWJlciB0byBhIGNsYXNzIGFuZCB0cnkgcmVuZGVyaW5nIGFnYWluLlxud29ya0luUHJvZ3Jlc3MudGFnPUNsYXNzQ29tcG9uZW50Oy8vIFRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgYSBmb3JrIG9mIGB1cGRhdGVDbGFzc0NvbXBvbmVudGBcbi8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4vLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4vLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG52YXIgaGFzQ29udGV4dDtpZihpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKXtoYXNDb250ZXh0PXRydWU7cHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7fWVsc2V7aGFzQ29udGV4dD1mYWxzZTt9cHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2NvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyk7bW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMscmVuZGVyTGFuZXMpO3JldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCx0cnVlLGhhc0NvbnRleHQscmVuZGVyTGFuZXMpO31mdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoX2N1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHJlbmRlckxhbmVzKXtyZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKF9jdXJyZW50LHdvcmtJblByb2dyZXNzKTt2YXIgcHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBjb250ZXh0O3t2YXIgdW5tYXNrZWRDb250ZXh0PWdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsZmFsc2UpO2NvbnRleHQ9Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQpO31wcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7dmFyIHZhbHVlO3ZhciBoYXNJZDt7bWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO317aWYoQ29tcG9uZW50LnByb3RvdHlwZSYmdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyPT09J2Z1bmN0aW9uJyl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCl8fCdVbmtub3duJztpZighZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pe2Vycm9yKFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIrJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLGNvbXBvbmVudE5hbWUsY29tcG9uZW50TmFtZSk7ZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV09dHJ1ZTt9fWlmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsbnVsbCk7fXNldElzUmVuZGVyaW5nKHRydWUpO1JlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudD13b3JrSW5Qcm9ncmVzczt2YWx1ZT1yZW5kZXJXaXRoSG9va3MobnVsbCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscHJvcHMsY29udGV4dCxyZW5kZXJMYW5lcyk7aGFzSWQ9Y2hlY2tEaWRSZW5kZXJJZEhvb2soKTtzZXRJc1JlbmRlcmluZyhmYWxzZSk7fXttYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO30vLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UGVyZm9ybWVkV29yazt7Ly8gU3VwcG9ydCBmb3IgbW9kdWxlIGNvbXBvbmVudHMgaXMgZGVwcmVjYXRlZCBhbmQgaXMgcmVtb3ZlZCBiZWhpbmQgYSBmbGFnLlxuLy8gV2hldGhlciBvciBub3QgaXQgd291bGQgY3Jhc2ggbGF0ZXIsIHdlIHdhbnQgdG8gc2hvdyBhIGdvb2QgbWVzc2FnZSBpbiBERVYgZmlyc3QuXG5pZih0eXBlb2YgdmFsdWU9PT0nb2JqZWN0JyYmdmFsdWUhPT1udWxsJiZ0eXBlb2YgdmFsdWUucmVuZGVyPT09J2Z1bmN0aW9uJyYmdmFsdWUuJCR0eXBlb2Y9PT11bmRlZmluZWQpe3ZhciBfY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KXx8J1Vua25vd24nO2lmKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSl7ZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcrJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJytcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIrXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIisnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsX2NvbXBvbmVudE5hbWUsX2NvbXBvbmVudE5hbWUsX2NvbXBvbmVudE5hbWUpO2RpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdPXRydWU7fX19aWYoLy8gUnVuIHRoZXNlIGNoZWNrcyBpbiBwcm9kdWN0aW9uIG9ubHkgaWYgdGhlIGZsYWcgaXMgb2ZmLlxuLy8gRXZlbnR1YWxseSB3ZSdsbCBkZWxldGUgdGhpcyBicmFuY2ggYWx0b2dldGhlci5cbnR5cGVvZiB2YWx1ZT09PSdvYmplY3QnJiZ2YWx1ZSE9PW51bGwmJnR5cGVvZiB2YWx1ZS5yZW5kZXI9PT0nZnVuY3Rpb24nJiZ2YWx1ZS4kJHR5cGVvZj09PXVuZGVmaW5lZCl7e3ZhciBfY29tcG9uZW50TmFtZTI9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCl8fCdVbmtub3duJztpZighZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdKXtlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJysnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnK1wiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIitcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiKydjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJyxfY29tcG9uZW50TmFtZTIsX2NvbXBvbmVudE5hbWUyLF9jb21wb25lbnROYW1lMik7ZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdPXRydWU7fX0vLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG53b3JrSW5Qcm9ncmVzcy50YWc9Q2xhc3NDb21wb25lbnQ7Ly8gVGhyb3cgb3V0IGFueSBob29rcyB0aGF0IHdlcmUgdXNlZC5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1udWxsOy8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4vLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4vLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG52YXIgaGFzQ29udGV4dD1mYWxzZTtpZihpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKXtoYXNDb250ZXh0PXRydWU7cHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7fWVsc2V7aGFzQ29udGV4dD1mYWxzZTt9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT12YWx1ZS5zdGF0ZSE9PW51bGwmJnZhbHVlLnN0YXRlIT09dW5kZWZpbmVkP3ZhbHVlLnN0YXRlOm51bGw7aW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTthZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsdmFsdWUpO21vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscHJvcHMscmVuZGVyTGFuZXMpO3JldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCx0cnVlLGhhc0NvbnRleHQscmVuZGVyTGFuZXMpO31lbHNley8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb24gY29tcG9uZW50XG53b3JrSW5Qcm9ncmVzcy50YWc9RnVuY3Rpb25Db21wb25lbnQ7e2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e3ZhbHVlPXJlbmRlcldpdGhIb29rcyhudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxwcm9wcyxjb250ZXh0LHJlbmRlckxhbmVzKTtoYXNJZD1jaGVja0RpZFJlbmRlcklkSG9vaygpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fX1pZihnZXRJc0h5ZHJhdGluZygpJiZoYXNJZCl7cHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7fXJlY29uY2lsZUNoaWxkcmVuKG51bGwsd29ya0luUHJvZ3Jlc3MsdmFsdWUscmVuZGVyTGFuZXMpO3t2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50KTt9cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO319ZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLENvbXBvbmVudCl7e2lmKENvbXBvbmVudCl7aWYoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKXtlcnJvcignJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuJyxDb21wb25lbnQuZGlzcGxheU5hbWV8fENvbXBvbmVudC5uYW1lfHwnQ29tcG9uZW50Jyk7fX1pZih3b3JrSW5Qcm9ncmVzcy5yZWYhPT1udWxsKXt2YXIgaW5mbz0nJzt2YXIgb3duZXJOYW1lPWdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7aWYob3duZXJOYW1lKXtpbmZvKz0nXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcrb3duZXJOYW1lKydgLic7fXZhciB3YXJuaW5nS2V5PW93bmVyTmFtZXx8Jyc7dmFyIGRlYnVnU291cmNlPXdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtpZihkZWJ1Z1NvdXJjZSl7d2FybmluZ0tleT1kZWJ1Z1NvdXJjZS5maWxlTmFtZSsnOicrZGVidWdTb3VyY2UubGluZU51bWJlcjt9aWYoIWRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSl7ZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzW3dhcm5pbmdLZXldPXRydWU7ZXJyb3IoJ0Z1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuICcrJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuICcrJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPyVzJyxpbmZvKTt9fWlmKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJyl7dmFyIF9jb21wb25lbnROYW1lMz1nZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KXx8J1Vua25vd24nO2lmKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pe2Vycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJyxfY29tcG9uZW50TmFtZTMpO2RpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXT10cnVlO319aWYodHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZT09PSdvYmplY3QnJiZDb21wb25lbnQuY29udGV4dFR5cGUhPT1udWxsKXt2YXIgX2NvbXBvbmVudE5hbWU0PWdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpfHwnVW5rbm93bic7aWYoIWRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTRdKXtlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuJyxfY29tcG9uZW50TmFtZTQpO2RpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTRdPXRydWU7fX19fXZhciBTVVNQRU5ERURfTUFSS0VSPXtkZWh5ZHJhdGVkOm51bGwsdHJlZUNvbnRleHQ6bnVsbCxyZXRyeUxhbmU6Tm9MYW5lfTtmdW5jdGlvbiBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpe3JldHVybntiYXNlTGFuZXM6cmVuZGVyTGFuZXMsY2FjaGVQb29sOmdldFN1c3BlbmRlZENhY2hlKCksdHJhbnNpdGlvbnM6bnVsbH07fWZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLHJlbmRlckxhbmVzKXt2YXIgY2FjaGVQb29sPW51bGw7cmV0dXJue2Jhc2VMYW5lczptZXJnZUxhbmVzKHByZXZPZmZzY3JlZW5TdGF0ZS5iYXNlTGFuZXMscmVuZGVyTGFuZXMpLGNhY2hlUG9vbDpjYWNoZVBvb2wsdHJhbnNpdGlvbnM6cHJldk9mZnNjcmVlblN0YXRlLnRyYW5zaXRpb25zfTt9Ly8gVE9ETzogUHJvYmFibHkgc2hvdWxkIGlubGluZSB0aGlzIGJhY2tcbmZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpey8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgd2UgbmVlZCB0b1xuLy8gcmVtYWluIG9uIHRoYXQgZmFsbGJhY2sgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjb250ZW50IGhhcyByZXNvbHZlZC5cbi8vIEZvciBleGFtcGxlLCBTdXNwZW5zZUxpc3QgY29vcmRpbmF0ZXMgd2hlbiBuZXN0ZWQgY29udGVudCBhcHBlYXJzLlxuaWYoY3VycmVudCE9PW51bGwpe3ZhciBzdXNwZW5zZVN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtpZihzdXNwZW5zZVN0YXRlPT09bnVsbCl7Ly8gQ3VycmVudGx5IHNob3dpbmcgY29udGVudC4gRG9uJ3QgaGlkZSBpdCwgZXZlbiBpZiBGb3JjZVN1c3BlbnNlRmFsbGJhY2tcbi8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4vLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4vLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG5yZXR1cm4gZmFsc2U7fX0vLyBOb3QgY3VycmVudGx5IHNob3dpbmcgY29udGVudC4gQ29uc3VsdCB0aGUgU3VzcGVuc2UgY29udGV4dC5cbnJldHVybiBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7fWZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQscmVuZGVyTGFuZXMpey8vIFRPRE86IFNob3VsZCBub3QgcmVtb3ZlIHJlbmRlciBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIGR1cmluZyB0aGlzIHJlbmRlclxucmV0dXJuIHJlbW92ZUxhbmVzKGN1cnJlbnQuY2hpbGRMYW5lcyxyZW5kZXJMYW5lcyk7fWZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3ZhciBuZXh0UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOy8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIHN1c3BlbmQuXG57aWYoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO319dmFyIHN1c3BlbnNlQ29udGV4dD1zdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7dmFyIHNob3dGYWxsYmFjaz1mYWxzZTt2YXIgZGlkU3VzcGVuZD0od29ya0luUHJvZ3Jlc3MuZmxhZ3MmRGlkQ2FwdHVyZSkhPT1Ob0ZsYWdzO2lmKGRpZFN1c3BlbmR8fHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LGN1cnJlbnQpKXsvLyBTb21ldGhpbmcgaW4gdGhpcyBib3VuZGFyeSdzIHN1YnRyZWUgYWxyZWFkeSBzdXNwZW5kZWQuIFN3aXRjaCB0b1xuLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbnNob3dGYWxsYmFjaz10cnVlO3dvcmtJblByb2dyZXNzLmZsYWdzJj1+RGlkQ2FwdHVyZTt9ZWxzZXsvLyBBdHRlbXB0aW5nIHRoZSBtYWluIGNvbnRlbnRcbmlmKGN1cnJlbnQ9PT1udWxsfHxjdXJyZW50Lm1lbW9pemVkU3RhdGUhPT1udWxsKXsvLyBUaGlzIGlzIGEgbmV3IG1vdW50IG9yIHRoaXMgYm91bmRhcnkgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgc3RhdGUuXG4vLyBNYXJrIHRoaXMgc3VidHJlZSBjb250ZXh0IGFzIGhhdmluZyBhdCBsZWFzdCBvbmUgaW52aXNpYmxlIHBhcmVudCB0aGF0IGNvdWxkXG4vLyBoYW5kbGUgdGhlIGZhbGxiYWNrIHN0YXRlLlxuLy8gQXZvaWRlZCBib3VuZGFyaWVzIGFyZSBub3QgY29uc2lkZXJlZCBzaW5jZSB0aGV5IGNhbm5vdCBoYW5kbGUgcHJlZmVycmVkIGZhbGxiYWNrIHN0YXRlcy5cbntzdXNwZW5zZUNvbnRleHQ9YWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0KTt9fX1zdXNwZW5zZUNvbnRleHQ9c2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLHN1c3BlbnNlQ29udGV4dCk7Ly8gT0ssIHRoZSBuZXh0IHBhcnQgaXMgY29uZnVzaW5nLiBXZSdyZSBhYm91dCB0byByZWNvbmNpbGUgdGhlIFN1c3BlbnNlXG4vLyBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGlzIGludm9sdmVzIHNvbWUgY3VzdG9tIHJlY29uY2lsaWF0aW9uIGxvZ2ljLiBUd29cbi8vIG1haW4gcmVhc29ucyB0aGlzIGlzIHNvIGNvbXBsaWNhdGVkLlxuLy9cbi8vIEZpcnN0LCBMZWdhY3kgTW9kZSBoYXMgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoZVxuLy8gcHJpbWFyeSB0cmVlIHdpbGwgY29tbWl0IGluIGFuIGluY29uc2lzdGVudCBzdGF0ZSwgc28gd2hlbiB3ZSBkbyB0aGVcbi8vIHNlY29uZCBwYXNzIHRvIHJlbmRlciB0aGUgZmFsbGJhY2ssIHdlIGRvIHNvbWUgZXhjZWVkaW5nbHksIHVoLCBjbGV2ZXJcbi8vIGhhY2tzIHRvIG1ha2UgdGhhdCBub3QgdG90YWxseSBicmVhay4gTGlrZSB0cmFuc2ZlcnJpbmcgZWZmZWN0cyBhbmRcbi8vIGRlbGV0aW9ucyBmcm9tIGhpZGRlbiB0cmVlLiBJbiBDb25jdXJyZW50IE1vZGUsIGl0J3MgbXVjaCBzaW1wbGVyLFxuLy8gYmVjYXVzZSB3ZSBiYWlsb3V0IG9uIHRoZSBwcmltYXJ5IHRyZWUgY29tcGxldGVseSBhbmQgbGVhdmUgaXQgaW4gaXRzIG9sZFxuLy8gc3RhdGUsIG5vIGVmZmVjdHMuIFNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgT2Zmc2NyZWVuIChleGNlcHQgdGhhdFxuLy8gT2Zmc2NyZWVuIGRvZXNuJ3QgaGF2ZSB0aGUgZmlyc3QgcmVuZGVyIHBhc3MpLlxuLy9cbi8vIFNlY29uZCBpcyBoeWRyYXRpb24uIER1cmluZyBoeWRyYXRpb24sIHRoZSBTdXNwZW5zZSBmaWJlciBoYXMgYSBzbGlnaHRseVxuLy8gZGlmZmVyZW50IGxheW91dCwgd2hlcmUgdGhlIGNoaWxkIHBvaW50cyB0byBhIGRlaHlkcmF0ZWQgZnJhZ21lbnQsIHdoaWNoXG4vLyBjb250YWlucyB0aGUgRE9NIHJlbmRlcmVkIGJ5IHRoZSBzZXJ2ZXIuXG4vL1xuLy8gVGhpcmQsIGV2ZW4gaWYgeW91IHNldCBhbGwgdGhhdCBhc2lkZSwgU3VzcGVuc2UgaXMgbGlrZSBlcnJvciBib3VuZGFyaWVzIGluXG4vLyB0aGF0IHdlIGZpcnN0IHdlIHRyeSB0byByZW5kZXIgb25lIHRyZWUsIGFuZCBpZiB0aGF0IGZhaWxzLCB3ZSByZW5kZXIgYWdhaW5cbi8vIGFuZCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdHJlZS4gTGlrZSBhIHRyeS9jYXRjaCBibG9jay4gU28gd2UgaGF2ZSB0byB0cmFja1xuLy8gd2hpY2ggYnJhbmNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcuIElkZWFsbHkgd2Ugd291bGQgbW9kZWwgdGhpcyB1c2luZ1xuLy8gYSBzdGFjay5cbmlmKGN1cnJlbnQ9PT1udWxsKXsvLyBJbml0aWFsIG1vdW50XG4vLyBTcGVjaWFsIHBhdGggZm9yIGh5ZHJhdGlvblxuLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbnRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTsvLyBUaGlzIGNvdWxkJ3ZlIGJlZW4gYSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudC5cbnZhciBzdXNwZW5zZVN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYoc3VzcGVuc2VTdGF0ZSE9PW51bGwpe3ZhciBkZWh5ZHJhdGVkPXN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtpZihkZWh5ZHJhdGVkIT09bnVsbCl7cmV0dXJuIG1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KHdvcmtJblByb2dyZXNzLGRlaHlkcmF0ZWQpO319dmFyIG5leHRQcmltYXJ5Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBuZXh0RmFsbGJhY2tDaGlsZHJlbj1uZXh0UHJvcHMuZmFsbGJhY2s7aWYoc2hvd0ZhbGxiYWNrKXt2YXIgZmFsbGJhY2tGcmFnbWVudD1tb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcyxuZXh0UHJpbWFyeUNoaWxkcmVuLG5leHRGYWxsYmFja0NoaWxkcmVuLHJlbmRlckxhbmVzKTt2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7cHJpbWFyeUNoaWxkRnJhZ21lbnQubWVtb2l6ZWRTdGF0ZT1tb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9U1VTUEVOREVEX01BUktFUjtyZXR1cm4gZmFsbGJhY2tGcmFnbWVudDt9ZWxzZXtyZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcyxuZXh0UHJpbWFyeUNoaWxkcmVuKTt9fWVsc2V7Ly8gVGhpcyBpcyBhbiB1cGRhdGUuXG4vLyBTcGVjaWFsIHBhdGggZm9yIGh5ZHJhdGlvblxudmFyIHByZXZTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7aWYocHJldlN0YXRlIT09bnVsbCl7dmFyIF9kZWh5ZHJhdGVkPXByZXZTdGF0ZS5kZWh5ZHJhdGVkO2lmKF9kZWh5ZHJhdGVkIT09bnVsbCl7cmV0dXJuIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLGRpZFN1c3BlbmQsbmV4dFByb3BzLF9kZWh5ZHJhdGVkLHByZXZTdGF0ZSxyZW5kZXJMYW5lcyk7fX1pZihzaG93RmFsbGJhY2spe3ZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW49bmV4dFByb3BzLmZhbGxiYWNrO3ZhciBfbmV4dFByaW1hcnlDaGlsZHJlbj1uZXh0UHJvcHMuY2hpbGRyZW47dmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudD11cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxfbmV4dFByaW1hcnlDaGlsZHJlbixfbmV4dEZhbGxiYWNrQ2hpbGRyZW4scmVuZGVyTGFuZXMpO3ZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyPXdvcmtJblByb2dyZXNzLmNoaWxkO3ZhciBwcmV2T2Zmc2NyZWVuU3RhdGU9Y3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlO19wcmltYXJ5Q2hpbGRGcmFnbWVudDIubWVtb2l6ZWRTdGF0ZT1wcmV2T2Zmc2NyZWVuU3RhdGU9PT1udWxsP21vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk6dXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUscmVuZGVyTGFuZXMpO19wcmltYXJ5Q2hpbGRGcmFnbWVudDIuY2hpbGRMYW5lcz1nZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShjdXJyZW50LHJlbmRlckxhbmVzKTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPVNVU1BFTkRFRF9NQVJLRVI7cmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDt9ZWxzZXt2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4yPW5leHRQcm9wcy5jaGlsZHJlbjt2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mz11cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLF9uZXh0UHJpbWFyeUNoaWxkcmVuMixyZW5kZXJMYW5lcyk7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1udWxsO3JldHVybiBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzO319fWZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MscHJpbWFyeUNoaWxkcmVuLHJlbmRlckxhbmVzKXt2YXIgbW9kZT13b3JrSW5Qcm9ncmVzcy5tb2RlO3ZhciBwcmltYXJ5Q2hpbGRQcm9wcz17bW9kZTondmlzaWJsZScsY2hpbGRyZW46cHJpbWFyeUNoaWxkcmVufTt2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ9bW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLG1vZGUpO3ByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybj13b3JrSW5Qcm9ncmVzczt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1wcmltYXJ5Q2hpbGRGcmFnbWVudDtyZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7fWZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLHByaW1hcnlDaGlsZHJlbixmYWxsYmFja0NoaWxkcmVuLHJlbmRlckxhbmVzKXt2YXIgbW9kZT13b3JrSW5Qcm9ncmVzcy5tb2RlO3ZhciBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50PXdvcmtJblByb2dyZXNzLmNoaWxkO3ZhciBwcmltYXJ5Q2hpbGRQcm9wcz17bW9kZTonaGlkZGVuJyxjaGlsZHJlbjpwcmltYXJ5Q2hpbGRyZW59O3ZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudDt2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O2lmKChtb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSYmcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCE9PW51bGwpey8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBjb21taXQgdGhlIHByaW1hcnkgdHJlZSBhcyBpZiBpdCBzdWNjZXNzZnVsbHlcbi8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG5wcmltYXJ5Q2hpbGRGcmFnbWVudD1wcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50O3ByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXM9Tm9MYW5lcztwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHM9cHJpbWFyeUNoaWxkUHJvcHM7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZQcm9maWxlTW9kZSl7Ly8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4vLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxucHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb249MDtwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWU9LTE7cHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbj0wO3ByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb249MDt9ZmFsbGJhY2tDaGlsZEZyYWdtZW50PWNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sbW9kZSxyZW5kZXJMYW5lcyxudWxsKTt9ZWxzZXtwcmltYXJ5Q2hpbGRGcmFnbWVudD1tb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsbW9kZSk7ZmFsbGJhY2tDaGlsZEZyYWdtZW50PWNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sbW9kZSxyZW5kZXJMYW5lcyxudWxsKTt9cHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuPXdvcmtJblByb2dyZXNzO2ZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7cHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZz1mYWxsYmFja0NoaWxkRnJhZ21lbnQ7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9cHJpbWFyeUNoaWxkRnJhZ21lbnQ7cmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDt9ZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLG1vZGUscmVuZGVyTGFuZXMpey8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlXG4vLyB0aGlzIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxucmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihvZmZzY3JlZW5Qcm9wcyxtb2RlLE5vTGFuZXMsbnVsbCk7fWZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudCxvZmZzY3JlZW5Qcm9wcyl7Ly8gVGhlIHByb3BzIGFyZ3VtZW50IHRvIGBjcmVhdGVXb3JrSW5Qcm9ncmVzc2AgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZSB0aGlzXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiBpdC5cbnJldHVybiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LG9mZnNjcmVlblByb3BzKTt9ZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxwcmltYXJ5Q2hpbGRyZW4scmVuZGVyTGFuZXMpe3ZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQ9Y3VycmVudC5jaGlsZDt2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudD1jdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZzt2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ9dXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQse21vZGU6J3Zpc2libGUnLGNoaWxkcmVuOnByaW1hcnlDaGlsZHJlbn0pO2lmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7cHJpbWFyeUNoaWxkRnJhZ21lbnQubGFuZXM9cmVuZGVyTGFuZXM7fXByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybj13b3JrSW5Qcm9ncmVzcztwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nPW51bGw7aWYoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCE9PW51bGwpey8vIERlbGV0ZSB0aGUgZmFsbGJhY2sgY2hpbGQgZnJhZ21lbnRcbnZhciBkZWxldGlvbnM9d29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zO2lmKGRlbGV0aW9ucz09PW51bGwpe3dvcmtJblByb2dyZXNzLmRlbGV0aW9ucz1bY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudF07d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PUNoaWxkRGVsZXRpb247fWVsc2V7ZGVsZXRpb25zLnB1c2goY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCk7fX13b3JrSW5Qcm9ncmVzcy5jaGlsZD1wcmltYXJ5Q2hpbGRGcmFnbWVudDtyZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7fWZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLHByaW1hcnlDaGlsZHJlbixmYWxsYmFja0NoaWxkcmVuLHJlbmRlckxhbmVzKXt2YXIgbW9kZT13b3JrSW5Qcm9ncmVzcy5tb2RlO3ZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQ9Y3VycmVudC5jaGlsZDt2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudD1jdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZzt2YXIgcHJpbWFyeUNoaWxkUHJvcHM9e21vZGU6J2hpZGRlbicsY2hpbGRyZW46cHJpbWFyeUNoaWxkcmVufTt2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7aWYoLy8gSW4gbGVnYWN5IG1vZGUsIHdlIGNvbW1pdCB0aGUgcHJpbWFyeSB0cmVlIGFzIGlmIGl0IHN1Y2Nlc3NmdWxseVxuLy8gY29tcGxldGVkLCBldmVuIHRob3VnaCBpdCdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS5cbihtb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSYmLy8gTWFrZSBzdXJlIHdlJ3JlIG9uIHRoZSBzZWNvbmQgcGFzcywgaS5lLiB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCB3YXNcbi8vIGFscmVhZHkgY2xvbmVkLiBJbiBsZWdhY3kgbW9kZSwgdGhlIG9ubHkgY2FzZSB3aGVyZSB0aGlzIGlzbid0IHRydWUgaXNcbi8vIHdoZW4gRGV2VG9vbHMgZm9yY2VzIHVzIHRvIGRpc3BsYXkgYSBmYWxsYmFjazsgd2Ugc2tpcCB0aGUgZmlyc3QgcmVuZGVyXG4vLyBwYXNzIGVudGlyZWx5IGFuZCBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgdGhlIGZhbGxiYWNrLiAoSW4gQ29uY3VycmVudFxuLy8gTW9kZSwgU3VzcGVuc2VMaXN0IGNhbiBhbHNvIHRyaWdnZXIgdGhpcyBzY2VuYXJpbywgYnV0IHRoaXMgaXMgYSBsZWdhY3ktXG4vLyBvbmx5IGNvZGVwYXRoLilcbndvcmtJblByb2dyZXNzLmNoaWxkIT09Y3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50KXt2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudD13b3JrSW5Qcm9ncmVzcy5jaGlsZDtwcmltYXJ5Q2hpbGRGcmFnbWVudD1wcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50O3ByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXM9Tm9MYW5lcztwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHM9cHJpbWFyeUNoaWxkUHJvcHM7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZQcm9maWxlTW9kZSl7Ly8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4vLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxucHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb249MDtwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWU9LTE7cHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbj1jdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbjtwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uPWN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO30vLyBUaGUgZmFsbGJhY2sgZmliZXIgd2FzIGFkZGVkIGFzIGEgZGVsZXRpb24gZHVyaW5nIHRoZSBmaXJzdCBwYXNzLlxuLy8gSG93ZXZlciwgc2luY2Ugd2UncmUgZ29pbmcgdG8gcmVtYWluIG9uIHRoZSBmYWxsYmFjaywgd2Ugbm8gbG9uZ2VyIHdhbnRcbi8vIHRvIGRlbGV0ZSBpdC5cbndvcmtJblByb2dyZXNzLmRlbGV0aW9ucz1udWxsO31lbHNle3ByaW1hcnlDaGlsZEZyYWdtZW50PXVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LHByaW1hcnlDaGlsZFByb3BzKTsvLyBTaW5jZSB3ZSdyZSByZXVzaW5nIGEgY3VycmVudCB0cmVlLCB3ZSBuZWVkIHRvIHJldXNlIHRoZSBmbGFncywgdG9vLlxuLy8gKFdlIGRvbid0IGRvIHRoaXMgaW4gbGVnYWN5IG1vZGUsIGJlY2F1c2UgaW4gbGVnYWN5IG1vZGUgd2UgZG9uJ3QgcmUtdXNlXG4vLyB0aGUgY3VycmVudCB0cmVlOyBzZWUgcHJldmlvdXMgYnJhbmNoLilcbnByaW1hcnlDaGlsZEZyYWdtZW50LnN1YnRyZWVGbGFncz1jdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzJlN0YXRpY01hc2s7fXZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7aWYoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCE9PW51bGwpe2ZhbGxiYWNrQ2hpbGRGcmFnbWVudD1jcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LGZhbGxiYWNrQ2hpbGRyZW4pO31lbHNle2ZhbGxiYWNrQ2hpbGRGcmFnbWVudD1jcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLG1vZGUscmVuZGVyTGFuZXMsbnVsbCk7Ly8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlIGJvdW5kYXJ5KSBhbHJlYWR5XG4vLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzfD1QbGFjZW1lbnQ7fWZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7cHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuPXdvcmtJblByb2dyZXNzO3ByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc9ZmFsbGJhY2tDaGlsZEZyYWdtZW50O3dvcmtJblByb2dyZXNzLmNoaWxkPXByaW1hcnlDaGlsZEZyYWdtZW50O3JldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7fWZ1bmN0aW9uIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMscmVjb3ZlcmFibGVFcnJvcil7Ly8gRmFsbGluZyBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuIEJlY2F1c2UgdGhpcyBoYXMgcGVyZm9ybWFuY2Vcbi8vIGltcGxpY2F0aW9ucywgaXQncyBjb25zaWRlcmVkIGEgcmVjb3ZlcmFibGUgZXJyb3IsIGV2ZW4gdGhvdWdoIHRoZSB1c2VyXG4vLyBsaWtlbHkgd29uJ3Qgb2JzZXJ2ZSBhbnl0aGluZyB3cm9uZyB3aXRoIHRoZSBVSS5cbi8vXG4vLyBUaGUgZXJyb3IgaXMgcGFzc2VkIGluIGFzIGFuIGFyZ3VtZW50IHRvIGVuZm9yY2UgdGhhdCBldmVyeSBjYWxsZXIgcHJvdmlkZVxuLy8gYSBjdXN0b20gbWVzc2FnZSwgb3IgZXhwbGljaXRseSBvcHQgb3V0IChjdXJyZW50bHkgdGhlIG9ubHkgcGF0aCB0aGF0IG9wdHNcbi8vIG91dCBpcyBsZWdhY3kgbW9kZTsgZXZlcnkgY29uY3VycmVudCBwYXRoIHByb3ZpZGVzIGFuIGVycm9yKS5cbmlmKHJlY292ZXJhYmxlRXJyb3IhPT1udWxsKXtxdWV1ZUh5ZHJhdGlvbkVycm9yKHJlY292ZXJhYmxlRXJyb3IpO30vLyBUaGlzIHdpbGwgYWRkIHRoZSBvbGQgZmliZXIgdG8gdGhlIGRlbGV0aW9uIGxpc3RcbnJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLGN1cnJlbnQuY2hpbGQsbnVsbCxyZW5kZXJMYW5lcyk7Ly8gV2UncmUgbm93IG5vdCBzdXNwZW5kZWQgbm9yIGRlaHlkcmF0ZWQuXG52YXIgbmV4dFByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgcHJpbWFyeUNoaWxkcmVuPW5leHRQcm9wcy5jaGlsZHJlbjt2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ9bW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcyxwcmltYXJ5Q2hpbGRyZW4pOy8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuLy8gbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cbnByaW1hcnlDaGlsZEZyYWdtZW50LmZsYWdzfD1QbGFjZW1lbnQ7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1udWxsO3JldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDt9ZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxwcmltYXJ5Q2hpbGRyZW4sZmFsbGJhY2tDaGlsZHJlbixyZW5kZXJMYW5lcyl7dmFyIGZpYmVyTW9kZT13b3JrSW5Qcm9ncmVzcy5tb2RlO3ZhciBwcmltYXJ5Q2hpbGRQcm9wcz17bW9kZTondmlzaWJsZScsY2hpbGRyZW46cHJpbWFyeUNoaWxkcmVufTt2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ9bW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLGZpYmVyTW9kZSk7dmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudD1jcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLGZpYmVyTW9kZSxyZW5kZXJMYW5lcyxudWxsKTsvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2Vcbi8vIGJvdW5kYXJ5KSBhbHJlYWR5IG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5mYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3N8PVBsYWNlbWVudDtwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7ZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybj13b3JrSW5Qcm9ncmVzcztwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nPWZhbGxiYWNrQ2hpbGRGcmFnbWVudDt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1wcmltYXJ5Q2hpbGRGcmFnbWVudDtpZigod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGUpey8vIFdlIHdpbGwgaGF2ZSBkcm9wcGVkIHRoZSBlZmZlY3QgbGlzdCB3aGljaCBjb250YWlucyB0aGVcbi8vIGRlbGV0aW9uLiBXZSBuZWVkIHRvIHJlY29uY2lsZSB0byBkZWxldGUgdGhlIGN1cnJlbnQgY2hpbGQuXG5yZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxjdXJyZW50LmNoaWxkLG51bGwscmVuZGVyTGFuZXMpO31yZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O31mdW5jdGlvbiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcyxzdXNwZW5zZUluc3RhbmNlLHJlbmRlckxhbmVzKXsvLyBEdXJpbmcgdGhlIGZpcnN0IHBhc3MsIHdlJ2xsIGJhaWwgb3V0IGFuZCBub3QgZHJpbGwgaW50byB0aGUgY2hpbGRyZW4uXG4vLyBJbnN0ZWFkLCB3ZSdsbCBsZWF2ZSB0aGUgY29udGVudCBpbiBwbGFjZSBhbmQgdHJ5IHRvIGh5ZHJhdGUgaXQgbGF0ZXIuXG5pZigod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpe3tlcnJvcignQ2Fubm90IGh5ZHJhdGUgU3VzcGVuc2UgaW4gbGVnYWN5IG1vZGUuIFN3aXRjaCBmcm9tICcrJ1JlYWN0RE9NLmh5ZHJhdGUoZWxlbWVudCwgY29udGFpbmVyKSB0byAnKydSZWFjdERPTUNsaWVudC5oeWRyYXRlUm9vdChjb250YWluZXIsIDxBcHAgLz4pJysnLnJlbmRlcihlbGVtZW50KSBvciByZW1vdmUgdGhlIFN1c3BlbnNlIGNvbXBvbmVudHMgZnJvbSAnKyd0aGUgc2VydmVyIHJlbmRlcmVkIGNvbXBvbmVudHMuJyk7fXdvcmtJblByb2dyZXNzLmxhbmVzPWxhbmVUb0xhbmVzKFN5bmNMYW5lKTt9ZWxzZSBpZihpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdXNwZW5zZUluc3RhbmNlKSl7Ly8gVGhpcyBpcyBhIGNsaWVudC1vbmx5IGJvdW5kYXJ5LiBTaW5jZSB3ZSB3b24ndCBnZXQgYW55IGNvbnRlbnQgZnJvbSB0aGUgc2VydmVyXG4vLyBmb3IgdGhpcywgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGF0IGF0IGEgaGlnaGVyIHByaW9yaXR5IGJhc2VkIG9uIHdoZW4gaXQgd291bGRcbi8vIGhhdmUgdGltZWQgb3V0LiBJbiB0aGVvcnkgd2UgY291bGQgcmVuZGVyIGl0IGluIHRoaXMgcGFzcyBidXQgaXQgd291bGQgaGF2ZSB0aGVcbi8vIHdyb25nIHByaW9yaXR5IGFzc29jaWF0ZWQgd2l0aCBpdCBhbmQgd2lsbCBwcmV2ZW50IGh5ZHJhdGlvbiBvZiBwYXJlbnQgcGF0aC5cbi8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHdvcmsgbGVmdCBvbiBpdCB0byByZW5kZXIgaXQgaW4gYSBzZXBhcmF0ZSBjb21taXQuXG4vLyBUT0RPIFRoaXMgdGltZSBzaG91bGQgYmUgdGhlIHRpbWUgYXQgd2hpY2ggdGhlIHNlcnZlciByZW5kZXJlZCByZXNwb25zZSB0aGF0IGlzXG4vLyBhIHBhcmVudCB0byB0aGlzIGJvdW5kYXJ5IHdhcyBkaXNwbGF5ZWQuIEhvd2V2ZXIsIHNpbmNlIHdlIGN1cnJlbnRseSBkb24ndCBoYXZlXG4vLyBhIHByb3RvY29sIHRvIHRyYW5zZmVyIHRoYXQgdGltZSwgd2UnbGwganVzdCBlc3RpbWF0ZSBpdCBieSB1c2luZyB0aGUgY3VycmVudFxuLy8gdGltZS4gVGhpcyB3aWxsIG1lYW4gdGhhdCBTdXNwZW5zZSB0aW1lb3V0cyBhcmUgc2xpZ2h0bHkgc2hpZnRlZCB0byBsYXRlciB0aGFuXG4vLyB0aGV5IHNob3VsZCBiZS5cbi8vIFNjaGVkdWxlIGEgbm9ybWFsIHByaSB1cGRhdGUgdG8gcmVuZGVyIHRoaXMgY29udGVudC5cbndvcmtJblByb2dyZXNzLmxhbmVzPWxhbmVUb0xhbmVzKERlZmF1bHRIeWRyYXRpb25MYW5lKTt9ZWxzZXsvLyBXZSdsbCBjb250aW51ZSBoeWRyYXRpbmcgdGhlIHJlc3QgYXQgb2Zmc2NyZWVuIHByaW9yaXR5IHNpbmNlIHdlJ2xsIGFscmVhZHlcbi8vIGJlIHNob3dpbmcgdGhlIHJpZ2h0IGNvbnRlbnQgY29taW5nIGZyb20gdGhlIHNlcnZlciwgaXQgaXMgbm8gcnVzaC5cbndvcmtJblByb2dyZXNzLmxhbmVzPWxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpO31yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gdXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsZGlkU3VzcGVuZCxuZXh0UHJvcHMsc3VzcGVuc2VJbnN0YW5jZSxzdXNwZW5zZVN0YXRlLHJlbmRlckxhbmVzKXtpZighZGlkU3VzcGVuZCl7Ly8gVGhpcyBpcyB0aGUgZmlyc3QgcmVuZGVyIHBhc3MuIEF0dGVtcHQgdG8gaHlkcmF0ZS5cbi8vIFdlIHNob3VsZCBuZXZlciBiZSBoeWRyYXRpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IGlzIHRoZSBmaXJzdCBwYXNzLFxuLy8gYnV0IGFmdGVyIHdlJ3ZlIGFscmVhZHkgY29tbWl0dGVkIG9uY2UuXG53YXJuSWZIeWRyYXRpbmcoKTtpZigod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpe3JldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzLC8vIFRPRE86IFdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLCB3ZSBzaG91bGQgbWFrZSB0aGlzIGVycm9yIGFyZ3VtZW50XG4vLyByZXF1aXJlZCDigJQgZXZlcnkgY29uY3VycmVudCBtb2RlIHBhdGggdGhhdCBjYXVzZXMgaHlkcmF0aW9uIHRvXG4vLyBkZS1vcHQgdG8gY2xpZW50IHJlbmRlcmluZyBzaG91bGQgaGF2ZSBhbiBlcnJvciBtZXNzYWdlLlxubnVsbCk7fWlmKGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN1c3BlbnNlSW5zdGFuY2UpKXsvLyBUaGlzIGJvdW5kYXJ5IGlzIGluIGEgcGVybWFuZW50IGZhbGxiYWNrIHN0YXRlLiBJbiB0aGlzIGNhc2UsIHdlJ2xsIG5ldmVyXG4vLyBnZXQgYW4gdXBkYXRlIGFuZCB3ZSdsbCBuZXZlciBiZSBhYmxlIHRvIGh5ZHJhdGUgdGhlIGZpbmFsIGNvbnRlbnQuIExldCdzIGp1c3QgdHJ5IHRoZVxuLy8gY2xpZW50IHNpZGUgcmVuZGVyIGluc3RlYWQuXG52YXIgZGlnZXN0LG1lc3NhZ2Usc3RhY2s7e3ZhciBfZ2V0U3VzcGVuc2VJbnN0YW5jZUY9Z2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzKHN1c3BlbnNlSW5zdGFuY2UpO2RpZ2VzdD1fZ2V0U3VzcGVuc2VJbnN0YW5jZUYuZGlnZXN0O21lc3NhZ2U9X2dldFN1c3BlbnNlSW5zdGFuY2VGLm1lc3NhZ2U7c3RhY2s9X2dldFN1c3BlbnNlSW5zdGFuY2VGLnN0YWNrO312YXIgZXJyb3I7aWYobWVzc2FnZSl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbmVycm9yPW5ldyBFcnJvcihtZXNzYWdlKTt9ZWxzZXtlcnJvcj1uZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgY291bGQgbm90IGZpbmlzaCB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5LCBsaWtlbHkgJysnZHVlIHRvIGFuIGVycm9yIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLiBTd2l0Y2hlZCB0byAnKydjbGllbnQgcmVuZGVyaW5nLicpO312YXIgY2FwdHVyZWRWYWx1ZT1jcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yLGRpZ2VzdCxzdGFjayk7cmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMsY2FwdHVyZWRWYWx1ZSk7fS8vIGFueSBjb250ZXh0IGhhcyBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHRyZWF0IGlzIGFzIGlmIHRoZSBpbnB1dCBtaWdodCBoYXZlIGNoYW5nZWQuXG52YXIgaGFzQ29udGV4dENoYW5nZWQ9aW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcyxjdXJyZW50LmNoaWxkTGFuZXMpO2lmKGRpZFJlY2VpdmVVcGRhdGV8fGhhc0NvbnRleHRDaGFuZ2VkKXsvLyBUaGlzIGJvdW5kYXJ5IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBmaXJzdCByZW5kZXIuIFRoaXMgbWVhbnMgdGhhdCB3ZSBhcmUgbm93IHVuYWJsZSB0b1xuLy8gaHlkcmF0ZSBpdC4gV2UgbWlnaHQgc3RpbGwgYmUgYWJsZSB0byBoeWRyYXRlIGl0IHVzaW5nIGEgaGlnaGVyIHByaW9yaXR5IGxhbmUuXG52YXIgcm9vdD1nZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtpZihyb290IT09bnVsbCl7dmFyIGF0dGVtcHRIeWRyYXRpb25BdExhbmU9Z2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbihyb290LHJlbmRlckxhbmVzKTtpZihhdHRlbXB0SHlkcmF0aW9uQXRMYW5lIT09Tm9MYW5lJiZhdHRlbXB0SHlkcmF0aW9uQXRMYW5lIT09c3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpey8vIEludGVudGlvbmFsbHkgbXV0YXRpbmcgc2luY2UgdGhpcyByZW5kZXIgd2lsbCBnZXQgaW50ZXJydXB0ZWQuIFRoaXNcbi8vIGlzIG9uZSBvZiB0aGUgdmVyeSByYXJlIHRpbWVzIHdoZXJlIHdlIG11dGF0ZSB0aGUgY3VycmVudCB0cmVlXG4vLyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbnN1c3BlbnNlU3RhdGUucmV0cnlMYW5lPWF0dGVtcHRIeWRyYXRpb25BdExhbmU7Ly8gVE9ETzogSWRlYWxseSB0aGlzIHdvdWxkIGluaGVyaXQgdGhlIGV2ZW50IHRpbWUgb2YgdGhlIGN1cnJlbnQgcmVuZGVyXG52YXIgZXZlbnRUaW1lPU5vVGltZXN0YW1wO2VucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShjdXJyZW50LGF0dGVtcHRIeWRyYXRpb25BdExhbmUpO3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGN1cnJlbnQsYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSxldmVudFRpbWUpO319Ly8gSWYgd2UgaGF2ZSBzY2hlZHVsZWQgaGlnaGVyIHByaSB3b3JrIGFib3ZlLCB0aGlzIHdpbGwgcHJvYmFibHkganVzdCBhYm9ydCB0aGUgcmVuZGVyXG4vLyBzaW5jZSB3ZSBub3cgaGF2ZSBoaWdoZXIgcHJpb3JpdHkgd29yaywgYnV0IGluIGNhc2UgaXQgZG9lc24ndCwgd2UgbmVlZCB0byBwcmVwYXJlIHRvXG4vLyByZW5kZXIgc29tZXRoaW5nLCBpZiB3ZSB0aW1lIG91dC4gRXZlbiBpZiB0aGF0IHJlcXVpcmVzIHVzIHRvIGRlbGV0ZSBldmVyeXRoaW5nIGFuZFxuLy8gc2tpcCBoeWRyYXRpb24uXG4vLyBEZWxheSBoYXZpbmcgdG8gZG8gdGhpcyBhcyBsb25nIGFzIHRoZSBzdXNwZW5zZSB0aW1lb3V0IGFsbG93cyB1cy5cbnJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTt2YXIgX2NhcHR1cmVkVmFsdWU9Y3JlYXRlQ2FwdHVyZWRWYWx1ZShuZXcgRXJyb3IoJ1RoaXMgU3VzcGVuc2UgYm91bmRhcnkgcmVjZWl2ZWQgYW4gdXBkYXRlIGJlZm9yZSBpdCBmaW5pc2hlZCAnKydoeWRyYXRpbmcuIFRoaXMgY2F1c2VkIHRoZSBib3VuZGFyeSB0byBzd2l0Y2ggdG8gY2xpZW50IHJlbmRlcmluZy4gJysnVGhlIHVzdWFsIHdheSB0byBmaXggdGhpcyBpcyB0byB3cmFwIHRoZSBvcmlnaW5hbCB1cGRhdGUgJysnaW4gc3RhcnRUcmFuc2l0aW9uLicpKTtyZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyxfY2FwdHVyZWRWYWx1ZSk7fWVsc2UgaWYoaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhzdXNwZW5zZUluc3RhbmNlKSl7Ly8gVGhpcyBjb21wb25lbnQgaXMgc3RpbGwgcGVuZGluZyBtb3JlIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBjYW4ndCBoeWRyYXRlIGl0c1xuLy8gY29udGVudC4gV2UgdHJlYXQgaXQgYXMgaWYgdGhpcyBjb21wb25lbnQgc3VzcGVuZGVkIGl0c2VsZi4gSXQgbWlnaHQgc2VlbSBhcyBpZlxuLy8gd2UgY291bGQganVzdCB0cnkgdG8gcmVuZGVyIGl0IGNsaWVudC1zaWRlIGluc3RlYWQuIEhvd2V2ZXIsIHRoaXMgd2lsbCBwZXJmb3JtIGFcbi8vIGxvdCBvZiB1bm5lY2Vzc2FyeSB3b3JrIGFuZCBpcyB1bmxpa2VseSB0byBjb21wbGV0ZSBzaW5jZSBpdCBvZnRlbiB3aWxsIHN1c3BlbmRcbi8vIG9uIG1pc3NpbmcgZGF0YSBhbnl3YXkuIEFkZGl0aW9uYWxseSwgdGhlIHNlcnZlciBtaWdodCBiZSBhYmxlIHRvIHJlbmRlciBtb3JlXG4vLyB0aGFuIHdlIGNhbiBvbiB0aGUgY2xpZW50IHlldC4gSW4gdGhhdCBjYXNlIHdlJ2QgZW5kIHVwIHdpdGggbW9yZSBmYWxsYmFjayBzdGF0ZXNcbi8vIG9uIHRoZSBjbGllbnQgdGhhbiBpZiB3ZSBqdXN0IGxlYXZlIGl0IGFsb25lLiBJZiB0aGUgc2VydmVyIHRpbWVzIG91dCBvciBlcnJvcnNcbi8vIHRoZXNlIHNob3VsZCB1cGRhdGUgdGhpcyBib3VuZGFyeSB0byB0aGUgcGVybWFuZW50IEZhbGxiYWNrIHN0YXRlIGluc3RlYWQuXG4vLyBNYXJrIGl0IGFzIGhhdmluZyBjYXB0dXJlZCAoaS5lLiBzdXNwZW5kZWQpLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7Ly8gTGVhdmUgdGhlIGNoaWxkIGluIHBsYWNlLiBJLmUuIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50Llxud29ya0luUHJvZ3Jlc3MuY2hpbGQ9Y3VycmVudC5jaGlsZDsvLyBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIHJldHJ5IHRoaXMgYm91bmRhcnkgb25jZSB0aGUgc2VydmVyIGhhcyBzZW50IHRoZSByZXN1bHQuXG52YXIgcmV0cnk9cmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeS5iaW5kKG51bGwsY3VycmVudCk7cmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkoc3VzcGVuc2VJbnN0YW5jZSxyZXRyeSk7cmV0dXJuIG51bGw7fWVsc2V7Ly8gVGhpcyBpcyB0aGUgZmlyc3QgYXR0ZW1wdC5cbnJlZW50ZXJIeWRyYXRpb25TdGF0ZUZyb21EZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxzdXNwZW5zZUluc3RhbmNlLHN1c3BlbnNlU3RhdGUudHJlZUNvbnRleHQpO3ZhciBwcmltYXJ5Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudD1tb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLHByaW1hcnlDaGlsZHJlbik7Ly8gTWFyayB0aGUgY2hpbGRyZW4gYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4vLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4vLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbi8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4vLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cbnByaW1hcnlDaGlsZEZyYWdtZW50LmZsYWdzfD1IeWRyYXRpbmc7cmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O319ZWxzZXsvLyBUaGlzIGlzIHRoZSBzZWNvbmQgcmVuZGVyIHBhc3MuIFdlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIGh5ZHJhdGVkLCBidXRcbi8vIHNvbWV0aGluZyBlaXRoZXIgc3VzcGVuZGVkIG9yIGVycm9yZWQuXG5pZih3b3JrSW5Qcm9ncmVzcy5mbGFncyZGb3JjZUNsaWVudFJlbmRlcil7Ly8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVHJ5IGFnYWluIHdpdGhvdXQgaHlkcmF0aW5nLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3MmPX5Gb3JjZUNsaWVudFJlbmRlcjt2YXIgX2NhcHR1cmVkVmFsdWUyPWNyZWF0ZUNhcHR1cmVkVmFsdWUobmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIHRoaXMgU3VzcGVuc2UgYm91bmRhcnkuICcrJ1N3aXRjaGVkIHRvIGNsaWVudCByZW5kZXJpbmcuJykpO3JldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzLF9jYXB0dXJlZFZhbHVlMik7fWVsc2UgaWYod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSE9PW51bGwpey8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYW5kIHdlIHNob3VsZCBzdGlsbCBiZSBpbiBkZWh5ZHJhdGVkIG1vZGUuXG4vLyBMZWF2ZSB0aGUgZXhpc3RpbmcgY2hpbGQgaW4gcGxhY2UuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZD1jdXJyZW50LmNoaWxkOy8vIFRoZSBkZWh5ZHJhdGVkIGNvbXBsZXRpb24gcGFzcyBleHBlY3RzIHRoaXMgZmxhZyB0byBiZSB0aGVyZVxuLy8gYnV0IHRoZSBub3JtYWwgc3VzcGVuc2UgcGFzcyBkb2Vzbid0Llxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7cmV0dXJuIG51bGw7fWVsc2V7Ly8gU3VzcGVuZGVkIGJ1dCB3ZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGluIGRlaHlkcmF0ZWQgbW9kZS5cbi8vIFRoZXJlZm9yZSB3ZSBub3cgaGF2ZSB0byByZW5kZXIgdGhlIGZhbGxiYWNrLlxudmFyIG5leHRQcmltYXJ5Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBuZXh0RmFsbGJhY2tDaGlsZHJlbj1uZXh0UHJvcHMuZmFsbGJhY2s7dmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudD1tb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRQcmltYXJ5Q2hpbGRyZW4sbmV4dEZhbGxiYWNrQ2hpbGRyZW4scmVuZGVyTGFuZXMpO3ZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0PXdvcmtJblByb2dyZXNzLmNoaWxkO19wcmltYXJ5Q2hpbGRGcmFnbWVudDQubWVtb2l6ZWRTdGF0ZT1tb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9U1VTUEVOREVEX01BUktFUjtyZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O319fWZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlcixyZW5kZXJMYW5lcyxwcm9wYWdhdGlvblJvb3Qpe2ZpYmVyLmxhbmVzPW1lcmdlTGFuZXMoZmliZXIubGFuZXMscmVuZGVyTGFuZXMpO3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZSE9PW51bGwpe2FsdGVybmF0ZS5sYW5lcz1tZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcyxyZW5kZXJMYW5lcyk7fXNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLHJlbmRlckxhbmVzLHByb3BhZ2F0aW9uUm9vdCk7fWZ1bmN0aW9uIHByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcyxmaXJzdENoaWxkLHJlbmRlckxhbmVzKXsvLyBNYXJrIGFueSBTdXNwZW5zZSBib3VuZGFyaWVzIHdpdGggZmFsbGJhY2tzIGFzIGhhdmluZyB3b3JrIHRvIGRvLlxuLy8gSWYgdGhleSB3ZXJlIHByZXZpb3VzbHkgZm9yY2VkIGludG8gZmFsbGJhY2tzLCB0aGV5IG1heSBub3cgYmUgYWJsZVxuLy8gdG8gdW5ibG9jay5cbnZhciBub2RlPWZpcnN0Q2hpbGQ7d2hpbGUobm9kZSE9PW51bGwpe2lmKG5vZGUudGFnPT09U3VzcGVuc2VDb21wb25lbnQpe3ZhciBzdGF0ZT1ub2RlLm1lbW9pemVkU3RhdGU7aWYoc3RhdGUhPT1udWxsKXtzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSxyZW5kZXJMYW5lcyx3b3JrSW5Qcm9ncmVzcyk7fX1lbHNlIGlmKG5vZGUudGFnPT09U3VzcGVuc2VMaXN0Q29tcG9uZW50KXsvLyBJZiB0aGUgdGFpbCBpcyBoaWRkZW4gdGhlcmUgbWlnaHQgbm90IGJlIGFuIFN1c3BlbnNlIGJvdW5kYXJpZXNcbi8vIHRvIHNjaGVkdWxlIHdvcmsgb24uIEluIHRoaXMgY2FzZSB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG9uIHRoZVxuLy8gbGlzdCBpdHNlbGYuXG4vLyBXZSBkb24ndCBoYXZlIHRvIHRyYXZlcnNlIHRvIHRoZSBjaGlsZHJlbiBvZiB0aGUgbGlzdCBzaW5jZVxuLy8gdGhlIGxpc3Qgd2lsbCBwcm9wYWdhdGUgdGhlIGNoYW5nZSB3aGVuIGl0IHJlcmVuZGVycy5cbnNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihub2RlLHJlbmRlckxhbmVzLHdvcmtJblByb2dyZXNzKTt9ZWxzZSBpZihub2RlLmNoaWxkIT09bnVsbCl7bm9kZS5jaGlsZC5yZXR1cm49bm9kZTtub2RlPW5vZGUuY2hpbGQ7Y29udGludWU7fWlmKG5vZGU9PT13b3JrSW5Qcm9ncmVzcyl7cmV0dXJuO313aGlsZShub2RlLnNpYmxpbmc9PT1udWxsKXtpZihub2RlLnJldHVybj09PW51bGx8fG5vZGUucmV0dXJuPT09d29ya0luUHJvZ3Jlc3Mpe3JldHVybjt9bm9kZT1ub2RlLnJldHVybjt9bm9kZS5zaWJsaW5nLnJldHVybj1ub2RlLnJldHVybjtub2RlPW5vZGUuc2libGluZzt9fWZ1bmN0aW9uIGZpbmRMYXN0Q29udGVudFJvdyhmaXJzdENoaWxkKXsvLyBUaGlzIGlzIGdvaW5nIHRvIGZpbmQgdGhlIGxhc3Qgcm93IGFtb25nIHRoZXNlIGNoaWxkcmVuIHRoYXQgaXMgYWxyZWFkeVxuLy8gc2hvd2luZyBjb250ZW50IG9uIHRoZSBzY3JlZW4sIGFzIG9wcG9zZWQgdG8gYmVpbmcgaW4gZmFsbGJhY2sgc3RhdGUgb3Jcbi8vIG5ldy4gSWYgYSByb3cgaGFzIG11bHRpcGxlIFN1c3BlbnNlIGJvdW5kYXJpZXMsIGFueSBvZiB0aGVtIGJlaW5nIGluIHRoZVxuLy8gZmFsbGJhY2sgc3RhdGUsIGNvdW50cyBhcyB0aGUgd2hvbGUgcm93IGJlaW5nIGluIGEgZmFsbGJhY2sgc3RhdGUuXG4vLyBOb3RlIHRoYXQgdGhlIFwicm93c1wiIHdpbGwgYmUgd29ya0luUHJvZ3Jlc3MsIGJ1dCBhbnkgbmVzdGVkIGNoaWxkcmVuXG4vLyB3aWxsIHN0aWxsIGJlIGN1cnJlbnQgc2luY2Ugd2UgaGF2ZW4ndCByZW5kZXJlZCB0aGVtIHlldC4gVGhlIG1vdW50ZWRcbi8vIG9yZGVyIG1heSBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG5ldyBvcmRlci4gV2UgdXNlIHRoZSBuZXcgb3JkZXIuXG52YXIgcm93PWZpcnN0Q2hpbGQ7dmFyIGxhc3RDb250ZW50Um93PW51bGw7d2hpbGUocm93IT09bnVsbCl7dmFyIGN1cnJlbnRSb3c9cm93LmFsdGVybmF0ZTsvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5pZihjdXJyZW50Um93IT09bnVsbCYmZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpPT09bnVsbCl7bGFzdENvbnRlbnRSb3c9cm93O31yb3c9cm93LnNpYmxpbmc7fXJldHVybiBsYXN0Q29udGVudFJvdzt9ZnVuY3Rpb24gdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcil7e2lmKHJldmVhbE9yZGVyIT09dW5kZWZpbmVkJiZyZXZlYWxPcmRlciE9PSdmb3J3YXJkcycmJnJldmVhbE9yZGVyIT09J2JhY2t3YXJkcycmJnJldmVhbE9yZGVyIT09J3RvZ2V0aGVyJyYmIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSl7ZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdPXRydWU7aWYodHlwZW9mIHJldmVhbE9yZGVyPT09J3N0cmluZycpe3N3aXRjaChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKXtjYXNlJ3RvZ2V0aGVyJzpjYXNlJ2ZvcndhcmRzJzpjYXNlJ2JhY2t3YXJkcyc6e2Vycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcrJ1VzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJyxyZXZlYWxPcmRlcixyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTticmVhazt9Y2FzZSdmb3J3YXJkJzpjYXNlJ2JhY2t3YXJkJzp7ZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJysnUmVhY3QgdXNlcyB0aGUgLXMgc3VmZml4IGluIHRoZSBzcGVsbGluZy4gVXNlIFwiJXNzXCIgaW5zdGVhZC4nLHJldmVhbE9yZGVyLHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO2JyZWFrO31kZWZhdWx0OmVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcrJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycscmV2ZWFsT3JkZXIpO2JyZWFrO319ZWxzZXtlcnJvcignJXMgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnKydEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLHJldmVhbE9yZGVyKTt9fX19ZnVuY3Rpb24gdmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSxyZXZlYWxPcmRlcil7e2lmKHRhaWxNb2RlIT09dW5kZWZpbmVkJiYhZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdKXtpZih0YWlsTW9kZSE9PSdjb2xsYXBzZWQnJiZ0YWlsTW9kZSE9PSdoaWRkZW4nKXtkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV09dHJ1ZTtlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnKydEaWQgeW91IG1lYW4gXCJjb2xsYXBzZWRcIiBvciBcImhpZGRlblwiPycsdGFpbE1vZGUpO31lbHNlIGlmKHJldmVhbE9yZGVyIT09J2ZvcndhcmRzJyYmcmV2ZWFsT3JkZXIhPT0nYmFja3dhcmRzJyl7ZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdPXRydWU7ZXJyb3IoJzxTdXNwZW5zZUxpc3QgdGFpbD1cIiVzXCIgLz4gaXMgb25seSB2YWxpZCBpZiByZXZlYWxPcmRlciBpcyAnKydcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gJysnRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsdGFpbE1vZGUpO319fX1mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCxpbmRleCl7e3ZhciBpc0FuQXJyYXk9aXNBcnJheShjaGlsZFNsb3QpO3ZhciBpc0l0ZXJhYmxlPSFpc0FuQXJyYXkmJnR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCk9PT0nZnVuY3Rpb24nO2lmKGlzQW5BcnJheXx8aXNJdGVyYWJsZSl7dmFyIHR5cGU9aXNBbkFycmF5PydhcnJheSc6J2l0ZXJhYmxlJztlcnJvcignQSBuZXN0ZWQgJXMgd2FzIHBhc3NlZCB0byByb3cgIyVzIGluIDxTdXNwZW5zZUxpc3QgLz4uIFdyYXAgaXQgaW4gJysnYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogJysnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+IC4uLiAnKyc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj57JXN9PC9TdXNwZW5zZUxpc3Q+IC4uLiAnKyc8L1N1c3BlbnNlTGlzdD4nLHR5cGUsaW5kZXgsdHlwZSk7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fWZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4oY2hpbGRyZW4scmV2ZWFsT3JkZXIpe3tpZigocmV2ZWFsT3JkZXI9PT0nZm9yd2FyZHMnfHxyZXZlYWxPcmRlcj09PSdiYWNrd2FyZHMnKSYmY2hpbGRyZW4hPT11bmRlZmluZWQmJmNoaWxkcmVuIT09bnVsbCYmY2hpbGRyZW4hPT1mYWxzZSl7aWYoaXNBcnJheShjaGlsZHJlbikpe2Zvcih2YXIgaT0wO2k8Y2hpbGRyZW4ubGVuZ3RoO2krKyl7aWYoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0saSkpe3JldHVybjt9fX1lbHNle3ZhciBpdGVyYXRvckZuPWdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO2lmKHR5cGVvZiBpdGVyYXRvckZuPT09J2Z1bmN0aW9uJyl7dmFyIGNoaWxkcmVuSXRlcmF0b3I9aXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtpZihjaGlsZHJlbkl0ZXJhdG9yKXt2YXIgc3RlcD1jaGlsZHJlbkl0ZXJhdG9yLm5leHQoKTt2YXIgX2k9MDtmb3IoOyFzdGVwLmRvbmU7c3RlcD1jaGlsZHJlbkl0ZXJhdG9yLm5leHQoKSl7aWYoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSxfaSkpe3JldHVybjt9X2krKzt9fX1lbHNle2Vycm9yKCdBIHNpbmdsZSByb3cgd2FzIHBhc3NlZCB0byBhIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9XCIlc1wiIC8+LiAnKydUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gJysnRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JyxyZXZlYWxPcmRlcik7fX19fX1mdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsaXNCYWNrd2FyZHMsdGFpbCxsYXN0Q29udGVudFJvdyx0YWlsTW9kZSl7dmFyIHJlbmRlclN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYocmVuZGVyU3RhdGU9PT1udWxsKXt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPXtpc0JhY2t3YXJkczppc0JhY2t3YXJkcyxyZW5kZXJpbmc6bnVsbCxyZW5kZXJpbmdTdGFydFRpbWU6MCxsYXN0Omxhc3RDb250ZW50Um93LHRhaWw6dGFpbCx0YWlsTW9kZTp0YWlsTW9kZX07fWVsc2V7Ly8gV2UgY2FuIHJldXNlIHRoZSBleGlzdGluZyBvYmplY3QgZnJvbSBwcmV2aW91cyByZW5kZXJzLlxucmVuZGVyU3RhdGUuaXNCYWNrd2FyZHM9aXNCYWNrd2FyZHM7cmVuZGVyU3RhdGUucmVuZGVyaW5nPW51bGw7cmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lPTA7cmVuZGVyU3RhdGUubGFzdD1sYXN0Q29udGVudFJvdztyZW5kZXJTdGF0ZS50YWlsPXRhaWw7cmVuZGVyU3RhdGUudGFpbE1vZGU9dGFpbE1vZGU7fX0vLyBUaGlzIGNhbiBlbmQgdXAgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IG11bHRpcGxlIHBhc3Nlcy5cbi8vIFRoZSBmaXJzdCBwYXNzIHNwbGl0cyB0aGUgY2hpbGRyZW4gZmliZXJzIGludG8gdHdvIHNldHMuIEEgaGVhZCBhbmQgdGFpbC5cbi8vIFdlIGZpcnN0IHJlbmRlciB0aGUgaGVhZC4gSWYgYW55dGhpbmcgaXMgaW4gZmFsbGJhY2sgc3RhdGUsIHdlIGRvIGFub3RoZXJcbi8vIHBhc3MgdGhyb3VnaCBiZWdpbldvcmsgdG8gcmVyZW5kZXIgYWxsIGNoaWxkcmVuIChpbmNsdWRpbmcgdGhlIHRhaWwpIHdpdGhcbi8vIHRoZSBmb3JjZSBzdXNwZW5kIGNvbnRleHQuIElmIHRoZSBmaXJzdCByZW5kZXIgZGlkbid0IGhhdmUgYW55dGhpbmcgaW5cbi8vIGluIGZhbGxiYWNrIHN0YXRlLiBUaGVuIHdlIHJlbmRlciBlYWNoIHJvdyBpbiB0aGUgdGFpbCBvbmUtYnktb25lLlxuLy8gVGhhdCBoYXBwZW5zIGluIHRoZSBjb21wbGV0ZVdvcmsgcGhhc2Ugd2l0aG91dCBnb2luZyBiYWNrIHRvIGJlZ2luV29yay5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt2YXIgbmV4dFByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgcmV2ZWFsT3JkZXI9bmV4dFByb3BzLnJldmVhbE9yZGVyO3ZhciB0YWlsTW9kZT1uZXh0UHJvcHMudGFpbDt2YXIgbmV3Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpO3ZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUscmV2ZWFsT3JkZXIpO3ZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4obmV3Q2hpbGRyZW4scmV2ZWFsT3JkZXIpO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV3Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3ZhciBzdXNwZW5zZUNvbnRleHQ9c3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O3ZhciBzaG91bGRGb3JjZUZhbGxiYWNrPWhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtpZihzaG91bGRGb3JjZUZhbGxiYWNrKXtzdXNwZW5zZUNvbnRleHQ9c2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTt9ZWxzZXt2YXIgZGlkU3VzcGVuZEJlZm9yZT1jdXJyZW50IT09bnVsbCYmKGN1cnJlbnQuZmxhZ3MmRGlkQ2FwdHVyZSkhPT1Ob0ZsYWdzO2lmKGRpZFN1c3BlbmRCZWZvcmUpey8vIElmIHdlIHByZXZpb3VzbHkgZm9yY2VkIGEgZmFsbGJhY2ssIHdlIG5lZWQgdG8gc2NoZWR1bGUgd29ya1xuLy8gb24gYW55IG5lc3RlZCBib3VuZGFyaWVzIHRvIGxldCB0aGVtIGtub3cgdG8gdHJ5IHRvIHJlbmRlclxuLy8gYWdhaW4uIFRoaXMgaXMgdGhlIHNhbWUgYXMgY29udGV4dCB1cGRhdGluZy5cbnByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcyx3b3JrSW5Qcm9ncmVzcy5jaGlsZCxyZW5kZXJMYW5lcyk7fXN1c3BlbnNlQ29udGV4dD1zZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQpO31wdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLHN1c3BlbnNlQ29udGV4dCk7aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlKXsvLyBJbiBsZWdhY3kgbW9kZSwgU3VzcGVuc2VMaXN0IGRvZXNuJ3Qgd29yayBzbyB3ZSBqdXN0XG4vLyB1c2UgbWFrZSBpdCBhIG5vb3AgYnkgdHJlYXRpbmcgaXQgYXMgdGhlIGRlZmF1bHQgcmV2ZWFsT3JkZXIuXG53b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW51bGw7fWVsc2V7c3dpdGNoKHJldmVhbE9yZGVyKXtjYXNlJ2ZvcndhcmRzJzp7dmFyIGxhc3RDb250ZW50Um93PWZpbmRMYXN0Q29udGVudFJvdyh3b3JrSW5Qcm9ncmVzcy5jaGlsZCk7dmFyIHRhaWw7aWYobGFzdENvbnRlbnRSb3c9PT1udWxsKXsvLyBUaGUgd2hvbGUgbGlzdCBpcyBwYXJ0IG9mIHRoZSB0YWlsLlxuLy8gVE9ETzogV2UgY291bGQgZmFzdCBwYXRoIGJ5IGp1c3QgcmVuZGVyaW5nIHRoZSB0YWlsIG5vdy5cbnRhaWw9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9bnVsbDt9ZWxzZXsvLyBEaXNjb25uZWN0IHRoZSB0YWlsIHJvd3MgYWZ0ZXIgdGhlIGNvbnRlbnQgcm93LlxuLy8gV2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZW0gc2VwYXJhdGVseSBsYXRlci5cbnRhaWw9bGFzdENvbnRlbnRSb3cuc2libGluZztsYXN0Q29udGVudFJvdy5zaWJsaW5nPW51bGw7fWluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcyxmYWxzZSwvLyBpc0JhY2t3YXJkc1xudGFpbCxsYXN0Q29udGVudFJvdyx0YWlsTW9kZSk7YnJlYWs7fWNhc2UnYmFja3dhcmRzJzp7Ly8gV2UncmUgZ29pbmcgdG8gZmluZCB0aGUgZmlyc3Qgcm93IHRoYXQgaGFzIGV4aXN0aW5nIGNvbnRlbnQuXG4vLyBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIGdvaW5nIHRvIHJldmVyc2UgdGhlIGxpc3Qgb2YgZXZlcnl0aGluZ1xuLy8gd2UgcGFzcyBpbiB0aGUgbWVhbnRpbWUuIFRoYXQncyBnb2luZyB0byBiZSBvdXIgdGFpbCBpbiByZXZlcnNlXG4vLyBvcmRlci5cbnZhciBfdGFpbD1udWxsO3ZhciByb3c9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9bnVsbDt3aGlsZShyb3chPT1udWxsKXt2YXIgY3VycmVudFJvdz1yb3cuYWx0ZXJuYXRlOy8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cbmlmKGN1cnJlbnRSb3chPT1udWxsJiZmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdyk9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1haW4gY29udGVudC5cbndvcmtJblByb2dyZXNzLmNoaWxkPXJvdzticmVhazt9dmFyIG5leHRSb3c9cm93LnNpYmxpbmc7cm93LnNpYmxpbmc9X3RhaWw7X3RhaWw9cm93O3Jvdz1uZXh0Um93O30vLyBUT0RPOiBJZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBpcyBudWxsLCB3ZSBjYW4gY29udGludWUgb24gdGhlIHRhaWwgaW1tZWRpYXRlbHkuXG5pbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsdHJ1ZSwvLyBpc0JhY2t3YXJkc1xuX3RhaWwsbnVsbCwvLyBsYXN0XG50YWlsTW9kZSk7YnJlYWs7fWNhc2UndG9nZXRoZXInOntpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsZmFsc2UsLy8gaXNCYWNrd2FyZHNcbm51bGwsLy8gdGFpbFxubnVsbCwvLyBsYXN0XG51bmRlZmluZWQpO2JyZWFrO31kZWZhdWx0OnsvLyBUaGUgZGVmYXVsdCByZXZlYWwgb3JkZXIgaXMgdGhlIHNhbWUgYXMgbm90IGhhdmluZ1xuLy8gYSBib3VuZGFyeS5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDt9fX1yZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXtwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyx3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7dmFyIG5leHRDaGlsZHJlbj13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7aWYoY3VycmVudD09PW51bGwpey8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4vLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2Vcbi8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbndvcmtJblByb2dyZXNzLmNoaWxkPXJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLG51bGwsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTt9ZWxzZXtyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7fXJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9dmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyPWZhbHNlO2Z1bmN0aW9uIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt2YXIgcHJvdmlkZXJUeXBlPXdvcmtJblByb2dyZXNzLnR5cGU7dmFyIGNvbnRleHQ9cHJvdmlkZXJUeXBlLl9jb250ZXh0O3ZhciBuZXdQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIG9sZFByb3BzPXdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7dmFyIG5ld1ZhbHVlPW5ld1Byb3BzLnZhbHVlO3tpZighKCd2YWx1ZSdpbiBuZXdQcm9wcykpe2lmKCFoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlcil7aGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXI9dHJ1ZTtlcnJvcignVGhlIGB2YWx1ZWAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGA8Q29udGV4dC5Qcm92aWRlcj5gLiBEaWQgeW91IG1pc3NwZWxsIGl0IG9yIGZvcmdldCB0byBwYXNzIGl0PycpO319dmFyIHByb3ZpZGVyUHJvcFR5cGVzPXdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO2lmKHByb3ZpZGVyUHJvcFR5cGVzKXtjaGVja1Byb3BUeXBlcyhwcm92aWRlclByb3BUeXBlcyxuZXdQcm9wcywncHJvcCcsJ0NvbnRleHQuUHJvdmlkZXInKTt9fXB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyxjb250ZXh0LG5ld1ZhbHVlKTt7aWYob2xkUHJvcHMhPT1udWxsKXt2YXIgb2xkVmFsdWU9b2xkUHJvcHMudmFsdWU7aWYob2JqZWN0SXMob2xkVmFsdWUsbmV3VmFsdWUpKXsvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuaWYob2xkUHJvcHMuY2hpbGRyZW49PT1uZXdQcm9wcy5jaGlsZHJlbiYmIWhhc0NvbnRleHRDaGFuZ2VkKCkpe3JldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO319ZWxzZXsvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbi8vIHRoZW0gdG8gdXBkYXRlLlxucHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcyxjb250ZXh0LHJlbmRlckxhbmVzKTt9fX12YXIgbmV3Q2hpbGRyZW49bmV3UHJvcHMuY2hpbGRyZW47cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXdDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO312YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyPWZhbHNlO2Z1bmN0aW9uIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt2YXIgY29udGV4dD13b3JrSW5Qcm9ncmVzcy50eXBlOy8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuLy8gREVWIG1vZGUsIHdlIGNyZWF0ZSBhIHNlcGFyYXRlIG9iamVjdCBmb3IgQ29udGV4dC5Db25zdW1lciB0aGF0IGFjdHNcbi8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbi8vIHJlZHVjZSBzaXplIGFuZCBvdmVyaGVhZC4gVGhlIHNlcGFyYXRlIG9iamVjdCByZWZlcmVuY2VzIGNvbnRleHQgdmlhXG4vLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbi8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cbntpZihjb250ZXh0Ll9jb250ZXh0PT09dW5kZWZpbmVkKXsvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbi8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbi8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbmlmKGNvbnRleHQhPT1jb250ZXh0LkNvbnN1bWVyKXtpZighaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKXtoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXI9dHJ1ZTtlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJysnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTt9fX1lbHNle2NvbnRleHQ9Y29udGV4dC5fY29udGV4dDt9fXZhciBuZXdQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIHJlbmRlcj1uZXdQcm9wcy5jaGlsZHJlbjt7aWYodHlwZW9mIHJlbmRlciE9PSdmdW5jdGlvbicpe2Vycm9yKCdBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgJytcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIrJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnKydpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LicpO319cHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO3ZhciBuZXdWYWx1ZT1yZWFkQ29udGV4dChjb250ZXh0KTt7bWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO312YXIgbmV3Q2hpbGRyZW47e1JlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudD13b3JrSW5Qcm9ncmVzcztzZXRJc1JlbmRlcmluZyh0cnVlKTtuZXdDaGlsZHJlbj1yZW5kZXIobmV3VmFsdWUpO3NldElzUmVuZGVyaW5nKGZhbHNlKTt9e21hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7fS8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1QZXJmb3JtZWRXb3JrO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV3Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3JldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKXtkaWRSZWNlaXZlVXBkYXRlPXRydWU7fWZ1bmN0aW9uIHJlc2V0U3VzcGVuZGVkQ3VycmVudE9uTW91bnRJbkxlZ2FjeU1vZGUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyl7aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlKXtpZihjdXJyZW50IT09bnVsbCl7Ly8gQSBsYXp5IGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4vLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG5jdXJyZW50LmFsdGVybmF0ZT1udWxsO3dvcmtJblByb2dyZXNzLmFsdGVybmF0ZT1udWxsOy8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcbndvcmtJblByb2dyZXNzLmZsYWdzfD1QbGFjZW1lbnQ7fX19ZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXtpZihjdXJyZW50IT09bnVsbCl7Ly8gUmV1c2UgcHJldmlvdXMgZGVwZW5kZW5jaWVzXG53b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM9Y3VycmVudC5kZXBlbmRlbmNpZXM7fXsvLyBEb24ndCB1cGRhdGUgXCJiYXNlXCIgcmVuZGVyIHRpbWVzIGZvciBiYWlsb3V0cy5cbnN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7fW1hcmtTa2lwcGVkVXBkYXRlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMpOy8vIENoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIGFueSBwZW5kaW5nIHdvcmsuXG5pZighaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcyx3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSl7Ly8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuLy8gVE9ETzogT25jZSB3ZSBhZGQgYmFjayByZXN1bWluZywgd2Ugc2hvdWxkIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBhcmVcbi8vIGEgd29yay1pbi1wcm9ncmVzcyBzZXQuIElmIHNvLCB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZWlyIGVmZmVjdHMuXG57cmV0dXJuIG51bGw7fX0vLyBUaGlzIGZpYmVyIGRvZXNuJ3QgaGF2ZSB3b3JrLCBidXQgaXRzIHN1YnRyZWUgZG9lcy4gQ2xvbmUgdGhlIGNoaWxkXG4vLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LHdvcmtJblByb2dyZXNzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHJlbW91bnRGaWJlcihjdXJyZW50LG9sZFdvcmtJblByb2dyZXNzLG5ld1dvcmtJblByb2dyZXNzKXt7dmFyIHJldHVybkZpYmVyPW9sZFdvcmtJblByb2dyZXNzLnJldHVybjtpZihyZXR1cm5GaWJlcj09PW51bGwpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG50aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzd2FwIHRoZSByb290IGZpYmVyLicpO30vLyBEaXNjb25uZWN0IGZyb20gdGhlIG9sZCBjdXJyZW50LlxuLy8gSXQgd2lsbCBnZXQgZGVsZXRlZC5cbmN1cnJlbnQuYWx0ZXJuYXRlPW51bGw7b2xkV29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlPW51bGw7Ly8gQ29ubmVjdCB0byB0aGUgbmV3IHRyZWUuXG5uZXdXb3JrSW5Qcm9ncmVzcy5pbmRleD1vbGRXb3JrSW5Qcm9ncmVzcy5pbmRleDtuZXdXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nPW9sZFdvcmtJblByb2dyZXNzLnNpYmxpbmc7bmV3V29ya0luUHJvZ3Jlc3MucmV0dXJuPW9sZFdvcmtJblByb2dyZXNzLnJldHVybjtuZXdXb3JrSW5Qcm9ncmVzcy5yZWY9b2xkV29ya0luUHJvZ3Jlc3MucmVmOy8vIFJlcGxhY2UgdGhlIGNoaWxkL3NpYmxpbmcgcG9pbnRlcnMgYWJvdmUgaXQuXG5pZihvbGRXb3JrSW5Qcm9ncmVzcz09PXJldHVybkZpYmVyLmNoaWxkKXtyZXR1cm5GaWJlci5jaGlsZD1uZXdXb3JrSW5Qcm9ncmVzczt9ZWxzZXt2YXIgcHJldlNpYmxpbmc9cmV0dXJuRmliZXIuY2hpbGQ7aWYocHJldlNpYmxpbmc9PT1udWxsKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xudGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLicpO313aGlsZShwcmV2U2libGluZy5zaWJsaW5nIT09b2xkV29ya0luUHJvZ3Jlc3Mpe3ByZXZTaWJsaW5nPXByZXZTaWJsaW5nLnNpYmxpbmc7aWYocHJldlNpYmxpbmc9PT1udWxsKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xudGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHRoZSBwcmV2aW91cyBzaWJsaW5nLicpO319cHJldlNpYmxpbmcuc2libGluZz1uZXdXb3JrSW5Qcm9ncmVzczt9Ly8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuLy8gU2luY2UgdGhlIG9sZCBmaWJlciBpcyBkaXNjb25uZWN0ZWQsIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgbWFudWFsbHkuXG52YXIgZGVsZXRpb25zPXJldHVybkZpYmVyLmRlbGV0aW9ucztpZihkZWxldGlvbnM9PT1udWxsKXtyZXR1cm5GaWJlci5kZWxldGlvbnM9W2N1cnJlbnRdO3JldHVybkZpYmVyLmZsYWdzfD1DaGlsZERlbGV0aW9uO31lbHNle2RlbGV0aW9ucy5wdXNoKGN1cnJlbnQpO31uZXdXb3JrSW5Qcm9ncmVzcy5mbGFnc3w9UGxhY2VtZW50Oy8vIFJlc3RhcnQgd29yayBmcm9tIHRoZSBuZXcgZmliZXIuXG5yZXR1cm4gbmV3V29ya0luUHJvZ3Jlc3M7fX1mdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LHJlbmRlckxhbmVzKXsvLyBCZWZvcmUgcGVyZm9ybWluZyBhbiBlYXJseSBiYWlsb3V0LCB3ZSBtdXN0IGNoZWNrIGlmIHRoZXJlIGFyZSBwZW5kaW5nXG4vLyB1cGRhdGVzIG9yIGNvbnRleHQuXG52YXIgdXBkYXRlTGFuZXM9Y3VycmVudC5sYW5lcztpZihpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLHJlbmRlckxhbmVzKSl7cmV0dXJuIHRydWU7fS8vIE5vIHBlbmRpbmcgdXBkYXRlLCBidXQgYmVjYXVzZSBjb250ZXh0IGlzIHByb3BhZ2F0ZWQgbGF6aWx5LCB3ZSBuZWVkXG5yZXR1cm4gZmFsc2U7fWZ1bmN0aW9uIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpey8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbi8vIHRoZSBiZWdpbiBwaGFzZS4gVGhlcmUncyBzdGlsbCBzb21lIGJvb2trZWVwaW5nIHdlIHRoYXQgbmVlZHMgdG8gYmUgZG9uZVxuLy8gaW4gdGhpcyBvcHRpbWl6ZWQgcGF0aCwgbW9zdGx5IHB1c2hpbmcgc3R1ZmYgb250byB0aGUgc3RhY2suXG5zd2l0Y2god29ya0luUHJvZ3Jlc3MudGFnKXtjYXNlIEhvc3RSb290OnB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO3ZhciByb290PXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtyZXNldEh5ZHJhdGlvblN0YXRlKCk7YnJlYWs7Y2FzZSBIb3N0Q29tcG9uZW50OnB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7YnJlYWs7Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIENvbXBvbmVudD13b3JrSW5Qcm9ncmVzcy50eXBlO2lmKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpe3B1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO31icmVhazt9Y2FzZSBIb3N0UG9ydGFsOnB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIENvbnRleHRQcm92aWRlcjp7dmFyIG5ld1ZhbHVlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMudmFsdWU7dmFyIGNvbnRleHQ9d29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsY29udGV4dCxuZXdWYWx1ZSk7YnJlYWs7fWNhc2UgUHJvZmlsZXI6ey8vIFByb2ZpbGVyIHNob3VsZCBvbmx5IGNhbGwgb25SZW5kZXIgd2hlbiBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzIGFjdHVhbGx5IHJlbmRlcmVkLlxudmFyIGhhc0NoaWxkV29yaz1pbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO2lmKGhhc0NoaWxkV29yayl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVVwZGF0ZTt9ey8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbi8vIFRoZXNlIGFyZSByZXNldCBkdXJpbmcgcmVuZGVyIHRvIGFsbG93IHRoZSBEZXZUb29scyBjb21taXQgaG9vayBhIGNoYW5jZSB0byByZWFkIHRoZW0sXG52YXIgc3RhdGVOb2RlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb249MDtzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uPTA7fX1icmVhaztjYXNlIFN1c3BlbnNlQ29tcG9uZW50Ont2YXIgc3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtpZihzdGF0ZSE9PW51bGwpe2lmKHN0YXRlLmRlaHlkcmF0ZWQhPT1udWxsKXtwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpOy8vIFdlIGtub3cgdGhhdCB0aGlzIGNvbXBvbmVudCB3aWxsIHN1c3BlbmQgYWdhaW4gYmVjYXVzZSBpZiBpdCBoYXNcbi8vIGJlZW4gdW5zdXNwZW5kZWQgaXQgaGFzIGNvbW1pdHRlZCBhcyBhIHJlc29sdmVkIFN1c3BlbnNlIGNvbXBvbmVudC5cbi8vIElmIGl0IG5lZWRzIHRvIGJlIHJldHJpZWQsIGl0IHNob3VsZCBoYXZlIHdvcmsgc2NoZWR1bGVkIG9uIGl0Llxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7Ly8gV2Ugc2hvdWxkIG5ldmVyIHJlbmRlciB0aGUgY2hpbGRyZW4gb2YgYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IHVudGlsIHdlXG4vLyB1cGdyYWRlIGl0LiBXZSByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsuXG5yZXR1cm4gbnVsbDt9Ly8gSWYgdGhpcyBib3VuZGFyeSBpcyBjdXJyZW50bHkgdGltZWQgb3V0LCB3ZSBuZWVkIHRvIGRlY2lkZVxuLy8gd2hldGhlciB0byByZXRyeSB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgb3IgdG8gc2tpcCBvdmVyIGl0IGFuZFxuLy8gZ28gc3RyYWlnaHQgdG8gdGhlIGZhbGxiYWNrLiBDaGVjayB0aGUgcHJpb3JpdHkgb2YgdGhlIHByaW1hcnlcbi8vIGNoaWxkIGZyYWdtZW50LlxudmFyIHByaW1hcnlDaGlsZEZyYWdtZW50PXdvcmtJblByb2dyZXNzLmNoaWxkO3ZhciBwcmltYXJ5Q2hpbGRMYW5lcz1wcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzO2lmKGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMscHJpbWFyeUNoaWxkTGFuZXMpKXsvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gVXNlIHRoZSBub3JtYWwgcGF0aFxuLy8gdG8gYXR0ZW1wdCB0byByZW5kZXIgdGhlIHByaW1hcnkgY2hpbGRyZW4gYWdhaW4uXG5yZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fWVsc2V7Ly8gVGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBwZW5kaW5nIHdvcmsgbWFya2VkXG4vLyBvbiBpdFxucHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBkbyBub3QgaGF2ZSBwZW5kaW5nIHdvcmsgd2l0aCBzdWZmaWNpZW50XG4vLyBwcmlvcml0eS4gQmFpbG91dC5cbnZhciBjaGlsZD1iYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2lmKGNoaWxkIT09bnVsbCl7Ly8gVGhlIGZhbGxiYWNrIGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBTa2lwIG92ZXIgdGhlXG4vLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbnJldHVybiBjaGlsZC5zaWJsaW5nO31lbHNley8vIE5vdGU6IFdlIGNhbiByZXR1cm4gYG51bGxgIGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IGNoZWNrZWRcbi8vIHdoZXRoZXIgdGhlcmUgd2VyZSBuZXN0ZWQgY29udGV4dCBjb25zdW1lcnMsIHZpYSB0aGUgY2FsbCB0b1xuLy8gYGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmtgIGFib3ZlLlxucmV0dXJuIG51bGw7fX19ZWxzZXtwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpO31icmVhazt9Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6e3ZhciBkaWRTdXNwZW5kQmVmb3JlPShjdXJyZW50LmZsYWdzJkRpZENhcHR1cmUpIT09Tm9GbGFnczt2YXIgX2hhc0NoaWxkV29yaz1pbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO2lmKGRpZFN1c3BlbmRCZWZvcmUpe2lmKF9oYXNDaGlsZFdvcmspey8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4vLyBzYW1lIGNoaWxkcmVuIHRoZW4gd2UncmUgc3RpbGwgaW4gcHJvZ3Jlc3NpdmUgbG9hZGluZyBzdGF0ZS5cbi8vIFNvbWV0aGluZyBtaWdodCBnZXQgdW5ibG9ja2VkIGJ5IHN0YXRlIHVwZGF0ZXMgb3IgcmV0cmllcyBpbiB0aGVcbi8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbi8vIHBhdGggdG8gY29tcHV0ZSB0aGUgY29ycmVjdCB0YWlsLlxucmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9Ly8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuLy8gdGhlbSBnb3QgcmV0cmllZCBzbyB0aGV5J2xsIHN0aWxsIGJlIGJsb2NrZWQgaW4gdGhlIHNhbWUgd2F5XG4vLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0Llxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7fS8vIElmIG5vdGhpbmcgc3VzcGVuZGVkIGJlZm9yZSBhbmQgd2UncmUgcmVuZGVyaW5nIHRoZSBzYW1lIGNoaWxkcmVuLFxuLy8gdGhlbiB0aGUgdGFpbCBkb2Vzbid0IG1hdHRlci4gQW55dGhpbmcgbmV3IHRoYXQgc3VzcGVuZHMgd2lsbCB3b3JrXG4vLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG52YXIgcmVuZGVyU3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtpZihyZW5kZXJTdGF0ZSE9PW51bGwpey8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbi8vIHVwZGF0ZSBpbiB0aGUgcGFzdCBidXQgZGlkbid0IGNvbXBsZXRlIGl0LlxucmVuZGVyU3RhdGUucmVuZGVyaW5nPW51bGw7cmVuZGVyU3RhdGUudGFpbD1udWxsO3JlbmRlclN0YXRlLmxhc3RFZmZlY3Q9bnVsbDt9cHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO2lmKF9oYXNDaGlsZFdvcmspe2JyZWFrO31lbHNley8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2Zcbi8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cbnJldHVybiBudWxsO319Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6Y2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6ey8vIE5lZWQgdG8gY2hlY2sgaWYgdGhlIHRyZWUgc3RpbGwgbmVlZHMgdG8gYmUgZGVmZXJyZWQuIFRoaXMgaXNcbi8vIGFsbW9zdCBpZGVudGljYWwgdG8gdGhlIGxvZ2ljIHVzZWQgaW4gdGhlIG5vcm1hbCB1cGRhdGUgcGF0aCxcbi8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuLy8gYXQgdGhlIG5leHQgbGV2ZWwgaW5zdGVhZCBvZiB0aGlzIG9uZSwgYmVjYXVzZSB0aGUgY2hpbGQgcHJvcHNcbi8vIGhhdmUgbm90IGNoYW5nZWQuIFdoaWNoIGlzIGZpbmUuXG4vLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbi8vIHBhdGggZnJvbSB0aGUgbm9ybWFsIHBhdGguIEknbSB0ZW1wdGVkIHRvIGRvIGEgbGFiZWxlZCBicmVhayBoZXJlXG4vLyBidXQgSSB3b24ndCA6KVxud29ya0luUHJvZ3Jlc3MubGFuZXM9Tm9MYW5lcztyZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO319cmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fWZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt7aWYod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50JiZjdXJyZW50IT09bnVsbCl7Ly8gVGhpcyB3aWxsIHJlc3RhcnQgdGhlIGJlZ2luIHBoYXNlIHdpdGggYSBuZXcgZmliZXIuXG5yZXR1cm4gcmVtb3VudEZpYmVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsd29ya0luUHJvZ3Jlc3Mua2V5LHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyx3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lcnx8bnVsbCx3b3JrSW5Qcm9ncmVzcy5tb2RlLHdvcmtJblByb2dyZXNzLmxhbmVzKSk7fX1pZihjdXJyZW50IT09bnVsbCl7dmFyIG9sZFByb3BzPWN1cnJlbnQubWVtb2l6ZWRQcm9wczt2YXIgbmV3UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO2lmKG9sZFByb3BzIT09bmV3UHJvcHN8fGhhc0NvbnRleHRDaGFuZ2VkKCl8fC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxud29ya0luUHJvZ3Jlc3MudHlwZSE9PWN1cnJlbnQudHlwZSl7Ly8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4vLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuZGlkUmVjZWl2ZVVwZGF0ZT10cnVlO31lbHNley8vIE5laXRoZXIgcHJvcHMgbm9yIGxlZ2FjeSBjb250ZXh0IGNoYW5nZXMuIENoZWNrIGlmIHRoZXJlJ3MgYSBwZW5kaW5nXG4vLyB1cGRhdGUgb3IgY29udGV4dCBjaGFuZ2UuXG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0PWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQscmVuZGVyTGFuZXMpO2lmKCFoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQmJi8vIElmIHRoaXMgaXMgdGhlIHNlY29uZCBwYXNzIG9mIGFuIGVycm9yIG9yIHN1c3BlbnNlIGJvdW5kYXJ5LCB0aGVyZVxuLy8gbWF5IG5vdCBiZSB3b3JrIHNjaGVkdWxlZCBvbiBgY3VycmVudGAsIHNvIHdlIGNoZWNrIGZvciB0aGlzIGZsYWcuXG4od29ya0luUHJvZ3Jlc3MuZmxhZ3MmRGlkQ2FwdHVyZSk9PT1Ob0ZsYWdzKXsvLyBObyBwZW5kaW5nIHVwZGF0ZXMgb3IgY29udGV4dC4gQmFpbCBvdXQgbm93LlxuZGlkUmVjZWl2ZVVwZGF0ZT1mYWxzZTtyZXR1cm4gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fWlmKChjdXJyZW50LmZsYWdzJkZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpIT09Tm9GbGFncyl7Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbmRpZFJlY2VpdmVVcGRhdGU9dHJ1ZTt9ZWxzZXsvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbiB0aGlzIGZpYmVyLCBidXQgdGhlcmUgYXJlIG5vIG5ldyBwcm9wc1xuLy8gbm9yIGxlZ2FjeSBjb250ZXh0LiBTZXQgdGhpcyB0byBmYWxzZS4gSWYgYW4gdXBkYXRlIHF1ZXVlIG9yIGNvbnRleHRcbi8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4vLyB0aGUgY29tcG9uZW50IHdpbGwgYXNzdW1lIHRoZSBjaGlsZHJlbiBoYXZlIG5vdCBjaGFuZ2VkIGFuZCBiYWlsIG91dC5cbmRpZFJlY2VpdmVVcGRhdGU9ZmFsc2U7fX19ZWxzZXtkaWRSZWNlaXZlVXBkYXRlPWZhbHNlO2lmKGdldElzSHlkcmF0aW5nKCkmJmlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpKXsvLyBDaGVjayBpZiB0aGlzIGNoaWxkIGJlbG9uZ3MgdG8gYSBsaXN0IG9mIG11bGlwbGUgY2hpbGRyZW4gaW5cbi8vIGl0cyBwYXJlbnQuXG4vL1xuLy8gSW4gYSB0cnVlIG11bHRpLXRocmVhZGVkIGltcGxlbWVudGF0aW9uLCB3ZSB3b3VsZCByZW5kZXIgY2hpbGRyZW4gb25cbi8vIHBhcmFsbGVsIHRocmVhZHMuIFRoaXMgd291bGQgcmVwcmVzZW50IHRoZSBiZWdpbm5pbmcgb2YgYSBuZXcgcmVuZGVyXG4vLyB0aHJlYWQgZm9yIHRoaXMgc3VidHJlZS5cbi8vXG4vLyBXZSBvbmx5IHVzZSB0aGlzIGZvciBpZCBnZW5lcmF0aW9uIGR1cmluZyBoeWRyYXRpb24sIHdoaWNoIGlzIHdoeSB0aGVcbi8vIGxvZ2ljIGlzIGxvY2F0ZWQgaW4gdGhpcyBzcGVjaWFsIGJyYW5jaC5cbnZhciBzbG90SW5kZXg9d29ya0luUHJvZ3Jlc3MuaW5kZXg7dmFyIG51bWJlck9mRm9ya3M9Z2V0Rm9ya3NBdExldmVsKCk7cHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyxudW1iZXJPZkZvcmtzLHNsb3RJbmRleCk7fX0vLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbi8vIFRPRE86IFRoaXMgYXNzdW1lcyB0aGF0IHdlJ3JlIGFib3V0IHRvIGV2YWx1YXRlIHRoZSBjb21wb25lbnQgYW5kIHByb2Nlc3Ncbi8vIHRoZSB1cGRhdGUgcXVldWUuIEhvd2V2ZXIsIHRoZXJlJ3MgYW4gZXhjZXB0aW9uOiBTaW1wbGVNZW1vQ29tcG9uZW50XG4vLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbi8vIG1vdmUgdGhpcyBhc3NpZ25tZW50IG91dCBvZiB0aGUgY29tbW9uIHBhdGggYW5kIGludG8gZWFjaCBicmFuY2guXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz1Ob0xhbmVzO3N3aXRjaCh3b3JrSW5Qcm9ncmVzcy50YWcpe2Nhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDp7cmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHdvcmtJblByb2dyZXNzLnR5cGUscmVuZGVyTGFuZXMpO31jYXNlIExhenlDb21wb25lbnQ6e3ZhciBlbGVtZW50VHlwZT13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtyZXR1cm4gbW91bnRMYXp5Q29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsZWxlbWVudFR5cGUscmVuZGVyTGFuZXMpO31jYXNlIEZ1bmN0aW9uQ29tcG9uZW50Ont2YXIgQ29tcG9uZW50PXdvcmtJblByb2dyZXNzLnR5cGU7dmFyIHVucmVzb2x2ZWRQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIHJlc29sdmVkUHJvcHM9d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU9PT1Db21wb25lbnQ/dW5yZXNvbHZlZFByb3BzOnJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LHVucmVzb2x2ZWRQcm9wcyk7cmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHJlc29sdmVkUHJvcHMscmVuZGVyTGFuZXMpO31jYXNlIENsYXNzQ29tcG9uZW50Ont2YXIgX0NvbXBvbmVudD13b3JrSW5Qcm9ncmVzcy50eXBlO3ZhciBfdW5yZXNvbHZlZFByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgX3Jlc29sdmVkUHJvcHM9d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU9PT1fQ29tcG9uZW50P191bnJlc29sdmVkUHJvcHM6cmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50LF91bnJlc29sdmVkUHJvcHMpO3JldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLF9Db21wb25lbnQsX3Jlc29sdmVkUHJvcHMscmVuZGVyTGFuZXMpO31jYXNlIEhvc3RSb290OnJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjYXNlIEhvc3RDb21wb25lbnQ6cmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Y2FzZSBIb3N0VGV4dDpyZXR1cm4gdXBkYXRlSG9zdFRleHQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDpyZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Y2FzZSBIb3N0UG9ydGFsOnJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Y2FzZSBGb3J3YXJkUmVmOnt2YXIgdHlwZT13b3JrSW5Qcm9ncmVzcy50eXBlO3ZhciBfdW5yZXNvbHZlZFByb3BzMj13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIF9yZXNvbHZlZFByb3BzMj13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZT09PXR5cGU/X3VucmVzb2x2ZWRQcm9wczI6cmVzb2x2ZURlZmF1bHRQcm9wcyh0eXBlLF91bnJlc29sdmVkUHJvcHMyKTtyZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LHdvcmtJblByb2dyZXNzLHR5cGUsX3Jlc29sdmVkUHJvcHMyLHJlbmRlckxhbmVzKTt9Y2FzZSBGcmFnbWVudDpyZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Y2FzZSBNb2RlOnJldHVybiB1cGRhdGVNb2RlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2Nhc2UgUHJvZmlsZXI6cmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2Nhc2UgQ29udGV4dFByb3ZpZGVyOnJldHVybiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Y2FzZSBDb250ZXh0Q29uc3VtZXI6cmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjYXNlIE1lbW9Db21wb25lbnQ6e3ZhciBfdHlwZTI9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgX3VucmVzb2x2ZWRQcm9wczM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOy8vIFJlc29sdmUgb3V0ZXIgcHJvcHMgZmlyc3QsIHRoZW4gcmVzb2x2ZSBpbm5lciBwcm9wcy5cbnZhciBfcmVzb2x2ZWRQcm9wczM9cmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIsX3VucmVzb2x2ZWRQcm9wczMpO3tpZih3b3JrSW5Qcm9ncmVzcy50eXBlIT09d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpe3ZhciBvdXRlclByb3BUeXBlcz1fdHlwZTIucHJvcFR5cGVzO2lmKG91dGVyUHJvcFR5cGVzKXtjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcyxfcmVzb2x2ZWRQcm9wczMsLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbidwcm9wJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoX3R5cGUyKSk7fX19X3Jlc29sdmVkUHJvcHMzPXJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLnR5cGUsX3Jlc29sdmVkUHJvcHMzKTtyZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLF90eXBlMixfcmVzb2x2ZWRQcm9wczMscmVuZGVyTGFuZXMpO31jYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e3JldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Msd29ya0luUHJvZ3Jlc3MudHlwZSx3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMscmVuZGVyTGFuZXMpO31jYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDp7dmFyIF9Db21wb25lbnQyPXdvcmtJblByb2dyZXNzLnR5cGU7dmFyIF91bnJlc29sdmVkUHJvcHM0PXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgX3Jlc29sdmVkUHJvcHM0PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlPT09X0NvbXBvbmVudDI/X3VucmVzb2x2ZWRQcm9wczQ6cmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50MixfdW5yZXNvbHZlZFByb3BzNCk7cmV0dXJuIG1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsX0NvbXBvbmVudDIsX3Jlc29sdmVkUHJvcHM0LHJlbmRlckxhbmVzKTt9Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6e3JldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fWNhc2UgU2NvcGVDb21wb25lbnQ6e2JyZWFrO31jYXNlIE9mZnNjcmVlbkNvbXBvbmVudDp7cmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9fXRocm93IG5ldyBFcnJvcihcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIrd29ya0luUHJvZ3Jlc3MudGFnK1wiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiKydSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fWZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3Mpey8vIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbi8vIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVVwZGF0ZTt9ZnVuY3Rpb24gbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UmVmO3t3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UmVmU3RhdGljO319dmFyIGFwcGVuZEFsbENoaWxkcmVuO3ZhciB1cGRhdGVIb3N0Q29udGFpbmVyO3ZhciB1cGRhdGVIb3N0Q29tcG9uZW50JDE7dmFyIHVwZGF0ZUhvc3RUZXh0JDE7ey8vIE11dGF0aW9uIG1vZGVcbmFwcGVuZEFsbENoaWxkcmVuPWZ1bmN0aW9uKHBhcmVudCx3b3JrSW5Qcm9ncmVzcyxuZWVkc1Zpc2liaWxpdHlUb2dnbGUsaXNIaWRkZW4pey8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxudmFyIG5vZGU9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7d2hpbGUobm9kZSE9PW51bGwpe2lmKG5vZGUudGFnPT09SG9zdENvbXBvbmVudHx8bm9kZS50YWc9PT1Ib3N0VGV4dCl7YXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCxub2RlLnN0YXRlTm9kZSk7fWVsc2UgaWYobm9kZS50YWc9PT1Ib3N0UG9ydGFsKTtlbHNlIGlmKG5vZGUuY2hpbGQhPT1udWxsKXtub2RlLmNoaWxkLnJldHVybj1ub2RlO25vZGU9bm9kZS5jaGlsZDtjb250aW51ZTt9aWYobm9kZT09PXdvcmtJblByb2dyZXNzKXtyZXR1cm47fXdoaWxlKG5vZGUuc2libGluZz09PW51bGwpe2lmKG5vZGUucmV0dXJuPT09bnVsbHx8bm9kZS5yZXR1cm49PT13b3JrSW5Qcm9ncmVzcyl7cmV0dXJuO31ub2RlPW5vZGUucmV0dXJuO31ub2RlLnNpYmxpbmcucmV0dXJuPW5vZGUucmV0dXJuO25vZGU9bm9kZS5zaWJsaW5nO319O3VwZGF0ZUhvc3RDb250YWluZXI9ZnVuY3Rpb24oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyl7Ly8gTm9vcFxufTt1cGRhdGVIb3N0Q29tcG9uZW50JDE9ZnVuY3Rpb24oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyx0eXBlLG5ld1Byb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSl7Ly8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbi8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG52YXIgb2xkUHJvcHM9Y3VycmVudC5tZW1vaXplZFByb3BzO2lmKG9sZFByb3BzPT09bmV3UHJvcHMpey8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2Vcbi8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG5yZXR1cm47fS8vIElmIHdlIGdldCB1cGRhdGVkIGJlY2F1c2Ugb25lIG9mIG91ciBjaGlsZHJlbiB1cGRhdGVkLCB3ZSBkb24ndFxuLy8gaGF2ZSBuZXdQcm9wcyBzbyB3ZSdsbCBoYXZlIHRvIHJldXNlIHRoZW0uXG4vLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbi8vIEV2ZW4gYmV0dGVyIHdvdWxkIGJlIGlmIGNoaWxkcmVuIHdlcmVuJ3Qgc3BlY2lhbCBjYXNlZCBhdCBhbGwgdGhvLlxudmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTt2YXIgY3VycmVudEhvc3RDb250ZXh0PWdldEhvc3RDb250ZXh0KCk7Ly8gVE9ETzogRXhwZXJpZW5jaW5nIGFuIGVycm9yIHdoZXJlIG9sZFByb3BzIGlzIG51bGwuIFN1Z2dlc3RzIGEgaG9zdFxuLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbi8vIHJlbGF0ZWQgdG8gYGhpZGRlbmAuXG52YXIgdXBkYXRlUGF5bG9hZD1wcmVwYXJlVXBkYXRlKGluc3RhbmNlLHR5cGUsb2xkUHJvcHMsbmV3UHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlLGN1cnJlbnRIb3N0Q29udGV4dCk7Ly8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG53b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT11cGRhdGVQYXlsb2FkOy8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG5pZih1cGRhdGVQYXlsb2FkKXttYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTt9fTt1cGRhdGVIb3N0VGV4dCQxPWZ1bmN0aW9uKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Msb2xkVGV4dCxuZXdUZXh0KXsvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbmlmKG9sZFRleHQhPT1uZXdUZXh0KXttYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTt9fTt9ZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayl7aWYoZ2V0SXNIeWRyYXRpbmcoKSl7Ly8gSWYgd2UncmUgaHlkcmF0aW5nLCB3ZSBzaG91bGQgY29uc3VtZSBhcyBtYW55IGl0ZW1zIGFzIHdlIGNhblxuLy8gc28gd2UgZG9uJ3QgbGVhdmUgYW55IGJlaGluZC5cbnJldHVybjt9c3dpdGNoKHJlbmRlclN0YXRlLnRhaWxNb2RlKXtjYXNlJ2hpZGRlbic6ey8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4vLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbi8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbi8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuLy8gdGhlcmUgYXJlIGFueS5cbnZhciB0YWlsTm9kZT1yZW5kZXJTdGF0ZS50YWlsO3ZhciBsYXN0VGFpbE5vZGU9bnVsbDt3aGlsZSh0YWlsTm9kZSE9PW51bGwpe2lmKHRhaWxOb2RlLmFsdGVybmF0ZSE9PW51bGwpe2xhc3RUYWlsTm9kZT10YWlsTm9kZTt9dGFpbE5vZGU9dGFpbE5vZGUuc2libGluZzt9Ly8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuaWYobGFzdFRhaWxOb2RlPT09bnVsbCl7Ly8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbnJlbmRlclN0YXRlLnRhaWw9bnVsbDt9ZWxzZXsvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbi8vIGluc2VydGVkLlxubGFzdFRhaWxOb2RlLnNpYmxpbmc9bnVsbDt9YnJlYWs7fWNhc2UnY29sbGFwc2VkJzp7Ly8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbi8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4vLyB0aGVyZSBhcmUgYW55LlxudmFyIF90YWlsTm9kZT1yZW5kZXJTdGF0ZS50YWlsO3ZhciBfbGFzdFRhaWxOb2RlPW51bGw7d2hpbGUoX3RhaWxOb2RlIT09bnVsbCl7aWYoX3RhaWxOb2RlLmFsdGVybmF0ZSE9PW51bGwpe19sYXN0VGFpbE5vZGU9X3RhaWxOb2RlO31fdGFpbE5vZGU9X3RhaWxOb2RlLnNpYmxpbmc7fS8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbi8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cbmlmKF9sYXN0VGFpbE5vZGU9PT1udWxsKXsvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuaWYoIWhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayYmcmVuZGVyU3RhdGUudGFpbCE9PW51bGwpey8vIFdlIHN1c3BlbmRlZCBkdXJpbmcgdGhlIGhlYWQuIFdlIHdhbnQgdG8gc2hvdyBhdCBsZWFzdCBvbmVcbi8vIHJvdyBhdCB0aGUgdGFpbC4gU28gd2UnbGwga2VlcCBvbiBhbmQgY3V0IG9mZiB0aGUgcmVzdC5cbnJlbmRlclN0YXRlLnRhaWwuc2libGluZz1udWxsO31lbHNle3JlbmRlclN0YXRlLnRhaWw9bnVsbDt9fWVsc2V7Ly8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4vLyBpbnNlcnRlZC5cbl9sYXN0VGFpbE5vZGUuc2libGluZz1udWxsO31icmVhazt9fX1mdW5jdGlvbiBidWJibGVQcm9wZXJ0aWVzKGNvbXBsZXRlZFdvcmspe3ZhciBkaWRCYWlsb3V0PWNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlIT09bnVsbCYmY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQ9PT1jb21wbGV0ZWRXb3JrLmNoaWxkO3ZhciBuZXdDaGlsZExhbmVzPU5vTGFuZXM7dmFyIHN1YnRyZWVGbGFncz1Ob0ZsYWdzO2lmKCFkaWRCYWlsb3V0KXsvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbmlmKChjb21wbGV0ZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXsvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxudmFyIGFjdHVhbER1cmF0aW9uPWNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247dmFyIHRyZWVCYXNlRHVyYXRpb249Y29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO3ZhciBjaGlsZD1jb21wbGV0ZWRXb3JrLmNoaWxkO3doaWxlKGNoaWxkIT09bnVsbCl7bmV3Q2hpbGRMYW5lcz1tZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsbWVyZ2VMYW5lcyhjaGlsZC5sYW5lcyxjaGlsZC5jaGlsZExhbmVzKSk7c3VidHJlZUZsYWdzfD1jaGlsZC5zdWJ0cmVlRmxhZ3M7c3VidHJlZUZsYWdzfD1jaGlsZC5mbGFnczsvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC4gVGhpcyB2YWx1ZSB3aWxsXG4vLyBvbmx5IGJlIHVwZGF0ZWQgaWYgd29yayBpcyBkb25lIG9uIHRoZSBmaWJlciAoaS5lLiBpdCBkb2Vzbid0IGJhaWxvdXQpLlxuLy8gV2hlbiB3b3JrIGlzIGRvbmUsIGl0IHNob3VsZCBidWJibGUgdG8gdGhlIHBhcmVudCdzIGFjdHVhbER1cmF0aW9uLiBJZlxuLy8gdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSwgdGhlblxuLy8gdGhpcyB2YWx1ZSB3aWxsIHJlZmxlY3QgdGhlIGFtb3VudCBvZiB0aW1lIHNwZW50IHdvcmtpbmcgb24gYSBwcmV2aW91c1xuLy8gcmVuZGVyLiBJbiB0aGF0IGNhc2UgaXQgc2hvdWxkIG5vdCBidWJibGUuIFdlIGRldGVybWluZSB3aGV0aGVyIGl0IHdhc1xuLy8gY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cbmFjdHVhbER1cmF0aW9uKz1jaGlsZC5hY3R1YWxEdXJhdGlvbjt0cmVlQmFzZUR1cmF0aW9uKz1jaGlsZC50cmVlQmFzZUR1cmF0aW9uO2NoaWxkPWNoaWxkLnNpYmxpbmc7fWNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb249YWN0dWFsRHVyYXRpb247Y29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uPXRyZWVCYXNlRHVyYXRpb247fWVsc2V7dmFyIF9jaGlsZD1jb21wbGV0ZWRXb3JrLmNoaWxkO3doaWxlKF9jaGlsZCE9PW51bGwpe25ld0NoaWxkTGFuZXM9bWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLG1lcmdlTGFuZXMoX2NoaWxkLmxhbmVzLF9jaGlsZC5jaGlsZExhbmVzKSk7c3VidHJlZUZsYWdzfD1fY2hpbGQuc3VidHJlZUZsYWdzO3N1YnRyZWVGbGFnc3w9X2NoaWxkLmZsYWdzOy8vIFVwZGF0ZSB0aGUgcmV0dXJuIHBvaW50ZXIgc28gdGhlIHRyZWUgaXMgY29uc2lzdGVudC4gVGhpcyBpcyBhIGNvZGVcbi8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5fY2hpbGQucmV0dXJuPWNvbXBsZXRlZFdvcms7X2NoaWxkPV9jaGlsZC5zaWJsaW5nO319Y29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3N8PXN1YnRyZWVGbGFnczt9ZWxzZXsvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbmlmKChjb21wbGV0ZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXsvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxudmFyIF90cmVlQmFzZUR1cmF0aW9uPWNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjt2YXIgX2NoaWxkMj1jb21wbGV0ZWRXb3JrLmNoaWxkO3doaWxlKF9jaGlsZDIhPT1udWxsKXtuZXdDaGlsZExhbmVzPW1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcyxtZXJnZUxhbmVzKF9jaGlsZDIubGFuZXMsX2NoaWxkMi5jaGlsZExhbmVzKSk7Ly8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4vLyBzbyB3ZSBzaG91bGQgYnViYmxlIHRob3NlIHVwIGV2ZW4gZHVyaW5nIGEgYmFpbG91dC4gQWxsIHRoZSBvdGhlclxuLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcbi8vIGlnbm9yZSB0aGVtLlxuc3VidHJlZUZsYWdzfD1fY2hpbGQyLnN1YnRyZWVGbGFncyZTdGF0aWNNYXNrO3N1YnRyZWVGbGFnc3w9X2NoaWxkMi5mbGFncyZTdGF0aWNNYXNrO190cmVlQmFzZUR1cmF0aW9uKz1fY2hpbGQyLnRyZWVCYXNlRHVyYXRpb247X2NoaWxkMj1fY2hpbGQyLnNpYmxpbmc7fWNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbj1fdHJlZUJhc2VEdXJhdGlvbjt9ZWxzZXt2YXIgX2NoaWxkMz1jb21wbGV0ZWRXb3JrLmNoaWxkO3doaWxlKF9jaGlsZDMhPT1udWxsKXtuZXdDaGlsZExhbmVzPW1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcyxtZXJnZUxhbmVzKF9jaGlsZDMubGFuZXMsX2NoaWxkMy5jaGlsZExhbmVzKSk7Ly8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4vLyBzbyB3ZSBzaG91bGQgYnViYmxlIHRob3NlIHVwIGV2ZW4gZHVyaW5nIGEgYmFpbG91dC4gQWxsIHRoZSBvdGhlclxuLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcbi8vIGlnbm9yZSB0aGVtLlxuc3VidHJlZUZsYWdzfD1fY2hpbGQzLnN1YnRyZWVGbGFncyZTdGF0aWNNYXNrO3N1YnRyZWVGbGFnc3w9X2NoaWxkMy5mbGFncyZTdGF0aWNNYXNrOy8vIFVwZGF0ZSB0aGUgcmV0dXJuIHBvaW50ZXIgc28gdGhlIHRyZWUgaXMgY29uc2lzdGVudC4gVGhpcyBpcyBhIGNvZGVcbi8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5fY2hpbGQzLnJldHVybj1jb21wbGV0ZWRXb3JrO19jaGlsZDM9X2NoaWxkMy5zaWJsaW5nO319Y29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3N8PXN1YnRyZWVGbGFnczt9Y29tcGxldGVkV29yay5jaGlsZExhbmVzPW5ld0NoaWxkTGFuZXM7cmV0dXJuIGRpZEJhaWxvdXQ7fWZ1bmN0aW9uIGNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0U3RhdGUpe2lmKGhhc1VuaHlkcmF0ZWRUYWlsTm9kZXMoKSYmKHdvcmtJblByb2dyZXNzLm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlJiYod29ya0luUHJvZ3Jlc3MuZmxhZ3MmRGlkQ2FwdHVyZSk9PT1Ob0ZsYWdzKXt3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzKHdvcmtJblByb2dyZXNzKTtyZXNldEh5ZHJhdGlvblN0YXRlKCk7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PUZvcmNlQ2xpZW50UmVuZGVyfEluY29tcGxldGV8U2hvdWxkQ2FwdHVyZTtyZXR1cm4gZmFsc2U7fXZhciB3YXNIeWRyYXRlZD1wb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7aWYobmV4dFN0YXRlIT09bnVsbCYmbmV4dFN0YXRlLmRlaHlkcmF0ZWQhPT1udWxsKXsvLyBXZSBtaWdodCBiZSBpbnNpZGUgYSBoeWRyYXRpb24gc3RhdGUgdGhlIGZpcnN0IHRpbWUgd2UncmUgcGlja2luZyB1cCB0aGlzXG4vLyBTdXNwZW5zZSBib3VuZGFyeSwgYW5kIGFsc28gYWZ0ZXIgd2UndmUgcmVlbnRlcmVkIGl0IGZvciBmdXJ0aGVyIGh5ZHJhdGlvbi5cbmlmKGN1cnJlbnQ9PT1udWxsKXtpZighd2FzSHlkcmF0ZWQpe3Rocm93IG5ldyBFcnJvcignQSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudCB3YXMgY29tcGxldGVkIHdpdGhvdXQgYSBoeWRyYXRlZCBub2RlLiAnKydUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO31wcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO2J1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3tpZigod29ya0luUHJvZ3Jlc3MubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpe3ZhciBpc1RpbWVkT3V0U3VzcGVuc2U9bmV4dFN0YXRlIT09bnVsbDtpZihpc1RpbWVkT3V0U3VzcGVuc2Upey8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxudmFyIHByaW1hcnlDaGlsZEZyYWdtZW50PXdvcmtJblByb2dyZXNzLmNoaWxkO2lmKHByaW1hcnlDaGlsZEZyYWdtZW50IT09bnVsbCl7Ly8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3JcbndvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24tPXByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247fX19fXJldHVybiBmYWxzZTt9ZWxzZXsvLyBXZSBtaWdodCBoYXZlIHJlZW50ZXJlZCB0aGlzIGJvdW5kYXJ5IHRvIGh5ZHJhdGUgaXQuIElmIHNvLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBoeWRyYXRpb25cbi8vIHN0YXRlIHNpbmNlIHdlJ3JlIG5vdyBleGl0aW5nIG91dCBvZiBpdC4gcG9wSHlkcmF0aW9uU3RhdGUgZG9lc24ndCBkbyB0aGF0IGZvciB1cy5cbnJlc2V0SHlkcmF0aW9uU3RhdGUoKTtpZigod29ya0luUHJvZ3Jlc3MuZmxhZ3MmRGlkQ2FwdHVyZSk9PT1Ob0ZsYWdzKXsvLyBUaGlzIGJvdW5kYXJ5IGRpZCBub3Qgc3VzcGVuZCBzbyBpdCdzIG5vdyBoeWRyYXRlZCBhbmQgdW5zdXNwZW5kZWQuXG53b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW51bGw7fS8vIElmIG5vdGhpbmcgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBtYXJrIHRoaXMgYm91bmRhcnlcbi8vIGFzIGhhdmluZyBoeWRyYXRlZCBzbyBldmVudHMga25vdyB0aGF0IHRoZXkncmUgZnJlZSB0byBiZSBpbnZva2VkLlxuLy8gSXQncyBhbHNvIGEgc2lnbmFsIHRvIHJlcGxheSBldmVudHMgYW5kIHRoZSBzdXNwZW5zZSBjYWxsYmFjay5cbi8vIElmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggcmV0cnkgbGlzdGVuZXJzLlxuLy8gU28gd2UgbWlnaHQgYXMgd2VsbCBhbHdheXMgbWFyayB0aGlzLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVVwZGF0ZTtidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTt7aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXt2YXIgX2lzVGltZWRPdXRTdXNwZW5zZT1uZXh0U3RhdGUhPT1udWxsO2lmKF9pc1RpbWVkT3V0U3VzcGVuc2Upey8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxudmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudD13b3JrSW5Qcm9ncmVzcy5jaGlsZDtpZihfcHJpbWFyeUNoaWxkRnJhZ21lbnQhPT1udWxsKXsvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxud29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbi09X3ByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247fX19fXJldHVybiBmYWxzZTt9fWVsc2V7Ly8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB0aGlzIHRyZWUuIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsXG4vLyB0aGVyZSBtYXkgaGF2ZSBiZWVuIHJlY292ZXJhYmxlIGVycm9ycyBkdXJpbmcgZmlyc3QgaHlkcmF0aW9uXG4vLyBhdHRlbXB0LiBJZiBzbywgYWRkIHRoZW0gdG8gYSBxdWV1ZSBzbyB3ZSBjYW4gbG9nIHRoZW0gaW4gdGhlXG4vLyBjb21taXQgcGhhc2UuXG51cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpOy8vIEZhbGwgdGhyb3VnaCB0byBub3JtYWwgU3VzcGVuc2UgcGF0aFxucmV0dXJuIHRydWU7fX1mdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7dmFyIG5ld1Byb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbi8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuLy8gZm9yIGh5ZHJhdGlvbi5cbnBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtzd2l0Y2god29ya0luUHJvZ3Jlc3MudGFnKXtjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6Y2FzZSBMYXp5Q29tcG9uZW50OmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIEZyYWdtZW50OmNhc2UgTW9kZTpjYXNlIFByb2ZpbGVyOmNhc2UgQ29udGV4dENvbnN1bWVyOmNhc2UgTWVtb0NvbXBvbmVudDpidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDtjYXNlIENsYXNzQ29tcG9uZW50Ont2YXIgQ29tcG9uZW50PXdvcmtJblByb2dyZXNzLnR5cGU7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7cG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7fWJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO31jYXNlIEhvc3RSb290Ont2YXIgZmliZXJSb290PXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO3Jlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO2lmKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCl7ZmliZXJSb290LmNvbnRleHQ9ZmliZXJSb290LnBlbmRpbmdDb250ZXh0O2ZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dD1udWxsO31pZihjdXJyZW50PT09bnVsbHx8Y3VycmVudC5jaGlsZD09PW51bGwpey8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbi8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbnZhciB3YXNIeWRyYXRlZD1wb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7aWYod2FzSHlkcmF0ZWQpey8vIElmIHdlIGh5ZHJhdGVkLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2NoZWR1bGUgYW4gdXBkYXRlIGZvclxuLy8gdGhlIGNvbW1pdCBzaWRlLWVmZmVjdHMgb24gdGhlIHJvb3QuXG5tYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTt9ZWxzZXtpZihjdXJyZW50IT09bnVsbCl7dmFyIHByZXZTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7aWYoLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNsaWVudCByb290XG4hcHJldlN0YXRlLmlzRGVoeWRyYXRlZHx8Ly8gQ2hlY2sgaWYgd2UgcmV2ZXJ0ZWQgdG8gY2xpZW50IHJlbmRlcmluZyAoZS5nLiBkdWUgdG8gYW4gZXJyb3IpXG4od29ya0luUHJvZ3Jlc3MuZmxhZ3MmRm9yY2VDbGllbnRSZW5kZXIpIT09Tm9GbGFncyl7Ly8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGNsZWFyIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzdGFydCBvZiB0aGVcbi8vIG5leHQgY29tbWl0LiBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugb2YgUmVhY3QgcmVuZGVyaW5nIGludG8gYVxuLy8gY29udGFpbmVyIHdpdGggcHJldmlvdXMgY2hpbGRyZW4uIEl0J3MgYWxzbyBzYWZlIHRvIGRvIGZvclxuLy8gdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGwgaWYgdGhlXG4vLyBwcmV2aW91cyByZW5kZXIgd2FzIG51bGwgKHNvIHRoZSBjb250YWluZXIgd291bGQgYWxyZWFkeVxuLy8gYmUgZW1wdHkpLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVNuYXBzaG90Oy8vIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsIHRoZXJlIG1heSBoYXZlIGJlZW5cbi8vIHJlY292ZXJhYmxlIGVycm9ycyBkdXJpbmcgZmlyc3QgaHlkcmF0aW9uIGF0dGVtcHQuIElmIHNvLCBhZGRcbi8vIHRoZW0gdG8gYSBxdWV1ZSBzbyB3ZSBjYW4gbG9nIHRoZW0gaW4gdGhlIGNvbW1pdCBwaGFzZS5cbnVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7fX19fXVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fWNhc2UgSG9zdENvbXBvbmVudDp7cG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO3ZhciByb290Q29udGFpbmVySW5zdGFuY2U9Z2V0Um9vdEhvc3RDb250YWluZXIoKTt2YXIgdHlwZT13b3JrSW5Qcm9ncmVzcy50eXBlO2lmKGN1cnJlbnQhPT1udWxsJiZ3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUhPW51bGwpe3VwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LHdvcmtJblByb2dyZXNzLHR5cGUsbmV3UHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlKTtpZihjdXJyZW50LnJlZiE9PXdvcmtJblByb2dyZXNzLnJlZil7bWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTt9fWVsc2V7aWYoIW5ld1Byb3BzKXtpZih3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcrJ2NhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fS8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9dmFyIGN1cnJlbnRIb3N0Q29udGV4dD1nZXRIb3N0Q29udGV4dCgpOy8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuLy8gXCJzdGFja1wiIGFzIHRoZSBwYXJlbnQuIFRoZW4gYXBwZW5kIGNoaWxkcmVuIGFzIHdlIGdvIGluIGJlZ2luV29ya1xuLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gYWRkIHRoZW0gdG9wLT5kb3duIG9yXG4vLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG52YXIgX3dhc0h5ZHJhdGVkPXBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtpZihfd2FzSHlkcmF0ZWQpey8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG4vLyB0byBjb25zb2xpZGF0ZS5cbmlmKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3Mscm9vdENvbnRhaW5lckluc3RhbmNlLGN1cnJlbnRIb3N0Q29udGV4dCkpey8vIElmIGNoYW5nZXMgdG8gdGhlIGh5ZHJhdGVkIG5vZGUgbmVlZCB0byBiZSBhcHBsaWVkIGF0IHRoZVxuLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxubWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7fX1lbHNle3ZhciBpbnN0YW5jZT1jcmVhdGVJbnN0YW5jZSh0eXBlLG5ld1Byb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxjdXJyZW50SG9zdENvbnRleHQsd29ya0luUHJvZ3Jlc3MpO2FwcGVuZEFsbENoaWxkcmVuKGluc3RhbmNlLHdvcmtJblByb2dyZXNzLGZhbHNlLGZhbHNlKTt3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU9aW5zdGFuY2U7Ly8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbi8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuaWYoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UsdHlwZSxuZXdQcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UpKXttYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTt9fWlmKHdvcmtJblByb2dyZXNzLnJlZiE9PW51bGwpey8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xubWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTt9fWJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO31jYXNlIEhvc3RUZXh0Ont2YXIgbmV3VGV4dD1uZXdQcm9wcztpZihjdXJyZW50JiZ3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUhPW51bGwpe3ZhciBvbGRUZXh0PWN1cnJlbnQubWVtb2l6ZWRQcm9wczsvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbnVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxvbGRUZXh0LG5ld1RleHQpO31lbHNle2lmKHR5cGVvZiBuZXdUZXh0IT09J3N0cmluZycpe2lmKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZT09PW51bGwpe3Rocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJysnY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9Ly8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbn12YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZT1nZXRSb290SG9zdENvbnRhaW5lcigpO3ZhciBfY3VycmVudEhvc3RDb250ZXh0PWdldEhvc3RDb250ZXh0KCk7dmFyIF93YXNIeWRyYXRlZDI9cG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO2lmKF93YXNIeWRyYXRlZDIpe2lmKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSl7bWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7fX1lbHNle3dvcmtJblByb2dyZXNzLnN0YXRlTm9kZT1jcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCxfcm9vdENvbnRhaW5lckluc3RhbmNlLF9jdXJyZW50SG9zdENvbnRleHQsd29ya0luUHJvZ3Jlc3MpO319YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fWNhc2UgU3VzcGVuc2VDb21wb25lbnQ6e3BvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7dmFyIG5leHRTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlOy8vIFNwZWNpYWwgcGF0aCBmb3IgZGVoeWRyYXRlZCBib3VuZGFyaWVzLiBXZSBtYXkgZXZlbnR1YWxseSBtb3ZlIHRoaXNcbi8vIHRvIGl0cyBvd24gZmliZXIgdHlwZSBzbyB0aGF0IHdlIGNhbiBhZGQgb3RoZXIga2luZHMgb2YgaHlkcmF0aW9uXG4vLyBib3VuZGFyaWVzIHRoYXQgYXJlbid0IGFzc29jaWF0ZWQgd2l0aCBhIFN1c3BlbnNlIHRyZWUuIEluIGFudGljaXBhdGlvblxuLy8gb2Ygc3VjaCBhIHJlZmFjdG9yLCBhbGwgdGhlIGh5ZHJhdGlvbiBsb2dpYyBpcyBjb250YWluZWQgaW5cbi8vIHRoaXMgYnJhbmNoLlxuaWYoY3VycmVudD09PW51bGx8fGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSE9PW51bGwmJmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5kZWh5ZHJhdGVkIT09bnVsbCl7dmFyIGZhbGx0aHJvdWdoVG9Ob3JtYWxTdXNwZW5zZVBhdGg9Y29tcGxldGVEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRTdGF0ZSk7aWYoIWZhbGx0aHJvdWdoVG9Ob3JtYWxTdXNwZW5zZVBhdGgpe2lmKHdvcmtJblByb2dyZXNzLmZsYWdzJlNob3VsZENhcHR1cmUpey8vIFNwZWNpYWwgY2FzZS4gVGhlcmUgd2VyZSByZW1haW5pbmcgdW5oeWRyYXRlZCBub2Rlcy4gV2UgdHJlYXRcbi8vIHRoaXMgYXMgYSBtaXNtYXRjaC4gUmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXG5yZXR1cm4gd29ya0luUHJvZ3Jlc3M7fWVsc2V7Ly8gRGlkIG5vdCBmaW5pc2ggaHlkcmF0aW5nLCBlaXRoZXIgYmVjYXVzZSB0aGlzIGlzIHRoZSBpbml0aWFsXG4vLyByZW5kZXIgb3IgYmVjYXVzZSBzb21ldGhpbmcgc3VzcGVuZGVkLlxucmV0dXJuIG51bGw7fX0vLyBDb250aW51ZSB3aXRoIHRoZSBub3JtYWwgU3VzcGVuc2UgcGF0aC5cbn1pZigod29ya0luUHJvZ3Jlc3MuZmxhZ3MmRGlkQ2FwdHVyZSkhPT1Ob0ZsYWdzKXsvLyBTb21ldGhpbmcgc3VzcGVuZGVkLiBSZS1yZW5kZXIgd2l0aCB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz1yZW5kZXJMYW5lczsvLyBEbyBub3QgcmVzZXQgdGhlIGVmZmVjdCBsaXN0LlxuaWYoKHdvcmtJblByb2dyZXNzLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXt0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTt9Ly8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxucmV0dXJuIHdvcmtJblByb2dyZXNzO312YXIgbmV4dERpZFRpbWVvdXQ9bmV4dFN0YXRlIT09bnVsbDt2YXIgcHJldkRpZFRpbWVvdXQ9Y3VycmVudCE9PW51bGwmJmN1cnJlbnQubWVtb2l6ZWRTdGF0ZSE9PW51bGw7Ly8gYSBwYXNzaXZlIGVmZmVjdCwgd2hpY2ggaXMgd2hlbiB3ZSBwcm9jZXNzIHRoZSB0cmFuc2l0aW9uc1xuaWYobmV4dERpZFRpbWVvdXQhPT1wcmV2RGlkVGltZW91dCl7Ly8gYW4gZWZmZWN0IHRvIHRvZ2dsZSB0aGUgc3VidHJlZSdzIHZpc2liaWxpdHkuIFdoZW4gd2Ugc3dpdGNoIGZyb21cbi8vIGZhbGxiYWNrIC0+IHByaW1hcnksIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgc2NoZWR1bGVzIHRoaXMgZWZmZWN0XG4vLyBhcyBwYXJ0IG9mIGl0cyBub3JtYWwgY29tcGxldGUgcGhhc2UuIEJ1dCB3aGVuIHdlIHN3aXRjaCBmcm9tXG4vLyBwcmltYXJ5IC0+IGZhbGxiYWNrLCB0aGUgaW5uZXIgT2Zmc2NyZWVuIGZpYmVyIGRvZXMgbm90IGhhdmUgYSBjb21wbGV0ZVxuLy8gcGhhc2UuIFNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgaXRzIGVmZmVjdCBoZXJlLlxuLy9cbi8vIFdlIGFsc28gdXNlIHRoaXMgZmxhZyB0byBjb25uZWN0L2Rpc2Nvbm5lY3QgdGhlIGVmZmVjdHMsIGJ1dCB0aGUgc2FtZVxuLy8gbG9naWMgYXBwbGllczogd2hlbiByZS1jb25uZWN0aW5nLCB0aGUgT2Zmc2NyZWVuIGZpYmVyJ3MgY29tcGxldGVcbi8vIHBoYXNlIHdpbGwgaGFuZGxlIHNjaGVkdWxpbmcgdGhlIGVmZmVjdC4gSXQncyBvbmx5IHdoZW4gdGhlIGZhbGxiYWNrXG4vLyBpcyBhY3RpdmUgdGhhdCB3ZSBoYXZlIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwuXG5pZihuZXh0RGlkVGltZW91dCl7dmFyIF9vZmZzY3JlZW5GaWJlcjI9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7X29mZnNjcmVlbkZpYmVyMi5mbGFnc3w9VmlzaWJpbGl0eTsvLyBUT0RPOiBUaGlzIHdpbGwgc3RpbGwgc3VzcGVuZCBhIHN5bmNocm9ub3VzIHRyZWUgaWYgYW55dGhpbmdcbi8vIGluIHRoZSBjb25jdXJyZW50IHRyZWUgYWxyZWFkeSBzdXNwZW5kZWQgZHVyaW5nIHRoaXMgcmVuZGVyLlxuLy8gVGhpcyBpcyBhIGtub3duIGJ1Zy5cbmlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZSl7Ly8gVE9ETzogTW92ZSB0aGlzIGJhY2sgdG8gdGhyb3dFeGNlcHRpb24gYmVjYXVzZSB0aGlzIGlzIHRvbyBsYXRlXG4vLyBpZiB0aGlzIGlzIGEgbGFyZ2UgdHJlZSB3aGljaCBpcyBjb21tb24gZm9yIGluaXRpYWwgbG9hZHMuIFdlXG4vLyBkb24ndCBrbm93IGlmIHdlIHNob3VsZCByZXN0YXJ0IGEgcmVuZGVyIG9yIG5vdCB1bnRpbCB3ZSBnZXRcbi8vIHRoaXMgbWFya2VyLCBhbmQgdGhpcyBpcyB0b28gbGF0ZS5cbi8vIElmIHRoaXMgcmVuZGVyIGFscmVhZHkgaGFkIGEgcGluZyBvciBsb3dlciBwcmkgdXBkYXRlcyxcbi8vIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlIGtub3cgd2UncmUgZ29pbmcgdG8gc3VzcGVuZCB3ZVxuLy8gc2hvdWxkIGJlIGFibGUgdG8gaW1tZWRpYXRlbHkgcmVzdGFydCBmcm9tIHdpdGhpbiB0aHJvd0V4Y2VwdGlvbi5cbnZhciBoYXNJbnZpc2libGVDaGlsZENvbnRleHQ9Y3VycmVudD09PW51bGwmJih3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIT09dHJ1ZXx8IWVuYWJsZVN1c3BlbnNlQXZvaWRUaGlzRmFsbGJhY2spO2lmKGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dHx8aGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCxJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpKXsvLyBJZiB0aGlzIHdhcyBpbiBhbiBpbnZpc2libGUgdHJlZSBvciBhIG5ldyByZW5kZXIsIHRoZW4gc2hvd2luZ1xuLy8gdGhpcyBib3VuZGFyeSBpcyBvay5cbnJlbmRlckRpZFN1c3BlbmQoKTt9ZWxzZXsvLyBPdGhlcndpc2UsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gaGlkZSBjb250ZW50IHNvIHdlIHNob3VsZFxuLy8gc3VzcGVuZCBmb3IgbG9uZ2VyIGlmIHBvc3NpYmxlLlxucmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO319fX12YXIgd2FrZWFibGVzPXdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO2lmKHdha2VhYmxlcyE9PW51bGwpey8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggYSByZXRyeSBsaXN0ZW5lciB0byB0aGUgcHJvbWlzZS5cbi8vIFRPRE86IE1vdmUgdG8gcGFzc2l2ZSBwaGFzZVxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVVwZGF0ZTt9YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7e2lmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7aWYobmV4dERpZFRpbWVvdXQpey8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxudmFyIHByaW1hcnlDaGlsZEZyYWdtZW50PXdvcmtJblByb2dyZXNzLmNoaWxkO2lmKHByaW1hcnlDaGlsZEZyYWdtZW50IT09bnVsbCl7Ly8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3JcbndvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24tPXByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247fX19fXJldHVybiBudWxsO31jYXNlIEhvc3RQb3J0YWw6cG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7dXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LHdvcmtJblByb2dyZXNzKTtpZihjdXJyZW50PT09bnVsbCl7cHJlcGFyZVBvcnRhbE1vdW50KHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTt9YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7Y2FzZSBDb250ZXh0UHJvdmlkZXI6Ly8gUG9wIHByb3ZpZGVyIGZpYmVyXG52YXIgY29udGV4dD13b3JrSW5Qcm9ncmVzcy50eXBlLl9jb250ZXh0O3BvcFByb3ZpZGVyKGNvbnRleHQsd29ya0luUHJvZ3Jlc3MpO2J1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO2Nhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OnsvLyBTYW1lIGFzIGNsYXNzIGNvbXBvbmVudCBjYXNlLiBJIHB1dCBpdCBkb3duIGhlcmUgc28gdGhhdCB0aGUgdGFncyBhcmVcbi8vIHNlcXVlbnRpYWwgdG8gZW5zdXJlIHRoaXMgc3dpdGNoIGlzIGNvbXBpbGVkIHRvIGEganVtcCB0YWJsZS5cbnZhciBfQ29tcG9uZW50PXdvcmtJblByb2dyZXNzLnR5cGU7aWYoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpe3BvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO31idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6e3BvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7dmFyIHJlbmRlclN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYocmVuZGVyU3RhdGU9PT1udWxsKXsvLyBXZSdyZSBydW5uaW5nIGluIHRoZSBkZWZhdWx0LCBcImluZGVwZW5kZW50XCIgbW9kZS5cbi8vIFdlIGRvbid0IGRvIGFueXRoaW5nIGluIHRoaXMgbW9kZS5cbmJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO312YXIgZGlkU3VzcGVuZEFscmVhZHk9KHdvcmtJblByb2dyZXNzLmZsYWdzJkRpZENhcHR1cmUpIT09Tm9GbGFnczt2YXIgcmVuZGVyZWRUYWlsPXJlbmRlclN0YXRlLnJlbmRlcmluZztpZihyZW5kZXJlZFRhaWw9PT1udWxsKXsvLyBXZSBqdXN0IHJlbmRlcmVkIHRoZSBoZWFkLlxuaWYoIWRpZFN1c3BlbmRBbHJlYWR5KXsvLyBUaGlzIGlzIHRoZSBmaXJzdCBwYXNzLiBXZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgYW55dGhpbmcgaXMgc3RpbGxcbi8vIHN1c3BlbmRlZCBpbiB0aGUgcmVuZGVyZWQgc2V0LlxuLy8gSWYgbmV3IGNvbnRlbnQgdW5zdXNwZW5kZWQsIGJ1dCB0aGVyZSdzIHN0aWxsIHNvbWUgY29udGVudCB0aGF0XG4vLyBkaWRuJ3QuIFRoZW4gd2UgbmVlZCB0byBkbyBhIHNlY29uZCBwYXNzIHRoYXQgZm9yY2VzIGV2ZXJ5dGhpbmdcbi8vIHRvIGtlZXAgc2hvd2luZyB0aGVpciBmYWxsYmFja3MuXG4vLyBXZSBtaWdodCBiZSBzdXNwZW5kZWQgaWYgc29tZXRoaW5nIGluIHRoaXMgcmVuZGVyIHBhc3Mgc3VzcGVuZGVkLCBvclxuLy8gc29tZXRoaW5nIGluIHRoZSBwcmV2aW91cyBjb21taXR0ZWQgcGFzcyBzdXNwZW5kZWQuIE90aGVyd2lzZSxcbi8vIHRoZXJlJ3Mgbm8gY2hhbmNlIHNvIHdlIGNhbiBza2lwIHRoZSBleHBlbnNpdmUgY2FsbCB0b1xuLy8gZmluZEZpcnN0U3VzcGVuZGVkLlxudmFyIGNhbm5vdEJlU3VzcGVuZGVkPXJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpJiYoY3VycmVudD09PW51bGx8fChjdXJyZW50LmZsYWdzJkRpZENhcHR1cmUpPT09Tm9GbGFncyk7aWYoIWNhbm5vdEJlU3VzcGVuZGVkKXt2YXIgcm93PXdvcmtJblByb2dyZXNzLmNoaWxkO3doaWxlKHJvdyE9PW51bGwpe3ZhciBzdXNwZW5kZWQ9ZmluZEZpcnN0U3VzcGVuZGVkKHJvdyk7aWYoc3VzcGVuZGVkIT09bnVsbCl7ZGlkU3VzcGVuZEFscmVhZHk9dHJ1ZTt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTtjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsZmFsc2UpOy8vIElmIHRoaXMgaXMgYSBuZXdseSBzdXNwZW5kZWQgdHJlZSwgaXQgbWlnaHQgbm90IGdldCBjb21taXR0ZWQgYXNcbi8vIHBhcnQgb2YgdGhlIHNlY29uZCBwYXNzLiBJbiB0aGF0IGNhc2Ugbm90aGluZyB3aWxsIHN1YnNjcmliZSB0b1xuLy8gaXRzIHRoZW5hYmxlcy4gSW5zdGVhZCwgd2UnbGwgdHJhbnNmZXIgaXRzIHRoZW5hYmxlcyB0byB0aGVcbi8vIFN1c3BlbnNlTGlzdCBzbyB0aGF0IGl0IGNhbiByZXRyeSBpZiB0aGV5IHJlc29sdmUuXG4vLyBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSBvZiB0aGVzZSBpbiB0aGUgbGlzdCBidXQgc2luY2Ugd2UncmVcbi8vIGdvaW5nIHRvIHdhaXQgZm9yIGFsbCBvZiB0aGVtIGFueXdheSwgaXQgZG9lc24ndCByZWFsbHkgbWF0dGVyXG4vLyB3aGljaCBvbmVzIGdldHMgdG8gcGluZy4gSW4gdGhlb3J5IHdlIGNvdWxkIGdldCBjbGV2ZXIgYW5kIGtlZXBcbi8vIHRyYWNrIG9mIGhvdyBtYW55IGRlcGVuZGVuY2llcyByZW1haW4gYnV0IGl0IGdldHMgdHJpY2t5IGJlY2F1c2Vcbi8vIGluIHRoZSBtZWFudGltZSwgd2UgY2FuIGFkZC9yZW1vdmUvY2hhbmdlIGl0ZW1zIGFuZCBkZXBlbmRlbmNpZXMuXG4vLyBXZSBtaWdodCBiYWlsIG91dCBvZiB0aGUgbG9vcCBiZWZvcmUgZmluZGluZyBhbnkgYnV0IHRoYXRcbi8vIGRvZXNuJ3QgbWF0dGVyIHNpbmNlIHRoYXQgbWVhbnMgdGhhdCB0aGUgb3RoZXIgYm91bmRhcmllcyB0aGF0XG4vLyB3ZSBkaWQgZmluZCBhbHJlYWR5IGhhcyB0aGVpciBsaXN0ZW5lcnMgYXR0YWNoZWQuXG52YXIgbmV3VGhlbmFibGVzPXN1c3BlbmRlZC51cGRhdGVRdWV1ZTtpZihuZXdUaGVuYWJsZXMhPT1udWxsKXt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1uZXdUaGVuYWJsZXM7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVVwZGF0ZTt9Ly8gUmVyZW5kZXIgdGhlIHdob2xlIGxpc3QsIGJ1dCB0aGlzIHRpbWUsIHdlJ2xsIGZvcmNlIGZhbGxiYWNrc1xuLy8gdG8gc3RheSBpbiBwbGFjZS5cbi8vIFJlc2V0IHRoZSBlZmZlY3QgZmxhZ3MgYmVmb3JlIGRvaW5nIHRoZSBzZWNvbmQgcGFzcyBzaW5jZSB0aGF0J3Mgbm93IGludmFsaWQuXG4vLyBSZXNldCB0aGUgY2hpbGQgZmliZXJzIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxud29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzPU5vRmxhZ3M7cmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Ly8gU2V0IHVwIHRoZSBTdXNwZW5zZSBDb250ZXh0IHRvIGZvcmNlIHN1c3BlbnNlIGFuZCBpbW1lZGlhdGVseVxuLy8gcmVyZW5kZXIgdGhlIGNoaWxkcmVuLlxucHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCxGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTsvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5yZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fXJvdz1yb3cuc2libGluZzt9fWlmKHJlbmRlclN0YXRlLnRhaWwhPT1udWxsJiZub3coKT5nZXRSZW5kZXJUYXJnZXRUaW1lKCkpey8vIFdlIGhhdmUgYWxyZWFkeSBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBidXQgd2Ugc3RpbGwgaGF2ZSByb3dzXG4vLyBsZWZ0IGluIHRoZSB0YWlsLiBXZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlciBhdHRlbXB0cyB0byByZW5kZXJcbi8vIHRoZSBtYWluIGNvbnRlbnQgYW5kIG9ubHkgcmVuZGVyIGZhbGxiYWNrcy5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO2RpZFN1c3BlbmRBbHJlYWR5PXRydWU7Y3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLGZhbHNlKTsvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4vLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4vLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbi8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4vLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4vLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxud29ya0luUHJvZ3Jlc3MubGFuZXM9U29tZVJldHJ5TGFuZTt9fWVsc2V7Y3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLGZhbHNlKTt9Ly8gTmV4dCB3ZSdyZSBnb2luZyB0byByZW5kZXIgdGhlIHRhaWwuXG59ZWxzZXsvLyBBcHBlbmQgdGhlIHJlbmRlcmVkIHJvdyB0byB0aGUgY2hpbGQgbGlzdC5cbmlmKCFkaWRTdXNwZW5kQWxyZWFkeSl7dmFyIF9zdXNwZW5kZWQ9ZmluZEZpcnN0U3VzcGVuZGVkKHJlbmRlcmVkVGFpbCk7aWYoX3N1c3BlbmRlZCE9PW51bGwpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO2RpZFN1c3BlbmRBbHJlYWR5PXRydWU7Ly8gRW5zdXJlIHdlIHRyYW5zZmVyIHRoZSB1cGRhdGUgcXVldWUgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IGRvZXNuJ3Rcbi8vIGdldCBsb3N0IGlmIHRoaXMgcm93IGVuZHMgdXAgZHJvcHBlZCBkdXJpbmcgYSBzZWNvbmQgcGFzcy5cbnZhciBfbmV3VGhlbmFibGVzPV9zdXNwZW5kZWQudXBkYXRlUXVldWU7aWYoX25ld1RoZW5hYmxlcyE9PW51bGwpe3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPV9uZXdUaGVuYWJsZXM7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVVwZGF0ZTt9Y3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLHRydWUpOy8vIFRoaXMgbWlnaHQgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuaWYocmVuZGVyU3RhdGUudGFpbD09PW51bGwmJnJlbmRlclN0YXRlLnRhaWxNb2RlPT09J2hpZGRlbicmJiFyZW5kZXJlZFRhaWwuYWx0ZXJuYXRlJiYhZ2V0SXNIeWRyYXRpbmcoKS8vIFdlIGRvbid0IGN1dCBpdCBpZiB3ZSdyZSBoeWRyYXRpbmcuXG4pey8vIFdlJ3JlIGRvbmUuXG5idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9fWVsc2UgaWYoLy8gVGhlIHRpbWUgaXQgdG9vayB0byByZW5kZXIgbGFzdCByb3cgaXMgZ3JlYXRlciB0aGFuIHRoZSByZW1haW5pbmdcbi8vIHRpbWUgd2UgaGF2ZSB0byByZW5kZXIuIFNvIHJlbmRlcmluZyBvbmUgbW9yZSByb3cgd291bGQgbGlrZWx5XG4vLyBleGNlZWQgaXQuXG5ub3coKSoyLXJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZT5nZXRSZW5kZXJUYXJnZXRUaW1lKCkmJnJlbmRlckxhbmVzIT09T2Zmc2NyZWVuTGFuZSl7Ly8gV2UgaGF2ZSBub3cgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYW5kIHdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyXG4vLyBhdHRlbXB0cyB0byByZW5kZXIgdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuLy8gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCB0aGlzIGlzIHVzdWFsbHkgZmFzdGVyLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7ZGlkU3VzcGVuZEFscmVhZHk9dHJ1ZTtjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsZmFsc2UpOy8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4vLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbi8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbi8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbi8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbi8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4vLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz1Tb21lUmV0cnlMYW5lO319aWYocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMpey8vIFRoZSBlZmZlY3QgbGlzdCBvZiB0aGUgYmFja3dhcmRzIHRhaWwgd2lsbCBoYXZlIGJlZW4gYWRkZWRcbi8vIHRvIHRoZSBlbmQuIFRoaXMgYnJlYWtzIHRoZSBndWFyYW50ZWUgdGhhdCBsaWZlLWN5Y2xlcyBmaXJlIGluXG4vLyBzaWJsaW5nIG9yZGVyIGJ1dCB0aGF0IGlzbid0IGEgc3Ryb25nIGd1YXJhbnRlZSBwcm9taXNlZCBieSBSZWFjdC5cbi8vIEVzcGVjaWFsbHkgc2luY2UgdGhlc2UgbWlnaHQgYWxzbyBqdXN0IHBvcCBpbiBkdXJpbmcgZnV0dXJlIGNvbW1pdHMuXG4vLyBBcHBlbmQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbnJlbmRlcmVkVGFpbC5zaWJsaW5nPXdvcmtJblByb2dyZXNzLmNoaWxkO3dvcmtJblByb2dyZXNzLmNoaWxkPXJlbmRlcmVkVGFpbDt9ZWxzZXt2YXIgcHJldmlvdXNTaWJsaW5nPXJlbmRlclN0YXRlLmxhc3Q7aWYocHJldmlvdXNTaWJsaW5nIT09bnVsbCl7cHJldmlvdXNTaWJsaW5nLnNpYmxpbmc9cmVuZGVyZWRUYWlsO31lbHNle3dvcmtJblByb2dyZXNzLmNoaWxkPXJlbmRlcmVkVGFpbDt9cmVuZGVyU3RhdGUubGFzdD1yZW5kZXJlZFRhaWw7fX1pZihyZW5kZXJTdGF0ZS50YWlsIT09bnVsbCl7Ly8gV2Ugc3RpbGwgaGF2ZSB0YWlsIHJvd3MgdG8gcmVuZGVyLlxuLy8gUG9wIGEgcm93LlxudmFyIG5leHQ9cmVuZGVyU3RhdGUudGFpbDtyZW5kZXJTdGF0ZS5yZW5kZXJpbmc9bmV4dDtyZW5kZXJTdGF0ZS50YWlsPW5leHQuc2libGluZztyZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWU9bm93KCk7bmV4dC5zaWJsaW5nPW51bGw7Ly8gUmVzdG9yZSB0aGUgY29udGV4dC5cbi8vIFRPRE86IFdlIGNhbiBwcm9iYWJseSBqdXN0IGF2b2lkIHBvcHBpbmcgaXQgaW5zdGVhZCBhbmQgb25seVxuLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxudmFyIHN1c3BlbnNlQ29udGV4dD1zdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7aWYoZGlkU3VzcGVuZEFscmVhZHkpe3N1c3BlbnNlQ29udGV4dD1zZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCxGb3JjZVN1c3BlbnNlRmFsbGJhY2spO31lbHNle3N1c3BlbnNlQ29udGV4dD1zZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQpO31wdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLHN1c3BlbnNlQ29udGV4dCk7Ly8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxucmV0dXJuIG5leHQ7fWJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO31jYXNlIFNjb3BlQ29tcG9uZW50OnticmVhazt9Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6Y2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6e3BvcFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzKTt2YXIgX25leHRTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO3ZhciBuZXh0SXNIaWRkZW49X25leHRTdGF0ZSE9PW51bGw7aWYoY3VycmVudCE9PW51bGwpe3ZhciBfcHJldlN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTt2YXIgcHJldklzSGlkZGVuPV9wcmV2U3RhdGUhPT1udWxsO2lmKHByZXZJc0hpZGRlbiE9PW5leHRJc0hpZGRlbiYmLy8gTGVnYWN5SGlkZGVuIGRvZXNuJ3QgZG8gYW55IGhpZGluZyDigJQgaXQgb25seSBwcmUtcmVuZGVycy5cbiFlbmFibGVMZWdhY3lIaWRkZW4pe3dvcmtJblByb2dyZXNzLmZsYWdzfD1WaXNpYmlsaXR5O319aWYoIW5leHRJc0hpZGRlbnx8KHdvcmtJblByb2dyZXNzLm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlKXtidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTt9ZWxzZXsvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBmb3IgaGlkZGVuIGNoaWxkcmVuIHVubGVzcyB3ZSdyZSByZW5kZXJpbmdcbi8vIGF0IG9mZnNjcmVlbiBwcmlvcml0eS5cbmlmKGluY2x1ZGVzU29tZUxhbmUoc3VidHJlZVJlbmRlckxhbmVzLE9mZnNjcmVlbkxhbmUpKXtidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTt7Ly8gQ2hlY2sgaWYgdGhlcmUgd2FzIGFuIGluc2VydGlvbiBvciB1cGRhdGUgaW4gdGhlIGhpZGRlbiBzdWJ0cmVlLlxuLy8gSWYgc28sIHdlIG5lZWQgdG8gaGlkZSB0aG9zZSBub2RlcyBpbiB0aGUgY29tbWl0IHBoYXNlLCBzb1xuLy8gc2NoZWR1bGUgYSB2aXNpYmlsaXR5IGVmZmVjdC5cbmlmKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyYoUGxhY2VtZW50fFVwZGF0ZSkpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1WaXNpYmlsaXR5O319fX1yZXR1cm4gbnVsbDt9Y2FzZSBDYWNoZUNvbXBvbmVudDp7cmV0dXJuIG51bGw7fWNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDp7cmV0dXJuIG51bGw7fX10aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiK3dvcmtJblByb2dyZXNzLnRhZytcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBcIisnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31mdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpey8vIE5vdGU6IFRoaXMgaW50ZW50aW9uYWxseSBkb2Vzbid0IGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZyBiZWNhdXNlIGNvbXBhcmluZ1xuLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4vLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4vLyBmb3IgaHlkcmF0aW9uLlxucG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO3N3aXRjaCh3b3JrSW5Qcm9ncmVzcy50YWcpe2Nhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBDb21wb25lbnQ9d29ya0luUHJvZ3Jlc3MudHlwZTtpZihpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKXtwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTt9dmFyIGZsYWdzPXdvcmtJblByb2dyZXNzLmZsYWdzO2lmKGZsYWdzJlNob3VsZENhcHR1cmUpe3dvcmtJblByb2dyZXNzLmZsYWdzPWZsYWdzJn5TaG91bGRDYXB0dXJlfERpZENhcHR1cmU7aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXt0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTt9cmV0dXJuIHdvcmtJblByb2dyZXNzO31yZXR1cm4gbnVsbDt9Y2FzZSBIb3N0Um9vdDp7dmFyIHJvb3Q9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3BvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO3BvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7cmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7dmFyIF9mbGFncz13b3JrSW5Qcm9ncmVzcy5mbGFncztpZigoX2ZsYWdzJlNob3VsZENhcHR1cmUpIT09Tm9GbGFncyYmKF9mbGFncyZEaWRDYXB0dXJlKT09PU5vRmxhZ3Mpey8vIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgcmVuZGVyIHRoYXQgd2Fzbid0IGNhcHR1cmVkIGJ5IGEgc3VzcGVuc2Vcbi8vIGJvdW5kYXJ5LiBEbyBhIHNlY29uZCBwYXNzIG9uIHRoZSByb290IHRvIHVubW91bnQgdGhlIGNoaWxkcmVuLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3M9X2ZsYWdzJn5TaG91bGRDYXB0dXJlfERpZENhcHR1cmU7cmV0dXJuIHdvcmtJblByb2dyZXNzO30vLyBXZSB1bndvdW5kIHRvIHRoZSByb290IHdpdGhvdXQgY29tcGxldGluZyBpdC4gRXhpdC5cbnJldHVybiBudWxsO31jYXNlIEhvc3RDb21wb25lbnQ6ey8vIFRPRE86IHBvcEh5ZHJhdGlvblN0YXRlXG5wb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fWNhc2UgU3VzcGVuc2VDb21wb25lbnQ6e3BvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7dmFyIHN1c3BlbnNlU3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtpZihzdXNwZW5zZVN0YXRlIT09bnVsbCYmc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkIT09bnVsbCl7aWYod29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdUaHJldyBpbiBuZXdseSBtb3VudGVkIGRlaHlkcmF0ZWQgY29tcG9uZW50LiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiAnKydSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXJlc2V0SHlkcmF0aW9uU3RhdGUoKTt9dmFyIF9mbGFnczI9d29ya0luUHJvZ3Jlc3MuZmxhZ3M7aWYoX2ZsYWdzMiZTaG91bGRDYXB0dXJlKXt3b3JrSW5Qcm9ncmVzcy5mbGFncz1fZmxhZ3MyJn5TaG91bGRDYXB0dXJlfERpZENhcHR1cmU7Ly8gQ2FwdHVyZWQgYSBzdXNwZW5zZSBlZmZlY3QuIFJlLXJlbmRlciB0aGUgYm91bmRhcnkuXG5pZigod29ya0luUHJvZ3Jlc3MubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpe3RyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO31yZXR1cm4gd29ya0luUHJvZ3Jlc3M7fXJldHVybiBudWxsO31jYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDp7cG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTsvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cbi8vIGNhdWdodCBieSBhIG5lc3RlZCBib3VuZGFyeS4gSWYgbm90LCBpdCBzaG91bGQgYnViYmxlIHRocm91Z2guXG5yZXR1cm4gbnVsbDt9Y2FzZSBIb3N0UG9ydGFsOnBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO2Nhc2UgQ29udGV4dFByb3ZpZGVyOnZhciBjb250ZXh0PXdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7cG9wUHJvdmlkZXIoY29udGV4dCx3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6Y2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6cG9wUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO2Nhc2UgQ2FjaGVDb21wb25lbnQ6cmV0dXJuIG51bGw7ZGVmYXVsdDpyZXR1cm4gbnVsbDt9fWZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LGludGVycnVwdGVkV29yayxyZW5kZXJMYW5lcyl7Ly8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4vLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cbi8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbi8vIGZvciBoeWRyYXRpb24uXG5wb3BUcmVlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO3N3aXRjaChpbnRlcnJ1cHRlZFdvcmsudGFnKXtjYXNlIENsYXNzQ29tcG9uZW50Ont2YXIgY2hpbGRDb250ZXh0VHlwZXM9aW50ZXJydXB0ZWRXb3JrLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7aWYoY2hpbGRDb250ZXh0VHlwZXMhPT1udWxsJiZjaGlsZENvbnRleHRUeXBlcyE9PXVuZGVmaW5lZCl7cG9wQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO31icmVhazt9Y2FzZSBIb3N0Um9vdDp7dmFyIHJvb3Q9aW50ZXJydXB0ZWRXb3JrLnN0YXRlTm9kZTtwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7cG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGludGVycnVwdGVkV29yayk7cmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7YnJlYWs7fWNhc2UgSG9zdENvbXBvbmVudDp7cG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTticmVhazt9Y2FzZSBIb3N0UG9ydGFsOnBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTticmVhaztjYXNlIFN1c3BlbnNlQ29tcG9uZW50OnBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO2JyZWFrO2Nhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OnBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO2JyZWFrO2Nhc2UgQ29udGV4dFByb3ZpZGVyOnZhciBjb250ZXh0PWludGVycnVwdGVkV29yay50eXBlLl9jb250ZXh0O3BvcFByb3ZpZGVyKGNvbnRleHQsaW50ZXJydXB0ZWRXb3JrKTticmVhaztjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpwb3BSZW5kZXJMYW5lcyhpbnRlcnJ1cHRlZFdvcmspO2JyZWFrO319dmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlPW51bGw7e2RpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlPW5ldyBTZXQoKTt9Ly8gVXNlZCBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSB0byB0cmFjayB0aGUgc3RhdGUgb2YgdGhlIE9mZnNjcmVlbiBjb21wb25lbnQgc3RhY2suXG4vLyBBbGxvd3MgdXMgdG8gYXZvaWQgdHJhdmVyc2luZyB0aGUgcmV0dXJuIHBhdGggdG8gZmluZCB0aGUgbmVhcmVzdCBPZmZzY3JlZW4gYW5jZXN0b3IuXG4vLyBPbmx5IHVzZWQgd2hlbiBlbmFibGVTdXNwZW5zZUxheW91dEVmZmVjdFNlbWFudGljcyBpcyBlbmFibGVkLlxudmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbj1mYWxzZTt2YXIgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1mYWxzZTt2YXIgUG9zc2libHlXZWFrU2V0PXR5cGVvZiBXZWFrU2V0PT09J2Z1bmN0aW9uJz9XZWFrU2V0OlNldDt2YXIgbmV4dEVmZmVjdD1udWxsOy8vIFVzZWQgZm9yIFByb2ZpbGluZyBidWlsZHMgdG8gdHJhY2sgdXBkYXRlcnMuXG52YXIgaW5Qcm9ncmVzc0xhbmVzPW51bGw7dmFyIGluUHJvZ3Jlc3NSb290PW51bGw7ZnVuY3Rpb24gcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKXsvLyBXcmFwcGluZyBlYWNoIHNtYWxsIHBhcnQgb2YgdGhlIGNvbW1pdCBwaGFzZSBpbnRvIGEgZ3VhcmRlZFxuLy8gY2FsbGJhY2sgaXMgYSBiaXQgdG9vIHNsb3cgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIxNjY2KS5cbi8vIEJ1dCB3ZSByZWx5IG9uIGl0IHRvIHN1cmZhY2UgZXJyb3JzIHRvIERFViB0b29scyBsaWtlIG92ZXJsYXlzXG4vLyAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMTcxMikuXG4vLyBBcyBhIGNvbXByb21pc2UsIHJldGhyb3cgb25seSBjYXVnaHQgZXJyb3JzIGluIGEgZ3VhcmQuXG57aW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsZnVuY3Rpb24oKXt0aHJvdyBlcnJvcjt9KTtjbGVhckNhdWdodEVycm9yKCk7fX12YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyPWZ1bmN0aW9uKGN1cnJlbnQsaW5zdGFuY2Upe2luc3RhbmNlLnByb3BzPWN1cnJlbnQubWVtb2l6ZWRQcm9wcztpbnN0YW5jZS5zdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7aWYoY3VycmVudC5tb2RlJlByb2ZpbGVNb2RlKXt0cnl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO2luc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7fWZpbmFsbHl7cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7fX1lbHNle2luc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7fX07Ly8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgbW91bnRpbmcuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3Ipe3RyeXtjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCxjdXJyZW50KTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixlcnJvcik7fX0vLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixpbnN0YW5jZSl7dHJ5e2NhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lcihjdXJyZW50LGluc3RhbmNlKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixlcnJvcik7fX0vLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnREaWRNb3VudChjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsaW5zdGFuY2Upe3RyeXtpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGVycm9yKTt9fS8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuZnVuY3Rpb24gc2FmZWx5QXR0YWNoUmVmKGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcil7dHJ5e2NvbW1pdEF0dGFjaFJlZihjdXJyZW50KTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixlcnJvcik7fX1mdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yKXt2YXIgcmVmPWN1cnJlbnQucmVmO2lmKHJlZiE9PW51bGwpe2lmKHR5cGVvZiByZWY9PT0nZnVuY3Rpb24nKXt2YXIgcmV0VmFsO3RyeXtpZihlbmFibGVQcm9maWxlclRpbWVyJiZlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzJiZjdXJyZW50Lm1vZGUmUHJvZmlsZU1vZGUpe3RyeXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7cmV0VmFsPXJlZihudWxsKTt9ZmluYWxseXtyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTt9fWVsc2V7cmV0VmFsPXJlZihudWxsKTt9fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZXJyb3IpO317aWYodHlwZW9mIHJldFZhbD09PSdmdW5jdGlvbicpe2Vycm9yKCdVbmV4cGVjdGVkIHJldHVybiB2YWx1ZSBmcm9tIGEgY2FsbGJhY2sgcmVmIGluICVzLiAnKydBIGNhbGxiYWNrIHJlZiBzaG91bGQgbm90IHJldHVybiBhIGZ1bmN0aW9uLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50KSk7fX19ZWxzZXtyZWYuY3VycmVudD1udWxsO319fWZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZXN0cm95KXt0cnl7ZGVzdHJveSgpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGVycm9yKTt9fXZhciBmb2N1c2VkSW5zdGFuY2VIYW5kbGU9bnVsbDt2YXIgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyPWZhbHNlO2Z1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LGZpcnN0Q2hpbGQpe2ZvY3VzZWRJbnN0YW5jZUhhbmRsZT1wcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7bmV4dEVmZmVjdD1maXJzdENoaWxkO2NvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbigpOy8vIFdlIG5vIGxvbmdlciBuZWVkIHRvIHRyYWNrIHRoZSBhY3RpdmUgaW5zdGFuY2UgZmliZXJcbnZhciBzaG91bGRGaXJlPXNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI9ZmFsc2U7Zm9jdXNlZEluc3RhbmNlSGFuZGxlPW51bGw7cmV0dXJuIHNob3VsZEZpcmU7fWZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbigpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDsvLyBUaGlzIHBoYXNlIGlzIG9ubHkgdXNlZCBmb3IgYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyLlxudmFyIGNoaWxkPWZpYmVyLmNoaWxkO2lmKChmaWJlci5zdWJ0cmVlRmxhZ3MmQmVmb3JlTXV0YXRpb25NYXNrKSE9PU5vRmxhZ3MmJmNoaWxkIT09bnVsbCl7Y2hpbGQucmV0dXJuPWZpYmVyO25leHRFZmZlY3Q9Y2hpbGQ7fWVsc2V7Y29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCk7fX19ZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O3NldEN1cnJlbnRGaWJlcihmaWJlcik7dHJ5e2NvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIoZmliZXIpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsZmliZXIucmV0dXJuLGVycm9yKTt9cmVzZXRDdXJyZW50RmliZXIoKTt2YXIgc2libGluZz1maWJlci5zaWJsaW5nO2lmKHNpYmxpbmchPT1udWxsKXtzaWJsaW5nLnJldHVybj1maWJlci5yZXR1cm47bmV4dEVmZmVjdD1zaWJsaW5nO3JldHVybjt9bmV4dEVmZmVjdD1maWJlci5yZXR1cm47fX1mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yayl7dmFyIGN1cnJlbnQ9ZmluaXNoZWRXb3JrLmFsdGVybmF0ZTt2YXIgZmxhZ3M9ZmluaXNoZWRXb3JrLmZsYWdzO2lmKChmbGFncyZTbmFwc2hvdCkhPT1Ob0ZsYWdzKXtzZXRDdXJyZW50RmliZXIoZmluaXNoZWRXb3JrKTtzd2l0Y2goZmluaXNoZWRXb3JrLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OnticmVhazt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7aWYoY3VycmVudCE9PW51bGwpe3ZhciBwcmV2UHJvcHM9Y3VycmVudC5tZW1vaXplZFByb3BzO3ZhciBwcmV2U3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO3ZhciBpbnN0YW5jZT1maW5pc2hlZFdvcmsuc3RhdGVOb2RlOy8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbi8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxue2lmKGZpbmlzaGVkV29yay50eXBlPT09ZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlJiYhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyl7aWYoaW5zdGFuY2UucHJvcHMhPT1maW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyl7ZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnKydnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gJysnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnKydhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcrJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspfHwnaW5zdGFuY2UnKTt9aWYoaW5zdGFuY2Uuc3RhdGUhPT1maW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSl7ZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnKydnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gJysnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnKydhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcrJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspfHwnaW5zdGFuY2UnKTt9fX12YXIgc25hcHNob3Q9aW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlPT09ZmluaXNoZWRXb3JrLnR5cGU/cHJldlByb3BzOnJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUscHJldlByb3BzKSxwcmV2U3RhdGUpO3t2YXIgZGlkV2FyblNldD1kaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtpZihzbmFwc2hvdD09PXVuZGVmaW5lZCYmIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSl7ZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO2Vycm9yKCclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnKydtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykpO319aW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGU9c25hcHNob3Q7fWJyZWFrO31jYXNlIEhvc3RSb290Ont7dmFyIHJvb3Q9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtjbGVhckNvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO31icmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50OmNhc2UgSG9zdFRleHQ6Y2FzZSBIb3N0UG9ydGFsOmNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50Oi8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuYnJlYWs7ZGVmYXVsdDp7dGhyb3cgbmV3IEVycm9yKCdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyAnKydsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fXJlc2V0Q3VycmVudEZpYmVyKCk7fX1mdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoZmxhZ3MsZmluaXNoZWRXb3JrLG5lYXJlc3RNb3VudGVkQW5jZXN0b3Ipe3ZhciB1cGRhdGVRdWV1ZT1maW5pc2hlZFdvcmsudXBkYXRlUXVldWU7dmFyIGxhc3RFZmZlY3Q9dXBkYXRlUXVldWUhPT1udWxsP3VwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q6bnVsbDtpZihsYXN0RWZmZWN0IT09bnVsbCl7dmFyIGZpcnN0RWZmZWN0PWxhc3RFZmZlY3QubmV4dDt2YXIgZWZmZWN0PWZpcnN0RWZmZWN0O2Rve2lmKChlZmZlY3QudGFnJmZsYWdzKT09PWZsYWdzKXsvLyBVbm1vdW50XG52YXIgZGVzdHJveT1lZmZlY3QuZGVzdHJveTtlZmZlY3QuZGVzdHJveT11bmRlZmluZWQ7aWYoZGVzdHJveSE9PXVuZGVmaW5lZCl7e2lmKChmbGFncyZQYXNzaXZlJDEpIT09Tm9GbGFncyQxKXttYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7fWVsc2UgaWYoKGZsYWdzJkxheW91dCkhPT1Ob0ZsYWdzJDEpe21hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO319e2lmKChmbGFncyZJbnNlcnRpb24pIT09Tm9GbGFncyQxKXtzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QodHJ1ZSk7fX1zYWZlbHlDYWxsRGVzdHJveShmaW5pc2hlZFdvcmssbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZXN0cm95KTt7aWYoKGZsYWdzJkluc2VydGlvbikhPT1Ob0ZsYWdzJDEpe3NldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7fX17aWYoKGZsYWdzJlBhc3NpdmUkMSkhPT1Ob0ZsYWdzJDEpe21hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKTt9ZWxzZSBpZigoZmxhZ3MmTGF5b3V0KSE9PU5vRmxhZ3MkMSl7bWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7fX19fWVmZmVjdD1lZmZlY3QubmV4dDt9d2hpbGUoZWZmZWN0IT09Zmlyc3RFZmZlY3QpO319ZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncyxmaW5pc2hlZFdvcmspe3ZhciB1cGRhdGVRdWV1ZT1maW5pc2hlZFdvcmsudXBkYXRlUXVldWU7dmFyIGxhc3RFZmZlY3Q9dXBkYXRlUXVldWUhPT1udWxsP3VwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q6bnVsbDtpZihsYXN0RWZmZWN0IT09bnVsbCl7dmFyIGZpcnN0RWZmZWN0PWxhc3RFZmZlY3QubmV4dDt2YXIgZWZmZWN0PWZpcnN0RWZmZWN0O2Rve2lmKChlZmZlY3QudGFnJmZsYWdzKT09PWZsYWdzKXt7aWYoKGZsYWdzJlBhc3NpdmUkMSkhPT1Ob0ZsYWdzJDEpe21hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7fWVsc2UgaWYoKGZsYWdzJkxheW91dCkhPT1Ob0ZsYWdzJDEpe21hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTt9fS8vIE1vdW50XG52YXIgY3JlYXRlPWVmZmVjdC5jcmVhdGU7e2lmKChmbGFncyZJbnNlcnRpb24pIT09Tm9GbGFncyQxKXtzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QodHJ1ZSk7fX1lZmZlY3QuZGVzdHJveT1jcmVhdGUoKTt7aWYoKGZsYWdzJkluc2VydGlvbikhPT1Ob0ZsYWdzJDEpe3NldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7fX17aWYoKGZsYWdzJlBhc3NpdmUkMSkhPT1Ob0ZsYWdzJDEpe21hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCk7fWVsc2UgaWYoKGZsYWdzJkxheW91dCkhPT1Ob0ZsYWdzJDEpe21hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKTt9fXt2YXIgZGVzdHJveT1lZmZlY3QuZGVzdHJveTtpZihkZXN0cm95IT09dW5kZWZpbmVkJiZ0eXBlb2YgZGVzdHJveSE9PSdmdW5jdGlvbicpe3ZhciBob29rTmFtZT12b2lkIDA7aWYoKGVmZmVjdC50YWcmTGF5b3V0KSE9PU5vRmxhZ3Mpe2hvb2tOYW1lPSd1c2VMYXlvdXRFZmZlY3QnO31lbHNlIGlmKChlZmZlY3QudGFnJkluc2VydGlvbikhPT1Ob0ZsYWdzKXtob29rTmFtZT0ndXNlSW5zZXJ0aW9uRWZmZWN0Jzt9ZWxzZXtob29rTmFtZT0ndXNlRWZmZWN0Jzt9dmFyIGFkZGVuZHVtPXZvaWQgMDtpZihkZXN0cm95PT09bnVsbCl7YWRkZW5kdW09JyBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiAnKyd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJzt9ZWxzZSBpZih0eXBlb2YgZGVzdHJveS50aGVuPT09J2Z1bmN0aW9uJyl7YWRkZW5kdW09J1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlICcraG9va05hbWUrJyhhc3luYyAoKSA9PiAuLi4pIG9yIHJldHVybmVkIGEgUHJvbWlzZS4gJysnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnKydhbmQgY2FsbCBpdCBpbW1lZGlhdGVseTpcXG5cXG4nK2hvb2tOYW1lKycoKCkgPT4ge1xcbicrJyAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbicrJyAgICAvLyBZb3UgY2FuIGF3YWl0IGhlcmVcXG4nKycgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuJysnICAgIC8vIC4uLlxcbicrJyAgfVxcbicrJyAgZmV0Y2hEYXRhKCk7XFxuJytcIn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcblwiKydMZWFybiBtb3JlIGFib3V0IGRhdGEgZmV0Y2hpbmcgd2l0aCBIb29rczogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2hvb2tzLWRhdGEtZmV0Y2hpbmcnO31lbHNle2FkZGVuZHVtPScgWW91IHJldHVybmVkOiAnK2Rlc3Ryb3k7fWVycm9yKCclcyBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCAnKyd3aGljaCBpcyB1c2VkIGZvciBjbGVhbi11cC4lcycsaG9va05hbWUsYWRkZW5kdW0pO319fWVmZmVjdD1lZmZlY3QubmV4dDt9d2hpbGUoZWZmZWN0IT09Zmlyc3RFZmZlY3QpO319ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZUVmZmVjdER1cmF0aW9ucyhmaW5pc2hlZFJvb3QsZmluaXNoZWRXb3JrKXt7Ly8gT25seSBQcm9maWxlcnMgd2l0aCB3b3JrIGluIHRoZWlyIHN1YnRyZWUgd2lsbCBoYXZlIGFuIFVwZGF0ZSBlZmZlY3Qgc2NoZWR1bGVkLlxuaWYoKGZpbmlzaGVkV29yay5mbGFncyZVcGRhdGUpIT09Tm9GbGFncyl7c3dpdGNoKGZpbmlzaGVkV29yay50YWcpe2Nhc2UgUHJvZmlsZXI6e3ZhciBwYXNzaXZlRWZmZWN0RHVyYXRpb249ZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb247dmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZT1maW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxpZD1fZmluaXNoZWRXb3JrJG1lbW9pemUuaWQsb25Qb3N0Q29tbWl0PV9maW5pc2hlZFdvcmskbWVtb2l6ZS5vblBvc3RDb21taXQ7Ly8gVGhpcyB2YWx1ZSB3aWxsIHN0aWxsIHJlZmxlY3QgdGhlIHByZXZpb3VzIGNvbW1pdCBwaGFzZS5cbi8vIEl0IGRvZXMgbm90IGdldCByZXNldCB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY29tbWl0IHBoYXNlLlxudmFyIGNvbW1pdFRpbWU9Z2V0Q29tbWl0VGltZSgpO3ZhciBwaGFzZT1maW5pc2hlZFdvcmsuYWx0ZXJuYXRlPT09bnVsbD8nbW91bnQnOid1cGRhdGUnO3tpZihpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSl7cGhhc2U9J25lc3RlZC11cGRhdGUnO319aWYodHlwZW9mIG9uUG9zdENvbW1pdD09PSdmdW5jdGlvbicpe29uUG9zdENvbW1pdChpZCxwaGFzZSxwYXNzaXZlRWZmZWN0RHVyYXRpb24sY29tbWl0VGltZSk7fS8vIEJ1YmJsZSB0aW1lcyB0byB0aGUgbmV4dCBuZWFyZXN0IGFuY2VzdG9yIFByb2ZpbGVyLlxuLy8gQWZ0ZXIgd2UgcHJvY2VzcyB0aGF0IFByb2ZpbGVyLCB3ZSdsbCBidWJibGUgZnVydGhlciB1cC5cbnZhciBwYXJlbnRGaWJlcj1maW5pc2hlZFdvcmsucmV0dXJuO291dGVyOndoaWxlKHBhcmVudEZpYmVyIT09bnVsbCl7c3dpdGNoKHBhcmVudEZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp2YXIgcm9vdD1wYXJlbnRGaWJlci5zdGF0ZU5vZGU7cm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24rPXBhc3NpdmVFZmZlY3REdXJhdGlvbjticmVhayBvdXRlcjtjYXNlIFByb2ZpbGVyOnZhciBwYXJlbnRTdGF0ZU5vZGU9cGFyZW50RmliZXIuc3RhdGVOb2RlO3BhcmVudFN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24rPXBhc3NpdmVFZmZlY3REdXJhdGlvbjticmVhayBvdXRlcjt9cGFyZW50RmliZXI9cGFyZW50RmliZXIucmV0dXJuO31icmVhazt9fX19fWZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIoZmluaXNoZWRSb290LGN1cnJlbnQsZmluaXNoZWRXb3JrLGNvbW1pdHRlZExhbmVzKXtpZigoZmluaXNoZWRXb3JrLmZsYWdzJkxheW91dE1hc2spIT09Tm9GbGFncyl7c3dpdGNoKGZpbmlzaGVkV29yay50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7aWYoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pey8vIEF0IHRoaXMgcG9pbnQgbGF5b3V0IGVmZmVjdHMgaGF2ZSBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIChkdXJpbmcgbXV0YXRpb24gcGhhc2UpLlxuLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbi8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cbmlmKGZpbmlzaGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKXt0cnl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO2NvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoTGF5b3V0fEhhc0VmZmVjdCxmaW5pc2hlZFdvcmspO31maW5hbGx5e3JlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7fX1lbHNle2NvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoTGF5b3V0fEhhc0VmZmVjdCxmaW5pc2hlZFdvcmspO319YnJlYWs7fWNhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBpbnN0YW5jZT1maW5pc2hlZFdvcmsuc3RhdGVOb2RlO2lmKGZpbmlzaGVkV29yay5mbGFncyZVcGRhdGUpe2lmKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKXtpZihjdXJyZW50PT09bnVsbCl7Ly8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4vLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG57aWYoZmluaXNoZWRXb3JrLnR5cGU9PT1maW5pc2hlZFdvcmsuZWxlbWVudFR5cGUmJiFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKXtpZihpbnN0YW5jZS5wcm9wcyE9PWZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKXtlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcrJ2NvbXBvbmVudERpZE1vdW50LiAnKydUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcrJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJysnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yayl8fCdpbnN0YW5jZScpO31pZihpbnN0YW5jZS5zdGF0ZSE9PWZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKXtlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcrJ2NvbXBvbmVudERpZE1vdW50LiAnKydUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcrJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJysnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yayl8fCdpbnN0YW5jZScpO319fWlmKGZpbmlzaGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKXt0cnl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7fWZpbmFsbHl7cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTt9fWVsc2V7aW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTt9fWVsc2V7dmFyIHByZXZQcm9wcz1maW5pc2hlZFdvcmsuZWxlbWVudFR5cGU9PT1maW5pc2hlZFdvcmsudHlwZT9jdXJyZW50Lm1lbW9pemVkUHJvcHM6cmVzb2x2ZURlZmF1bHRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSxjdXJyZW50Lm1lbW9pemVkUHJvcHMpO3ZhciBwcmV2U3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlOy8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbi8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxue2lmKGZpbmlzaGVkV29yay50eXBlPT09ZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlJiYhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyl7aWYoaW5zdGFuY2UucHJvcHMhPT1maW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyl7ZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnKydjb21wb25lbnREaWRVcGRhdGUuICcrJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJysnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnKydQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKXx8J2luc3RhbmNlJyk7fWlmKGluc3RhbmNlLnN0YXRlIT09ZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpe2Vycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJysnY29tcG9uZW50RGlkVXBkYXRlLiAnKydUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcrJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJysnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yayl8fCdpbnN0YW5jZScpO319fWlmKGZpbmlzaGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKXt0cnl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMscHJldlN0YXRlLGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTt9ZmluYWxseXtyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO319ZWxzZXtpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLHByZXZTdGF0ZSxpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7fX19fS8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4vLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxudmFyIHVwZGF0ZVF1ZXVlPWZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtpZih1cGRhdGVRdWV1ZSE9PW51bGwpe3tpZihmaW5pc2hlZFdvcmsudHlwZT09PWZpbmlzaGVkV29yay5lbGVtZW50VHlwZSYmIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpe2lmKGluc3RhbmNlLnByb3BzIT09ZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpe2Vycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJysncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnKydUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcrJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJysnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yayl8fCdpbnN0YW5jZScpO31pZihpbnN0YW5jZS5zdGF0ZSE9PWZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKXtlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcrJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJysnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnKydhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcrJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspfHwnaW5zdGFuY2UnKTt9fX0vLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4vLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbi8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbmNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yayx1cGRhdGVRdWV1ZSxpbnN0YW5jZSk7fWJyZWFrO31jYXNlIEhvc3RSb290OnsvLyBUT0RPOiBJIHRoaW5rIHRoaXMgaXMgbm93IGFsd2F5cyBub24tbnVsbCBieSB0aGUgdGltZSBpdCByZWFjaGVzIHRoZVxuLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cbnZhciBfdXBkYXRlUXVldWU9ZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO2lmKF91cGRhdGVRdWV1ZSE9PW51bGwpe3ZhciBfaW5zdGFuY2U9bnVsbDtpZihmaW5pc2hlZFdvcmsuY2hpbGQhPT1udWxsKXtzd2l0Y2goZmluaXNoZWRXb3JrLmNoaWxkLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50Ol9pbnN0YW5jZT1nZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTticmVhaztjYXNlIENsYXNzQ29tcG9uZW50Ol9pbnN0YW5jZT1maW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO2JyZWFrO319Y29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLF91cGRhdGVRdWV1ZSxfaW5zdGFuY2UpO31icmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgX2luc3RhbmNlMj1maW5pc2hlZFdvcmsuc3RhdGVOb2RlOy8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbi8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbi8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuaWYoY3VycmVudD09PW51bGwmJmZpbmlzaGVkV29yay5mbGFncyZVcGRhdGUpe3ZhciB0eXBlPWZpbmlzaGVkV29yay50eXBlO3ZhciBwcm9wcz1maW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztjb21taXRNb3VudChfaW5zdGFuY2UyLHR5cGUscHJvcHMpO31icmVhazt9Y2FzZSBIb3N0VGV4dDp7Ly8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbmJyZWFrO31jYXNlIEhvc3RQb3J0YWw6ey8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG5icmVhazt9Y2FzZSBQcm9maWxlcjp7e3ZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyPWZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLG9uQ29tbWl0PV9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Db21taXQsb25SZW5kZXI9X2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblJlbmRlcjt2YXIgZWZmZWN0RHVyYXRpb249ZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbjt2YXIgY29tbWl0VGltZT1nZXRDb21taXRUaW1lKCk7dmFyIHBoYXNlPWN1cnJlbnQ9PT1udWxsPydtb3VudCc6J3VwZGF0ZSc7e2lmKGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpKXtwaGFzZT0nbmVzdGVkLXVwZGF0ZSc7fX1pZih0eXBlb2Ygb25SZW5kZXI9PT0nZnVuY3Rpb24nKXtvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCxwaGFzZSxmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSxjb21taXRUaW1lKTt9e2lmKHR5cGVvZiBvbkNvbW1pdD09PSdmdW5jdGlvbicpe29uQ29tbWl0KGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLHBoYXNlLGVmZmVjdER1cmF0aW9uLGNvbW1pdFRpbWUpO30vLyBTY2hlZHVsZSBhIHBhc3NpdmUgZWZmZWN0IGZvciB0aGlzIFByb2ZpbGVyIHRvIGNhbGwgb25Qb3N0Q29tbWl0IGhvb2tzLlxuLy8gVGhpcyBlZmZlY3Qgc2hvdWxkIGJlIHNjaGVkdWxlZCBldmVuIGlmIHRoZXJlIGlzIG5vIG9uUG9zdENvbW1pdCBjYWxsYmFjayBmb3IgdGhpcyBQcm9maWxlcixcbi8vIGJlY2F1c2UgdGhlIGVmZmVjdCBpcyBhbHNvIHdoZXJlIHRpbWVzIGJ1YmJsZSB0byBwYXJlbnQgUHJvZmlsZXJzLlxuZW5xdWV1ZVBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3QoZmluaXNoZWRXb3JrKTsvLyBQcm9wYWdhdGUgbGF5b3V0IGVmZmVjdCBkdXJhdGlvbnMgdG8gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3Rvci5cbi8vIERvIG5vdCByZXNldCB0aGVzZSB2YWx1ZXMgdW50aWwgdGhlIG5leHQgcmVuZGVyIHNvIERldlRvb2xzIGhhcyBhIGNoYW5jZSB0byByZWFkIHRoZW0gZmlyc3QuXG52YXIgcGFyZW50RmliZXI9ZmluaXNoZWRXb3JrLnJldHVybjtvdXRlcjp3aGlsZShwYXJlbnRGaWJlciE9PW51bGwpe3N3aXRjaChwYXJlbnRGaWJlci50YWcpe2Nhc2UgSG9zdFJvb3Q6dmFyIHJvb3Q9cGFyZW50RmliZXIuc3RhdGVOb2RlO3Jvb3QuZWZmZWN0RHVyYXRpb24rPWVmZmVjdER1cmF0aW9uO2JyZWFrIG91dGVyO2Nhc2UgUHJvZmlsZXI6dmFyIHBhcmVudFN0YXRlTm9kZT1wYXJlbnRGaWJlci5zdGF0ZU5vZGU7cGFyZW50U3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uKz1lZmZlY3REdXJhdGlvbjticmVhayBvdXRlcjt9cGFyZW50RmliZXI9cGFyZW50RmliZXIucmV0dXJuO319fWJyZWFrO31jYXNlIFN1c3BlbnNlQ29tcG9uZW50Ontjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsZmluaXNoZWRXb3JrKTticmVhazt9Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6Y2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6Y2FzZSBTY29wZUNvbXBvbmVudDpjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6e2JyZWFrO31kZWZhdWx0OnRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgJysnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX1pZighb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbil7e2lmKGZpbmlzaGVkV29yay5mbGFncyZSZWYpe2NvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspO319fX1mdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHNPbkZpYmVyKG5vZGUpey8vIFR1cm4gb24gbGF5b3V0IGVmZmVjdHMgaW4gYSB0cmVlIHRoYXQgcHJldmlvdXNseSBkaXNhcHBlYXJlZC5cbi8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgTGF5b3V0U3RhdGljXG5zd2l0Y2gobm9kZS50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7aWYobm9kZS5tb2RlJlByb2ZpbGVNb2RlKXt0cnl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO3NhZmVseUNhbGxDb21taXRIb29rTGF5b3V0RWZmZWN0TGlzdE1vdW50KG5vZGUsbm9kZS5yZXR1cm4pO31maW5hbGx5e3JlY29yZExheW91dEVmZmVjdER1cmF0aW9uKG5vZGUpO319ZWxzZXtzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChub2RlLG5vZGUucmV0dXJuKTt9YnJlYWs7fWNhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBpbnN0YW5jZT1ub2RlLnN0YXRlTm9kZTtpZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQ9PT0nZnVuY3Rpb24nKXtzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQobm9kZSxub2RlLnJldHVybixpbnN0YW5jZSk7fXNhZmVseUF0dGFjaFJlZihub2RlLG5vZGUucmV0dXJuKTticmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50OntzYWZlbHlBdHRhY2hSZWYobm9kZSxub2RlLnJldHVybik7YnJlYWs7fX19ZnVuY3Rpb24gaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLGlzSGlkZGVuKXsvLyBPbmx5IGhpZGUgb3IgdW5oaWRlIHRoZSB0b3AtbW9zdCBob3N0IG5vZGVzLlxudmFyIGhvc3RTdWJ0cmVlUm9vdD1udWxsO3svLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4vLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG52YXIgbm9kZT1maW5pc2hlZFdvcms7d2hpbGUodHJ1ZSl7aWYobm9kZS50YWc9PT1Ib3N0Q29tcG9uZW50KXtpZihob3N0U3VidHJlZVJvb3Q9PT1udWxsKXtob3N0U3VidHJlZVJvb3Q9bm9kZTt0cnl7dmFyIGluc3RhbmNlPW5vZGUuc3RhdGVOb2RlO2lmKGlzSGlkZGVuKXtoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO31lbHNle3VuaGlkZUluc3RhbmNlKG5vZGUuc3RhdGVOb2RlLG5vZGUubWVtb2l6ZWRQcm9wcyk7fX1jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO319fWVsc2UgaWYobm9kZS50YWc9PT1Ib3N0VGV4dCl7aWYoaG9zdFN1YnRyZWVSb290PT09bnVsbCl7dHJ5e3ZhciBfaW5zdGFuY2UzPW5vZGUuc3RhdGVOb2RlO2lmKGlzSGlkZGVuKXtoaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMpO31lbHNle3VuaGlkZVRleHRJbnN0YW5jZShfaW5zdGFuY2UzLG5vZGUubWVtb2l6ZWRQcm9wcyk7fX1jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO319fWVsc2UgaWYoKG5vZGUudGFnPT09T2Zmc2NyZWVuQ29tcG9uZW50fHxub2RlLnRhZz09PUxlZ2FjeUhpZGRlbkNvbXBvbmVudCkmJm5vZGUubWVtb2l6ZWRTdGF0ZSE9PW51bGwmJm5vZGUhPT1maW5pc2hlZFdvcmspO2Vsc2UgaWYobm9kZS5jaGlsZCE9PW51bGwpe25vZGUuY2hpbGQucmV0dXJuPW5vZGU7bm9kZT1ub2RlLmNoaWxkO2NvbnRpbnVlO31pZihub2RlPT09ZmluaXNoZWRXb3JrKXtyZXR1cm47fXdoaWxlKG5vZGUuc2libGluZz09PW51bGwpe2lmKG5vZGUucmV0dXJuPT09bnVsbHx8bm9kZS5yZXR1cm49PT1maW5pc2hlZFdvcmspe3JldHVybjt9aWYoaG9zdFN1YnRyZWVSb290PT09bm9kZSl7aG9zdFN1YnRyZWVSb290PW51bGw7fW5vZGU9bm9kZS5yZXR1cm47fWlmKGhvc3RTdWJ0cmVlUm9vdD09PW5vZGUpe2hvc3RTdWJ0cmVlUm9vdD1udWxsO31ub2RlLnNpYmxpbmcucmV0dXJuPW5vZGUucmV0dXJuO25vZGU9bm9kZS5zaWJsaW5nO319fWZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspe3ZhciByZWY9ZmluaXNoZWRXb3JrLnJlZjtpZihyZWYhPT1udWxsKXt2YXIgaW5zdGFuY2U9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTt2YXIgaW5zdGFuY2VUb1VzZTtzd2l0Y2goZmluaXNoZWRXb3JrLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50Omluc3RhbmNlVG9Vc2U9Z2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO2JyZWFrO2RlZmF1bHQ6aW5zdGFuY2VUb1VzZT1pbnN0YW5jZTt9Ly8gTW92ZWQgb3V0c2lkZSB0byBlbnN1cmUgRENFIHdvcmtzIHdpdGggdGhpcyBmbGFnXG5pZih0eXBlb2YgcmVmPT09J2Z1bmN0aW9uJyl7dmFyIHJldFZhbDtpZihmaW5pc2hlZFdvcmsubW9kZSZQcm9maWxlTW9kZSl7dHJ5e3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtyZXRWYWw9cmVmKGluc3RhbmNlVG9Vc2UpO31maW5hbGx5e3JlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7fX1lbHNle3JldFZhbD1yZWYoaW5zdGFuY2VUb1VzZSk7fXtpZih0eXBlb2YgcmV0VmFsPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gYSBjYWxsYmFjayByZWYgaW4gJXMuICcrJ0EgY2FsbGJhY2sgcmVmIHNob3VsZCBub3QgcmV0dXJuIGEgZnVuY3Rpb24uJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykpO319fWVsc2V7e2lmKCFyZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSl7ZXJyb3IoJ1VuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuICcrJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspKTt9fXJlZi5jdXJyZW50PWluc3RhbmNlVG9Vc2U7fX19ZnVuY3Rpb24gZGV0YWNoRmliZXJNdXRhdGlvbihmaWJlcil7Ly8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXIgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLlxuLy8gVGhpcyBlbmFibGVzIHVzIHRvIGRldGVjdCBhbmQgd2FybiBhZ2FpbnN0IHN0YXRlIHVwZGF0ZXMgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cbi8vIEl0IGFsc28gcHJldmVudHMgZXZlbnRzIGZyb20gYnViYmxpbmcgZnJvbSB3aXRoaW4gZGlzY29ubmVjdGVkIGNvbXBvbmVudHMuXG4vL1xuLy8gSWRlYWxseSwgd2Ugc2hvdWxkIGFsc28gY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbi8vIGdldCBHQzplZCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmb3Igc3VyZSB3aGljaCBwYXJlbnQgaXMgdGhlIGN1cnJlbnRcbi8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLlxuLy8gVGhpcyBjaGlsZCBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuLy9cbi8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjbGVhciBjaGlsZCBvciBzaWJsaW5nIHBvaW50ZXJzIHlldC5cbi8vIFRoZXkncmUgbmVlZGVkIGZvciBwYXNzaXZlIGVmZmVjdHMgYW5kIGZvciBmaW5kRE9NTm9kZS5cbi8vIFdlIGRlZmVyIHRob3NlIGZpZWxkcywgYW5kIGFsbCBvdGhlciBjbGVhbnVwLCB0byB0aGUgcGFzc2l2ZSBwaGFzZSAoc2VlIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKS5cbi8vXG4vLyBEb24ndCByZXNldCB0aGUgYWx0ZXJuYXRlIHlldCwgZWl0aGVyLiBXZSBuZWVkIHRoYXQgc28gd2UgY2FuIGRldGFjaCB0aGVcbi8vIGFsdGVybmF0ZSdzIGZpZWxkcyBpbiB0aGUgcGFzc2l2ZSBwaGFzZS4gQ2xlYXJpbmcgdGhlIHJldHVybiBwb2ludGVyIGlzXG4vLyBzdWZmaWNpZW50IGZvciBmaW5kRE9NTm9kZSBzZW1hbnRpY3MuXG52YXIgYWx0ZXJuYXRlPWZpYmVyLmFsdGVybmF0ZTtpZihhbHRlcm5hdGUhPT1udWxsKXthbHRlcm5hdGUucmV0dXJuPW51bGw7fWZpYmVyLnJldHVybj1udWxsO31mdW5jdGlvbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhmaWJlcil7dmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGU7aWYoYWx0ZXJuYXRlIT09bnVsbCl7ZmliZXIuYWx0ZXJuYXRlPW51bGw7ZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoYWx0ZXJuYXRlKTt9Ly8gTm90ZTogRGVmZW5zaXZlbHkgdXNpbmcgbmVnYXRpb24gaW5zdGVhZCBvZiA8IGluIGNhc2Vcbi8vIGBkZWxldGVkVHJlZUNsZWFuVXBMZXZlbGAgaXMgdW5kZWZpbmVkLlxuey8vIENsZWFyIGN5Y2xpY2FsIEZpYmVyIGZpZWxkcy4gVGhpcyBsZXZlbCBhbG9uZSBpcyBkZXNpZ25lZCB0byByb3VnaGx5XG4vLyBhcHByb3hpbWF0ZSB0aGUgcGxhbm5lZCBGaWJlciByZWZhY3Rvci4gSW4gdGhhdCB3b3JsZCwgYHNldFN0YXRlYCB3aWxsIGJlXG4vLyBib3VuZCB0byBhIHNwZWNpYWwgXCJpbnN0YW5jZVwiIG9iamVjdCBpbnN0ZWFkIG9mIGEgRmliZXIuIFRoZSBJbnN0YW5jZVxuLy8gb2JqZWN0IHdpbGwgbm90IGhhdmUgYW55IG9mIHRoZXNlIGZpZWxkcy4gSXQgd2lsbCBvbmx5IGJlIGNvbm5lY3RlZCB0b1xuLy8gdGhlIGZpYmVyIHRyZWUgdmlhIGEgc2luZ2xlIGxpbmsgYXQgdGhlIHJvb3QuIFNvIGlmIHRoaXMgbGV2ZWwgYWxvbmUgaXNcbi8vIHN1ZmZpY2llbnQgdG8gZml4IG1lbW9yeSBpc3N1ZXMsIHRoYXQgYm9kZXMgd2VsbCBmb3Igb3VyIHBsYW5zLlxuZmliZXIuY2hpbGQ9bnVsbDtmaWJlci5kZWxldGlvbnM9bnVsbDtmaWJlci5zaWJsaW5nPW51bGw7Ly8gVGhlIGBzdGF0ZU5vZGVgIGlzIGN5Y2xpY2FsIGJlY2F1c2Ugb24gaG9zdCBub2RlcyBpdCBwb2ludHMgdG8gdGhlIGhvc3Rcbi8vIHRyZWUsIHdoaWNoIGhhcyBpdHMgb3duIHBvaW50ZXJzIHRvIGNoaWxkcmVuLCBwYXJlbnRzLCBhbmQgc2libGluZ3MuXG4vLyBUaGUgb3RoZXIgaG9zdCBub2RlcyBhbHNvIHBvaW50IGJhY2sgdG8gZmliZXJzLCBzbyB3ZSBzaG91bGQgZGV0YWNoIHRoYXRcbi8vIG9uZSwgdG9vLlxuaWYoZmliZXIudGFnPT09SG9zdENvbXBvbmVudCl7dmFyIGhvc3RJbnN0YW5jZT1maWJlci5zdGF0ZU5vZGU7aWYoaG9zdEluc3RhbmNlIT09bnVsbCl7ZGV0YWNoRGVsZXRlZEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7fX1maWJlci5zdGF0ZU5vZGU9bnVsbDsvLyBJJ20gaW50ZW50aW9uYWxseSBub3QgY2xlYXJpbmcgdGhlIGByZXR1cm5gIGZpZWxkIGluIHRoaXMgbGV2ZWwuIFdlXG4vLyBhbHJlYWR5IGRpc2Nvbm5lY3QgdGhlIGByZXR1cm5gIHBvaW50ZXIgYXQgdGhlIHJvb3Qgb2YgdGhlIGRlbGV0ZWRcbi8vIHN1YnRyZWUgKGluIGBkZXRhY2hGaWJlck11dGF0aW9uYCkuIEJlc2lkZXMsIGByZXR1cm5gIGJ5IGl0c2VsZiBpcyBub3Rcbi8vIGN5Y2xpY2FsIOKAlCBpdCdzIG9ubHkgY3ljbGljYWwgd2hlbiBjb21iaW5lZCB3aXRoIGBjaGlsZGAsIGBzaWJsaW5nYCwgYW5kXG4vLyBgYWx0ZXJuYXRlYC4gQnV0IHdlJ2xsIGNsZWFyIGl0IGluIHRoZSBuZXh0IGxldmVsIGFueXdheSwganVzdCBpbiBjYXNlLlxue2ZpYmVyLl9kZWJ1Z093bmVyPW51bGw7fXsvLyBUaGVvcmV0aWNhbGx5LCBub3RoaW5nIGluIGhlcmUgc2hvdWxkIGJlIG5lY2Vzc2FyeSwgYmVjYXVzZSB3ZSBhbHJlYWR5XG4vLyBkaXNjb25uZWN0ZWQgdGhlIGZpYmVyIGZyb20gdGhlIHRyZWUuIFNvIGV2ZW4gaWYgc29tZXRoaW5nIGxlYWtzIHRoaXNcbi8vIHBhcnRpY3VsYXIgZmliZXIsIGl0IHdvbid0IGxlYWsgYW55dGhpbmcgZWxzZVxuLy9cbi8vIFRoZSBwdXJwb3NlIG9mIHRoaXMgYnJhbmNoIGlzIHRvIGJlIHN1cGVyIGFnZ3Jlc3NpdmUgc28gd2UgY2FuIG1lYXN1cmVcbi8vIGlmIHRoZXJlJ3MgYW55IGRpZmZlcmVuY2UgaW4gbWVtb3J5IGltcGFjdC4gSWYgdGhlcmUgaXMsIHRoYXQgY291bGRcbi8vIGluZGljYXRlIGEgUmVhY3QgbGVhayB3ZSBkb24ndCBrbm93IGFib3V0LlxuZmliZXIucmV0dXJuPW51bGw7ZmliZXIuZGVwZW5kZW5jaWVzPW51bGw7ZmliZXIubWVtb2l6ZWRQcm9wcz1udWxsO2ZpYmVyLm1lbW9pemVkU3RhdGU9bnVsbDtmaWJlci5wZW5kaW5nUHJvcHM9bnVsbDtmaWJlci5zdGF0ZU5vZGU9bnVsbDsvLyBUT0RPOiBNb3ZlIHRvIGBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcmAgaW5zdGVhZC5cbmZpYmVyLnVwZGF0ZVF1ZXVlPW51bGw7fX19ZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKXt2YXIgcGFyZW50PWZpYmVyLnJldHVybjt3aGlsZShwYXJlbnQhPT1udWxsKXtpZihpc0hvc3RQYXJlbnQocGFyZW50KSl7cmV0dXJuIHBhcmVudDt9cGFyZW50PXBhcmVudC5yZXR1cm47fXRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJysnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpe3JldHVybiBmaWJlci50YWc9PT1Ib3N0Q29tcG9uZW50fHxmaWJlci50YWc9PT1Ib3N0Um9vdHx8ZmliZXIudGFnPT09SG9zdFBvcnRhbDt9ZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpey8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuLy8gbm9kZS4gVW5mb3J0dW5hdGVseSwgaWYgbXVsdGlwbGUgaW5zZXJ0aW9ucyBhcmUgZG9uZSBpbiBhIHJvdyB3ZSBoYXZlIHRvXG4vLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbi8vIFRPRE86IEZpbmQgYSBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpcy5cbnZhciBub2RlPWZpYmVyO3NpYmxpbmdzOndoaWxlKHRydWUpey8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbndoaWxlKG5vZGUuc2libGluZz09PW51bGwpe2lmKG5vZGUucmV0dXJuPT09bnVsbHx8aXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSl7Ly8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuLy8gbGFzdCBzaWJsaW5nLlxucmV0dXJuIG51bGw7fW5vZGU9bm9kZS5yZXR1cm47fW5vZGUuc2libGluZy5yZXR1cm49bm9kZS5yZXR1cm47bm9kZT1ub2RlLnNpYmxpbmc7d2hpbGUobm9kZS50YWchPT1Ib3N0Q29tcG9uZW50JiZub2RlLnRhZyE9PUhvc3RUZXh0JiZub2RlLnRhZyE9PURlaHlkcmF0ZWRGcmFnbWVudCl7Ly8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuaWYobm9kZS5mbGFncyZQbGFjZW1lbnQpey8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuY29udGludWUgc2libGluZ3M7fS8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuLy8gV2UgYWxzbyBza2lwIHBvcnRhbHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgcGFydCBvZiB0aGlzIGhvc3QgdHJlZS5cbmlmKG5vZGUuY2hpbGQ9PT1udWxsfHxub2RlLnRhZz09PUhvc3RQb3J0YWwpe2NvbnRpbnVlIHNpYmxpbmdzO31lbHNle25vZGUuY2hpbGQucmV0dXJuPW5vZGU7bm9kZT1ub2RlLmNoaWxkO319Ly8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbmlmKCEobm9kZS5mbGFncyZQbGFjZW1lbnQpKXsvLyBGb3VuZCBpdCFcbnJldHVybiBub2RlLnN0YXRlTm9kZTt9fX1mdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKXt2YXIgcGFyZW50RmliZXI9Z2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7Ly8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5zd2l0Y2gocGFyZW50RmliZXIudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6e3ZhciBwYXJlbnQ9cGFyZW50RmliZXIuc3RhdGVOb2RlO2lmKHBhcmVudEZpYmVyLmZsYWdzJkNvbnRlbnRSZXNldCl7Ly8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xucmVzZXRUZXh0Q29udGVudChwYXJlbnQpOy8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG5wYXJlbnRGaWJlci5mbGFncyY9fkNvbnRlbnRSZXNldDt9dmFyIGJlZm9yZT1nZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspOy8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbi8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbmluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssYmVmb3JlLHBhcmVudCk7YnJlYWs7fWNhc2UgSG9zdFJvb3Q6Y2FzZSBIb3N0UG9ydGFsOnt2YXIgX3BhcmVudD1wYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzt2YXIgX2JlZm9yZT1nZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO2luc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoZmluaXNoZWRXb3JrLF9iZWZvcmUsX3BhcmVudCk7YnJlYWs7fS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnKydpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX1mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsYmVmb3JlLHBhcmVudCl7dmFyIHRhZz1ub2RlLnRhZzt2YXIgaXNIb3N0PXRhZz09PUhvc3RDb21wb25lbnR8fHRhZz09PUhvc3RUZXh0O2lmKGlzSG9zdCl7dmFyIHN0YXRlTm9kZT1ub2RlLnN0YXRlTm9kZTtpZihiZWZvcmUpe2luc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCxzdGF0ZU5vZGUsYmVmb3JlKTt9ZWxzZXthcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCxzdGF0ZU5vZGUpO319ZWxzZSBpZih0YWc9PT1Ib3N0UG9ydGFsKTtlbHNle3ZhciBjaGlsZD1ub2RlLmNoaWxkO2lmKGNoaWxkIT09bnVsbCl7aW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihjaGlsZCxiZWZvcmUscGFyZW50KTt2YXIgc2libGluZz1jaGlsZC5zaWJsaW5nO3doaWxlKHNpYmxpbmchPT1udWxsKXtpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKHNpYmxpbmcsYmVmb3JlLHBhcmVudCk7c2libGluZz1zaWJsaW5nLnNpYmxpbmc7fX19fWZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLGJlZm9yZSxwYXJlbnQpe3ZhciB0YWc9bm9kZS50YWc7dmFyIGlzSG9zdD10YWc9PT1Ib3N0Q29tcG9uZW50fHx0YWc9PT1Ib3N0VGV4dDtpZihpc0hvc3Qpe3ZhciBzdGF0ZU5vZGU9bm9kZS5zdGF0ZU5vZGU7aWYoYmVmb3JlKXtpbnNlcnRCZWZvcmUocGFyZW50LHN0YXRlTm9kZSxiZWZvcmUpO31lbHNle2FwcGVuZENoaWxkKHBhcmVudCxzdGF0ZU5vZGUpO319ZWxzZSBpZih0YWc9PT1Ib3N0UG9ydGFsKTtlbHNle3ZhciBjaGlsZD1ub2RlLmNoaWxkO2lmKGNoaWxkIT09bnVsbCl7aW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGNoaWxkLGJlZm9yZSxwYXJlbnQpO3ZhciBzaWJsaW5nPWNoaWxkLnNpYmxpbmc7d2hpbGUoc2libGluZyE9PW51bGwpe2luc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShzaWJsaW5nLGJlZm9yZSxwYXJlbnQpO3NpYmxpbmc9c2libGluZy5zaWJsaW5nO319fX0vLyBUaGVzZSBhcmUgdHJhY2tlZCBvbiB0aGUgc3RhY2sgYXMgd2UgcmVjdXJzaXZlbHkgdHJhdmVyc2UgYVxuLy8gZGVsZXRlZCBzdWJ0cmVlLlxuLy8gVE9ETzogVXBkYXRlIHRoZXNlIGR1cmluZyB0aGUgd2hvbGUgbXV0YXRpb24gcGhhc2UsIG5vdCBqdXN0IGR1cmluZ1xuLy8gYSBkZWxldGlvbi5cbnZhciBob3N0UGFyZW50PW51bGw7dmFyIGhvc3RQYXJlbnRJc0NvbnRhaW5lcj1mYWxzZTtmdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHMocm9vdCxyZXR1cm5GaWJlcixkZWxldGVkRmliZXIpe3svLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBkZWxldGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbi8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbi8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQsIGRldGFjaCByZWZzLCBjbGVhblxuLy8gdXAgbW91bnRlZCBsYXlvdXQgZWZmZWN0cywgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQuXG4vLyBXZSBvbmx5IG5lZWQgdG8gcmVtb3ZlIHRoZSB0b3Btb3N0IGhvc3QgY2hpbGQgaW4gZWFjaCBicmFuY2guIEJ1dCB0aGVuIHdlXG4vLyBzdGlsbCBuZWVkIHRvIGtlZXAgdHJhdmVyc2luZyB0byB1bm1vdW50IGVmZmVjdHMsIHJlZnMsIGFuZCBjV1UuIFRPRE86IFdlXG4vLyBjb3VsZCBzcGxpdCB0aGlzIGludG8gdHdvIHNlcGFyYXRlIHRyYXZlcnNhbHMgZnVuY3Rpb25zLCB3aGVyZSB0aGUgc2Vjb25kXG4vLyBvbmUgZG9lc24ndCBpbmNsdWRlIGFueSByZW1vdmVDaGlsZCBsb2dpYy4gVGhpcyBpcyBtYXliZSB0aGUgc2FtZVxuLy8gZnVuY3Rpb24gYXMgXCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzXCIgKG9yIHdoYXRldmVyIHRoYXQgdHVybnMgaW50byBhZnRlclxuLy8gdGhlIGxheW91dCBwaGFzZSBpcyByZWZhY3RvcmVkIHRvIHVzZSByZWN1cnNpb24pLlxuLy8gQmVmb3JlIHN0YXJ0aW5nLCBmaW5kIHRoZSBuZWFyZXN0IGhvc3QgcGFyZW50IG9uIHRoZSBzdGFjayBzbyB3ZSBrbm93XG4vLyB3aGljaCBpbnN0YW5jZS9jb250YWluZXIgdG8gcmVtb3ZlIHRoZSBjaGlsZHJlbiBmcm9tLlxuLy8gVE9ETzogSW5zdGVhZCBvZiBzZWFyY2hpbmcgdXAgdGhlIGZpYmVyIHJldHVybiBwYXRoIG9uIGV2ZXJ5IGRlbGV0aW9uLCB3ZVxuLy8gY2FuIHRyYWNrIHRoZSBuZWFyZXN0IGhvc3QgY29tcG9uZW50IG9uIHRoZSBKUyBzdGFjayBhcyB3ZSB0cmF2ZXJzZSB0aGVcbi8vIHRyZWUgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFRoaXMgd291bGQgbWFrZSBpbnNlcnRpb25zIGZhc3RlciwgdG9vLlxudmFyIHBhcmVudD1yZXR1cm5GaWJlcjtmaW5kUGFyZW50OndoaWxlKHBhcmVudCE9PW51bGwpe3N3aXRjaChwYXJlbnQudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6e2hvc3RQYXJlbnQ9cGFyZW50LnN0YXRlTm9kZTtob3N0UGFyZW50SXNDb250YWluZXI9ZmFsc2U7YnJlYWsgZmluZFBhcmVudDt9Y2FzZSBIb3N0Um9vdDp7aG9zdFBhcmVudD1wYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87aG9zdFBhcmVudElzQ29udGFpbmVyPXRydWU7YnJlYWsgZmluZFBhcmVudDt9Y2FzZSBIb3N0UG9ydGFsOntob3N0UGFyZW50PXBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztob3N0UGFyZW50SXNDb250YWluZXI9dHJ1ZTticmVhayBmaW5kUGFyZW50O319cGFyZW50PXBhcmVudC5yZXR1cm47fWlmKGhvc3RQYXJlbnQ9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5ICcrJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9Y29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LHJldHVybkZpYmVyLGRlbGV0ZWRGaWJlcik7aG9zdFBhcmVudD1udWxsO2hvc3RQYXJlbnRJc0NvbnRhaW5lcj1mYWxzZTt9ZGV0YWNoRmliZXJNdXRhdGlvbihkZWxldGVkRmliZXIpO31mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLHBhcmVudCl7Ly8gVE9ETzogVXNlIGEgc3RhdGljIGZsYWcgdG8gc2tpcCB0cmVlcyB0aGF0IGRvbid0IGhhdmUgdW5tb3VudCBlZmZlY3RzXG52YXIgY2hpbGQ9cGFyZW50LmNoaWxkO3doaWxlKGNoaWxkIT09bnVsbCl7Y29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixjaGlsZCk7Y2hpbGQ9Y2hpbGQuc2libGluZzt9fWZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVsZXRlZEZpYmVyKXtvbkNvbW1pdFVubW91bnQoZGVsZXRlZEZpYmVyKTsvLyBUaGUgY2FzZXMgaW4gdGhpcyBvdXRlciBzd2l0Y2ggbW9kaWZ5IHRoZSBzdGFjayBiZWZvcmUgdGhleSB0cmF2ZXJzZVxuLy8gaW50byB0aGVpciBzdWJ0cmVlLiBUaGVyZSBhcmUgc2ltcGxlciBjYXNlcyBpbiB0aGUgaW5uZXIgc3dpdGNoXG4vLyB0aGF0IGRvbid0IG1vZGlmeSB0aGUgc3RhY2suXG5zd2l0Y2goZGVsZXRlZEZpYmVyLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50OntpZighb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbil7c2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlcixuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTt9Ly8gSW50ZW50aW9uYWwgZmFsbHRocm91Z2ggdG8gbmV4dCBicmFuY2hcbn0vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcbmNhc2UgSG9zdFRleHQ6ey8vIFdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlIG5lYXJlc3QgaG9zdCBjaGlsZC4gU2V0IHRoZSBob3N0IHBhcmVudFxuLy8gdG8gYG51bGxgIG9uIHRoZSBzdGFjayB0byBpbmRpY2F0ZSB0aGF0IG5lc3RlZCBjaGlsZHJlbiBkb24ndFxuLy8gbmVlZCB0byBiZSByZW1vdmVkLlxue3ZhciBwcmV2SG9zdFBhcmVudD1ob3N0UGFyZW50O3ZhciBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyPWhvc3RQYXJlbnRJc0NvbnRhaW5lcjtob3N0UGFyZW50PW51bGw7cmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZWxldGVkRmliZXIpO2hvc3RQYXJlbnQ9cHJldkhvc3RQYXJlbnQ7aG9zdFBhcmVudElzQ29udGFpbmVyPXByZXZIb3N0UGFyZW50SXNDb250YWluZXI7aWYoaG9zdFBhcmVudCE9PW51bGwpey8vIE5vdyB0aGF0IGFsbCB0aGUgY2hpbGQgZWZmZWN0cyBoYXZlIHVubW91bnRlZCwgd2UgY2FuIHJlbW92ZSB0aGVcbi8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbmlmKGhvc3RQYXJlbnRJc0NvbnRhaW5lcil7cmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGhvc3RQYXJlbnQsZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7fWVsc2V7cmVtb3ZlQ2hpbGQoaG9zdFBhcmVudCxkZWxldGVkRmliZXIuc3RhdGVOb2RlKTt9fX1yZXR1cm47fWNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OnsvLyBEZWxldGUgdGhlIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgYW5kIGFsbCBvZiBpdHMgY29udGVudC5cbntpZihob3N0UGFyZW50IT09bnVsbCl7aWYoaG9zdFBhcmVudElzQ29udGFpbmVyKXtjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKGhvc3RQYXJlbnQsZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7fWVsc2V7Y2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGhvc3RQYXJlbnQsZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7fX19cmV0dXJuO31jYXNlIEhvc3RQb3J0YWw6e3svLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbnZhciBfcHJldkhvc3RQYXJlbnQ9aG9zdFBhcmVudDt2YXIgX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXI9aG9zdFBhcmVudElzQ29udGFpbmVyO2hvc3RQYXJlbnQ9ZGVsZXRlZEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2hvc3RQYXJlbnRJc0NvbnRhaW5lcj10cnVlO3JlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVsZXRlZEZpYmVyKTtob3N0UGFyZW50PV9wcmV2SG9zdFBhcmVudDtob3N0UGFyZW50SXNDb250YWluZXI9X3ByZXZIb3N0UGFyZW50SXNDb250YWluZXI7fXJldHVybjt9Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBNZW1vQ29tcG9uZW50OmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7aWYoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pe3ZhciB1cGRhdGVRdWV1ZT1kZWxldGVkRmliZXIudXBkYXRlUXVldWU7aWYodXBkYXRlUXVldWUhPT1udWxsKXt2YXIgbGFzdEVmZmVjdD11cGRhdGVRdWV1ZS5sYXN0RWZmZWN0O2lmKGxhc3RFZmZlY3QhPT1udWxsKXt2YXIgZmlyc3RFZmZlY3Q9bGFzdEVmZmVjdC5uZXh0O3ZhciBlZmZlY3Q9Zmlyc3RFZmZlY3Q7ZG97dmFyIF9lZmZlY3Q9ZWZmZWN0LGRlc3Ryb3k9X2VmZmVjdC5kZXN0cm95LHRhZz1fZWZmZWN0LnRhZztpZihkZXN0cm95IT09dW5kZWZpbmVkKXtpZigodGFnJkluc2VydGlvbikhPT1Ob0ZsYWdzJDEpe3NhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlcixuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlc3Ryb3kpO31lbHNlIGlmKCh0YWcmTGF5b3V0KSE9PU5vRmxhZ3MkMSl7e21hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChkZWxldGVkRmliZXIpO31pZihkZWxldGVkRmliZXIubW9kZSZQcm9maWxlTW9kZSl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO3NhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlcixuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlc3Ryb3kpO3JlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGRlbGV0ZWRGaWJlcik7fWVsc2V7c2FmZWx5Q2FsbERlc3Ryb3koZGVsZXRlZEZpYmVyLG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVzdHJveSk7fXttYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTt9fX1lZmZlY3Q9ZWZmZWN0Lm5leHQ7fXdoaWxlKGVmZmVjdCE9PWZpcnN0RWZmZWN0KTt9fX1yZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlbGV0ZWRGaWJlcik7cmV0dXJuO31jYXNlIENsYXNzQ29tcG9uZW50OntpZighb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbil7c2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlcixuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTt2YXIgaW5zdGFuY2U9ZGVsZXRlZEZpYmVyLnN0YXRlTm9kZTtpZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQ9PT0nZnVuY3Rpb24nKXtzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZGVsZXRlZEZpYmVyLG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsaW5zdGFuY2UpO319cmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZWxldGVkRmliZXIpO3JldHVybjt9Y2FzZSBTY29wZUNvbXBvbmVudDp7cmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZWxldGVkRmliZXIpO3JldHVybjt9Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6e2lmKC8vIFRPRE86IFJlbW92ZSB0aGlzIGRlYWQgZmxhZ1xuZGVsZXRlZEZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpey8vIElmIHRoaXMgb2Zmc2NyZWVuIGNvbXBvbmVudCBpcyBoaWRkZW4sIHdlIGFscmVhZHkgdW5tb3VudGVkIGl0LiBCZWZvcmVcbi8vIGRlbGV0aW5nIHRoZSBjaGlsZHJlbiwgdHJhY2sgdGhhdCBpdCdzIGFscmVhZHkgdW5tb3VudGVkIHNvIHRoYXQgd2Vcbi8vIGRvbid0IGF0dGVtcHQgdG8gdW5tb3VudCB0aGUgZWZmZWN0cyBhZ2Fpbi5cbi8vIFRPRE86IElmIHRoZSB0cmVlIGlzIGhpZGRlbiwgaW4gbW9zdCBjYXNlcyB3ZSBzaG91bGQgYmUgYWJsZSB0byBza2lwXG4vLyBvdmVyIHRoZSBuZXN0ZWQgY2hpbGRyZW4gZW50aXJlbHkuIEFuIGV4Y2VwdGlvbiBpcyB3ZSBoYXZlbid0IHlldCBmb3VuZFxuLy8gdGhlIHRvcG1vc3QgaG9zdCBub2RlIHRvIGRlbGV0ZSwgd2hpY2ggd2UgYWxyZWFkeSB0cmFjayBvbiB0aGUgc3RhY2suXG4vLyBCdXQgdGhlIG90aGVyIGNhc2UgaXMgcG9ydGFscywgd2hpY2ggbmVlZCB0byBiZSBkZXRhY2hlZCBubyBtYXR0ZXIgaG93XG4vLyBkZWVwbHkgdGhleSBhcmUgbmVzdGVkLiBXZSBzaG91bGQgdXNlIGEgc3VidHJlZSBmbGFnIHRvIHRyYWNrIHdoZXRoZXIgYVxuLy8gc3VidHJlZSBpbmNsdWRlcyBhIG5lc3RlZCBwb3J0YWwuXG52YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVufHxkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZSE9PW51bGw7cmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZWxldGVkRmliZXIpO29mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49cHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47fWVsc2V7cmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZWxldGVkRmliZXIpO31icmVhazt9ZGVmYXVsdDp7cmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZWxldGVkRmliZXIpO3JldHVybjt9fX1mdW5jdGlvbiBjb21taXRTdXNwZW5zZUNhbGxiYWNrKGZpbmlzaGVkV29yayl7Ly8gVE9ETzogTW92ZSB0aGlzIHRvIHBhc3NpdmUgcGhhc2VcbnZhciBuZXdTdGF0ZT1maW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTt9ZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LGZpbmlzaGVkV29yayl7dmFyIG5ld1N0YXRlPWZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO2lmKG5ld1N0YXRlPT09bnVsbCl7dmFyIGN1cnJlbnQ9ZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtpZihjdXJyZW50IT09bnVsbCl7dmFyIHByZXZTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7aWYocHJldlN0YXRlIT09bnVsbCl7dmFyIHN1c3BlbnNlSW5zdGFuY2U9cHJldlN0YXRlLmRlaHlkcmF0ZWQ7aWYoc3VzcGVuc2VJbnN0YW5jZSE9PW51bGwpe2NvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTt9fX19fWZ1bmN0aW9uIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKXsvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB3YWtlYWJsZXMuXG4vLyBGb3IgZWFjaCB3YWtlYWJsZSwgYXR0YWNoIGEgbGlzdGVuZXIgc28gdGhhdCB3aGVuIGl0IHJlc29sdmVzLCBSZWFjdFxuLy8gYXR0ZW1wdHMgdG8gcmUtcmVuZGVyIHRoZSBib3VuZGFyeSBpbiB0aGUgcHJpbWFyeSAocHJlLXRpbWVvdXQpIHN0YXRlLlxudmFyIHdha2VhYmxlcz1maW5pc2hlZFdvcmsudXBkYXRlUXVldWU7aWYod2FrZWFibGVzIT09bnVsbCl7ZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlPW51bGw7dmFyIHJldHJ5Q2FjaGU9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtpZihyZXRyeUNhY2hlPT09bnVsbCl7cmV0cnlDYWNoZT1maW5pc2hlZFdvcmsuc3RhdGVOb2RlPW5ldyBQb3NzaWJseVdlYWtTZXQoKTt9d2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24od2FrZWFibGUpey8vIE1lbW9pemUgdXNpbmcgdGhlIGJvdW5kYXJ5IGZpYmVyIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbnZhciByZXRyeT1yZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsZmluaXNoZWRXb3JrLHdha2VhYmxlKTtpZighcmV0cnlDYWNoZS5oYXMod2FrZWFibGUpKXtyZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7e2lmKGlzRGV2VG9vbHNQcmVzZW50KXtpZihpblByb2dyZXNzTGFuZXMhPT1udWxsJiZpblByb2dyZXNzUm9vdCE9PW51bGwpey8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCBhc3NvY2lhdGUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzIHdpdGggaXQuXG5yZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKGluUHJvZ3Jlc3NSb290LGluUHJvZ3Jlc3NMYW5lcyk7fWVsc2V7dGhyb3cgRXJyb3IoJ0V4cGVjdGVkIGZpbmlzaGVkIHJvb3QgYW5kIGxhbmVzIHRvIGJlIHNldC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTt9fX13YWtlYWJsZS50aGVuKHJldHJ5LHJldHJ5KTt9fSk7fX0vLyBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hlbiBhIFN1c3BlbnNlIGJvdW5kYXJ5IGdvZXMgZnJvbSB2aXNpYmxlIHRvIGhpZGRlbi5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayxjb21taXR0ZWRMYW5lcyl7aW5Qcm9ncmVzc0xhbmVzPWNvbW1pdHRlZExhbmVzO2luUHJvZ3Jlc3NSb290PXJvb3Q7c2V0Q3VycmVudEZpYmVyKGZpbmlzaGVkV29yayk7Y29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmsscm9vdCk7c2V0Q3VycmVudEZpYmVyKGZpbmlzaGVkV29yayk7aW5Qcm9ncmVzc0xhbmVzPW51bGw7aW5Qcm9ncmVzc1Jvb3Q9bnVsbDt9ZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LHBhcmVudEZpYmVyLGxhbmVzKXsvLyBEZWxldGlvbnMgZWZmZWN0cyBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlciB0eXBlLiBUaGV5IG5lZWQgdG8gaGFwcGVuXG4vLyBiZWZvcmUgdGhlIGNoaWxkcmVuIGVmZmVjdHMgaGFlIGZpcmVkLlxudmFyIGRlbGV0aW9ucz1wYXJlbnRGaWJlci5kZWxldGlvbnM7aWYoZGVsZXRpb25zIT09bnVsbCl7Zm9yKHZhciBpPTA7aTxkZWxldGlvbnMubGVuZ3RoO2krKyl7dmFyIGNoaWxkVG9EZWxldGU9ZGVsZXRpb25zW2ldO3RyeXtjb21taXREZWxldGlvbkVmZmVjdHMocm9vdCxwYXJlbnRGaWJlcixjaGlsZFRvRGVsZXRlKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGNoaWxkVG9EZWxldGUscGFyZW50RmliZXIsZXJyb3IpO319fXZhciBwcmV2RGVidWdGaWJlcj1nZXRDdXJyZW50RmliZXIoKTtpZihwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MmTXV0YXRpb25NYXNrKXt2YXIgY2hpbGQ9cGFyZW50RmliZXIuY2hpbGQ7d2hpbGUoY2hpbGQhPT1udWxsKXtzZXRDdXJyZW50RmliZXIoY2hpbGQpO2NvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoY2hpbGQscm9vdCk7Y2hpbGQ9Y2hpbGQuc2libGluZzt9fXNldEN1cnJlbnRGaWJlcihwcmV2RGVidWdGaWJlcik7fWZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLHJvb3QsbGFuZXMpe3ZhciBjdXJyZW50PWZpbmlzaGVkV29yay5hbHRlcm5hdGU7dmFyIGZsYWdzPWZpbmlzaGVkV29yay5mbGFnczsvLyBUaGUgZWZmZWN0IGZsYWcgc2hvdWxkIGJlIGNoZWNrZWQgKmFmdGVyKiB3ZSByZWZpbmUgdGhlIHR5cGUgb2YgZmliZXIsXG4vLyBiZWNhdXNlIHRoZSBmaWJlciB0YWcgaXMgbW9yZSBzcGVjaWZpYy4gQW4gZXhjZXB0aW9uIGlzIGFueSBmbGFnIHJlbGF0ZWRcbi8vIHRvIHJlY29uY2lsYXRpb24sIGJlY2F1c2UgdGhvc2UgY2FuIGJlIHNldCBvbiBhbGwgZmliZXIgdHlwZXMuXG5zd2l0Y2goZmluaXNoZWRXb3JrLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBNZW1vQ29tcG9uZW50OmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7aWYoZmxhZ3MmVXBkYXRlKXt0cnl7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KEluc2VydGlvbnxIYXNFZmZlY3QsZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4pO2NvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9ufEhhc0VmZmVjdCxmaW5pc2hlZFdvcmspO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO30vLyBMYXlvdXQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGR1cmluZyB0aGUgbXV0YXRpb24gcGhhc2Ugc28gdGhhdCBhbGxcbi8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuLy8gVGhpcyBwcmV2ZW50cyBzaWJsaW5nIGNvbXBvbmVudCBlZmZlY3RzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBlYWNoIG90aGVyLFxuLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4vLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuaWYoZmluaXNoZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpe3RyeXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dHxIYXNFZmZlY3QsZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4pO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO31yZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO31lbHNle3RyeXtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0fEhhc0VmZmVjdCxmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybik7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fX19cmV0dXJuO31jYXNlIENsYXNzQ29tcG9uZW50OntyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtpZihmbGFncyZSZWYpe2lmKGN1cnJlbnQhPT1udWxsKXtzYWZlbHlEZXRhY2hSZWYoY3VycmVudCxjdXJyZW50LnJldHVybik7fX1yZXR1cm47fWNhc2UgSG9zdENvbXBvbmVudDp7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7aWYoZmxhZ3MmUmVmKXtpZihjdXJyZW50IT09bnVsbCl7c2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsY3VycmVudC5yZXR1cm4pO319ey8vIFRPRE86IENvbnRlbnRSZXNldCBnZXRzIGNsZWFyZWQgYnkgdGhlIGNoaWxkcmVuIGR1cmluZyB0aGUgY29tbWl0XG4vLyBwaGFzZS4gVGhpcyBpcyBhIHJlZmFjdG9yIGhhemFyZCBiZWNhdXNlIGl0IG1lYW5zIHdlIG11c3QgcmVhZFxuLy8gZmxhZ3MgdGhlIGZsYWdzIGFmdGVyIGBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHNgIGhhcyBhbHJlYWR5IHJ1bjtcbi8vIHRoZSBvcmRlciBtYXR0ZXJzLiBXZSBzaG91bGQgcmVmYWN0b3Igc28gdGhhdCBDb250ZW50UmVzZXQgZG9lcyBub3Rcbi8vIHJlbHkgb24gbXV0YXRpbmcgdGhlIGZsYWcgZHVyaW5nIGNvbW1pdC4gTGlrZSBieSBzZXR0aW5nIGEgZmxhZ1xuLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UgaW5zdGVhZC5cbmlmKGZpbmlzaGVkV29yay5mbGFncyZDb250ZW50UmVzZXQpe3ZhciBpbnN0YW5jZT1maW5pc2hlZFdvcmsuc3RhdGVOb2RlO3RyeXtyZXNldFRleHRDb250ZW50KGluc3RhbmNlKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9fWlmKGZsYWdzJlVwZGF0ZSl7dmFyIF9pbnN0YW5jZTQ9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtpZihfaW5zdGFuY2U0IT1udWxsKXsvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbnZhciBuZXdQcm9wcz1maW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wczsvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4vLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbi8vIHRoaXMgY2FzZS5cbnZhciBvbGRQcm9wcz1jdXJyZW50IT09bnVsbD9jdXJyZW50Lm1lbW9pemVkUHJvcHM6bmV3UHJvcHM7dmFyIHR5cGU9ZmluaXNoZWRXb3JrLnR5cGU7Ly8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxudmFyIHVwZGF0ZVBheWxvYWQ9ZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO2ZpbmlzaGVkV29yay51cGRhdGVRdWV1ZT1udWxsO2lmKHVwZGF0ZVBheWxvYWQhPT1udWxsKXt0cnl7Y29tbWl0VXBkYXRlKF9pbnN0YW5jZTQsdXBkYXRlUGF5bG9hZCx0eXBlLG9sZFByb3BzLG5ld1Byb3BzLGZpbmlzaGVkV29yayk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fX19fX1yZXR1cm47fWNhc2UgSG9zdFRleHQ6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO2NvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO2lmKGZsYWdzJlVwZGF0ZSl7e2lmKGZpbmlzaGVkV29yay5zdGF0ZU5vZGU9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcrJ2NhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXZhciB0ZXh0SW5zdGFuY2U9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTt2YXIgbmV3VGV4dD1maW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wczsvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4vLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbi8vIHRoaXMgY2FzZS5cbnZhciBvbGRUZXh0PWN1cnJlbnQhPT1udWxsP2N1cnJlbnQubWVtb2l6ZWRQcm9wczpuZXdUZXh0O3RyeXtjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSxvbGRUZXh0LG5ld1RleHQpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO319fXJldHVybjt9Y2FzZSBIb3N0Um9vdDp7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7aWYoZmxhZ3MmVXBkYXRlKXt7aWYoY3VycmVudCE9PW51bGwpe3ZhciBwcmV2Um9vdFN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtpZihwcmV2Um9vdFN0YXRlLmlzRGVoeWRyYXRlZCl7dHJ5e2NvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fX19fX1yZXR1cm47fWNhc2UgSG9zdFBvcnRhbDp7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7cmV0dXJuO31jYXNlIFN1c3BlbnNlQ29tcG9uZW50OntyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTt2YXIgb2Zmc2NyZWVuRmliZXI9ZmluaXNoZWRXb3JrLmNoaWxkO2lmKG9mZnNjcmVlbkZpYmVyLmZsYWdzJlZpc2liaWxpdHkpe3ZhciBvZmZzY3JlZW5JbnN0YW5jZT1vZmZzY3JlZW5GaWJlci5zdGF0ZU5vZGU7dmFyIG5ld1N0YXRlPW9mZnNjcmVlbkZpYmVyLm1lbW9pemVkU3RhdGU7dmFyIGlzSGlkZGVuPW5ld1N0YXRlIT09bnVsbDsvLyBUcmFjayB0aGUgY3VycmVudCBzdGF0ZSBvbiB0aGUgT2Zmc2NyZWVuIGluc3RhbmNlIHNvIHdlIGNhblxuLy8gcmVhZCBpdCBkdXJpbmcgYW4gZXZlbnRcbm9mZnNjcmVlbkluc3RhbmNlLmlzSGlkZGVuPWlzSGlkZGVuO2lmKGlzSGlkZGVuKXt2YXIgd2FzSGlkZGVuPW9mZnNjcmVlbkZpYmVyLmFsdGVybmF0ZSE9PW51bGwmJm9mZnNjcmVlbkZpYmVyLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlIT09bnVsbDtpZighd2FzSGlkZGVuKXsvLyBUT0RPOiBNb3ZlIHRvIHBhc3NpdmUgcGhhc2Vcbm1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO319fWlmKGZsYWdzJlVwZGF0ZSl7dHJ5e2NvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9YXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspO31yZXR1cm47fWNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50Ont2YXIgX3dhc0hpZGRlbj1jdXJyZW50IT09bnVsbCYmY3VycmVudC5tZW1vaXplZFN0YXRlIT09bnVsbDtpZigvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZWFkIGZsYWdcbmZpbmlzaGVkV29yay5tb2RlJkNvbmN1cnJlbnRNb2RlKXsvLyBCZWZvcmUgY29tbWl0dGluZyB0aGUgY2hpbGRyZW4sIHRyYWNrIG9uIHRoZSBzdGFjayB3aGV0aGVyIHRoaXNcbi8vIG9mZnNjcmVlbiBzdWJ0cmVlIHdhcyBhbHJlYWR5IGhpZGRlbiwgc28gdGhhdCB3ZSBkb24ndCB1bm1vdW50IHRoZVxuLy8gZWZmZWN0cyBhZ2Fpbi5cbnZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1vZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO29mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49cHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW58fF93YXNIaWRkZW47cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1wcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjt9ZWxzZXtyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTt9Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7aWYoZmxhZ3MmVmlzaWJpbGl0eSl7dmFyIF9vZmZzY3JlZW5JbnN0YW5jZT1maW5pc2hlZFdvcmsuc3RhdGVOb2RlO3ZhciBfbmV3U3RhdGU9ZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7dmFyIF9pc0hpZGRlbj1fbmV3U3RhdGUhPT1udWxsO3ZhciBvZmZzY3JlZW5Cb3VuZGFyeT1maW5pc2hlZFdvcms7Ly8gVHJhY2sgdGhlIGN1cnJlbnQgc3RhdGUgb24gdGhlIE9mZnNjcmVlbiBpbnN0YW5jZSBzbyB3ZSBjYW5cbi8vIHJlYWQgaXQgZHVyaW5nIGFuIGV2ZW50XG5fb2Zmc2NyZWVuSW5zdGFuY2UuaXNIaWRkZW49X2lzSGlkZGVuO3tpZihfaXNIaWRkZW4pe2lmKCFfd2FzSGlkZGVuKXtpZigob2Zmc2NyZWVuQm91bmRhcnkubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGUpe25leHRFZmZlY3Q9b2Zmc2NyZWVuQm91bmRhcnk7dmFyIG9mZnNjcmVlbkNoaWxkPW9mZnNjcmVlbkJvdW5kYXJ5LmNoaWxkO3doaWxlKG9mZnNjcmVlbkNoaWxkIT09bnVsbCl7bmV4dEVmZmVjdD1vZmZzY3JlZW5DaGlsZDtkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKG9mZnNjcmVlbkNoaWxkKTtvZmZzY3JlZW5DaGlsZD1vZmZzY3JlZW5DaGlsZC5zaWJsaW5nO319fX19ey8vIFRPRE86IFRoaXMgbmVlZHMgdG8gcnVuIHdoZW5ldmVyIHRoZXJlJ3MgYW4gaW5zZXJ0aW9uIG9yIHVwZGF0ZVxuLy8gaW5zaWRlIGEgaGlkZGVuIE9mZnNjcmVlbiB0cmVlLlxuaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4ob2Zmc2NyZWVuQm91bmRhcnksX2lzSGlkZGVuKTt9fXJldHVybjt9Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO2NvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO2lmKGZsYWdzJlVwZGF0ZSl7YXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspO31yZXR1cm47fWNhc2UgU2NvcGVDb21wb25lbnQ6e3JldHVybjt9ZGVmYXVsdDp7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7cmV0dXJuO319fWZ1bmN0aW9uIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspey8vIFBsYWNlbWVudCBlZmZlY3RzIChpbnNlcnRpb25zLCByZW9yZGVycykgY2FuIGJlIHNjaGVkdWxlZCBvbiBhbnkgZmliZXJcbi8vIHR5cGUuIFRoZXkgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSBjaGlsZHJlbiBlZmZlY3RzIGhhdmUgZmlyZWQsIGJ1dFxuLy8gYmVmb3JlIHRoZSBlZmZlY3RzIG9uIHRoaXMgZmliZXIgaGF2ZSBmaXJlZC5cbnZhciBmbGFncz1maW5pc2hlZFdvcmsuZmxhZ3M7aWYoZmxhZ3MmUGxhY2VtZW50KXt0cnl7Y29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yayk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fS8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzXG4vLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuLy8gVE9ETzogZmluZERPTU5vZGUgZG9lc24ndCByZWx5IG9uIHRoaXMgYW55IG1vcmUgYnV0IGlzTW91bnRlZCBkb2VzXG4vLyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIGtpbGwgdGhpcy5cbmZpbmlzaGVkV29yay5mbGFncyY9flBsYWNlbWVudDt9aWYoZmxhZ3MmSHlkcmF0aW5nKXtmaW5pc2hlZFdvcmsuZmxhZ3MmPX5IeWRyYXRpbmc7fX1mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayxyb290LGNvbW1pdHRlZExhbmVzKXtpblByb2dyZXNzTGFuZXM9Y29tbWl0dGVkTGFuZXM7aW5Qcm9ncmVzc1Jvb3Q9cm9vdDtuZXh0RWZmZWN0PWZpbmlzaGVkV29yaztjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKGZpbmlzaGVkV29yayxyb290LGNvbW1pdHRlZExhbmVzKTtpblByb2dyZXNzTGFuZXM9bnVsbDtpblByb2dyZXNzUm9vdD1udWxsO31mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LHJvb3QsY29tbWl0dGVkTGFuZXMpey8vIFN1c3BlbnNlIGxheW91dCBlZmZlY3RzIHNlbWFudGljcyBkb24ndCBjaGFuZ2UgZm9yIGxlZ2FjeSByb290cy5cbnZhciBpc01vZGVyblJvb3Q9KHN1YnRyZWVSb290Lm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlO3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDt2YXIgZmlyc3RDaGlsZD1maWJlci5jaGlsZDtpZihmaWJlci50YWc9PT1PZmZzY3JlZW5Db21wb25lbnQmJmlzTW9kZXJuUm9vdCl7Ly8gS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBPZmZzY3JlZW4gc3RhY2sncyBzdGF0ZS5cbnZhciBpc0hpZGRlbj1maWJlci5tZW1vaXplZFN0YXRlIT09bnVsbDt2YXIgbmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuPWlzSGlkZGVufHxvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47aWYobmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuKXsvLyBUaGUgT2Zmc2NyZWVuIHRyZWUgaXMgaGlkZGVuLiBTa2lwIG92ZXIgaXRzIGxheW91dCBlZmZlY3RzLlxuY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LHJvb3QsY29tbWl0dGVkTGFuZXMpO2NvbnRpbnVlO31lbHNley8vIFRPRE8gKE9mZnNjcmVlbikgQWxzbyBjaGVjazogc3VidHJlZUZsYWdzICYgTGF5b3V0TWFza1xudmFyIGN1cnJlbnQ9ZmliZXIuYWx0ZXJuYXRlO3ZhciB3YXNIaWRkZW49Y3VycmVudCE9PW51bGwmJmN1cnJlbnQubWVtb2l6ZWRTdGF0ZSE9PW51bGw7dmFyIG5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49d2FzSGlkZGVufHxvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO3ZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuPW9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjt2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjsvLyBUcmF2ZXJzZSB0aGUgT2Zmc2NyZWVuIHN1YnRyZWUgd2l0aCB0aGUgY3VycmVudCBPZmZzY3JlZW4gYXMgdGhlIHJvb3QuXG5vZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW49bmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO29mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49bmV3T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtpZihvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuJiYhcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pey8vIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSByZWFwcGVhcmluZyBib3VuZGFyeS4gVHVybiBpdHMgbGF5b3V0IGVmZmVjdHNcbi8vIGJhY2sgb24uXG5uZXh0RWZmZWN0PWZpYmVyO3JlYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihmaWJlcik7fXZhciBjaGlsZD1maXJzdENoaWxkO3doaWxlKGNoaWxkIT09bnVsbCl7bmV4dEVmZmVjdD1jaGlsZDtjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKGNoaWxkLC8vIE5ldyByb290OyBidWJibGUgYmFjayB1cCB0byBoZXJlIGFuZCBzdG9wLlxucm9vdCxjb21taXR0ZWRMYW5lcyk7Y2hpbGQ9Y2hpbGQuc2libGluZzt9Ly8gUmVzdG9yZSBPZmZzY3JlZW4gc3RhdGUgYW5kIHJlc3VtZSBpbiBvdXItcHJvZ3Jlc3MgdHJhdmVyc2FsLlxubmV4dEVmZmVjdD1maWJlcjtvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW49cHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO2NvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCxyb290LGNvbW1pdHRlZExhbmVzKTtjb250aW51ZTt9fWlmKChmaWJlci5zdWJ0cmVlRmxhZ3MmTGF5b3V0TWFzaykhPT1Ob0ZsYWdzJiZmaXJzdENoaWxkIT09bnVsbCl7Zmlyc3RDaGlsZC5yZXR1cm49ZmliZXI7bmV4dEVmZmVjdD1maXJzdENoaWxkO31lbHNle2NvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCxyb290LGNvbW1pdHRlZExhbmVzKTt9fX1mdW5jdGlvbiBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3Qscm9vdCxjb21taXR0ZWRMYW5lcyl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O2lmKChmaWJlci5mbGFncyZMYXlvdXRNYXNrKSE9PU5vRmxhZ3Mpe3ZhciBjdXJyZW50PWZpYmVyLmFsdGVybmF0ZTtzZXRDdXJyZW50RmliZXIoZmliZXIpO3RyeXtjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsY3VycmVudCxmaWJlcixjb21taXR0ZWRMYW5lcyk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlcixmaWJlci5yZXR1cm4sZXJyb3IpO31yZXNldEN1cnJlbnRGaWJlcigpO31pZihmaWJlcj09PXN1YnRyZWVSb290KXtuZXh0RWZmZWN0PW51bGw7cmV0dXJuO312YXIgc2libGluZz1maWJlci5zaWJsaW5nO2lmKHNpYmxpbmchPT1udWxsKXtzaWJsaW5nLnJldHVybj1maWJlci5yZXR1cm47bmV4dEVmZmVjdD1zaWJsaW5nO3JldHVybjt9bmV4dEVmZmVjdD1maWJlci5yZXR1cm47fX1mdW5jdGlvbiBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290KXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7dmFyIGZpcnN0Q2hpbGQ9ZmliZXIuY2hpbGQ7Ly8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiAoUmVmU3RhdGljIHwgTGF5b3V0U3RhdGljKVxuc3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBNZW1vQ29tcG9uZW50OmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7aWYoZmliZXIubW9kZSZQcm9maWxlTW9kZSl7dHJ5e3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0LGZpYmVyLGZpYmVyLnJldHVybik7fWZpbmFsbHl7cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmliZXIpO319ZWxzZXtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0LGZpYmVyLGZpYmVyLnJldHVybik7fWJyZWFrO31jYXNlIENsYXNzQ29tcG9uZW50OnsvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIFJlZlN0YXRpY1xuc2FmZWx5RGV0YWNoUmVmKGZpYmVyLGZpYmVyLnJldHVybik7dmFyIGluc3RhbmNlPWZpYmVyLnN0YXRlTm9kZTtpZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQ9PT0nZnVuY3Rpb24nKXtzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsZmliZXIucmV0dXJuLGluc3RhbmNlKTt9YnJlYWs7fWNhc2UgSG9zdENvbXBvbmVudDp7c2FmZWx5RGV0YWNoUmVmKGZpYmVyLGZpYmVyLnJldHVybik7YnJlYWs7fWNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OnsvLyBDaGVjayBpZiB0aGlzIGlzIGFcbnZhciBpc0hpZGRlbj1maWJlci5tZW1vaXplZFN0YXRlIT09bnVsbDtpZihpc0hpZGRlbil7Ly8gTmVzdGVkIE9mZnNjcmVlbiB0cmVlIGlzIGFscmVhZHkgaGlkZGVuLiBEb24ndCBkaXNhcHBlYXJcbi8vIGl0cyBlZmZlY3RzLlxuZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7Y29udGludWU7fWJyZWFrO319Ly8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogc3VidHJlZUZsYWdzICYgTGF5b3V0U3RhdGljXG5pZihmaXJzdENoaWxkIT09bnVsbCl7Zmlyc3RDaGlsZC5yZXR1cm49ZmliZXI7bmV4dEVmZmVjdD1maXJzdENoaWxkO31lbHNle2Rpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO319fWZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3Qpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDtpZihmaWJlcj09PXN1YnRyZWVSb290KXtuZXh0RWZmZWN0PW51bGw7cmV0dXJuO312YXIgc2libGluZz1maWJlci5zaWJsaW5nO2lmKHNpYmxpbmchPT1udWxsKXtzaWJsaW5nLnJldHVybj1maWJlci5yZXR1cm47bmV4dEVmZmVjdD1zaWJsaW5nO3JldHVybjt9bmV4dEVmZmVjdD1maWJlci5yZXR1cm47fX1mdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oc3VidHJlZVJvb3Qpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDt2YXIgZmlyc3RDaGlsZD1maWJlci5jaGlsZDtpZihmaWJlci50YWc9PT1PZmZzY3JlZW5Db21wb25lbnQpe3ZhciBpc0hpZGRlbj1maWJlci5tZW1vaXplZFN0YXRlIT09bnVsbDtpZihpc0hpZGRlbil7Ly8gTmVzdGVkIE9mZnNjcmVlbiB0cmVlIGlzIHN0aWxsIGhpZGRlbi4gRG9uJ3QgcmUtYXBwZWFyIGl0cyBlZmZlY3RzLlxucmVhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTtjb250aW51ZTt9fS8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dFN0YXRpY1xuaWYoZmlyc3RDaGlsZCE9PW51bGwpey8vIFRoaXMgbm9kZSBtYXkgaGF2ZSBiZWVuIHJldXNlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLCBzbyB3ZSBjYW4ndFxuLy8gYXNzdW1lIGl0cyByZXR1cm4gcG9pbnRlciBpcyBjb3JyZWN0LlxuZmlyc3RDaGlsZC5yZXR1cm49ZmliZXI7bmV4dEVmZmVjdD1maXJzdENoaWxkO31lbHNle3JlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7fX19ZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7Ly8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBMYXlvdXRTdGF0aWNcbnNldEN1cnJlbnRGaWJlcihmaWJlcik7dHJ5e3JlYXBwZWFyTGF5b3V0RWZmZWN0c09uRmliZXIoZmliZXIpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsZmliZXIucmV0dXJuLGVycm9yKTt9cmVzZXRDdXJyZW50RmliZXIoKTtpZihmaWJlcj09PXN1YnRyZWVSb290KXtuZXh0RWZmZWN0PW51bGw7cmV0dXJuO312YXIgc2libGluZz1maWJlci5zaWJsaW5nO2lmKHNpYmxpbmchPT1udWxsKXsvLyBUaGlzIG5vZGUgbWF5IGhhdmUgYmVlbiByZXVzZWQgZnJvbSBhIHByZXZpb3VzIHJlbmRlciwgc28gd2UgY2FuJ3Rcbi8vIGFzc3VtZSBpdHMgcmV0dXJuIHBvaW50ZXIgaXMgY29ycmVjdC5cbnNpYmxpbmcucmV0dXJuPWZpYmVyLnJldHVybjtuZXh0RWZmZWN0PXNpYmxpbmc7cmV0dXJuO31uZXh0RWZmZWN0PWZpYmVyLnJldHVybjt9fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmssY29tbWl0dGVkTGFuZXMsY29tbWl0dGVkVHJhbnNpdGlvbnMpe25leHRFZmZlY3Q9ZmluaXNoZWRXb3JrO2NvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfYmVnaW4oZmluaXNoZWRXb3JrLHJvb3QsY29tbWl0dGVkTGFuZXMsY29tbWl0dGVkVHJhbnNpdGlvbnMpO31mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LHJvb3QsY29tbWl0dGVkTGFuZXMsY29tbWl0dGVkVHJhbnNpdGlvbnMpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDt2YXIgZmlyc3RDaGlsZD1maWJlci5jaGlsZDtpZigoZmliZXIuc3VidHJlZUZsYWdzJlBhc3NpdmVNYXNrKSE9PU5vRmxhZ3MmJmZpcnN0Q2hpbGQhPT1udWxsKXtmaXJzdENoaWxkLnJldHVybj1maWJlcjtuZXh0RWZmZWN0PWZpcnN0Q2hpbGQ7fWVsc2V7Y29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCxyb290LGNvbW1pdHRlZExhbmVzLGNvbW1pdHRlZFRyYW5zaXRpb25zKTt9fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LHJvb3QsY29tbWl0dGVkTGFuZXMsY29tbWl0dGVkVHJhbnNpdGlvbnMpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDtpZigoZmliZXIuZmxhZ3MmUGFzc2l2ZSkhPT1Ob0ZsYWdzKXtzZXRDdXJyZW50RmliZXIoZmliZXIpO3RyeXtjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKHJvb3QsZmliZXIsY29tbWl0dGVkTGFuZXMsY29tbWl0dGVkVHJhbnNpdGlvbnMpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsZmliZXIucmV0dXJuLGVycm9yKTt9cmVzZXRDdXJyZW50RmliZXIoKTt9aWYoZmliZXI9PT1zdWJ0cmVlUm9vdCl7bmV4dEVmZmVjdD1udWxsO3JldHVybjt9dmFyIHNpYmxpbmc9ZmliZXIuc2libGluZztpZihzaWJsaW5nIT09bnVsbCl7c2libGluZy5yZXR1cm49ZmliZXIucmV0dXJuO25leHRFZmZlY3Q9c2libGluZztyZXR1cm47fW5leHRFZmZlY3Q9ZmliZXIucmV0dXJuO319ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihmaW5pc2hlZFJvb3QsZmluaXNoZWRXb3JrLGNvbW1pdHRlZExhbmVzLGNvbW1pdHRlZFRyYW5zaXRpb25zKXtzd2l0Y2goZmluaXNoZWRXb3JrLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntpZihmaW5pc2hlZFdvcmsubW9kZSZQcm9maWxlTW9kZSl7c3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTt0cnl7Y29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDF8SGFzRWZmZWN0LGZpbmlzaGVkV29yayk7fWZpbmFsbHl7cmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7fX1lbHNle2NvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoUGFzc2l2ZSQxfEhhc0VmZmVjdCxmaW5pc2hlZFdvcmspO31icmVhazt9fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmlyc3RDaGlsZCl7bmV4dEVmZmVjdD1maXJzdENoaWxkO2NvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbigpO31mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfYmVnaW4oKXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7dmFyIGNoaWxkPWZpYmVyLmNoaWxkO2lmKChuZXh0RWZmZWN0LmZsYWdzJkNoaWxkRGVsZXRpb24pIT09Tm9GbGFncyl7dmFyIGRlbGV0aW9ucz1maWJlci5kZWxldGlvbnM7aWYoZGVsZXRpb25zIT09bnVsbCl7Zm9yKHZhciBpPTA7aTxkZWxldGlvbnMubGVuZ3RoO2krKyl7dmFyIGZpYmVyVG9EZWxldGU9ZGVsZXRpb25zW2ldO25leHRFZmZlY3Q9ZmliZXJUb0RlbGV0ZTtjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGZpYmVyVG9EZWxldGUsZmliZXIpO317Ly8gQSBmaWJlciB3YXMgZGVsZXRlZCBmcm9tIHRoaXMgcGFyZW50IGZpYmVyLCBidXQgaXQncyBzdGlsbCBwYXJ0IG9mXG4vLyB0aGUgcHJldmlvdXMgKGFsdGVybmF0ZSkgcGFyZW50IGZpYmVyJ3MgbGlzdCBvZiBjaGlsZHJlbi4gQmVjYXVzZVxuLy8gY2hpbGRyZW4gYXJlIGEgbGlua2VkIGxpc3QsIGFuIGVhcmxpZXIgc2libGluZyB0aGF0J3Mgc3RpbGwgYWxpdmVcbi8vIHdpbGwgYmUgY29ubmVjdGVkIHRvIHRoZSBkZWxldGVkIGZpYmVyIHZpYSBpdHMgYGFsdGVybmF0ZWA6XG4vL1xuLy8gICBsaXZlIGZpYmVyXG4vLyAgIC0tYWx0ZXJuYXRlLS0+IHByZXZpb3VzIGxpdmUgZmliZXJcbi8vICAgLS1zaWJsaW5nLS0+IGRlbGV0ZWQgZmliZXJcbi8vXG4vLyBXZSBjYW4ndCBkaXNjb25uZWN0IGBhbHRlcm5hdGVgIG9uIG5vZGVzIHRoYXQgaGF2ZW4ndCBiZWVuIGRlbGV0ZWRcbi8vIHlldCwgYnV0IHdlIGNhbiBkaXNjb25uZWN0IHRoZSBgc2libGluZ2AgYW5kIGBjaGlsZGAgcG9pbnRlcnMuXG52YXIgcHJldmlvdXNGaWJlcj1maWJlci5hbHRlcm5hdGU7aWYocHJldmlvdXNGaWJlciE9PW51bGwpe3ZhciBkZXRhY2hlZENoaWxkPXByZXZpb3VzRmliZXIuY2hpbGQ7aWYoZGV0YWNoZWRDaGlsZCE9PW51bGwpe3ByZXZpb3VzRmliZXIuY2hpbGQ9bnVsbDtkb3t2YXIgZGV0YWNoZWRTaWJsaW5nPWRldGFjaGVkQ2hpbGQuc2libGluZztkZXRhY2hlZENoaWxkLnNpYmxpbmc9bnVsbDtkZXRhY2hlZENoaWxkPWRldGFjaGVkU2libGluZzt9d2hpbGUoZGV0YWNoZWRDaGlsZCE9PW51bGwpO319fW5leHRFZmZlY3Q9ZmliZXI7fX1pZigoZmliZXIuc3VidHJlZUZsYWdzJlBhc3NpdmVNYXNrKSE9PU5vRmxhZ3MmJmNoaWxkIT09bnVsbCl7Y2hpbGQucmV0dXJuPWZpYmVyO25leHRFZmZlY3Q9Y2hpbGQ7fWVsc2V7Y29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2NvbXBsZXRlKCk7fX19ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2NvbXBsZXRlKCl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O2lmKChmaWJlci5mbGFncyZQYXNzaXZlKSE9PU5vRmxhZ3Mpe3NldEN1cnJlbnRGaWJlcihmaWJlcik7Y29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpYmVyKTtyZXNldEN1cnJlbnRGaWJlcigpO312YXIgc2libGluZz1maWJlci5zaWJsaW5nO2lmKHNpYmxpbmchPT1udWxsKXtzaWJsaW5nLnJldHVybj1maWJlci5yZXR1cm47bmV4dEVmZmVjdD1zaWJsaW5nO3JldHVybjt9bmV4dEVmZmVjdD1maWJlci5yZXR1cm47fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoZmluaXNoZWRXb3JrKXtzd2l0Y2goZmluaXNoZWRXb3JrLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntpZihmaW5pc2hlZFdvcmsubW9kZSZQcm9maWxlTW9kZSl7c3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxfEhhc0VmZmVjdCxmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybik7cmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7fWVsc2V7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMXxIYXNFZmZlY3QsZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4pO31icmVhazt9fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGRlbGV0ZWRTdWJ0cmVlUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yKXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7Ly8gRGVsZXRpb24gZWZmZWN0cyBmaXJlIGluIHBhcmVudCAtPiBjaGlsZCBvcmRlclxuLy8gVE9ETzogQ2hlY2sgaWYgZmliZXIgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnXG5zZXRDdXJyZW50RmliZXIoZmliZXIpO2NvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGZpYmVyLG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO3Jlc2V0Q3VycmVudEZpYmVyKCk7dmFyIGNoaWxkPWZpYmVyLmNoaWxkOy8vIFRPRE86IE9ubHkgdHJhdmVyc2Ugc3VidHJlZSBpZiBpdCBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWcuIChCdXQsIGlmIHdlXG4vLyBkbyB0aGlzLCBzdGlsbCBuZWVkIHRvIGhhbmRsZSBgZGVsZXRlZFRyZWVDbGVhblVwTGV2ZWxgIGNvcnJlY3RseS4pXG5pZihjaGlsZCE9PW51bGwpe2NoaWxkLnJldHVybj1maWJlcjtuZXh0RWZmZWN0PWNoaWxkO31lbHNle2NvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KTt9fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlKGRlbGV0ZWRTdWJ0cmVlUm9vdCl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O3ZhciBzaWJsaW5nPWZpYmVyLnNpYmxpbmc7dmFyIHJldHVybkZpYmVyPWZpYmVyLnJldHVybjt7Ly8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgdGhlIGVudGlyZSBkZWxldGVkIHRyZWUgYW5kIGNsZWFuIHVwIGZpYmVyIGZpZWxkcy5cbi8vIFRoaXMgaXMgbW9yZSBhZ2dyZXNzaXZlIHRoYW4gaWRlYWwsIGFuZCB0aGUgbG9uZyB0ZXJtIGdvYWwgaXMgdG8gb25seVxuLy8gaGF2ZSB0byBkZXRhY2ggdGhlIGRlbGV0ZWQgdHJlZSBhdCB0aGUgcm9vdC5cbmRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKTtpZihmaWJlcj09PWRlbGV0ZWRTdWJ0cmVlUm9vdCl7bmV4dEVmZmVjdD1udWxsO3JldHVybjt9fWlmKHNpYmxpbmchPT1udWxsKXtzaWJsaW5nLnJldHVybj1yZXR1cm5GaWJlcjtuZXh0RWZmZWN0PXNpYmxpbmc7cmV0dXJuO31uZXh0RWZmZWN0PXJldHVybkZpYmVyO319ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yKXtzd2l0Y2goY3VycmVudC50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7aWYoY3VycmVudC5tb2RlJlByb2ZpbGVNb2RlKXtzdGFydFBhc3NpdmVFZmZlY3RUaW1lcigpO2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEsY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtyZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oY3VycmVudCk7fWVsc2V7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSxjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO31icmVhazt9fX0vLyBUT0RPOiBSZXVzZSByZWFwcGVhckxheW91dEVmZmVjdHMgdHJhdmVyc2FsIGhlcmU/XG5mdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RNb3VudEluREVWKGZpYmVyKXt7Ly8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbnN3aXRjaChmaWJlci50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7dHJ5e2NvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoTGF5b3V0fEhhc0VmZmVjdCxmaWJlcik7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlcixmaWJlci5yZXR1cm4sZXJyb3IpO31icmVhazt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIGluc3RhbmNlPWZpYmVyLnN0YXRlTm9kZTt0cnl7aW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLGZpYmVyLnJldHVybixlcnJvcik7fWJyZWFrO319fX1mdW5jdGlvbiBpbnZva2VQYXNzaXZlRWZmZWN0TW91bnRJbkRFVihmaWJlcil7ey8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG5zd2l0Y2goZmliZXIudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e3RyeXtjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KFBhc3NpdmUkMXxIYXNFZmZlY3QsZmliZXIpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsZmliZXIucmV0dXJuLGVycm9yKTt9YnJlYWs7fX19fWZ1bmN0aW9uIGludm9rZUxheW91dEVmZmVjdFVubW91bnRJbkRFVihmaWJlcil7ey8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG5zd2l0Y2goZmliZXIudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e3RyeXtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0fEhhc0VmZmVjdCxmaWJlcixmaWJlci5yZXR1cm4pO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsZmliZXIucmV0dXJuLGVycm9yKTt9YnJlYWs7fWNhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBpbnN0YW5jZT1maWJlci5zdGF0ZU5vZGU7aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50PT09J2Z1bmN0aW9uJyl7c2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGZpYmVyLGZpYmVyLnJldHVybixpbnN0YW5jZSk7fWJyZWFrO319fX1mdW5jdGlvbiBpbnZva2VQYXNzaXZlRWZmZWN0VW5tb3VudEluREVWKGZpYmVyKXt7Ly8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbnN3aXRjaChmaWJlci50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7dHJ5e2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDF8SGFzRWZmZWN0LGZpYmVyLGZpYmVyLnJldHVybik7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlcixmaWJlci5yZXR1cm4sZXJyb3IpO319fX19dmFyIENPTVBPTkVOVF9UWVBFPTA7dmFyIEhBU19QU0VVRE9fQ0xBU1NfVFlQRT0xO3ZhciBST0xFX1RZUEU9Mjt2YXIgVEVTVF9OQU1FX1RZUEU9Mzt2YXIgVEVYVF9UWVBFPTQ7aWYodHlwZW9mIFN5bWJvbD09PSdmdW5jdGlvbicmJlN5bWJvbC5mb3Ipe3ZhciBzeW1ib2xGb3I9U3ltYm9sLmZvcjtDT01QT05FTlRfVFlQRT1zeW1ib2xGb3IoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO0hBU19QU0VVRE9fQ0xBU1NfVFlQRT1zeW1ib2xGb3IoJ3NlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3MnKTtST0xFX1RZUEU9c3ltYm9sRm9yKCdzZWxlY3Rvci5yb2xlJyk7VEVTVF9OQU1FX1RZUEU9c3ltYm9sRm9yKCdzZWxlY3Rvci50ZXN0X2lkJyk7VEVYVF9UWVBFPXN5bWJvbEZvcignc2VsZWN0b3IudGV4dCcpO312YXIgY29tbWl0SG9va3M9W107ZnVuY3Rpb24gb25Db21taXRSb290JDEoKXt7Y29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbihjb21taXRIb29rKXtyZXR1cm4gY29tbWl0SG9vaygpO30pO319dmFyIFJlYWN0Q3VycmVudEFjdFF1ZXVlPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEFjdFF1ZXVlO2Z1bmN0aW9uIGlzTGVnYWN5QWN0RW52aXJvbm1lbnQoZmliZXIpe3svLyBMZWdhY3kgbW9kZS4gV2UgcHJlc2VydmUgdGhlIGJlaGF2aW9yIG9mIFJlYWN0IDE3J3MgYWN0LiBJdCBhc3N1bWVzIGFuXG4vLyBhY3QgZW52aXJvbm1lbnQgd2hlbmV2ZXIgYGplc3RgIGlzIGRlZmluZWQsIGJ1dCB5b3UgY2FuIHN0aWxsIHR1cm4gb2ZmXG4vLyBzcHVyaW91cyB3YXJuaW5ncyBieSBzZXR0aW5nIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBleHBsaWNpdGx5XG4vLyB0byBmYWxzZS5cbnZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWw9Ly8gJEZsb3dFeHBlY3RlZEVycm9yIOKAkyBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgZ2xvYmFsXG50eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIT09J3VuZGVmaW5lZCc/SVNfUkVBQ1RfQUNUX0VOVklST05NRU5UOnVuZGVmaW5lZDsvLyAkRmxvd0V4cGVjdGVkRXJyb3IgLSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCBqZXN0XG52YXIgamVzdElzRGVmaW5lZD10eXBlb2YgamVzdCE9PSd1bmRlZmluZWQnO3JldHVybiBqZXN0SXNEZWZpbmVkJiZpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwhPT1mYWxzZTt9fWZ1bmN0aW9uIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCl7e3ZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWw9Ly8gJEZsb3dFeHBlY3RlZEVycm9yIOKAkyBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgZ2xvYmFsXG50eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIT09J3VuZGVmaW5lZCc/SVNfUkVBQ1RfQUNUX0VOVklST05NRU5UOnVuZGVmaW5lZDtpZighaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsJiZSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50IT09bnVsbCl7Ly8gVE9ETzogSW5jbHVkZSBsaW5rIHRvIHJlbGV2YW50IGRvY3VtZW50YXRpb24gcGFnZS5cbmVycm9yKCdUaGUgY3VycmVudCB0ZXN0aW5nIGVudmlyb25tZW50IGlzIG5vdCBjb25maWd1cmVkIHRvIHN1cHBvcnQgJysnYWN0KC4uLiknKTt9cmV0dXJuIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbDt9fXZhciBjZWlsPU1hdGguY2VpbDt2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsUmVhY3RDdXJyZW50T3duZXIkMj1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcixSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFJlYWN0Q3VycmVudEFjdFF1ZXVlJDE9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWU7dmFyIE5vQ29udGV4dD0vKiAgICAgICAgICAgICAqLzA7dmFyIEJhdGNoZWRDb250ZXh0PS8qICAgICAgICAgICAgICAgKi8xO3ZhciBSZW5kZXJDb250ZXh0PS8qICAgICAgICAgICAgICAgICovMjt2YXIgQ29tbWl0Q29udGV4dD0vKiAgICAgICAgICAgICAgICAqLzQ7dmFyIFJvb3RJblByb2dyZXNzPTA7dmFyIFJvb3RGYXRhbEVycm9yZWQ9MTt2YXIgUm9vdEVycm9yZWQ9Mjt2YXIgUm9vdFN1c3BlbmRlZD0zO3ZhciBSb290U3VzcGVuZGVkV2l0aERlbGF5PTQ7dmFyIFJvb3RDb21wbGV0ZWQ9NTt2YXIgUm9vdERpZE5vdENvbXBsZXRlPTY7Ly8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG52YXIgZXhlY3V0aW9uQ29udGV4dD1Ob0NvbnRleHQ7Ly8gVGhlIHJvb3Qgd2UncmUgd29ya2luZyBvblxudmFyIHdvcmtJblByb2dyZXNzUm9vdD1udWxsOy8vIFRoZSBmaWJlciB3ZSdyZSB3b3JraW5nIG9uXG52YXIgd29ya0luUHJvZ3Jlc3M9bnVsbDsvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM9Tm9MYW5lczsvLyBTdGFjayB0aGF0IGFsbG93cyBjb21wb25lbnRzIHRvIGNoYW5nZSB0aGUgcmVuZGVyIGxhbmVzIGZvciBpdHMgc3VidHJlZVxuLy8gVGhpcyBpcyBhIHN1cGVyc2V0IG9mIHRoZSBsYW5lcyB3ZSBzdGFydGVkIHdvcmtpbmcgb24gYXQgdGhlIHJvb3QuIFRoZSBvbmx5XG4vLyBjYXNlIHdoZXJlIGl0J3MgZGlmZmVyZW50IGZyb20gYHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzYCBpcyB3aGVuIHdlXG4vLyBlbnRlciBhIHN1YnRyZWUgdGhhdCBpcyBoaWRkZW4gYW5kIG5lZWRzIHRvIGJlIHVuaGlkZGVuOiBTdXNwZW5zZSBhbmRcbi8vIE9mZnNjcmVlbiBjb21wb25lbnQuXG4vL1xuLy8gTW9zdCB0aGluZ3MgaW4gdGhlIHdvcmsgbG9vcCBzaG91bGQgZGVhbCB3aXRoIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLlxuLy8gTW9zdCB0aGluZ3MgaW4gYmVnaW4vY29tcGxldGUgcGhhc2VzIHNob3VsZCBkZWFsIHdpdGggc3VidHJlZVJlbmRlckxhbmVzLlxudmFyIHN1YnRyZWVSZW5kZXJMYW5lcz1Ob0xhbmVzO3ZhciBzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3I9Y3JlYXRlQ3Vyc29yKE5vTGFuZXMpOy8vIFdoZXRoZXIgdG8gcm9vdCBjb21wbGV0ZWQsIGVycm9yZWQsIHN1c3BlbmRlZCwgZXRjLlxudmFyIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9Um9vdEluUHJvZ3Jlc3M7Ly8gQSBmYXRhbCBlcnJvciwgaWYgb25lIGlzIHRocm93blxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I9bnVsbDsvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxudmFyIHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXM9Tm9MYW5lczsvLyBUaGUgd29yayBsZWZ0IG92ZXIgYnkgY29tcG9uZW50cyB0aGF0IHdlcmUgdmlzaXRlZCBkdXJpbmcgdGhpcyByZW5kZXIuIE9ubHlcbi8vIGluY2x1ZGVzIHVucHJvY2Vzc2VkIHVwZGF0ZXMsIG5vdCB3b3JrIGluIGJhaWxlZCBvdXQgY2hpbGRyZW4uXG52YXIgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzPU5vTGFuZXM7Ly8gTGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgKGluIGFuIGludGVybGVhdmVkIGV2ZW50KSBkdXJpbmcgdGhpcyByZW5kZXIuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXM9Tm9MYW5lczsvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSAoKm5vdCogYW4gaW50ZXJsZWF2ZWQgZXZlbnQpLlxudmFyIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzPU5vTGFuZXM7Ly8gRXJyb3JzIHRoYXQgYXJlIHRocm93biBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzPW51bGw7Ly8gVGhlc2UgYXJlIGVycm9ycyB0aGF0IHdlIHJlY292ZXJlZCBmcm9tIHdpdGhvdXQgc3VyZmFjaW5nIHRoZW0gdG8gdGhlIFVJLlxuLy8gV2Ugd2lsbCBsb2cgdGhlbSBvbmNlIHRoZSB0cmVlIGNvbW1pdHMuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM9bnVsbDsvLyBUaGUgbW9zdCByZWNlbnQgdGltZSB3ZSBjb21taXR0ZWQgYSBmYWxsYmFjay4gVGhpcyBsZXRzIHVzIGVuc3VyZSBhIHRyYWluXG4vLyBtb2RlbCB3aGVyZSB3ZSBkb24ndCBjb21taXQgbmV3IGxvYWRpbmcgc3RhdGVzIGluIHRvbyBxdWljayBzdWNjZXNzaW9uLlxudmFyIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWU9MDt2YXIgRkFMTEJBQ0tfVEhST1RUTEVfTVM9NTAwOy8vIFRoZSBhYnNvbHV0ZSB0aW1lIGZvciB3aGVuIHdlIHNob3VsZCBzdGFydCBnaXZpbmcgdXAgb24gcmVuZGVyaW5nXG4vLyBtb3JlIGFuZCBwcmVmZXIgQ1BVIHN1c3BlbnNlIGhldXJpc3RpY3MgaW5zdGVhZC5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lPUluZmluaXR5Oy8vIEhvdyBsb25nIGEgcmVuZGVyIGlzIHN1cHBvc2VkIHRvIHRha2UgYmVmb3JlIHdlIHN0YXJ0IGZvbGxvd2luZyBDUFVcbi8vIHN1c3BlbnNlIGhldXJpc3RpY3MgYW5kIG9wdCBvdXQgb2YgcmVuZGVyaW5nIG1vcmUgY29udGVudC5cbnZhciBSRU5ERVJfVElNRU9VVF9NUz01MDA7dmFyIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnM9bnVsbDtmdW5jdGlvbiByZXNldFJlbmRlclRpbWVyKCl7d29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZT1ub3coKStSRU5ERVJfVElNRU9VVF9NUzt9ZnVuY3Rpb24gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpe3JldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lO312YXIgaGFzVW5jYXVnaHRFcnJvcj1mYWxzZTt2YXIgZmlyc3RVbmNhdWdodEVycm9yPW51bGw7dmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkPW51bGw7Ly8gT25seSB1c2VkIHdoZW4gZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVTY2hlZHVsZWRIb29rIGlzIHRydWU7XG52YXIgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM9ZmFsc2U7dmFyIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzPW51bGw7dmFyIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzPU5vTGFuZXM7dmFyIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzPVtdO3ZhciBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zPW51bGw7Ly8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xudmFyIE5FU1RFRF9VUERBVEVfTElNSVQ9NTA7dmFyIG5lc3RlZFVwZGF0ZUNvdW50PTA7dmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcz1udWxsO3ZhciBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHM9ZmFsc2U7dmFyIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHM9ZmFsc2U7dmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVD01MDt2YXIgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50PTA7dmFyIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXM9bnVsbDsvLyBJZiB0d28gdXBkYXRlcyBhcmUgc2NoZWR1bGVkIHdpdGhpbiB0aGUgc2FtZSBldmVudCwgd2Ugc2hvdWxkIHRyZWF0IHRoZWlyXG4vLyBldmVudCB0aW1lcyBhcyBzaW11bHRhbmVvdXMsIGV2ZW4gaWYgdGhlIGFjdHVhbCBjbG9jayB0aW1lIGhhcyBhZHZhbmNlZFxuLy8gYmV0d2VlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCBjYWxsLlxudmFyIGN1cnJlbnRFdmVudFRpbWU9Tm9UaW1lc3RhbXA7dmFyIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lPU5vTGFuZXM7dmFyIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdD1mYWxzZTtmdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKXtyZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290O31mdW5jdGlvbiByZXF1ZXN0RXZlbnRUaW1lKCl7aWYoKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpIT09Tm9Db250ZXh0KXsvLyBXZSdyZSBpbnNpZGUgUmVhY3QsIHNvIGl0J3MgZmluZSB0byByZWFkIHRoZSBhY3R1YWwgdGltZS5cbnJldHVybiBub3coKTt9Ly8gV2UncmUgbm90IGluc2lkZSBSZWFjdCwgc28gd2UgbWF5IGJlIGluIHRoZSBtaWRkbGUgb2YgYSBicm93c2VyIGV2ZW50LlxuaWYoY3VycmVudEV2ZW50VGltZSE9PU5vVGltZXN0YW1wKXsvLyBVc2UgdGhlIHNhbWUgc3RhcnQgdGltZSBmb3IgYWxsIHVwZGF0ZXMgdW50aWwgd2UgZW50ZXIgUmVhY3QgYWdhaW4uXG5yZXR1cm4gY3VycmVudEV2ZW50VGltZTt9Ly8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHNpbmNlIFJlYWN0IHlpZWxkZWQuIENvbXB1dGUgYSBuZXcgc3RhcnQgdGltZS5cbmN1cnJlbnRFdmVudFRpbWU9bm93KCk7cmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7fWZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKXsvLyBTcGVjaWFsIGNhc2VzXG52YXIgbW9kZT1maWJlci5tb2RlO2lmKChtb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7cmV0dXJuIFN5bmNMYW5lO31lbHNlIGlmKChleGVjdXRpb25Db250ZXh0JlJlbmRlckNvbnRleHQpIT09Tm9Db250ZXh0JiZ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyE9PU5vTGFuZXMpey8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBUaGVzZSBhcmUgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLiBUaGVcbi8vIG9sZCBiZWhhdmlvciBpcyB0byBnaXZlIHRoaXMgdGhlIHNhbWUgXCJ0aHJlYWRcIiAobGFuZXMpIGFzXG4vLyB3aGF0ZXZlciBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLiBTbyBpZiB5b3UgY2FsbCBgc2V0U3RhdGVgIG9uIGEgY29tcG9uZW50XG4vLyB0aGF0IGhhcHBlbnMgbGF0ZXIgaW4gdGhlIHNhbWUgcmVuZGVyLCBpdCB3aWxsIGZsdXNoLiBJZGVhbGx5LCB3ZSB3YW50IHRvXG4vLyByZW1vdmUgdGhlIHNwZWNpYWwgY2FzZSBhbmQgdHJlYXQgdGhlbSBhcyBpZiB0aGV5IGNhbWUgZnJvbSBhblxuLy8gaW50ZXJsZWF2ZWQgZXZlbnQuIFJlZ2FyZGxlc3MsIHRoaXMgcGF0dGVybiBpcyBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuXG4vLyBUaGlzIGJlaGF2aW9yIGlzIG9ubHkgYSBmYWxsYmFjay4gVGhlIGZsYWcgb25seSBleGlzdHMgdW50aWwgd2UgY2FuIHJvbGxcbi8vIG91dCB0aGUgc2V0U3RhdGUgd2FybmluZywgc2luY2UgZXhpc3RpbmcgY29kZSBtaWdodCBhY2NpZGVudGFsbHkgcmVseSBvblxuLy8gdGhlIGN1cnJlbnQgYmVoYXZpb3IuXG5yZXR1cm4gcGlja0FyYml0cmFyeUxhbmUod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO312YXIgaXNUcmFuc2l0aW9uPXJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbigpIT09Tm9UcmFuc2l0aW9uO2lmKGlzVHJhbnNpdGlvbil7aWYoUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uIT09bnVsbCl7dmFyIHRyYW5zaXRpb249UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO2lmKCF0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKXt0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzPW5ldyBTZXQoKTt9dHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpO30vLyBUaGUgYWxnb3JpdGhtIGZvciBhc3NpZ25pbmcgYW4gdXBkYXRlIHRvIGEgbGFuZSBzaG91bGQgYmUgc3RhYmxlIGZvciBhbGxcbi8vIHVwZGF0ZXMgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aGluIHRoZSBzYW1lIGV2ZW50LiBUbyBkbyB0aGlzLCB0aGVcbi8vIGlucHV0cyB0byB0aGUgYWxnb3JpdGhtIG11c3QgYmUgdGhlIHNhbWUuXG4vL1xuLy8gVGhlIHRyaWNrIHdlIHVzZSBpcyB0byBjYWNoZSB0aGUgZmlyc3Qgb2YgZWFjaCBvZiB0aGVzZSBpbnB1dHMgd2l0aGluIGFuXG4vLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpc1xuLy8gb3Zlci4gT3VyIGhldXJpc3RpYyBmb3IgdGhhdCBpcyB3aGVuZXZlciB3ZSBlbnRlciBhIGNvbmN1cnJlbnQgd29yayBsb29wLlxuaWYoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmU9PT1Ob0xhbmUpey8vIEFsbCB0cmFuc2l0aW9ucyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgYXJlIGFzc2lnbmVkIHRoZSBzYW1lIGxhbmUuXG5jdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZT1jbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpO31yZXR1cm4gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmU7fS8vIFVwZGF0ZXMgb3JpZ2luYXRpbmcgaW5zaWRlIGNlcnRhaW4gUmVhY3QgbWV0aG9kcywgbGlrZSBmbHVzaFN5bmMsIGhhdmVcbi8vIHRoZWlyIHByaW9yaXR5IHNldCBieSB0cmFja2luZyBpdCB3aXRoIGEgY29udGV4dCB2YXJpYWJsZS5cbi8vXG4vLyBUaGUgb3BhcXVlIHR5cGUgcmV0dXJuZWQgYnkgdGhlIGhvc3QgY29uZmlnIGlzIGludGVybmFsbHkgYSBsYW5lLCBzbyB3ZSBjYW5cbi8vIHVzZSB0aGF0IGRpcmVjdGx5LlxuLy8gVE9ETzogTW92ZSB0aGlzIHR5cGUgY29udmVyc2lvbiB0byB0aGUgZXZlbnQgcHJpb3JpdHkgbW9kdWxlLlxudmFyIHVwZGF0ZUxhbmU9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7aWYodXBkYXRlTGFuZSE9PU5vTGFuZSl7cmV0dXJuIHVwZGF0ZUxhbmU7fS8vIFRoaXMgdXBkYXRlIG9yaWdpbmF0ZWQgb3V0c2lkZSBSZWFjdC4gQXNrIHRoZSBob3N0IGVudmlyb25tZW50IGZvciBhblxuLy8gYXBwcm9wcmlhdGUgcHJpb3JpdHksIGJhc2VkIG9uIHRoZSB0eXBlIG9mIGV2ZW50LlxuLy9cbi8vIFRoZSBvcGFxdWUgdHlwZSByZXR1cm5lZCBieSB0aGUgaG9zdCBjb25maWcgaXMgaW50ZXJuYWxseSBhIGxhbmUsIHNvIHdlIGNhblxuLy8gdXNlIHRoYXQgZGlyZWN0bHkuXG4vLyBUT0RPOiBNb3ZlIHRoaXMgdHlwZSBjb252ZXJzaW9uIHRvIHRoZSBldmVudCBwcmlvcml0eSBtb2R1bGUuXG52YXIgZXZlbnRMYW5lPWdldEN1cnJlbnRFdmVudFByaW9yaXR5KCk7cmV0dXJuIGV2ZW50TGFuZTt9ZnVuY3Rpb24gcmVxdWVzdFJldHJ5TGFuZShmaWJlcil7Ly8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4vLyBcInJldHJpZXNcIiDigJQgYSBzcGVjaWFsIHVwZGF0ZSB0aGF0IGF0dGVtcHRzIHRvIGZsaXAgYSBTdXNwZW5zZSBib3VuZGFyeVxuLy8gZnJvbSBpdHMgcGxhY2Vob2xkZXIgc3RhdGUgdG8gaXRzIHByaW1hcnkvcmVzb2x2ZWQgc3RhdGUuXG4vLyBTcGVjaWFsIGNhc2VzXG52YXIgbW9kZT1maWJlci5tb2RlO2lmKChtb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7cmV0dXJuIFN5bmNMYW5lO31yZXR1cm4gY2xhaW1OZXh0UmV0cnlMYW5lKCk7fWZ1bmN0aW9uIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLGxhbmUsZXZlbnRUaW1lKXtjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKTt7aWYoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KXtlcnJvcigndXNlSW5zZXJ0aW9uRWZmZWN0IG11c3Qgbm90IHNjaGVkdWxlIHVwZGF0ZXMuJyk7fX17aWYoaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzKXtkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzPXRydWU7fX0vLyBNYXJrIHRoYXQgdGhlIHJvb3QgaGFzIGEgcGVuZGluZyB1cGRhdGUuXG5tYXJrUm9vdFVwZGF0ZWQocm9vdCxsYW5lLGV2ZW50VGltZSk7aWYoKGV4ZWN1dGlvbkNvbnRleHQmUmVuZGVyQ29udGV4dCkhPT1Ob0xhbmVzJiZyb290PT09d29ya0luUHJvZ3Jlc3NSb290KXsvLyBUaGlzIHVwZGF0ZSB3YXMgZGlzcGF0Y2hlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpcyBpcyBhIG1pc3Rha2Vcbi8vIGlmIHRoZSB1cGRhdGUgb3JpZ2luYXRlcyBmcm9tIHVzZXIgc3BhY2UgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBsb2NhbFxuLy8gaG9vayB1cGRhdGVzLCB3aGljaCBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseSBhbmQgZG9uJ3QgcmVhY2ggdGhpc1xuLy8gZnVuY3Rpb24pLCBidXQgdGhlcmUgYXJlIHNvbWUgaW50ZXJuYWwgUmVhY3QgZmVhdHVyZXMgdGhhdCB1c2UgdGhpcyBhc1xuLy8gYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLCBsaWtlIHNlbGVjdGl2ZSBoeWRyYXRpb24uXG53YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFVihmaWJlcik7Ly8gVHJhY2sgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Vcbn1lbHNley8vIFRoaXMgaXMgYSBub3JtYWwgdXBkYXRlLCBzY2hlZHVsZWQgZnJvbSBvdXRzaWRlIHRoZSByZW5kZXIgcGhhc2UuIEZvclxuLy8gZXhhbXBsZSwgZHVyaW5nIGFuIGlucHV0IGV2ZW50Llxue2lmKGlzRGV2VG9vbHNQcmVzZW50KXthZGRGaWJlclRvTGFuZXNNYXAocm9vdCxmaWJlcixsYW5lKTt9fXdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcik7aWYocm9vdD09PXdvcmtJblByb2dyZXNzUm9vdCl7Ly8gUmVjZWl2ZWQgYW4gdXBkYXRlIHRvIGEgdHJlZSB0aGF0J3MgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcuIE1hcmtcbi8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuLy8gYGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaGAgZmxhZyBpcyBvZmYgYW5kIHRoaXMgaXMgYSByZW5kZXJcbi8vIHBoYXNlIHVwZGF0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBkb24ndCB0cmVhdCByZW5kZXIgcGhhc2UgdXBkYXRlcyBhcyBpZlxuLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuaWYoKGV4ZWN1dGlvbkNvbnRleHQmUmVuZGVyQ29udGV4dCk9PT1Ob0NvbnRleHQpe3dvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzPW1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsbGFuZSk7fWlmKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9PT1Sb290U3VzcGVuZGVkV2l0aERlbGF5KXsvLyBUaGUgcm9vdCBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHdoaWNoIG1lYW5zIHRoaXMgcmVuZGVyXG4vLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcbi8vIHN1c3BlbmRlZCBub3csIHJpZ2h0IGJlZm9yZSBtYXJraW5nIHRoZSBpbmNvbWluZyB1cGRhdGUuIFRoaXMgaGFzIHRoZVxuLy8gZWZmZWN0IG9mIGludGVycnVwdGluZyB0aGUgY3VycmVudCByZW5kZXIgYW5kIHN3aXRjaGluZyB0byB0aGUgdXBkYXRlLlxuLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuLy8gYWxyZWFkeSBzdGFydGVkIHJlbmRlcmluZy5cbm1hcmtSb290U3VzcGVuZGVkJDEocm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7fX1lbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxldmVudFRpbWUpO2lmKGxhbmU9PT1TeW5jTGFuZSYmZXhlY3V0aW9uQ29udGV4dD09PU5vQ29udGV4dCYmKGZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlJiYvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuIVJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSl7Ly8gRmx1c2ggdGhlIHN5bmNocm9ub3VzIHdvcmsgbm93LCB1bmxlc3Mgd2UncmUgYWxyZWFkeSB3b3JraW5nIG9yIGluc2lkZVxuLy8gYSBiYXRjaC4gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGluc2lkZSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgaW5zdGVhZCBvZlxuLy8gc2NoZWR1bGVDYWxsYmFja0ZvckZpYmVyIHRvIHByZXNlcnZlIHRoZSBhYmlsaXR5IHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbi8vIHdpdGhvdXQgaW1tZWRpYXRlbHkgZmx1c2hpbmcgaXQuIFdlIG9ubHkgZG8gdGhpcyBmb3IgdXNlci1pbml0aWF0ZWRcbi8vIHVwZGF0ZXMsIHRvIHByZXNlcnZlIGhpc3RvcmljYWwgYmVoYXZpb3Igb2YgbGVnYWN5IG1vZGUuXG5yZXNldFJlbmRlclRpbWVyKCk7Zmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpO319fWZ1bmN0aW9uIHNjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdChyb290LGxhbmUsZXZlbnRUaW1lKXsvLyBUaGlzIGlzIGEgc3BlY2lhbCBmb3JrIG9mIHNjaGVkdWxlVXBkYXRlT25GaWJlciB0aGF0IGlzIG9ubHkgdXNlZCB0b1xuLy8gc2NoZWR1bGUgdGhlIGluaXRpYWwgaHlkcmF0aW9uIG9mIGEgcm9vdCB0aGF0IGhhcyBqdXN0IGJlZW4gY3JlYXRlZC4gTW9zdFxuLy8gb2YgdGhlIHN0dWZmIGluIHNjaGVkdWxlVXBkYXRlT25GaWJlciBjYW4gYmUgc2tpcHBlZC5cbi8vXG4vLyBUaGUgbWFpbiByZWFzb24gZm9yIHRoaXMgc2VwYXJhdGUgcGF0aCwgdGhvdWdoLCBpcyB0byBkaXN0aW5ndWlzaCB0aGVcbi8vIGluaXRpYWwgY2hpbGRyZW4gZnJvbSBzdWJzZXF1ZW50IHVwZGF0ZXMuIEluIGZ1bGx5IGNsaWVudC1yZW5kZXJlZCByb290c1xuLy8gKGNyZWF0ZVJvb3QgaW5zdGVhZCBvZiBoeWRyYXRlUm9vdCksIGFsbCB0b3AtbGV2ZWwgcmVuZGVycyBhcmUgbW9kZWxlZCBhc1xuLy8gdXBkYXRlcywgYnV0IGh5ZHJhdGlvbiByb290cyBhcmUgc3BlY2lhbCBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBtdXN0XG4vLyBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLlxudmFyIGN1cnJlbnQ9cm9vdC5jdXJyZW50O2N1cnJlbnQubGFuZXM9bGFuZTttYXJrUm9vdFVwZGF0ZWQocm9vdCxsYW5lLGV2ZW50VGltZSk7ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsZXZlbnRUaW1lKTt9ZnVuY3Rpb24gaXNVbnNhZmVDbGFzc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKXsvLyBDaGVjayBpZiB0aGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gT25seSBjYWxsZWQgYnkgY2xhc3MgY29tcG9uZW50cyxcbi8vIHdoaWNoIHNwZWNpYWwgKGRlcHJlY2F0ZWQpIGJlaGF2aW9yIGZvciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmUgcHJvcHMuXG5yZXR1cm4oLy8gVE9ETzogUmVtb3ZlIG91dGRhdGVkIGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaCBleHBlcmltZW50LiBXZVxuLy8gZGVjaWRlZCBub3QgdG8gZW5hYmxlIGl0LlxuKGV4ZWN1dGlvbkNvbnRleHQmUmVuZGVyQ29udGV4dCkhPT1Ob0NvbnRleHQpO30vLyBVc2UgdGhpcyBmdW5jdGlvbiB0byBzY2hlZHVsZSBhIHRhc2sgZm9yIGEgcm9vdC4gVGhlcmUncyBvbmx5IG9uZSB0YXNrIHBlclxuLy8gcm9vdDsgaWYgYSB0YXNrIHdhcyBhbHJlYWR5IHNjaGVkdWxlZCwgd2UnbGwgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBwcmlvcml0eVxuLy8gb2YgdGhlIGV4aXN0aW5nIHRhc2sgaXMgdGhlIHNhbWUgYXMgdGhlIHByaW9yaXR5IG9mIHRoZSBuZXh0IGxldmVsIHRoYXQgdGhlXG4vLyByb290IGhhcyB3b3JrIG9uLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSB1cGRhdGUsIGFuZCByaWdodCBiZWZvcmVcbi8vIGV4aXRpbmcgYSB0YXNrLlxuZnVuY3Rpb24gZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsY3VycmVudFRpbWUpe3ZhciBleGlzdGluZ0NhbGxiYWNrTm9kZT1yb290LmNhbGxiYWNrTm9kZTsvLyBDaGVjayBpZiBhbnkgbGFuZXMgYXJlIGJlaW5nIHN0YXJ2ZWQgYnkgb3RoZXIgd29yay4gSWYgc28sIG1hcmsgdGhlbSBhc1xuLy8gZXhwaXJlZCBzbyB3ZSBrbm93IHRvIHdvcmsgb24gdGhvc2UgbmV4dC5cbm1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQocm9vdCxjdXJyZW50VGltZSk7Ly8gRGV0ZXJtaW5lIHRoZSBuZXh0IGxhbmVzIHRvIHdvcmsgb24sIGFuZCB0aGVpciBwcmlvcml0eS5cbnZhciBuZXh0TGFuZXM9Z2V0TmV4dExhbmVzKHJvb3Qscm9vdD09PXdvcmtJblByb2dyZXNzUm9vdD93b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lczpOb0xhbmVzKTtpZihuZXh0TGFuZXM9PT1Ob0xhbmVzKXsvLyBTcGVjaWFsIGNhc2U6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuaWYoZXhpc3RpbmdDYWxsYmFja05vZGUhPT1udWxsKXtjYW5jZWxDYWxsYmFjayQxKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTt9cm9vdC5jYWxsYmFja05vZGU9bnVsbDtyb290LmNhbGxiYWNrUHJpb3JpdHk9Tm9MYW5lO3JldHVybjt9Ly8gV2UgdXNlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGxhbmUgdG8gcmVwcmVzZW50IHRoZSBwcmlvcml0eSBvZiB0aGUgY2FsbGJhY2suXG52YXIgbmV3Q2FsbGJhY2tQcmlvcml0eT1nZXRIaWdoZXN0UHJpb3JpdHlMYW5lKG5leHRMYW5lcyk7Ly8gQ2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyB0YXNrLiBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSBpdC5cbnZhciBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHk9cm9vdC5jYWxsYmFja1ByaW9yaXR5O2lmKGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eT09PW5ld0NhbGxiYWNrUHJpb3JpdHkmJi8vIFNwZWNpYWwgY2FzZSByZWxhdGVkIHRvIGBhY3RgLiBJZiB0aGUgY3VycmVudGx5IHNjaGVkdWxlZCB0YXNrIGlzIGFcbi8vIFNjaGVkdWxlciB0YXNrLCByYXRoZXIgdGhhbiBhbiBgYWN0YCB0YXNrLCBjYW5jZWwgaXQgYW5kIHJlLXNjaGVkdWxlZFxuLy8gb24gdGhlIGBhY3RgIHF1ZXVlLlxuIShSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQhPT1udWxsJiZleGlzdGluZ0NhbGxiYWNrTm9kZSE9PWZha2VBY3RDYWxsYmFja05vZGUpKXt7Ly8gSWYgd2UncmUgZ29pbmcgdG8gcmUtdXNlIGFuIGV4aXN0aW5nIHRhc2ssIGl0IG5lZWRzIHRvIGV4aXN0LlxuLy8gQXNzdW1lIHRoYXQgZGlzY3JldGUgdXBkYXRlIG1pY3JvdGFza3MgYXJlIG5vbi1jYW5jZWxsYWJsZSBhbmQgbnVsbC5cbi8vIFRPRE86IFRlbXBvcmFyeSB1bnRpbCB3ZSBjb25maXJtIHRoaXMgd2FybmluZyBpcyBub3QgZmlyZWQuXG5pZihleGlzdGluZ0NhbGxiYWNrTm9kZT09bnVsbCYmZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5IT09U3luY0xhbmUpe2Vycm9yKCdFeHBlY3RlZCBzY2hlZHVsZWQgY2FsbGJhY2sgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX0vLyBUaGUgcHJpb3JpdHkgaGFzbid0IGNoYW5nZWQuIFdlIGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgdGFzay4gRXhpdC5cbnJldHVybjt9aWYoZXhpc3RpbmdDYWxsYmFja05vZGUhPW51bGwpey8vIENhbmNlbCB0aGUgZXhpc3RpbmcgY2FsbGJhY2suIFdlJ2xsIHNjaGVkdWxlIGEgbmV3IG9uZSBiZWxvdy5cbmNhbmNlbENhbGxiYWNrJDEoZXhpc3RpbmdDYWxsYmFja05vZGUpO30vLyBTY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cbnZhciBuZXdDYWxsYmFja05vZGU7aWYobmV3Q2FsbGJhY2tQcmlvcml0eT09PVN5bmNMYW5lKXsvLyBTcGVjaWFsIGNhc2U6IFN5bmMgUmVhY3QgY2FsbGJhY2tzIGFyZSBzY2hlZHVsZWQgb24gYSBzcGVjaWFsXG4vLyBpbnRlcm5hbCBxdWV1ZVxuaWYocm9vdC50YWc9PT1MZWdhY3lSb290KXtpZihSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmlzQmF0Y2hpbmdMZWdhY3khPT1udWxsKXtSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlPXRydWU7fXNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrKHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwscm9vdCkpO31lbHNle3NjaGVkdWxlU3luY0NhbGxiYWNrKHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwscm9vdCkpO317Ly8gRmx1c2ggdGhlIHF1ZXVlIGluIGEgbWljcm90YXNrLlxuaWYoUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50IT09bnVsbCl7Ly8gSW5zaWRlIGBhY3RgLCB1c2Ugb3VyIGludGVybmFsIGBhY3RgIHF1ZXVlIHNvIHRoYXQgdGhlc2UgZ2V0IGZsdXNoZWRcbi8vIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2NvcGUgZXZlbiB3aGVuIHVzaW5nIHRoZSBzeW5jIHZlcnNpb25cbi8vIG9mIGBhY3RgLlxuUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50LnB1c2goZmx1c2hTeW5jQ2FsbGJhY2tzKTt9ZWxzZXtzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbigpey8vIEluIFNhZmFyaSwgYXBwZW5kaW5nIGFuIGlmcmFtZSBmb3JjZXMgbWljcm90YXNrcyB0byBydW4uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIyNDU5XG4vLyBXZSBkb24ndCBzdXBwb3J0IHJ1bm5pbmcgY2FsbGJhY2tzIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyXG4vLyBvciBjb21taXQgc28gd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0IHRoYXQuXG5pZigoZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSk9PT1Ob0NvbnRleHQpey8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHN0aWxsIHByZW1hdHVyZWx5IGZsdXNoIHRoZSBjYWxsYmFja3Ncbi8vIGlmIHRoaXMgaGFwcGVucyBvdXRzaWRlIHJlbmRlciBvciBjb21taXQgcGhhc2UgKGUuZy4gaW4gYW4gZXZlbnQpLlxuZmx1c2hTeW5jQ2FsbGJhY2tzKCk7fX0pO319bmV3Q2FsbGJhY2tOb2RlPW51bGw7fWVsc2V7dmFyIHNjaGVkdWxlclByaW9yaXR5TGV2ZWw7c3dpdGNoKGxhbmVzVG9FdmVudFByaW9yaXR5KG5leHRMYW5lcykpe2Nhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OnNjaGVkdWxlclByaW9yaXR5TGV2ZWw9SW1tZWRpYXRlUHJpb3JpdHk7YnJlYWs7Y2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpzY2hlZHVsZXJQcmlvcml0eUxldmVsPVVzZXJCbG9ja2luZ1ByaW9yaXR5O2JyZWFrO2Nhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6c2NoZWR1bGVyUHJpb3JpdHlMZXZlbD1Ob3JtYWxQcmlvcml0eTticmVhaztjYXNlIElkbGVFdmVudFByaW9yaXR5OnNjaGVkdWxlclByaW9yaXR5TGV2ZWw9SWRsZVByaW9yaXR5O2JyZWFrO2RlZmF1bHQ6c2NoZWR1bGVyUHJpb3JpdHlMZXZlbD1Ob3JtYWxQcmlvcml0eTticmVhazt9bmV3Q2FsbGJhY2tOb2RlPXNjaGVkdWxlQ2FsbGJhY2skMShzY2hlZHVsZXJQcmlvcml0eUxldmVsLHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdC5iaW5kKG51bGwscm9vdCkpO31yb290LmNhbGxiYWNrUHJpb3JpdHk9bmV3Q2FsbGJhY2tQcmlvcml0eTtyb290LmNhbGxiYWNrTm9kZT1uZXdDYWxsYmFja05vZGU7fS8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBldmVyeSBjb25jdXJyZW50IHRhc2ssIGkuZS4gYW55dGhpbmcgdGhhdFxuLy8gZ29lcyB0aHJvdWdoIFNjaGVkdWxlci5cbmZ1bmN0aW9uIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdChyb290LGRpZFRpbWVvdXQpe3tyZXNldE5lc3RlZFVwZGF0ZUZsYWcoKTt9Ly8gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBhIFJlYWN0IGV2ZW50LCB3ZSBjYW4gY2xlYXIgdGhlIGN1cnJlbnRcbi8vIGV2ZW50IHRpbWUuIFRoZSBuZXh0IHVwZGF0ZSB3aWxsIGNvbXB1dGUgYSBuZXcgZXZlbnQgdGltZS5cbmN1cnJlbnRFdmVudFRpbWU9Tm9UaW1lc3RhbXA7Y3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmU9Tm9MYW5lcztpZigoZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSkhPT1Ob0NvbnRleHQpe3Rocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7fS8vIEZsdXNoIGFueSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBiZWZvcmUgZGVjaWRpbmcgd2hpY2ggbGFuZXMgdG8gd29yayBvbixcbi8vIGluIGNhc2UgdGhleSBzY2hlZHVsZSBhZGRpdGlvbmFsIHdvcmsuXG52YXIgb3JpZ2luYWxDYWxsYmFja05vZGU9cm9vdC5jYWxsYmFja05vZGU7dmFyIGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHM9Zmx1c2hQYXNzaXZlRWZmZWN0cygpO2lmKGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMpey8vIFNvbWV0aGluZyBpbiB0aGUgcGFzc2l2ZSBlZmZlY3QgcGhhc2UgbWF5IGhhdmUgY2FuY2VsZWQgdGhlIGN1cnJlbnQgdGFzay5cbi8vIENoZWNrIGlmIHRoZSB0YXNrIG5vZGUgZm9yIHRoaXMgcm9vdCB3YXMgY2hhbmdlZC5cbmlmKHJvb3QuY2FsbGJhY2tOb2RlIT09b3JpZ2luYWxDYWxsYmFja05vZGUpey8vIFRoZSBjdXJyZW50IHRhc2sgd2FzIGNhbmNlbGVkLiBFeGl0LiBXZSBkb24ndCBuZWVkIHRvIGNhbGxcbi8vIGBlbnN1cmVSb290SXNTY2hlZHVsZWRgIGJlY2F1c2UgdGhlIGNoZWNrIGFib3ZlIGltcGxpZXMgZWl0aGVyIHRoYXRcbi8vIHRoZXJlJ3MgYSBuZXcgdGFzaywgb3IgdGhhdCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdC5cbnJldHVybiBudWxsO319Ly8gRGV0ZXJtaW5lIHRoZSBuZXh0IGxhbmVzIHRvIHdvcmsgb24sIHVzaW5nIHRoZSBmaWVsZHMgc3RvcmVkXG4vLyBvbiB0aGUgcm9vdC5cbnZhciBsYW5lcz1nZXROZXh0TGFuZXMocm9vdCxyb290PT09d29ya0luUHJvZ3Jlc3NSb290P3dvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzOk5vTGFuZXMpO2lmKGxhbmVzPT09Tm9MYW5lcyl7Ly8gRGVmZW5zaXZlIGNvZGluZy4gVGhpcyBpcyBuZXZlciBleHBlY3RlZCB0byBoYXBwZW4uXG5yZXR1cm4gbnVsbDt9Ly8gV2UgZGlzYWJsZSB0aW1lLXNsaWNpbmcgaW4gc29tZSBjYXNlczogaWYgdGhlIHdvcmsgaGFzIGJlZW4gQ1BVLWJvdW5kXG4vLyBmb3IgdG9vIGxvbmcgKFwiZXhwaXJlZFwiIHdvcmssIHRvIHByZXZlbnQgc3RhcnZhdGlvbiksIG9yIHdlJ3JlIGluXG4vLyBzeW5jLXVwZGF0ZXMtYnktZGVmYXVsdCBtb2RlLlxuLy8gVE9ETzogV2Ugb25seSBjaGVjayBgZGlkVGltZW91dGAgZGVmZW5zaXZlbHksIHRvIGFjY291bnQgZm9yIGEgU2NoZWR1bGVyXG4vLyBidWcgd2UncmUgc3RpbGwgaW52ZXN0aWdhdGluZy4gT25jZSB0aGUgYnVnIGluIFNjaGVkdWxlciBpcyBmaXhlZCxcbi8vIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2UgdHJhY2sgZXhwaXJhdGlvbiBvdXJzZWx2ZXMuXG52YXIgc2hvdWxkVGltZVNsaWNlPSFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LGxhbmVzKSYmIWluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCxsYW5lcykmJiFkaWRUaW1lb3V0O3ZhciBleGl0U3RhdHVzPXNob3VsZFRpbWVTbGljZT9yZW5kZXJSb290Q29uY3VycmVudChyb290LGxhbmVzKTpyZW5kZXJSb290U3luYyhyb290LGxhbmVzKTtpZihleGl0U3RhdHVzIT09Um9vdEluUHJvZ3Jlc3Mpe2lmKGV4aXRTdGF0dXM9PT1Sb290RXJyb3JlZCl7Ly8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsXG4vLyByZW5kZXIgc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGxcbi8vIGluY2x1ZGVzIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlclxuLy8gdGhlIHNlY29uZCBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxudmFyIGVycm9yUmV0cnlMYW5lcz1nZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtpZihlcnJvclJldHJ5TGFuZXMhPT1Ob0xhbmVzKXtsYW5lcz1lcnJvclJldHJ5TGFuZXM7ZXhpdFN0YXR1cz1yZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LGVycm9yUmV0cnlMYW5lcyk7fX1pZihleGl0U3RhdHVzPT09Um9vdEZhdGFsRXJyb3JlZCl7dmFyIGZhdGFsRXJyb3I9d29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcjtwcmVwYXJlRnJlc2hTdGFjayhyb290LE5vTGFuZXMpO21hcmtSb290U3VzcGVuZGVkJDEocm9vdCxsYW5lcyk7ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3Qsbm93KCkpO3Rocm93IGZhdGFsRXJyb3I7fWlmKGV4aXRTdGF0dXM9PT1Sb290RGlkTm90Q29tcGxldGUpey8vIFRoZSByZW5kZXIgdW53b3VuZCB3aXRob3V0IGNvbXBsZXRpbmcgdGhlIHRyZWUuIFRoaXMgaGFwcGVucyBpbiBzcGVjaWFsXG4vLyBjYXNlcyB3aGVyZSBuZWVkIHRvIGV4aXQgdGhlIGN1cnJlbnQgcmVuZGVyIHdpdGhvdXQgcHJvZHVjaW5nIGFcbi8vIGNvbnNpc3RlbnQgdHJlZSBvciBjb21taXR0aW5nLlxuLy9cbi8vIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGR1cmluZyBhIGNvbmN1cnJlbnQgcmVuZGVyLCBub3QgYSBkaXNjcmV0ZSBvclxuLy8gc3luY2hyb25vdXMgdXBkYXRlLiBXZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGNoZWNrZWQgZm9yIHRoaXMgd2hlbiB3ZVxuLy8gdW53b3VuZCB0aGUgc3RhY2suXG5tYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsbGFuZXMpO31lbHNley8vIFRoZSByZW5kZXIgY29tcGxldGVkLlxuLy8gQ2hlY2sgaWYgdGhpcyByZW5kZXIgbWF5IGhhdmUgeWllbGRlZCB0byBhIGNvbmN1cnJlbnQgZXZlbnQsIGFuZCBpZiBzbyxcbi8vIGNvbmZpcm0gdGhhdCBhbnkgbmV3bHkgcmVuZGVyZWQgc3RvcmVzIGFyZSBjb25zaXN0ZW50LlxuLy8gVE9ETzogSXQncyBwb3NzaWJsZSB0aGF0IGV2ZW4gYSBjb25jdXJyZW50IHJlbmRlciBtYXkgbmV2ZXIgaGF2ZSB5aWVsZGVkXG4vLyB0byB0aGUgbWFpbiB0aHJlYWQsIGlmIGl0IHdhcyBmYXN0IGVub3VnaCwgb3IgaWYgaXQgZXhwaXJlZC4gV2UgY291bGRcbi8vIHNraXAgdGhlIGNvbnNpc3RlbmN5IGNoZWNrIGluIHRoYXQgY2FzZSwgdG9vLlxudmFyIHJlbmRlcldhc0NvbmN1cnJlbnQ9IWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsbGFuZXMpO3ZhciBmaW5pc2hlZFdvcms9cm9vdC5jdXJyZW50LmFsdGVybmF0ZTtpZihyZW5kZXJXYXNDb25jdXJyZW50JiYhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykpey8vIEEgc3RvcmUgd2FzIG11dGF0ZWQgaW4gYW4gaW50ZXJsZWF2ZWQgZXZlbnQuIFJlbmRlciBhZ2Fpbixcbi8vIHN5bmNocm9ub3VzbHksIHRvIGJsb2NrIGZ1cnRoZXIgbXV0YXRpb25zLlxuZXhpdFN0YXR1cz1yZW5kZXJSb290U3luYyhyb290LGxhbmVzKTsvLyBXZSBuZWVkIHRvIGNoZWNrIGFnYWluIGlmIHNvbWV0aGluZyB0aHJld1xuaWYoZXhpdFN0YXR1cz09PVJvb3RFcnJvcmVkKXt2YXIgX2Vycm9yUmV0cnlMYW5lcz1nZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtpZihfZXJyb3JSZXRyeUxhbmVzIT09Tm9MYW5lcyl7bGFuZXM9X2Vycm9yUmV0cnlMYW5lcztleGl0U3RhdHVzPXJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsX2Vycm9yUmV0cnlMYW5lcyk7Ly8gV2UgYXNzdW1lIHRoZSB0cmVlIGlzIG5vdyBjb25zaXN0ZW50IGJlY2F1c2Ugd2UgZGlkbid0IHlpZWxkIHRvIGFueVxuLy8gY29uY3VycmVudCBldmVudHMuXG59fWlmKGV4aXRTdGF0dXM9PT1Sb290RmF0YWxFcnJvcmVkKXt2YXIgX2ZhdGFsRXJyb3I9d29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcjtwcmVwYXJlRnJlc2hTdGFjayhyb290LE5vTGFuZXMpO21hcmtSb290U3VzcGVuZGVkJDEocm9vdCxsYW5lcyk7ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3Qsbm93KCkpO3Rocm93IF9mYXRhbEVycm9yO319Ly8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIFRoZSBuZXh0IHN0ZXAgaXMgZWl0aGVyIHRvIGNvbW1pdCBpdCxcbi8vIG9yLCBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLCB3YWl0IHRvIGNvbW1pdCBpdCBhZnRlciBhIHRpbWVvdXQuXG5yb290LmZpbmlzaGVkV29yaz1maW5pc2hlZFdvcms7cm9vdC5maW5pc2hlZExhbmVzPWxhbmVzO2ZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCxleGl0U3RhdHVzLGxhbmVzKTt9fWVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LG5vdygpKTtpZihyb290LmNhbGxiYWNrTm9kZT09PW9yaWdpbmFsQ2FsbGJhY2tOb2RlKXsvLyBUaGUgdGFzayBub2RlIHNjaGVkdWxlZCBmb3IgdGhpcyByb290IGlzIHRoZSBzYW1lIG9uZSB0aGF0J3Ncbi8vIGN1cnJlbnRseSBleGVjdXRlZC4gTmVlZCB0byByZXR1cm4gYSBjb250aW51YXRpb24uXG5yZXR1cm4gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCxyb290KTt9cmV0dXJuIG51bGw7fWZ1bmN0aW9uIHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsZXJyb3JSZXRyeUxhbmVzKXsvLyBJZiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgaHlkcmF0aW9uLCBkaXNjYXJkIHNlcnZlciByZXNwb25zZSBhbmQgZmFsbFxuLy8gYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG4vLyBCZWZvcmUgcmVuZGVyaW5nIGFnYWluLCBzYXZlIHRoZSBlcnJvcnMgZnJvbSB0aGUgcHJldmlvdXMgYXR0ZW1wdC5cbnZhciBlcnJvcnNGcm9tRmlyc3RBdHRlbXB0PXdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7aWYoaXNSb290RGVoeWRyYXRlZChyb290KSl7Ly8gVGhlIHNoZWxsIGZhaWxlZCB0byBoeWRyYXRlLiBTZXQgYSBmbGFnIHRvIGZvcmNlIGEgY2xpZW50IHJlbmRlcmluZ1xuLy8gZHVyaW5nIHRoZSBuZXh0IGF0dGVtcHQuIFRvIGRvIHRoaXMsIHdlIGNhbGwgcHJlcGFyZUZyZXNoU3RhY2sgbm93XG4vLyB0byBjcmVhdGUgdGhlIHJvb3Qgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhpcyBpcyBhIGJpdCB3ZWlyZCBpbiB0ZXJtc1xuLy8gb2YgZmFjdG9yaW5nLCBiZWNhdXNlIGl0IHJlbGllcyBvbiByZW5kZXJSb290U3luYyBub3QgY2FsbGluZ1xuLy8gcHJlcGFyZUZyZXNoU3RhY2sgYWdhaW4gaW4gdGhlIGNhbGwgYmVsb3csIHdoaWNoIGhhcHBlbnMgYmVjYXVzZSB0aGVcbi8vIHJvb3QgYW5kIGxhbmVzIGhhdmVuJ3QgY2hhbmdlZC5cbi8vXG4vLyBUT0RPOiBJIHRoaW5rIHdoYXQgd2Ugc2hvdWxkIGRvIGlzIHNldCBGb3JjZUNsaWVudFJlbmRlciBpbnNpZGVcbi8vIHRocm93RXhjZXB0aW9uLCBsaWtlIHdlIGRvIGZvciBuZXN0ZWQgU3VzcGVuc2UgYm91bmRhcmllcy4gVGhlIHJlYXNvblxuLy8gaXQncyBoZXJlIGluc3RlYWQgaXMgc28gd2UgY2FuIHN3aXRjaCB0byB0aGUgc3luY2hyb25vdXMgd29yayBsb29wLCB0b28uXG4vLyBTb21ldGhpbmcgdG8gY29uc2lkZXIgZm9yIGEgZnV0dXJlIHJlZmFjdG9yLlxudmFyIHJvb3RXb3JrSW5Qcm9ncmVzcz1wcmVwYXJlRnJlc2hTdGFjayhyb290LGVycm9yUmV0cnlMYW5lcyk7cm9vdFdvcmtJblByb2dyZXNzLmZsYWdzfD1Gb3JjZUNsaWVudFJlbmRlcjt7ZXJyb3JIeWRyYXRpbmdDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTt9fXZhciBleGl0U3RhdHVzPXJlbmRlclJvb3RTeW5jKHJvb3QsZXJyb3JSZXRyeUxhbmVzKTtpZihleGl0U3RhdHVzIT09Um9vdEVycm9yZWQpey8vIFN1Y2Nlc3NmdWxseSBmaW5pc2hlZCByZW5kZXJpbmcgb24gcmV0cnlcbi8vIFRoZSBlcnJvcnMgZnJvbSB0aGUgZmFpbGVkIGZpcnN0IGF0dGVtcHQgaGF2ZSBiZWVuIHJlY292ZXJlZC4gQWRkXG4vLyB0aGVtIHRvIHRoZSBjb2xsZWN0aW9uIG9mIHJlY292ZXJhYmxlIGVycm9ycy4gV2UnbGwgbG9nIHRoZW0gaW4gdGhlXG4vLyBjb21taXQgcGhhc2UuXG52YXIgZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQ9d29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7d29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM9ZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdDsvLyBUaGUgZXJyb3JzIGZyb20gdGhlIHNlY29uZCBhdHRlbXB0IHNob3VsZCBiZSBxdWV1ZWQgYWZ0ZXIgdGhlIGVycm9yc1xuLy8gZnJvbSB0aGUgZmlyc3QgYXR0ZW1wdCwgdG8gcHJlc2VydmUgdGhlIGNhdXNhbCBzZXF1ZW5jZS5cbmlmKGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0IT09bnVsbCl7cXVldWVSZWNvdmVyYWJsZUVycm9ycyhlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCk7fX1yZXR1cm4gZXhpdFN0YXR1czt9ZnVuY3Rpb24gcXVldWVSZWNvdmVyYWJsZUVycm9ycyhlcnJvcnMpe2lmKHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzPT09bnVsbCl7d29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM9ZXJyb3JzO31lbHNle3dvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLnB1c2guYXBwbHkod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsZXJyb3JzKTt9fWZ1bmN0aW9uIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCxleGl0U3RhdHVzLGxhbmVzKXtzd2l0Y2goZXhpdFN0YXR1cyl7Y2FzZSBSb290SW5Qcm9ncmVzczpjYXNlIFJvb3RGYXRhbEVycm9yZWQ6e3Rocm93IG5ldyBFcnJvcignUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO30vLyBGbG93IGtub3dzIGFib3V0IGludmFyaWFudCwgc28gaXQgY29tcGxhaW5zIGlmIEkgYWRkIGEgYnJlYWtcbi8vIHN0YXRlbWVudCwgYnV0IGVzbGludCBkb2Vzbid0IGtub3cgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnNcbi8vIGlmIEkgZG8uIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuY2FzZSBSb290RXJyb3JlZDp7Ly8gV2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gcmV0cnkgdGhpcyB0cmVlLiBJZiB3ZSByZWFjaGVkXG4vLyB0aGlzIHBvaW50LCBpdCBlcnJvcmVkIGFnYWluLiBDb21taXQgaXQuXG5jb21taXRSb290KHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyk7YnJlYWs7fWNhc2UgUm9vdFN1c3BlbmRlZDp7bWFya1Jvb3RTdXNwZW5kZWQkMShyb290LGxhbmVzKTsvLyBXZSBoYXZlIGFuIGFjY2VwdGFibGUgbG9hZGluZyBzdGF0ZS4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHdlXG4vLyBzaG91bGQgaW1tZWRpYXRlbHkgY29tbWl0IGl0IG9yIHdhaXQgYSBiaXQuXG5pZihpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSYmLy8gZG8gbm90IGRlbGF5IGlmIHdlJ3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZVxuIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKXsvLyBUaGlzIHJlbmRlciBvbmx5IGluY2x1ZGVkIHJldHJpZXMsIG5vIHVwZGF0ZXMuIFRocm90dGxlIGNvbW1pdHRpbmdcbi8vIHJldHJpZXMgc28gdGhhdCB3ZSBkb24ndCBzaG93IHRvbyBtYW55IGxvYWRpbmcgc3RhdGVzIHRvbyBxdWlja2x5LlxudmFyIG1zVW50aWxUaW1lb3V0PWdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUrRkFMTEJBQ0tfVEhST1RUTEVfTVMtbm93KCk7Ly8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5pZihtc1VudGlsVGltZW91dD4xMCl7dmFyIG5leHRMYW5lcz1nZXROZXh0TGFuZXMocm9vdCxOb0xhbmVzKTtpZihuZXh0TGFuZXMhPT1Ob0xhbmVzKXsvLyBUaGVyZSdzIGFkZGl0aW9uYWwgd29yayBvbiB0aGlzIHJvb3QuXG5icmVhazt9dmFyIHN1c3BlbmRlZExhbmVzPXJvb3Quc3VzcGVuZGVkTGFuZXM7aWYoIWlzU3Vic2V0T2ZMYW5lcyhzdXNwZW5kZWRMYW5lcyxsYW5lcykpey8vIFdlIHNob3VsZCBwcmVmZXIgdG8gcmVuZGVyIHRoZSBmYWxsYmFjayBvZiBhdCB0aGUgbGFzdFxuLy8gc3VzcGVuZGVkIGxldmVsLiBQaW5nIHRoZSBsYXN0IHN1c3BlbmRlZCBsZXZlbCB0byB0cnlcbi8vIHJlbmRlcmluZyBpdCBhZ2Fpbi5cbi8vIEZJWE1FOiBXaGF0IGlmIHRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIElkbGU/IFNob3VsZCBub3QgcmVzdGFydC5cbnZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO21hcmtSb290UGluZ2VkKHJvb3Qsc3VzcGVuZGVkTGFuZXMpO2JyZWFrO30vLyBUaGUgcmVuZGVyIGlzIHN1c3BlbmRlZCwgaXQgaGFzbid0IHRpbWVkIG91dCwgYW5kIHRoZXJlJ3Mgbm9cbi8vIGxvd2VyIHByaW9yaXR5IHdvcmsgdG8gZG8uIEluc3RlYWQgb2YgY29tbWl0dGluZyB0aGUgZmFsbGJhY2tcbi8vIGltbWVkaWF0ZWx5LCB3YWl0IGZvciBtb3JlIGRhdGEgdG8gYXJyaXZlLlxucm9vdC50aW1lb3V0SGFuZGxlPXNjaGVkdWxlVGltZW91dChjb21taXRSb290LmJpbmQobnVsbCxyb290LHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpLG1zVW50aWxUaW1lb3V0KTticmVhazt9fS8vIFRoZSB3b3JrIGV4cGlyZWQuIENvbW1pdCBpbW1lZGlhdGVseS5cbmNvbW1pdFJvb3Qocm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyx3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTticmVhazt9Y2FzZSBSb290U3VzcGVuZGVkV2l0aERlbGF5OnttYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsbGFuZXMpO2lmKGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSl7Ly8gVGhpcyBpcyBhIHRyYW5zaXRpb24sIHNvIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgY29tbWl0dGluZyBhXG4vLyBwbGFjZWhvbGRlciBhbmQgd2l0aG91dCBzY2hlZHVsaW5nIGEgdGltZW91dC4gRGVsYXkgaW5kZWZpbml0ZWx5XG4vLyB1bnRpbCB3ZSByZWNlaXZlIG1vcmUgZGF0YS5cbmJyZWFrO31pZighc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkpey8vIFRoaXMgaXMgbm90IGEgdHJhbnNpdGlvbiwgYnV0IHdlIGRpZCB0cmlnZ2VyIGFuIGF2b2lkZWQgc3RhdGUuXG4vLyBTY2hlZHVsZSBhIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkgYWZ0ZXIgYSBzaG9ydCBkZWxheSwgdXNpbmcgdGhlIEp1c3Rcbi8vIE5vdGljZWFibGUgRGlmZmVyZW5jZS5cbi8vIFRPRE86IElzIHRoZSBKTkQgb3B0aW1pemF0aW9uIHdvcnRoIHRoZSBhZGRlZCBjb21wbGV4aXR5PyBJZiB0aGlzIGlzXG4vLyB0aGUgb25seSByZWFzb24gd2UgdHJhY2sgdGhlIGV2ZW50IHRpbWUsIHRoZW4gcHJvYmFibHkgbm90LlxuLy8gQ29uc2lkZXIgcmVtb3ZpbmcuXG52YXIgbW9zdFJlY2VudEV2ZW50VGltZT1nZXRNb3N0UmVjZW50RXZlbnRUaW1lKHJvb3QsbGFuZXMpO3ZhciBldmVudFRpbWVNcz1tb3N0UmVjZW50RXZlbnRUaW1lO3ZhciB0aW1lRWxhcHNlZE1zPW5vdygpLWV2ZW50VGltZU1zO3ZhciBfbXNVbnRpbFRpbWVvdXQ9am5kKHRpbWVFbGFwc2VkTXMpLXRpbWVFbGFwc2VkTXM7Ly8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5pZihfbXNVbnRpbFRpbWVvdXQ+MTApey8vIEluc3RlYWQgb2YgY29tbWl0dGluZyB0aGUgZmFsbGJhY2sgaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YVxuLy8gdG8gYXJyaXZlLlxucm9vdC50aW1lb3V0SGFuZGxlPXNjaGVkdWxlVGltZW91dChjb21taXRSb290LmJpbmQobnVsbCxyb290LHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpLF9tc1VudGlsVGltZW91dCk7YnJlYWs7fX0vLyBDb21taXQgdGhlIHBsYWNlaG9sZGVyLlxuY29tbWl0Um9vdChyb290LHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpO2JyZWFrO31jYXNlIFJvb3RDb21wbGV0ZWQ6ey8vIFRoZSB3b3JrIGNvbXBsZXRlZC4gUmVhZHkgdG8gY29tbWl0LlxuY29tbWl0Um9vdChyb290LHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpO2JyZWFrO31kZWZhdWx0Ont0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcm9vdCBleGl0IHN0YXR1cy4nKTt9fX1mdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKXsvLyBTZWFyY2ggdGhlIHJlbmRlcmVkIHRyZWUgZm9yIGV4dGVybmFsIHN0b3JlIHJlYWRzLCBhbmQgY2hlY2sgd2hldGhlciB0aGVcbi8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQgaW4gYSBjb25jdXJyZW50IGV2ZW50LiBJbnRlbnRpb25hbGx5IHVzaW5nIGFuIGl0ZXJhdGl2ZVxuLy8gbG9vcCBpbnN0ZWFkIG9mIHJlY3Vyc2lvbiBzbyB3ZSBjYW4gZXhpdCBlYXJseS5cbnZhciBub2RlPWZpbmlzaGVkV29yazt3aGlsZSh0cnVlKXtpZihub2RlLmZsYWdzJlN0b3JlQ29uc2lzdGVuY3kpe3ZhciB1cGRhdGVRdWV1ZT1ub2RlLnVwZGF0ZVF1ZXVlO2lmKHVwZGF0ZVF1ZXVlIT09bnVsbCl7dmFyIGNoZWNrcz11cGRhdGVRdWV1ZS5zdG9yZXM7aWYoY2hlY2tzIT09bnVsbCl7Zm9yKHZhciBpPTA7aTxjaGVja3MubGVuZ3RoO2krKyl7dmFyIGNoZWNrPWNoZWNrc1tpXTt2YXIgZ2V0U25hcHNob3Q9Y2hlY2suZ2V0U25hcHNob3Q7dmFyIHJlbmRlcmVkVmFsdWU9Y2hlY2sudmFsdWU7dHJ5e2lmKCFvYmplY3RJcyhnZXRTbmFwc2hvdCgpLHJlbmRlcmVkVmFsdWUpKXsvLyBGb3VuZCBhbiBpbmNvbnNpc3RlbnQgc3RvcmUuXG5yZXR1cm4gZmFsc2U7fX1jYXRjaChlcnJvcil7Ly8gSWYgYGdldFNuYXBzaG90YCB0aHJvd3MsIHJldHVybiBgZmFsc2VgLiBUaGlzIHdpbGwgc2NoZWR1bGVcbi8vIGEgcmUtcmVuZGVyLCBhbmQgdGhlIGVycm9yIHdpbGwgYmUgcmV0aHJvd24gZHVyaW5nIHJlbmRlci5cbnJldHVybiBmYWxzZTt9fX19fXZhciBjaGlsZD1ub2RlLmNoaWxkO2lmKG5vZGUuc3VidHJlZUZsYWdzJlN0b3JlQ29uc2lzdGVuY3kmJmNoaWxkIT09bnVsbCl7Y2hpbGQucmV0dXJuPW5vZGU7bm9kZT1jaGlsZDtjb250aW51ZTt9aWYobm9kZT09PWZpbmlzaGVkV29yayl7cmV0dXJuIHRydWU7fXdoaWxlKG5vZGUuc2libGluZz09PW51bGwpe2lmKG5vZGUucmV0dXJuPT09bnVsbHx8bm9kZS5yZXR1cm49PT1maW5pc2hlZFdvcmspe3JldHVybiB0cnVlO31ub2RlPW5vZGUucmV0dXJuO31ub2RlLnNpYmxpbmcucmV0dXJuPW5vZGUucmV0dXJuO25vZGU9bm9kZS5zaWJsaW5nO30vLyBGbG93IGRvZXNuJ3Qga25vdyB0aGlzIGlzIHVucmVhY2hhYmxlLCBidXQgZXNsaW50IGRvZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxucmV0dXJuIHRydWU7fWZ1bmN0aW9uIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCxzdXNwZW5kZWRMYW5lcyl7Ly8gV2hlbiBzdXNwZW5kaW5nLCB3ZSBzaG91bGQgYWx3YXlzIGV4Y2x1ZGUgbGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCBvciAobW9yZVxuLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4vLyBUT0RPOiBMb2wgbWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gZmFjdG9yIHRoaXMgYmVzaWRlcyB0aGlzXG4vLyBvYm5veGlvdXNseSBuYW1lZCBmdW5jdGlvbiA6KVxuc3VzcGVuZGVkTGFuZXM9cmVtb3ZlTGFuZXMoc3VzcGVuZGVkTGFuZXMsd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO3N1c3BlbmRlZExhbmVzPXJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKTttYXJrUm9vdFN1c3BlbmRlZChyb290LHN1c3BlbmRlZExhbmVzKTt9Ly8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgZ29cbi8vIHRocm91Z2ggU2NoZWR1bGVyXG5mdW5jdGlvbiBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCl7e3N5bmNOZXN0ZWRVcGRhdGVGbGFnKCk7fWlmKChleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKSE9PU5vQ29udGV4dCl7dGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTt9Zmx1c2hQYXNzaXZlRWZmZWN0cygpO3ZhciBsYW5lcz1nZXROZXh0TGFuZXMocm9vdCxOb0xhbmVzKTtpZighaW5jbHVkZXNTb21lTGFuZShsYW5lcyxTeW5jTGFuZSkpey8vIFRoZXJlJ3Mgbm8gcmVtYWluaW5nIHN5bmMgd29yayBsZWZ0LlxuZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3Qsbm93KCkpO3JldHVybiBudWxsO312YXIgZXhpdFN0YXR1cz1yZW5kZXJSb290U3luYyhyb290LGxhbmVzKTtpZihyb290LnRhZyE9PUxlZ2FjeVJvb3QmJmV4aXRTdGF0dXM9PT1Sb290RXJyb3JlZCl7Ly8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbi8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG4vLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxudmFyIGVycm9yUmV0cnlMYW5lcz1nZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtpZihlcnJvclJldHJ5TGFuZXMhPT1Ob0xhbmVzKXtsYW5lcz1lcnJvclJldHJ5TGFuZXM7ZXhpdFN0YXR1cz1yZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LGVycm9yUmV0cnlMYW5lcyk7fX1pZihleGl0U3RhdHVzPT09Um9vdEZhdGFsRXJyb3JlZCl7dmFyIGZhdGFsRXJyb3I9d29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcjtwcmVwYXJlRnJlc2hTdGFjayhyb290LE5vTGFuZXMpO21hcmtSb290U3VzcGVuZGVkJDEocm9vdCxsYW5lcyk7ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3Qsbm93KCkpO3Rocm93IGZhdGFsRXJyb3I7fWlmKGV4aXRTdGF0dXM9PT1Sb290RGlkTm90Q29tcGxldGUpe3Rocm93IG5ldyBFcnJvcignUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO30vLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gQmVjYXVzZSB0aGlzIGlzIGEgc3luYyByZW5kZXIsIHdlXG4vLyB3aWxsIGNvbW1pdCBpdCBldmVuIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQuXG52YXIgZmluaXNoZWRXb3JrPXJvb3QuY3VycmVudC5hbHRlcm5hdGU7cm9vdC5maW5pc2hlZFdvcms9ZmluaXNoZWRXb3JrO3Jvb3QuZmluaXNoZWRMYW5lcz1sYW5lcztjb21taXRSb290KHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyk7Ly8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuLy8gcGVuZGluZyBsZXZlbC5cbmVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LG5vdygpKTtyZXR1cm4gbnVsbDt9ZnVuY3Rpb24gZmx1c2hSb290KHJvb3QsbGFuZXMpe2lmKGxhbmVzIT09Tm9MYW5lcyl7bWFya1Jvb3RFbnRhbmdsZWQocm9vdCxtZXJnZUxhbmVzKGxhbmVzLFN5bmNMYW5lKSk7ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3Qsbm93KCkpO2lmKChleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKT09PU5vQ29udGV4dCl7cmVzZXRSZW5kZXJUaW1lcigpO2ZsdXNoU3luY0NhbGxiYWNrcygpO319fWZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzJDEoZm4sYSl7dmFyIHByZXZFeGVjdXRpb25Db250ZXh0PWV4ZWN1dGlvbkNvbnRleHQ7ZXhlY3V0aW9uQ29udGV4dHw9QmF0Y2hlZENvbnRleHQ7dHJ5e3JldHVybiBmbihhKTt9ZmluYWxseXtleGVjdXRpb25Db250ZXh0PXByZXZFeGVjdXRpb25Db250ZXh0Oy8vIElmIHRoZXJlIHdlcmUgbGVnYWN5IHN5bmMgdXBkYXRlcywgZmx1c2ggdGhlbSBhdCB0aGUgZW5kIG9mIHRoZSBvdXRlclxuLy8gbW9zdCBiYXRjaGVkVXBkYXRlcy1saWtlIG1ldGhvZC5cbmlmKGV4ZWN1dGlvbkNvbnRleHQ9PT1Ob0NvbnRleHQmJi8vIFRyZWF0IGBhY3RgIGFzIGlmIGl0J3MgaW5zaWRlIGBiYXRjaGVkVXBkYXRlc2AsIGV2ZW4gaW4gbGVnYWN5IG1vZGUuXG4hUmVhY3RDdXJyZW50QWN0UXVldWUkMS5pc0JhdGNoaW5nTGVnYWN5KXtyZXNldFJlbmRlclRpbWVyKCk7Zmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpO319fWZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyhmbixhLGIsYyxkKXt2YXIgcHJldmlvdXNQcmlvcml0eT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTt2YXIgcHJldlRyYW5zaXRpb249UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO3RyeXtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249bnVsbDtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtyZXR1cm4gZm4oYSxiLGMsZCk7fWZpbmFsbHl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1wcmV2VHJhbnNpdGlvbjtpZihleGVjdXRpb25Db250ZXh0PT09Tm9Db250ZXh0KXtyZXNldFJlbmRlclRpbWVyKCk7fX19Ly8gT3ZlcmxvYWQgdGhlIGRlZmluaXRpb24gdG8gdGhlIHR3byB2YWxpZCBzaWduYXR1cmVzLlxuLy8gV2FybmluZywgdGhpcyBvcHRzLW91dCBvZiBjaGVja2luZyB0aGUgZnVuY3Rpb24gYm9keS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGZsdXNoU3luYyhmbil7Ly8gSW4gbGVnYWN5IG1vZGUsIHdlIGZsdXNoIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4vLyBuZXh0IGV2ZW50LCBub3QgYXQgdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgb25lLlxuaWYocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMhPT1udWxsJiZyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cy50YWc9PT1MZWdhY3lSb290JiYoZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSk9PT1Ob0NvbnRleHQpe2ZsdXNoUGFzc2l2ZUVmZmVjdHMoKTt9dmFyIHByZXZFeGVjdXRpb25Db250ZXh0PWV4ZWN1dGlvbkNvbnRleHQ7ZXhlY3V0aW9uQ29udGV4dHw9QmF0Y2hlZENvbnRleHQ7dmFyIHByZXZUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjt2YXIgcHJldmlvdXNQcmlvcml0eT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTt0cnl7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPW51bGw7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7aWYoZm4pe3JldHVybiBmbigpO31lbHNle3JldHVybiB1bmRlZmluZWQ7fX1maW5hbGx5e3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247ZXhlY3V0aW9uQ29udGV4dD1wcmV2RXhlY3V0aW9uQ29udGV4dDsvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBoYXBwZW4gZXZlbiBpZiBiYXRjaGVkVXBkYXRlcyBpcyBoaWdoZXIgdXBcbi8vIHRoZSBzdGFjay5cbmlmKChleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKT09PU5vQ29udGV4dCl7Zmx1c2hTeW5jQ2FsbGJhY2tzKCk7fX19ZnVuY3Rpb24gaXNBbHJlYWR5UmVuZGVyaW5nKCl7Ly8gVXNlZCBieSB0aGUgcmVuZGVyZXIgdG8gcHJpbnQgYSB3YXJuaW5nIGlmIGNlcnRhaW4gQVBJcyBhcmUgY2FsbGVkIGZyb21cbi8vIHRoZSB3cm9uZyBjb250ZXh0LlxucmV0dXJuKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpIT09Tm9Db250ZXh0O31mdW5jdGlvbiBwdXNoUmVuZGVyTGFuZXMoZmliZXIsbGFuZXMpe3B1c2goc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLHN1YnRyZWVSZW5kZXJMYW5lcyxmaWJlcik7c3VidHJlZVJlbmRlckxhbmVzPW1lcmdlTGFuZXMoc3VidHJlZVJlbmRlckxhbmVzLGxhbmVzKTt3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzPW1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyxsYW5lcyk7fWZ1bmN0aW9uIHBvcFJlbmRlckxhbmVzKGZpYmVyKXtzdWJ0cmVlUmVuZGVyTGFuZXM9c3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7cG9wKHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvcixmaWJlcik7fWZ1bmN0aW9uIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsbGFuZXMpe3Jvb3QuZmluaXNoZWRXb3JrPW51bGw7cm9vdC5maW5pc2hlZExhbmVzPU5vTGFuZXM7dmFyIHRpbWVvdXRIYW5kbGU9cm9vdC50aW1lb3V0SGFuZGxlO2lmKHRpbWVvdXRIYW5kbGUhPT1ub1RpbWVvdXQpey8vIFRoZSByb290IHByZXZpb3VzIHN1c3BlbmRlZCBhbmQgc2NoZWR1bGVkIGEgdGltZW91dCB0byBjb21taXQgYSBmYWxsYmFja1xuLy8gc3RhdGUuIE5vdyB0aGF0IHdlIGhhdmUgYWRkaXRpb25hbCB3b3JrLCBjYW5jZWwgdGhlIHRpbWVvdXQuXG5yb290LnRpbWVvdXRIYW5kbGU9bm9UaW1lb3V0Oy8vICRGbG93Rml4TWUgQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG5jYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO31pZih3b3JrSW5Qcm9ncmVzcyE9PW51bGwpe3ZhciBpbnRlcnJ1cHRlZFdvcms9d29ya0luUHJvZ3Jlc3MucmV0dXJuO3doaWxlKGludGVycnVwdGVkV29yayE9PW51bGwpe3ZhciBjdXJyZW50PWludGVycnVwdGVkV29yay5hbHRlcm5hdGU7dW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsaW50ZXJydXB0ZWRXb3JrKTtpbnRlcnJ1cHRlZFdvcms9aW50ZXJydXB0ZWRXb3JrLnJldHVybjt9fXdvcmtJblByb2dyZXNzUm9vdD1yb290O3ZhciByb290V29ya0luUHJvZ3Jlc3M9Y3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LG51bGwpO3dvcmtJblByb2dyZXNzPXJvb3RXb3JrSW5Qcm9ncmVzczt3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcz1zdWJ0cmVlUmVuZGVyTGFuZXM9d29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcz1sYW5lczt3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPVJvb3RJblByb2dyZXNzO3dvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I9bnVsbDt3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXM9Tm9MYW5lczt3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcz1Ob0xhbmVzO3dvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzPU5vTGFuZXM7d29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycz1udWxsO3dvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzPW51bGw7ZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO3tSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7fXJldHVybiByb290V29ya0luUHJvZ3Jlc3M7fWZ1bmN0aW9uIGhhbmRsZUVycm9yKHJvb3QsdGhyb3duVmFsdWUpe2Rve3ZhciBlcnJvcmVkV29yaz13b3JrSW5Qcm9ncmVzczt0cnl7Ly8gUmVzZXQgbW9kdWxlLWxldmVsIHN0YXRlIHRoYXQgd2FzIHNldCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbnJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO3Jlc2V0SG9va3NBZnRlclRocm93KCk7cmVzZXRDdXJyZW50RmliZXIoKTsvLyBUT0RPOiBJIGZvdW5kIGFuZCBhZGRlZCB0aGlzIG1pc3NpbmcgbGluZSB3aGlsZSBpbnZlc3RpZ2F0aW5nIGFcbi8vIHNlcGFyYXRlIGlzc3VlLiBXcml0ZSBhIHJlZ3Jlc3Npb24gdGVzdCB1c2luZyBzdHJpbmcgcmVmcy5cblJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudD1udWxsO2lmKGVycm9yZWRXb3JrPT09bnVsbHx8ZXJyb3JlZFdvcmsucmV0dXJuPT09bnVsbCl7Ly8gRXhwZWN0ZWQgdG8gYmUgd29ya2luZyBvbiBhIG5vbi1yb290IGZpYmVyLiBUaGlzIGlzIGEgZmF0YWwgZXJyb3Jcbi8vIGJlY2F1c2UgdGhlcmUncyBubyBhbmNlc3RvciB0aGF0IGNhbiBoYW5kbGUgaXQ7IHRoZSByb290IGlzXG4vLyBzdXBwb3NlZCB0byBjYXB0dXJlIGFsbCBlcnJvcnMgdGhhdCB3ZXJlbid0IGNhdWdodCBieSBhbiBlcnJvclxuLy8gYm91bmRhcnkuXG53b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPVJvb3RGYXRhbEVycm9yZWQ7d29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcj10aHJvd25WYWx1ZTsvLyBTZXQgYHdvcmtJblByb2dyZXNzYCB0byBudWxsLiBUaGlzIHJlcHJlc2VudHMgYWR2YW5jaW5nIHRvIHRoZSBuZXh0XG4vLyBzaWJsaW5nLCBvciB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyBzaWJsaW5ncy4gQnV0IHNpbmNlIHRoZSByb290XG4vLyBoYXMgbm8gc2libGluZ3Mgbm9yIGEgcGFyZW50LCB3ZSBzZXQgaXQgdG8gbnVsbC4gVXN1YWxseSB0aGlzIGlzXG4vLyBoYW5kbGVkIGJ5IGBjb21wbGV0ZVVuaXRPZldvcmtgIG9yIGB1bndpbmRXb3JrYCwgYnV0IHNpbmNlIHdlJ3JlXG4vLyBpbnRlbnRpb25hbGx5IG5vdCBjYWxsaW5nIHRob3NlLCB3ZSBuZWVkIHNldCBpdCBoZXJlLlxuLy8gVE9ETzogQ29uc2lkZXIgY2FsbGluZyBgdW53aW5kV29ya2AgdG8gcG9wIHRoZSBjb250ZXh0cy5cbndvcmtJblByb2dyZXNzPW51bGw7cmV0dXJuO31pZihlbmFibGVQcm9maWxlclRpbWVyJiZlcnJvcmVkV29yay5tb2RlJlByb2ZpbGVNb2RlKXsvLyBSZWNvcmQgdGhlIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGJlZm9yZSBhbiBlcnJvciB3YXMgdGhyb3duLiBUaGlzXG4vLyBhdm9pZHMgaW5hY2N1cmF0ZSBQcm9maWxlciBkdXJhdGlvbnMgaW4gdGhlIGNhc2Ugb2YgYVxuLy8gc3VzcGVuZGVkIHJlbmRlci5cbnN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZXJyb3JlZFdvcmssdHJ1ZSk7fWlmKGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcil7bWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtpZih0aHJvd25WYWx1ZSE9PW51bGwmJnR5cGVvZiB0aHJvd25WYWx1ZT09PSdvYmplY3QnJiZ0eXBlb2YgdGhyb3duVmFsdWUudGhlbj09PSdmdW5jdGlvbicpe3ZhciB3YWtlYWJsZT10aHJvd25WYWx1ZTttYXJrQ29tcG9uZW50U3VzcGVuZGVkKGVycm9yZWRXb3JrLHdha2VhYmxlLHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTt9ZWxzZXttYXJrQ29tcG9uZW50RXJyb3JlZChlcnJvcmVkV29yayx0aHJvd25WYWx1ZSx3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7fX10aHJvd0V4Y2VwdGlvbihyb290LGVycm9yZWRXb3JrLnJldHVybixlcnJvcmVkV29yayx0aHJvd25WYWx1ZSx3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7Y29tcGxldGVVbml0T2ZXb3JrKGVycm9yZWRXb3JrKTt9Y2F0Y2goeWV0QW5vdGhlclRocm93blZhbHVlKXsvLyBTb21ldGhpbmcgaW4gdGhlIHJldHVybiBwYXRoIGFsc28gdGhyZXcuXG50aHJvd25WYWx1ZT15ZXRBbm90aGVyVGhyb3duVmFsdWU7aWYod29ya0luUHJvZ3Jlc3M9PT1lcnJvcmVkV29yayYmZXJyb3JlZFdvcmshPT1udWxsKXsvLyBJZiB0aGlzIGJvdW5kYXJ5IGhhcyBhbHJlYWR5IGVycm9yZWQsIHRoZW4gd2UgaGFkIHRyb3VibGUgcHJvY2Vzc2luZ1xuLy8gdGhlIGVycm9yLiBCdWJibGUgaXQgdG8gdGhlIG5leHQgYm91bmRhcnkuXG5lcnJvcmVkV29yaz1lcnJvcmVkV29yay5yZXR1cm47d29ya0luUHJvZ3Jlc3M9ZXJyb3JlZFdvcms7fWVsc2V7ZXJyb3JlZFdvcms9d29ya0luUHJvZ3Jlc3M7fWNvbnRpbnVlO30vLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5yZXR1cm47fXdoaWxlKHRydWUpO31mdW5jdGlvbiBwdXNoRGlzcGF0Y2hlcigpe3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudD1Db250ZXh0T25seURpc3BhdGNoZXI7aWYocHJldkRpc3BhdGNoZXI9PT1udWxsKXsvLyBUaGUgUmVhY3QgaXNvbW9ycGhpYyBwYWNrYWdlIGRvZXMgbm90IGluY2x1ZGUgYSBkZWZhdWx0IGRpc3BhdGNoZXIuXG4vLyBJbnN0ZWFkIHRoZSBmaXJzdCByZW5kZXJlciB3aWxsIGxhemlseSBhdHRhY2ggb25lLCBpbiBvcmRlciB0byBnaXZlXG4vLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbnJldHVybiBDb250ZXh0T25seURpc3BhdGNoZXI7fWVsc2V7cmV0dXJuIHByZXZEaXNwYXRjaGVyO319ZnVuY3Rpb24gcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcil7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fWZ1bmN0aW9uIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpe2dsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWU9bm93KCk7fWZ1bmN0aW9uIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobGFuZSl7d29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzPW1lcmdlTGFuZXMobGFuZSx3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpO31mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kKCl7aWYod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz09PVJvb3RJblByb2dyZXNzKXt3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPVJvb3RTdXNwZW5kZWQ7fX1mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCl7aWYod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz09PVJvb3RJblByb2dyZXNzfHx3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPT09Um9vdFN1c3BlbmRlZHx8d29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz09PVJvb3RFcnJvcmVkKXt3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPVJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7fS8vIENoZWNrIGlmIHRoZXJlIGFyZSB1cGRhdGVzIHRoYXQgd2Ugc2tpcHBlZCB0cmVlIHRoYXQgbWlnaHQgaGF2ZSB1bmJsb2NrZWRcbi8vIHRoaXMgcmVuZGVyLlxuaWYod29ya0luUHJvZ3Jlc3NSb290IT09bnVsbCYmKGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKXx8aW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcykpKXsvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgc28gdGhhdCB3ZSBzd2l0Y2ggdG8gd29ya2luZyBvblxuLy8gdGhlIHVwZGF0ZXMgdGhhdCB3ZXJlIHNraXBwZWQuIFVzdWFsbHkgd2Ugb25seSBzdXNwZW5kIGF0IHRoZSBlbmQgb2Zcbi8vIHRoZSByZW5kZXIgcGhhc2UuXG4vLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgYWx3YXlzIG1hcmsgdGhlIHJvb3QgYXMgc3VzcGVuZGVkIGltbWVkaWF0ZWx5XG4vLyAoaW5zaWRlIHRoaXMgZnVuY3Rpb24pLCBzaW5jZSBieSBzdXNwZW5kaW5nIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlclxuLy8gcGhhc2UgaW50cm9kdWNlcyBhIHBvdGVudGlhbCBtaXN0YWtlIHdoZXJlIHdlIHN1c3BlbmQgbGFuZXMgdGhhdCB3ZXJlXG4vLyBwaW5nZWQgb3IgdXBkYXRlZCB3aGlsZSB3ZSB3ZXJlIHJlbmRlcmluZy5cbm1hcmtSb290U3VzcGVuZGVkJDEod29ya0luUHJvZ3Jlc3NSb290LHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTt9fWZ1bmN0aW9uIHJlbmRlckRpZEVycm9yKGVycm9yKXtpZih3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzIT09Um9vdFN1c3BlbmRlZFdpdGhEZWxheSl7d29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz1Sb290RXJyb3JlZDt9aWYod29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycz09PW51bGwpe3dvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM9W2Vycm9yXTt9ZWxzZXt3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzLnB1c2goZXJyb3IpO319Ly8gQ2FsbGVkIGR1cmluZyByZW5kZXIgdG8gZGV0ZXJtaW5lIGlmIGFueXRoaW5nIGhhcyBzdXNwZW5kZWQuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHdlJ3JlIG5vdCBzdXJlLlxuZnVuY3Rpb24gcmVuZGVySGFzTm90U3VzcGVuZGVkWWV0KCl7Ly8gSWYgc29tZXRoaW5nIGVycm9yZWQgb3IgY29tcGxldGVkLCB3ZSBjYW4ndCByZWFsbHkgYmUgc3VyZSxcbi8vIHNvIHRob3NlIGFyZSBmYWxzZS5cbnJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPT09Um9vdEluUHJvZ3Jlc3M7fWZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsbGFuZXMpe3ZhciBwcmV2RXhlY3V0aW9uQ29udGV4dD1leGVjdXRpb25Db250ZXh0O2V4ZWN1dGlvbkNvbnRleHR8PVJlbmRlckNvbnRleHQ7dmFyIHByZXZEaXNwYXRjaGVyPXB1c2hEaXNwYXRjaGVyKCk7Ly8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4vLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuaWYod29ya0luUHJvZ3Jlc3NSb290IT09cm9vdHx8d29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMhPT1sYW5lcyl7e2lmKGlzRGV2VG9vbHNQcmVzZW50KXt2YXIgbWVtb2l6ZWRVcGRhdGVycz1yb290Lm1lbW9pemVkVXBkYXRlcnM7aWYobWVtb2l6ZWRVcGRhdGVycy5zaXplPjApe3Jlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7bWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO30vLyBBdCB0aGlzIHBvaW50LCBtb3ZlIEZpYmVycyB0aGF0IHNjaGVkdWxlZCB0aGUgdXBjb21pbmcgd29yayBmcm9tIHRoZSBNYXAgdG8gdGhlIFNldC5cbi8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4vLyBJdCdzIGltcG9ydGFudCB0byBtb3ZlIHRoZW0gbm93IGluIGNhc2UgdGhlIHdvcmsgc3Bhd25zIG1vcmUgd29yayBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoIGRpZmZlcmVudCB1cGRhdGVycy5cbi8vIFRoYXQgd2F5IHdlIGNhbiBrZWVwIHRoZSBjdXJyZW50IHVwZGF0ZSBhbmQgZnV0dXJlIHVwZGF0ZXMgc2VwYXJhdGUuXG5tb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCxsYW5lcyk7fX13b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zPWdldFRyYW5zaXRpb25zRm9yTGFuZXMoKTtwcmVwYXJlRnJlc2hTdGFjayhyb290LGxhbmVzKTt9e21hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTt9ZG97dHJ5e3dvcmtMb29wU3luYygpO2JyZWFrO31jYXRjaCh0aHJvd25WYWx1ZSl7aGFuZGxlRXJyb3Iocm9vdCx0aHJvd25WYWx1ZSk7fX13aGlsZSh0cnVlKTtyZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtleGVjdXRpb25Db250ZXh0PXByZXZFeGVjdXRpb25Db250ZXh0O3BvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO2lmKHdvcmtJblByb2dyZXNzIT09bnVsbCl7Ly8gVGhpcyBpcyBhIHN5bmMgcmVuZGVyLCBzbyB3ZSBzaG91bGQgaGF2ZSBmaW5pc2hlZCB0aGUgd2hvbGUgdHJlZS5cbnRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCBhbiBpbmNvbXBsZXRlIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhICcrJ2J1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXttYXJrUmVuZGVyU3RvcHBlZCgpO30vLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxud29ya0luUHJvZ3Jlc3NSb290PW51bGw7d29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM9Tm9MYW5lcztyZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1czt9Ly8gVGhlIHdvcmsgbG9vcCBpcyBhbiBleHRyZW1lbHkgaG90IHBhdGguIFRlbGwgQ2xvc3VyZSBub3QgdG8gaW5saW5lIGl0LlxuLyoqIEBub2lubGluZSAqL2Z1bmN0aW9uIHdvcmtMb29wU3luYygpey8vIEFscmVhZHkgdGltZWQgb3V0LCBzbyBwZXJmb3JtIHdvcmsgd2l0aG91dCBjaGVja2luZyBpZiB3ZSBuZWVkIHRvIHlpZWxkLlxud2hpbGUod29ya0luUHJvZ3Jlc3MhPT1udWxsKXtwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7fX1mdW5jdGlvbiByZW5kZXJSb290Q29uY3VycmVudChyb290LGxhbmVzKXt2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQ9ZXhlY3V0aW9uQ29udGV4dDtleGVjdXRpb25Db250ZXh0fD1SZW5kZXJDb250ZXh0O3ZhciBwcmV2RGlzcGF0Y2hlcj1wdXNoRGlzcGF0Y2hlcigpOy8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuLy8gYW5kIHByZXBhcmUgYSBmcmVzaCBvbmUuIE90aGVyd2lzZSB3ZSdsbCBjb250aW51ZSB3aGVyZSB3ZSBsZWZ0IG9mZi5cbmlmKHdvcmtJblByb2dyZXNzUm9vdCE9PXJvb3R8fHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIT09bGFuZXMpe3tpZihpc0RldlRvb2xzUHJlc2VudCl7dmFyIG1lbW9pemVkVXBkYXRlcnM9cm9vdC5tZW1vaXplZFVwZGF0ZXJzO2lmKG1lbW9pemVkVXBkYXRlcnMuc2l6ZT4wKXtyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO21lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTt9Ly8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4vLyBJZiB3ZSBiYWlsb3V0IG9uIHRoaXMgd29yaywgd2UnbGwgbW92ZSB0aGVtIGJhY2sgKGxpa2UgYWJvdmUpLlxuLy8gSXQncyBpbXBvcnRhbnQgdG8gbW92ZSB0aGVtIG5vdyBpbiBjYXNlIHRoZSB3b3JrIHNwYXducyBtb3JlIHdvcmsgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aCBkaWZmZXJlbnQgdXBkYXRlcnMuXG4vLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxubW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsbGFuZXMpO319d29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucz1nZXRUcmFuc2l0aW9uc0ZvckxhbmVzKCk7cmVzZXRSZW5kZXJUaW1lcigpO3ByZXBhcmVGcmVzaFN0YWNrKHJvb3QsbGFuZXMpO317bWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO31kb3t0cnl7d29ya0xvb3BDb25jdXJyZW50KCk7YnJlYWs7fWNhdGNoKHRocm93blZhbHVlKXtoYW5kbGVFcnJvcihyb290LHRocm93blZhbHVlKTt9fXdoaWxlKHRydWUpO3Jlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO3BvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO2V4ZWN1dGlvbkNvbnRleHQ9cHJldkV4ZWN1dGlvbkNvbnRleHQ7aWYod29ya0luUHJvZ3Jlc3MhPT1udWxsKXsvLyBTdGlsbCB3b3JrIHJlbWFpbmluZy5cbnttYXJrUmVuZGVyWWllbGRlZCgpO31yZXR1cm4gUm9vdEluUHJvZ3Jlc3M7fWVsc2V7Ly8gQ29tcGxldGVkIHRoZSB0cmVlLlxue21hcmtSZW5kZXJTdG9wcGVkKCk7fS8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhlcmUncyBubyBpbi1wcm9ncmVzcyByZW5kZXIuXG53b3JrSW5Qcm9ncmVzc1Jvb3Q9bnVsbDt3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcz1Ob0xhbmVzOy8vIFJldHVybiB0aGUgZmluYWwgZXhpdCBzdGF0dXMuXG5yZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1czt9fS8qKiBAbm9pbmxpbmUgKi9mdW5jdGlvbiB3b3JrTG9vcENvbmN1cnJlbnQoKXsvLyBQZXJmb3JtIHdvcmsgdW50aWwgU2NoZWR1bGVyIGFza3MgdXMgdG8geWllbGRcbndoaWxlKHdvcmtJblByb2dyZXNzIT09bnVsbCYmIXNob3VsZFlpZWxkKCkpe3BlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTt9fWZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspey8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbi8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4vLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG52YXIgY3VycmVudD11bml0T2ZXb3JrLmFsdGVybmF0ZTtzZXRDdXJyZW50RmliZXIodW5pdE9mV29yayk7dmFyIG5leHQ7aWYoKHVuaXRPZldvcmsubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpe3N0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTtuZXh0PWJlZ2luV29yayQxKGN1cnJlbnQsdW5pdE9mV29yayxzdWJ0cmVlUmVuZGVyTGFuZXMpO3N0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEodW5pdE9mV29yayx0cnVlKTt9ZWxzZXtuZXh0PWJlZ2luV29yayQxKGN1cnJlbnQsdW5pdE9mV29yayxzdWJ0cmVlUmVuZGVyTGFuZXMpO31yZXNldEN1cnJlbnRGaWJlcigpO3VuaXRPZldvcmsubWVtb2l6ZWRQcm9wcz11bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztpZihuZXh0PT09bnVsbCl7Ly8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspO31lbHNle3dvcmtJblByb2dyZXNzPW5leHQ7fVJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudD1udWxsO31mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayl7Ly8gQXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCB1bml0IG9mIHdvcmssIHRoZW4gbW92ZSB0byB0aGUgbmV4dFxuLy8gc2libGluZy4gSWYgdGhlcmUgYXJlIG5vIG1vcmUgc2libGluZ3MsIHJldHVybiB0byB0aGUgcGFyZW50IGZpYmVyLlxudmFyIGNvbXBsZXRlZFdvcms9dW5pdE9mV29yaztkb3svLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4vLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxudmFyIGN1cnJlbnQ9Y29tcGxldGVkV29yay5hbHRlcm5hdGU7dmFyIHJldHVybkZpYmVyPWNvbXBsZXRlZFdvcmsucmV0dXJuOy8vIENoZWNrIGlmIHRoZSB3b3JrIGNvbXBsZXRlZCBvciBpZiBzb21ldGhpbmcgdGhyZXcuXG5pZigoY29tcGxldGVkV29yay5mbGFncyZJbmNvbXBsZXRlKT09PU5vRmxhZ3Mpe3NldEN1cnJlbnRGaWJlcihjb21wbGV0ZWRXb3JrKTt2YXIgbmV4dD12b2lkIDA7aWYoKGNvbXBsZXRlZFdvcmsubW9kZSZQcm9maWxlTW9kZSk9PT1Ob01vZGUpe25leHQ9Y29tcGxldGVXb3JrKGN1cnJlbnQsY29tcGxldGVkV29yayxzdWJ0cmVlUmVuZGVyTGFuZXMpO31lbHNle3N0YXJ0UHJvZmlsZXJUaW1lcihjb21wbGV0ZWRXb3JrKTtuZXh0PWNvbXBsZXRlV29yayhjdXJyZW50LGNvbXBsZXRlZFdvcmssc3VidHJlZVJlbmRlckxhbmVzKTsvLyBVcGRhdGUgcmVuZGVyIGR1cmF0aW9uIGFzc3VtaW5nIHdlIGRpZG4ndCBlcnJvci5cbnN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yayxmYWxzZSk7fXJlc2V0Q3VycmVudEZpYmVyKCk7aWYobmV4dCE9PW51bGwpey8vIENvbXBsZXRpbmcgdGhpcyBmaWJlciBzcGF3bmVkIG5ldyB3b3JrLiBXb3JrIG9uIHRoYXQgbmV4dC5cbndvcmtJblByb2dyZXNzPW5leHQ7cmV0dXJuO319ZWxzZXsvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4vLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbi8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxudmFyIF9uZXh0PXVud2luZFdvcmsoY3VycmVudCxjb21wbGV0ZWRXb3JrKTsvLyBCZWNhdXNlIHRoaXMgZmliZXIgZGlkIG5vdCBjb21wbGV0ZSwgZG9uJ3QgcmVzZXQgaXRzIGxhbmVzLlxuaWYoX25leHQhPT1udWxsKXsvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbi8vIGJhY2sgaGVyZSBhZ2Fpbi5cbi8vIFNpbmNlIHdlJ3JlIHJlc3RhcnRpbmcsIHJlbW92ZSBhbnl0aGluZyB0aGF0IGlzIG5vdCBhIGhvc3QgZWZmZWN0XG4vLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuX25leHQuZmxhZ3MmPUhvc3RFZmZlY3RNYXNrO3dvcmtJblByb2dyZXNzPV9uZXh0O3JldHVybjt9aWYoKGNvbXBsZXRlZFdvcmsubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpey8vIFJlY29yZCB0aGUgcmVuZGVyIGR1cmF0aW9uIGZvciB0aGUgZmliZXIgdGhhdCBlcnJvcmVkLlxuc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShjb21wbGV0ZWRXb3JrLGZhbHNlKTsvLyBJbmNsdWRlIHRoZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gZmFpbGVkIGNoaWxkcmVuIGJlZm9yZSBjb250aW51aW5nLlxudmFyIGFjdHVhbER1cmF0aW9uPWNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247dmFyIGNoaWxkPWNvbXBsZXRlZFdvcmsuY2hpbGQ7d2hpbGUoY2hpbGQhPT1udWxsKXthY3R1YWxEdXJhdGlvbis9Y2hpbGQuYWN0dWFsRHVyYXRpb247Y2hpbGQ9Y2hpbGQuc2libGluZzt9Y29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbj1hY3R1YWxEdXJhdGlvbjt9aWYocmV0dXJuRmliZXIhPT1udWxsKXsvLyBNYXJrIHRoZSBwYXJlbnQgZmliZXIgYXMgaW5jb21wbGV0ZSBhbmQgY2xlYXIgaXRzIHN1YnRyZWUgZmxhZ3MuXG5yZXR1cm5GaWJlci5mbGFnc3w9SW5jb21wbGV0ZTtyZXR1cm5GaWJlci5zdWJ0cmVlRmxhZ3M9Tm9GbGFncztyZXR1cm5GaWJlci5kZWxldGlvbnM9bnVsbDt9ZWxzZXsvLyBXZSd2ZSB1bndvdW5kIGFsbCB0aGUgd2F5IHRvIHRoZSByb290Llxud29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz1Sb290RGlkTm90Q29tcGxldGU7d29ya0luUHJvZ3Jlc3M9bnVsbDtyZXR1cm47fX12YXIgc2libGluZ0ZpYmVyPWNvbXBsZXRlZFdvcmsuc2libGluZztpZihzaWJsaW5nRmliZXIhPT1udWxsKXsvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0Llxud29ya0luUHJvZ3Jlc3M9c2libGluZ0ZpYmVyO3JldHVybjt9Ly8gT3RoZXJ3aXNlLCByZXR1cm4gdG8gdGhlIHBhcmVudFxuY29tcGxldGVkV29yaz1yZXR1cm5GaWJlcjsvLyBVcGRhdGUgdGhlIG5leHQgdGhpbmcgd2UncmUgd29ya2luZyBvbiBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MuXG53b3JrSW5Qcm9ncmVzcz1jb21wbGV0ZWRXb3JrO313aGlsZShjb21wbGV0ZWRXb3JrIT09bnVsbCk7Ly8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cbmlmKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9PT1Sb290SW5Qcm9ncmVzcyl7d29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz1Sb290Q29tcGxldGVkO319ZnVuY3Rpb24gY29tbWl0Um9vdChyb290LHJlY292ZXJhYmxlRXJyb3JzLHRyYW5zaXRpb25zKXsvLyBUT0RPOiBUaGlzIG5vIGxvbmdlciBtYWtlcyBhbnkgc2Vuc2UuIFdlIGFscmVhZHkgd3JhcCB0aGUgbXV0YXRpb24gYW5kXG4vLyBsYXlvdXQgcGhhc2VzLiBTaG91bGQgYmUgYWJsZSB0byByZW1vdmUuXG52YXIgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7dmFyIHByZXZUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjt0cnl7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPW51bGw7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7Y29tbWl0Um9vdEltcGwocm9vdCxyZWNvdmVyYWJsZUVycm9ycyx0cmFuc2l0aW9ucyxwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSk7fWZpbmFsbHl7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPXByZXZUcmFuc2l0aW9uO3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSk7fXJldHVybiBudWxsO31mdW5jdGlvbiBjb21taXRSb290SW1wbChyb290LHJlY292ZXJhYmxlRXJyb3JzLHRyYW5zaXRpb25zLHJlbmRlclByaW9yaXR5TGV2ZWwpe2Rvey8vIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCB3aWxsIGNhbGwgYGZsdXNoU3luY1VwZGF0ZVF1ZXVlYCBhdCB0aGUgZW5kLCB3aGljaFxuLy8gbWVhbnMgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgc29tZXRpbWVzIHJlc3VsdCBpbiBhZGRpdGlvbmFsXG4vLyBwYXNzaXZlIGVmZmVjdHMuIFNvIHdlIG5lZWQgdG8ga2VlcCBmbHVzaGluZyBpbiBhIGxvb3AgdW50aWwgdGhlcmUgYXJlXG4vLyBubyBtb3JlIHBlbmRpbmcgZWZmZWN0cy5cbi8vIFRPRE86IE1pZ2h0IGJlIGJldHRlciBpZiBgZmx1c2hQYXNzaXZlRWZmZWN0c2AgZGlkIG5vdCBhdXRvbWF0aWNhbGx5XG4vLyBmbHVzaCBzeW5jaHJvbm91cyB3b3JrIGF0IHRoZSBlbmQsIHRvIGF2b2lkIGZhY3RvcmluZyBoYXphcmRzIGxpa2UgdGhpcy5cbmZsdXNoUGFzc2l2ZUVmZmVjdHMoKTt9d2hpbGUocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMhPT1udWxsKTtmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKTtpZigoZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSkhPT1Ob0NvbnRleHQpe3Rocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7fXZhciBmaW5pc2hlZFdvcms9cm9vdC5maW5pc2hlZFdvcms7dmFyIGxhbmVzPXJvb3QuZmluaXNoZWRMYW5lczt7bWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpO31pZihmaW5pc2hlZFdvcms9PT1udWxsKXt7bWFya0NvbW1pdFN0b3BwZWQoKTt9cmV0dXJuIG51bGw7fWVsc2V7e2lmKGxhbmVzPT09Tm9MYW5lcyl7ZXJyb3IoJ3Jvb3QuZmluaXNoZWRMYW5lcyBzaG91bGQgbm90IGJlIGVtcHR5IGR1cmluZyBhIGNvbW1pdC4gVGhpcyBpcyBhICcrJ2J1ZyBpbiBSZWFjdC4nKTt9fX1yb290LmZpbmlzaGVkV29yaz1udWxsO3Jvb3QuZmluaXNoZWRMYW5lcz1Ob0xhbmVzO2lmKGZpbmlzaGVkV29yaz09PXJvb3QuY3VycmVudCl7dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgJysnYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO30vLyBjb21taXRSb290IG5ldmVyIHJldHVybnMgYSBjb250aW51YXRpb247IGl0IGFsd2F5cyBmaW5pc2hlcyBzeW5jaHJvbm91c2x5LlxuLy8gU28gd2UgY2FuIGNsZWFyIHRoZXNlIG5vdyB0byBhbGxvdyBhIG5ldyBjYWxsYmFjayB0byBiZSBzY2hlZHVsZWQuXG5yb290LmNhbGxiYWNrTm9kZT1udWxsO3Jvb3QuY2FsbGJhY2tQcmlvcml0eT1Ob0xhbmU7Ly8gVXBkYXRlIHRoZSBmaXJzdCBhbmQgbGFzdCBwZW5kaW5nIHRpbWVzIG9uIHRoaXMgcm9vdC4gVGhlIG5ldyBmaXJzdFxuLy8gcGVuZGluZyB0aW1lIGlzIHdoYXRldmVyIGlzIGxlZnQgb24gdGhlIHJvb3QgZmliZXIuXG52YXIgcmVtYWluaW5nTGFuZXM9bWVyZ2VMYW5lcyhmaW5pc2hlZFdvcmsubGFuZXMsZmluaXNoZWRXb3JrLmNoaWxkTGFuZXMpO21hcmtSb290RmluaXNoZWQocm9vdCxyZW1haW5pbmdMYW5lcyk7aWYocm9vdD09PXdvcmtJblByb2dyZXNzUm9vdCl7Ly8gV2UgY2FuIHJlc2V0IHRoZXNlIG5vdyB0aGF0IHRoZXkgYXJlIGZpbmlzaGVkLlxud29ya0luUHJvZ3Jlc3NSb290PW51bGw7d29ya0luUHJvZ3Jlc3M9bnVsbDt3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcz1Ob0xhbmVzO30vLyBJZiB0aGVyZSBhcmUgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMsIHNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gcHJvY2VzcyB0aGVtLlxuLy8gRG8gdGhpcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gaXQgaXMgcXVldWVkIGJlZm9yZSBhbnl0aGluZyBlbHNlIHRoYXRcbi8vIG1pZ2h0IGdldCBzY2hlZHVsZWQgaW4gdGhlIGNvbW1pdCBwaGFzZS4gKFNlZSAjMTY3MTQuKVxuLy8gVE9ETzogRGVsZXRlIGFsbCBvdGhlciBwbGFjZXMgdGhhdCBzY2hlZHVsZSB0aGUgcGFzc2l2ZSBlZmZlY3QgY2FsbGJhY2tcbi8vIFRoZXkncmUgcmVkdW5kYW50LlxuaWYoKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MmUGFzc2l2ZU1hc2spIT09Tm9GbGFnc3x8KGZpbmlzaGVkV29yay5mbGFncyZQYXNzaXZlTWFzaykhPT1Ob0ZsYWdzKXtpZighcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpe3Jvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzPXRydWU7Ly8gdG8gc3RvcmUgaXQgaW4gcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyB1bnRpbCB0aGV5IGdldCBwcm9jZXNzZWRcbi8vIFdlIG5lZWQgdG8gcGFzcyB0aGlzIHRocm91Z2ggYXMgYW4gYXJndW1lbnQgdG8gY29tbWl0Um9vdFxuLy8gYmVjYXVzZSB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zIG1pZ2h0IGhhdmUgY2hhbmdlZCBiZXR3ZWVuXG4vLyB0aGUgcHJldmlvdXMgcmVuZGVyIGFuZCBjb21taXQgaWYgd2UgdGhyb3R0bGUgdGhlIGNvbW1pdFxuLy8gd2l0aCBzZXRUaW1lb3V0XG5wZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zPXRyYW5zaXRpb25zO3NjaGVkdWxlQ2FsbGJhY2skMShOb3JtYWxQcmlvcml0eSxmdW5jdGlvbigpe2ZsdXNoUGFzc2l2ZUVmZmVjdHMoKTsvLyBUaGlzIHJlbmRlciB0cmlnZ2VyZWQgcGFzc2l2ZSBlZmZlY3RzOiByZWxlYXNlIHRoZSByb290IGNhY2hlIHBvb2xcbi8vICphZnRlciogcGFzc2l2ZSBlZmZlY3RzIGZpcmUgdG8gYXZvaWQgZnJlZWluZyBhIGNhY2hlIHBvb2wgdGhhdCBtYXlcbi8vIGJlIHJlZmVyZW5jZWQgYnkgYSBub2RlIGluIHRoZSB0cmVlIChIb3N0Um9vdCwgQ2FjaGUgYm91bmRhcnkgZXRjKVxucmV0dXJuIG51bGw7fSk7fX0vLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IGVmZmVjdHMgaW4gdGhlIHdob2xlIHRyZWUuXG4vLyBUT0RPOiBUaGlzIGlzIGxlZnQgb3ZlciBmcm9tIHRoZSBlZmZlY3QgbGlzdCBpbXBsZW1lbnRhdGlvbiwgd2hlcmUgd2UgaGFkXG4vLyB0byBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBgZmlyc3RFZmZlY3RgIHRvIHNhdGlzZnkgRmxvdy4gSSB0aGluayB0aGVcbi8vIG9ubHkgb3RoZXIgcmVhc29uIHRoaXMgb3B0aW1pemF0aW9uIGV4aXN0cyBpcyBiZWNhdXNlIGl0IGFmZmVjdHMgcHJvZmlsaW5nLlxuLy8gUmVjb25zaWRlciB3aGV0aGVyIHRoaXMgaXMgbmVjZXNzYXJ5LlxudmFyIHN1YnRyZWVIYXNFZmZlY3RzPShmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzJihCZWZvcmVNdXRhdGlvbk1hc2t8TXV0YXRpb25NYXNrfExheW91dE1hc2t8UGFzc2l2ZU1hc2spKSE9PU5vRmxhZ3M7dmFyIHJvb3RIYXNFZmZlY3Q9KGZpbmlzaGVkV29yay5mbGFncyYoQmVmb3JlTXV0YXRpb25NYXNrfE11dGF0aW9uTWFza3xMYXlvdXRNYXNrfFBhc3NpdmVNYXNrKSkhPT1Ob0ZsYWdzO2lmKHN1YnRyZWVIYXNFZmZlY3RzfHxyb290SGFzRWZmZWN0KXt2YXIgcHJldlRyYW5zaXRpb249UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1udWxsO3ZhciBwcmV2aW91c1ByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO3ZhciBwcmV2RXhlY3V0aW9uQ29udGV4dD1leGVjdXRpb25Db250ZXh0O2V4ZWN1dGlvbkNvbnRleHR8PUNvbW1pdENvbnRleHQ7Ly8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcblJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudD1udWxsOy8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3Ncbi8vIG9mIHRoZSBlZmZlY3QgbGlzdCBmb3IgZWFjaCBwaGFzZTogYWxsIG11dGF0aW9uIGVmZmVjdHMgY29tZSBiZWZvcmUgYWxsXG4vLyBsYXlvdXQgZWZmZWN0cywgYW5kIHNvIG9uLlxuLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcbi8vIHN0YXRlIG9mIHRoZSBob3N0IHRyZWUgcmlnaHQgYmVmb3JlIHdlIG11dGF0ZSBpdC4gVGhpcyBpcyB3aGVyZVxuLy8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgaXMgY2FsbGVkLlxudmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cj1jb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO3svLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbi8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxucmVjb3JkQ29tbWl0VGltZSgpO31jb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmssbGFuZXMpO3Jlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKTsvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuLy8gdGhlIG11dGF0aW9uIHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsIGN1cnJlbnQgZHVyaW5nXG4vLyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgbGF5b3V0IHBoYXNlLCBzbyB0aGF0IHRoZSBmaW5pc2hlZFxuLy8gd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG5yb290LmN1cnJlbnQ9ZmluaXNoZWRXb3JrOy8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBsYXlvdXQgcGhhc2UsIHdoZXJlIHdlIGNhbGwgZWZmZWN0cyB0aGF0IHJlYWRcbnttYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO31jb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayxyb290LGxhbmVzKTt7bWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCk7fS8vIG9wcG9ydHVuaXR5IHRvIHBhaW50LlxucmVxdWVzdFBhaW50KCk7ZXhlY3V0aW9uQ29udGV4dD1wcmV2RXhlY3V0aW9uQ29udGV4dDsvLyBSZXNldCB0aGUgcHJpb3JpdHkgdG8gdGhlIHByZXZpb3VzIG5vbi1zeW5jIHZhbHVlLlxuc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1wcmV2VHJhbnNpdGlvbjt9ZWxzZXsvLyBObyBlZmZlY3RzLlxucm9vdC5jdXJyZW50PWZpbmlzaGVkV29yazsvLyBNZWFzdXJlIHRoZXNlIGFueXdheSBzbyB0aGUgZmxhbWVncmFwaCBleHBsaWNpdGx5IHNob3dzIHRoYXQgdGhlcmUgd2VyZVxuLy8gbm8gZWZmZWN0cy5cbi8vIFRPRE86IE1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIHJlcG9ydCB0aGlzLlxue3JlY29yZENvbW1pdFRpbWUoKTt9fXZhciByb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzPXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzO2lmKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKXsvLyBUaGlzIGNvbW1pdCBoYXMgcGFzc2l2ZSBlZmZlY3RzLiBTdGFzaCBhIHJlZmVyZW5jZSB0byB0aGVtLiBCdXQgZG9uJ3Rcbi8vIHNjaGVkdWxlIGEgY2FsbGJhY2sgdW50aWwgYWZ0ZXIgZmx1c2hpbmcgbGF5b3V0IHdvcmsuXG5yb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cz1mYWxzZTtyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cz1yb290O3BlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzPWxhbmVzO31lbHNle3tuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQ9MDtyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzPW51bGw7fX0vLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGFuIGVmZmVjdCBtaWdodCBoYXZlIHVwZGF0ZWQgaXRcbnJlbWFpbmluZ0xhbmVzPXJvb3QucGVuZGluZ0xhbmVzOy8vIENoZWNrIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290XG4vLyBUT0RPOiBUaGlzIGlzIHBhcnQgb2YgdGhlIGBjb21wb25lbnREaWRDYXRjaGAgaW1wbGVtZW50YXRpb24uIEl0cyBwdXJwb3NlXG4vLyBpcyB0byBkZXRlY3Qgd2hldGhlciBzb21ldGhpbmcgbWlnaHQgaGF2ZSBjYWxsZWQgc2V0U3RhdGUgaW5zaWRlXG4vLyBgY29tcG9uZW50RGlkQ2F0Y2hgLiBUaGUgbWVjaGFuaXNtIGlzIGtub3duIHRvIGJlIGZsYXdlZCBiZWNhdXNlIGBzZXRTdGF0ZWBcbi8vIGluc2lkZSBgY29tcG9uZW50RGlkQ2F0Y2hgIGlzIGl0c2VsZiBmbGF3ZWQg4oCUIHRoYXQncyB3aHkgd2UgcmVjb21tZW5kXG4vLyBgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yYCBpbnN0ZWFkLiBIb3dldmVyLCBpdCBjb3VsZCBiZSBpbXByb3ZlZCBieVxuLy8gY2hlY2tpbmcgaWYgcmVtYWluaW5nTGFuZXMgaW5jbHVkZXMgU3luYyB3b3JrLCBpbnN0ZWFkIG9mIHdoZXRoZXIgdGhlcmUnc1xuLy8gYW55IHdvcmsgcmVtYWluaW5nIGF0IGFsbCAod2hpY2ggd291bGQgYWxzbyBpbmNsdWRlIHN0dWZmIGxpa2UgU3VzcGVuc2Vcbi8vIHJldHJpZXMgb3IgdHJhbnNpdGlvbnMpLiBJdCdzIGJlZW4gbGlrZSB0aGlzIGZvciBhIHdoaWxlLCB0aG91Z2gsIHNvIGZpeGluZ1xuLy8gaXQgcHJvYmFibHkgaXNuJ3QgdGhhdCB1cmdlbnQuXG5pZihyZW1haW5pbmdMYW5lcz09PU5vTGFuZXMpey8vIElmIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmssIHdlIGNhbiBjbGVhciB0aGUgc2V0IG9mIGFscmVhZHkgZmFpbGVkXG4vLyBlcnJvciBib3VuZGFyaWVzLlxubGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQ9bnVsbDt9e2lmKCFyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzKXtjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LGZhbHNlKTt9fW9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLHJlbmRlclByaW9yaXR5TGV2ZWwpO3tpZihpc0RldlRvb2xzUHJlc2VudCl7cm9vdC5tZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7fX17b25Db21taXRSb290JDEoKTt9Ly8gQWx3YXlzIGNhbGwgdGhpcyBiZWZvcmUgZXhpdGluZyBgY29tbWl0Um9vdGAsIHRvIGVuc3VyZSB0aGF0IGFueVxuLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5lbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxub3coKSk7aWYocmVjb3ZlcmFibGVFcnJvcnMhPT1udWxsKXsvLyBUaGVyZSB3ZXJlIGVycm9ycyBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCByZWNvdmVyZWQgZnJvbSB0aGVtIHdpdGhvdXRcbi8vIG5lZWRpbmcgdG8gc3VyZmFjZSBpdCB0byB0aGUgVUkuIFdlIGxvZyB0aGVtIGhlcmUuXG52YXIgb25SZWNvdmVyYWJsZUVycm9yPXJvb3Qub25SZWNvdmVyYWJsZUVycm9yO2Zvcih2YXIgaT0wO2k8cmVjb3ZlcmFibGVFcnJvcnMubGVuZ3RoO2krKyl7dmFyIHJlY292ZXJhYmxlRXJyb3I9cmVjb3ZlcmFibGVFcnJvcnNbaV07dmFyIGNvbXBvbmVudFN0YWNrPXJlY292ZXJhYmxlRXJyb3Iuc3RhY2s7dmFyIGRpZ2VzdD1yZWNvdmVyYWJsZUVycm9yLmRpZ2VzdDtvblJlY292ZXJhYmxlRXJyb3IocmVjb3ZlcmFibGVFcnJvci52YWx1ZSx7Y29tcG9uZW50U3RhY2s6Y29tcG9uZW50U3RhY2ssZGlnZXN0OmRpZ2VzdH0pO319aWYoaGFzVW5jYXVnaHRFcnJvcil7aGFzVW5jYXVnaHRFcnJvcj1mYWxzZTt2YXIgZXJyb3IkMT1maXJzdFVuY2F1Z2h0RXJyb3I7Zmlyc3RVbmNhdWdodEVycm9yPW51bGw7dGhyb3cgZXJyb3IkMTt9Ly8gSWYgdGhlIHBhc3NpdmUgZWZmZWN0cyBhcmUgdGhlIHJlc3VsdCBvZiBhIGRpc2NyZXRlIHJlbmRlciwgZmx1c2ggdGhlbVxuLy8gc3luY2hyb25vdXNseSBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHRhc2sgc28gdGhhdCB0aGUgcmVzdWx0IGlzXG4vLyBpbW1lZGlhdGVseSBvYnNlcnZhYmxlLiBPdGhlcndpc2UsIHdlIGFzc3VtZSB0aGF0IHRoZXkgYXJlIG5vdFxuLy8gb3JkZXItZGVwZW5kZW50IGFuZCBkbyBub3QgbmVlZCB0byBiZSBvYnNlcnZlZCBieSBleHRlcm5hbCBzeXN0ZW1zLCBzbyB3ZVxuLy8gY2FuIHdhaXQgdW50aWwgYWZ0ZXIgcGFpbnQuXG4vLyBUT0RPOiBXZSBjYW4gb3B0aW1pemUgdGhpcyBieSBub3Qgc2NoZWR1bGluZyB0aGUgY2FsbGJhY2sgZWFybGllci4gU2luY2Ugd2Vcbi8vIGN1cnJlbnRseSBzY2hlZHVsZSB0aGUgY2FsbGJhY2sgaW4gbXVsdGlwbGUgcGxhY2VzLCB3aWxsIHdhaXQgdW50aWwgdGhvc2Vcbi8vIGFyZSBjb25zb2xpZGF0ZWQuXG5pZihpbmNsdWRlc1NvbWVMYW5lKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzLFN5bmNMYW5lKSYmcm9vdC50YWchPT1MZWdhY3lSb290KXtmbHVzaFBhc3NpdmVFZmZlY3RzKCk7fS8vIFJlYWQgdGhpcyBhZ2Fpbiwgc2luY2UgYSBwYXNzaXZlIGVmZmVjdCBtaWdodCBoYXZlIHVwZGF0ZWQgaXRcbnJlbWFpbmluZ0xhbmVzPXJvb3QucGVuZGluZ0xhbmVzO2lmKGluY2x1ZGVzU29tZUxhbmUocmVtYWluaW5nTGFuZXMsU3luY0xhbmUpKXt7bWFya05lc3RlZFVwZGF0ZVNjaGVkdWxlZCgpO30vLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByb290IHN5bmNocm9ub3VzbHkgcmUtcmVuZGVycyB3aXRob3V0XG4vLyBmaW5pc2hpbmcuIElmIHRoZXJlIGFyZSB0b28gbWFueSwgaXQgaW5kaWNhdGVzIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wLlxuaWYocm9vdD09PXJvb3RXaXRoTmVzdGVkVXBkYXRlcyl7bmVzdGVkVXBkYXRlQ291bnQrKzt9ZWxzZXtuZXN0ZWRVcGRhdGVDb3VudD0wO3Jvb3RXaXRoTmVzdGVkVXBkYXRlcz1yb290O319ZWxzZXtuZXN0ZWRVcGRhdGVDb3VudD0wO30vLyBJZiBsYXlvdXQgd29yayB3YXMgc2NoZWR1bGVkLCBmbHVzaCBpdCBub3cuXG5mbHVzaFN5bmNDYWxsYmFja3MoKTt7bWFya0NvbW1pdFN0b3BwZWQoKTt9cmV0dXJuIG51bGw7fWZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKXsvLyBSZXR1cm5zIHdoZXRoZXIgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgZmx1c2hlZC5cbi8vIFRPRE86IENvbWJpbmUgdGhpcyBjaGVjayB3aXRoIHRoZSBvbmUgaW4gZmx1c2hQYXNzaXZlRUZmZWN0c0ltcGwuIFdlIHNob3VsZFxuLy8gcHJvYmFibHkganVzdCBjb21iaW5lIHRoZSB0d28gZnVuY3Rpb25zLiBJIGJlbGlldmUgdGhleSB3ZXJlIG9ubHkgc2VwYXJhdGVcbi8vIGluIHRoZSBmaXJzdCBwbGFjZSBiZWNhdXNlIHdlIHVzZWQgdG8gd3JhcCBpdCB3aXRoXG4vLyBgU2NoZWR1bGVyLnJ1bldpdGhQcmlvcml0eWAsIHdoaWNoIGFjY2VwdHMgYSBmdW5jdGlvbi4gQnV0IG5vdyB3ZSB0cmFjayB0aGVcbi8vIHByaW9yaXR5IHdpdGhpbiBSZWFjdCBpdHNlbGYsIHNvIHdlIGNhbiBtdXRhdGUgdGhlIHZhcmlhYmxlIGRpcmVjdGx5LlxuaWYocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMhPT1udWxsKXt2YXIgcmVuZGVyUHJpb3JpdHk9bGFuZXNUb0V2ZW50UHJpb3JpdHkocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMpO3ZhciBwcmlvcml0eT1sb3dlckV2ZW50UHJpb3JpdHkoRGVmYXVsdEV2ZW50UHJpb3JpdHkscmVuZGVyUHJpb3JpdHkpO3ZhciBwcmV2VHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247dmFyIHByZXZpb3VzUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7dHJ5e1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1udWxsO3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7cmV0dXJuIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsKCk7fWZpbmFsbHl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1wcmV2VHJhbnNpdGlvbjsvLyBPbmNlIHBhc3NpdmUgZWZmZWN0cyBoYXZlIHJ1biBmb3IgdGhlIHRyZWUgLSBnaXZpbmcgY29tcG9uZW50cyBhXG59fXJldHVybiBmYWxzZTt9ZnVuY3Rpb24gZW5xdWV1ZVBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3QoZmliZXIpe3twZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cy5wdXNoKGZpYmVyKTtpZighcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpe3Jvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzPXRydWU7c2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5LGZ1bmN0aW9uKCl7Zmx1c2hQYXNzaXZlRWZmZWN0cygpO3JldHVybiBudWxsO30pO319fWZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsKCl7aWYocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHM9PT1udWxsKXtyZXR1cm4gZmFsc2U7fS8vIENhY2hlIGFuZCBjbGVhciB0aGUgdHJhbnNpdGlvbnMgZmxhZ1xudmFyIHRyYW5zaXRpb25zPXBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM7cGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucz1udWxsO3ZhciByb290PXJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzO3ZhciBsYW5lcz1wZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcztyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cz1udWxsOy8vIFRPRE86IFRoaXMgaXMgc29tZXRpbWVzIG91dCBvZiBzeW5jIHdpdGggcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMuXG4vLyBGaWd1cmUgb3V0IHdoeSBhbmQgZml4IGl0LiBJdCdzIG5vdCBjYXVzaW5nIGFueSBrbm93biBpc3N1ZXMgKHByb2JhYmx5XG4vLyBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZvciBwcm9maWxpbmcpLCBidXQgaXQncyBhIHJlZmFjdG9yIGhhemFyZC5cbnBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzPU5vTGFuZXM7aWYoKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpIT09Tm9Db250ZXh0KXt0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgd2hpbGUgYWxyZWFkeSByZW5kZXJpbmcuJyk7fXtpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHM9dHJ1ZTtkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzPWZhbHNlO317bWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7fXZhciBwcmV2RXhlY3V0aW9uQ29udGV4dD1leGVjdXRpb25Db250ZXh0O2V4ZWN1dGlvbkNvbnRleHR8PUNvbW1pdENvbnRleHQ7Y29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKHJvb3QuY3VycmVudCk7Y29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0cyhyb290LHJvb3QuY3VycmVudCxsYW5lcyx0cmFuc2l0aW9ucyk7Ly8gVE9ETzogTW92ZSB0byBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzXG57dmFyIHByb2ZpbGVyRWZmZWN0cz1wZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cztwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cz1bXTtmb3IodmFyIGk9MDtpPHByb2ZpbGVyRWZmZWN0cy5sZW5ndGg7aSsrKXt2YXIgX2ZpYmVyPXByb2ZpbGVyRWZmZWN0c1tpXTtjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKHJvb3QsX2ZpYmVyKTt9fXttYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk7fXtjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LHRydWUpO31leGVjdXRpb25Db250ZXh0PXByZXZFeGVjdXRpb25Db250ZXh0O2ZsdXNoU3luY0NhbGxiYWNrcygpO3svLyBJZiBhZGRpdGlvbmFsIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIHNjaGVkdWxlZCwgaW5jcmVtZW50IGEgY291bnRlci4gSWYgdGhpc1xuLy8gZXhjZWVkcyB0aGUgbGltaXQsIHdlJ2xsIGZpcmUgYSB3YXJuaW5nLlxuaWYoZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyl7aWYocm9vdD09PXJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMpe25lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCsrO31lbHNle25lc3RlZFBhc3NpdmVVcGRhdGVDb3VudD0wO3Jvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXM9cm9vdDt9fWVsc2V7bmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50PTA7fWlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cz1mYWxzZTtkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzPWZhbHNlO30vLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcbm9uUG9zdENvbW1pdFJvb3Qocm9vdCk7e3ZhciBzdGF0ZU5vZGU9cm9vdC5jdXJyZW50LnN0YXRlTm9kZTtzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb249MDtzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uPTA7fXJldHVybiB0cnVlO31mdW5jdGlvbiBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKXtyZXR1cm4gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQhPT1udWxsJiZsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpO31mdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKXtpZihsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZD09PW51bGwpe2xlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkPW5ldyBTZXQoW2luc3RhbmNlXSk7fWVsc2V7bGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKGluc3RhbmNlKTt9fWZ1bmN0aW9uIHByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvcihlcnJvcil7aWYoIWhhc1VuY2F1Z2h0RXJyb3Ipe2hhc1VuY2F1Z2h0RXJyb3I9dHJ1ZTtmaXJzdFVuY2F1Z2h0RXJyb3I9ZXJyb3I7fX12YXIgb25VbmNhdWdodEVycm9yPXByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvcjtmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsc291cmNlRmliZXIsZXJyb3Ipe3ZhciBlcnJvckluZm89Y3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3Isc291cmNlRmliZXIpO3ZhciB1cGRhdGU9Y3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3RGaWJlcixlcnJvckluZm8sU3luY0xhbmUpO3ZhciByb290PWVucXVldWVVcGRhdGUocm9vdEZpYmVyLHVwZGF0ZSxTeW5jTGFuZSk7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7aWYocm9vdCE9PW51bGwpe21hcmtSb290VXBkYXRlZChyb290LFN5bmNMYW5lLGV2ZW50VGltZSk7ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsZXZlbnRUaW1lKTt9fWZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKHNvdXJjZUZpYmVyLG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZXJyb3IkMSl7e3JlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvciQxKTtzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoZmFsc2UpO31pZihzb3VyY2VGaWJlci50YWc9PT1Ib3N0Um9vdCl7Ly8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsc291cmNlRmliZXIsZXJyb3IkMSk7cmV0dXJuO312YXIgZmliZXI9bnVsbDt7ZmliZXI9bmVhcmVzdE1vdW50ZWRBbmNlc3Rvcjt9d2hpbGUoZmliZXIhPT1udWxsKXtpZihmaWJlci50YWc9PT1Ib3N0Um9vdCl7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoZmliZXIsc291cmNlRmliZXIsZXJyb3IkMSk7cmV0dXJuO31lbHNlIGlmKGZpYmVyLnRhZz09PUNsYXNzQ29tcG9uZW50KXt2YXIgY3Rvcj1maWJlci50eXBlO3ZhciBpbnN0YW5jZT1maWJlci5zdGF0ZU5vZGU7aWYodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yPT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoPT09J2Z1bmN0aW9uJyYmIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKXt2YXIgZXJyb3JJbmZvPWNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yJDEsc291cmNlRmliZXIpO3ZhciB1cGRhdGU9Y3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlcixlcnJvckluZm8sU3luY0xhbmUpO3ZhciByb290PWVucXVldWVVcGRhdGUoZmliZXIsdXBkYXRlLFN5bmNMYW5lKTt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTtpZihyb290IT09bnVsbCl7bWFya1Jvb3RVcGRhdGVkKHJvb3QsU3luY0xhbmUsZXZlbnRUaW1lKTtlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxldmVudFRpbWUpO31yZXR1cm47fX1maWJlcj1maWJlci5yZXR1cm47fXsvLyBUT0RPOiBVbnRpbCB3ZSByZS1sYW5kIHNraXBVbm1vdW50ZWRCb3VuZGFyaWVzIChzZWUgIzIwMTQ3KSwgdGhpcyB3YXJuaW5nXG4vLyB3aWxsIGZpcmUgZm9yIGVycm9ycyB0aGF0IGFyZSB0aHJvd24gYnkgZGVzdHJveSBmdW5jdGlvbnMgaW5zaWRlIGRlbGV0ZWRcbi8vIHRyZWVzLiBXaGF0IGl0IHNob3VsZCBpbnN0ZWFkIGRvIGlzIHByb3BhZ2F0ZSB0aGUgZXJyb3IgdG8gdGhlIHBhcmVudCBvZlxuLy8gdGhlIGRlbGV0ZWQgdHJlZS4gSW4gdGhlIG1lYW50aW1lLCBkbyBub3QgYWRkIHRoaXMgd2FybmluZyB0byB0aGVcbi8vIGFsbG93bGlzdDsgdGhpcyBpcyBvbmx5IGZvciBvdXIgaW50ZXJuYWwgdXNlLlxuZXJyb3IoJ0ludGVybmFsIFJlYWN0IGVycm9yOiBBdHRlbXB0ZWQgdG8gY2FwdHVyZSBhIGNvbW1pdCBwaGFzZSBlcnJvciAnKydpbnNpZGUgYSBkZXRhY2hlZCB0cmVlLiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4gTGlrZWx5ICcrJ2NhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuICcrJ2FscmVhZHktZmluaXNoZWQgdHJlZSwgb3IgYW4gaW5jb25zaXN0ZW50IHJldHVybiBwb2ludGVyLlxcblxcbicrJ0Vycm9yIG1lc3NhZ2U6XFxuXFxuJXMnLGVycm9yJDEpO319ZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3Qocm9vdCx3YWtlYWJsZSxwaW5nZWRMYW5lcyl7dmFyIHBpbmdDYWNoZT1yb290LnBpbmdDYWNoZTtpZihwaW5nQ2FjaGUhPT1udWxsKXsvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxucGluZ0NhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7fXZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO21hcmtSb290UGluZ2VkKHJvb3QscGluZ2VkTGFuZXMpO3dhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWKHJvb3QpO2lmKHdvcmtJblByb2dyZXNzUm9vdD09PXJvb3QmJmlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxwaW5nZWRMYW5lcykpey8vIFJlY2VpdmVkIGEgcGluZyBhdCB0aGUgc2FtZSBwcmlvcml0eSBsZXZlbCBhdCB3aGljaCB3ZSdyZSBjdXJyZW50bHlcbi8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3Jcbi8vIHRoZSBsb2dpYyBvZiB3aGV0aGVyIG9yIG5vdCBhIHJvb3Qgc3VzcGVuZHMgb25jZSBpdCBjb21wbGV0ZXMuXG4vLyBUT0RPOiBJZiB3ZSdyZSByZW5kZXJpbmcgc3luYyBlaXRoZXIgZHVlIHRvIFN5bmMsIEJhdGNoZWQgb3IgZXhwaXJlZCxcbi8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuLy8gSWYgd2UncmUgc3VzcGVuZGVkIHdpdGggZGVsYXksIG9yIGlmIGl0J3MgYSByZXRyeSwgd2UnbGwgYWx3YXlzIHN1c3BlbmRcbi8vIHNvIHdlIGNhbiBhbHdheXMgcmVzdGFydC5cbmlmKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9PT1Sb290U3VzcGVuZGVkV2l0aERlbGF5fHx3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPT09Um9vdFN1c3BlbmRlZCYmaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykmJm5vdygpLWdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWU8RkFMTEJBQ0tfVEhST1RUTEVfTVMpey8vIFJlc3RhcnQgZnJvbSB0aGUgcm9vdC5cbnByZXBhcmVGcmVzaFN0YWNrKHJvb3QsTm9MYW5lcyk7fWVsc2V7Ly8gRXZlbiB0aG91Z2ggd2UgY2FuJ3QgcmVzdGFydCByaWdodCBub3csIHdlIG1pZ2h0IGdldCBhblxuLy8gb3Bwb3J0dW5pdHkgbGF0ZXIuIFNvIHdlIG1hcmsgdGhpcyByZW5kZXIgYXMgaGF2aW5nIGEgcGluZy5cbndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzPW1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMscGluZ2VkTGFuZXMpO319ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsZXZlbnRUaW1lKTt9ZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIscmV0cnlMYW5lKXsvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50IG9yIFN1c3BlbnNlTGlzdCBjb21wb25lbnQpXG4vLyBwcmV2aW91c2x5IHdhcyByZW5kZXJlZCBpbiBpdHMgZmFsbGJhY2sgc3RhdGUuIE9uZSBvZiB0aGUgcHJvbWlzZXMgdGhhdFxuLy8gc3VzcGVuZGVkIGl0IGhhcyByZXNvbHZlZCwgd2hpY2ggbWVhbnMgYXQgbGVhc3QgcGFydCBvZiB0aGUgdHJlZSB3YXNcbi8vIGxpa2VseSB1bmJsb2NrZWQuIFRyeSByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGxhbmVzLlxuaWYocmV0cnlMYW5lPT09Tm9MYW5lKXsvLyBUT0RPOiBBc3NpZ24gdGhpcyB0byBgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmVgPyB0byBhdm9pZFxuLy8gdW5uZWNlc3NhcnkgZW50YW5nbGVtZW50P1xucmV0cnlMYW5lPXJlcXVlc3RSZXRyeUxhbmUoYm91bmRhcnlGaWJlcik7fS8vIFRPRE86IFNwZWNpYWwgY2FzZSBpZGxlIHByaW9yaXR5P1xudmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGJvdW5kYXJ5RmliZXIscmV0cnlMYW5lKTtpZihyb290IT09bnVsbCl7bWFya1Jvb3RVcGRhdGVkKHJvb3QscmV0cnlMYW5lLGV2ZW50VGltZSk7ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsZXZlbnRUaW1lKTt9fWZ1bmN0aW9uIHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoYm91bmRhcnlGaWJlcil7dmFyIHN1c3BlbnNlU3RhdGU9Ym91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO3ZhciByZXRyeUxhbmU9Tm9MYW5lO2lmKHN1c3BlbnNlU3RhdGUhPT1udWxsKXtyZXRyeUxhbmU9c3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU7fXJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLHJldHJ5TGFuZSk7fWZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsd2FrZWFibGUpe3ZhciByZXRyeUxhbmU9Tm9MYW5lOy8vIERlZmF1bHRcbnZhciByZXRyeUNhY2hlO3N3aXRjaChib3VuZGFyeUZpYmVyLnRhZyl7Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDpyZXRyeUNhY2hlPWJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO3ZhciBzdXNwZW5zZVN0YXRlPWJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtpZihzdXNwZW5zZVN0YXRlIT09bnVsbCl7cmV0cnlMYW5lPXN1c3BlbnNlU3RhdGUucmV0cnlMYW5lO31icmVhaztjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpyZXRyeUNhY2hlPWJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCdQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiAnKydUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO31pZihyZXRyeUNhY2hlIT09bnVsbCl7Ly8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbi8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbnJldHJ5Q2FjaGUuZGVsZXRlKHdha2VhYmxlKTt9cmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIscmV0cnlMYW5lKTt9Ly8gQ29tcHV0ZXMgdGhlIG5leHQgSnVzdCBOb3RpY2VhYmxlIERpZmZlcmVuY2UgKEpORCkgYm91bmRhcnkuXG4vLyBUaGUgdGhlb3J5IGlzIHRoYXQgYSBwZXJzb24gY2FuJ3QgdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHNtYWxsIGRpZmZlcmVuY2VzIGluIHRpbWUuXG4vLyBUaGVyZWZvcmUsIGlmIHdlIHdhaXQgYSBiaXQgbG9uZ2VyIHRoYW4gbmVjZXNzYXJ5IHRoYXQgd29uJ3QgdHJhbnNsYXRlIHRvIGEgbm90aWNlYWJsZVxuLy8gZGlmZmVyZW5jZSBpbiB0aGUgZXhwZXJpZW5jZS4gSG93ZXZlciwgd2FpdGluZyBmb3IgbG9uZ2VyIG1pZ2h0IG1lYW4gdGhhdCB3ZSBjYW4gYXZvaWRcbi8vIHNob3dpbmcgYW4gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFRoZSBsb25nZXIgd2UgaGF2ZSBhbHJlYWR5IHdhaXRlZCwgdGhlIGhhcmRlciBpdFxuLy8gaXMgdG8gdGVsbCBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLiBUaGVyZWZvcmUsIHRoZSBsb25nZXIgd2UndmUgYWxyZWFkeSB3YWl0ZWQsXG4vLyB0aGUgbG9uZ2VyIHdlIGNhbiB3YWl0IGFkZGl0aW9uYWxseS4gQXQgc29tZSBwb2ludCB3ZSBoYXZlIHRvIGdpdmUgdXAgdGhvdWdoLlxuLy8gV2UgcGljayBhIHRyYWluIG1vZGVsIHdoZXJlIHRoZSBuZXh0IGJvdW5kYXJ5IGNvbW1pdHMgYXQgYSBjb25zaXN0ZW50IHNjaGVkdWxlLlxuLy8gVGhlc2UgcGFydGljdWxhciBudW1iZXJzIGFyZSB2YWd1ZSBlc3RpbWF0ZXMuIFdlIGV4cGVjdCB0byBhZGp1c3QgdGhlbSBiYXNlZCBvbiByZXNlYXJjaC5cbmZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCl7cmV0dXJuIHRpbWVFbGFwc2VkPDEyMD8xMjA6dGltZUVsYXBzZWQ8NDgwPzQ4MDp0aW1lRWxhcHNlZDwxMDgwPzEwODA6dGltZUVsYXBzZWQ8MTkyMD8xOTIwOnRpbWVFbGFwc2VkPDMwMDA/MzAwMDp0aW1lRWxhcHNlZDw0MzIwPzQzMjA6Y2VpbCh0aW1lRWxhcHNlZC8xOTYwKSoxOTYwO31mdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKXtpZihuZXN0ZWRVcGRhdGVDb3VudD5ORVNURURfVVBEQVRFX0xJTUlUKXtuZXN0ZWRVcGRhdGVDb3VudD0wO3Jvb3RXaXRoTmVzdGVkVXBkYXRlcz1udWxsO3Rocm93IG5ldyBFcnJvcignTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50ICcrJ3JlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgJysnY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byAnKydwcmV2ZW50IGluZmluaXRlIGxvb3BzLicpO317aWYobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50Pk5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCl7bmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50PTA7cm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcz1udWxsO2Vycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJytcImNhbGxzIHNldFN0YXRlIGluc2lkZSB1c2VFZmZlY3QsIGJ1dCB1c2VFZmZlY3QgZWl0aGVyIGRvZXNuJ3QgXCIrJ2hhdmUgYSBkZXBlbmRlbmN5IGFycmF5LCBvciBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzIG9uICcrJ2V2ZXJ5IHJlbmRlci4nKTt9fX1mdW5jdGlvbiBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKXt7UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO3tSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncygpO319fWZ1bmN0aW9uIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihmaWJlcixoYXNQYXNzaXZlRWZmZWN0cyl7ey8vIFRPRE8gKFN0cmljdEVmZmVjdHMpIFNob3VsZCB3ZSBzZXQgYSBtYXJrZXIgb24gdGhlIHJvb3QgaWYgaXQgY29udGFpbnMgc3RyaWN0IGVmZmVjdHNcbi8vIHNvIHdlIGRvbid0IHRyYXZlcnNlIHVubmVjZXNzYXJpbHk/IHNpbWlsYXIgdG8gc3VidHJlZUZsYWdzIGJ1dCBqdXN0IGF0IHRoZSByb290IGxldmVsLlxuLy8gTWF5YmUgbm90IGEgYmlnIGRlYWwgc2luY2UgdGhpcyBpcyBERVYgb25seSBiZWhhdmlvci5cbnNldEN1cnJlbnRGaWJlcihmaWJlcik7aW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLE1vdW50TGF5b3V0RGV2LGludm9rZUxheW91dEVmZmVjdFVubW91bnRJbkRFVik7aWYoaGFzUGFzc2l2ZUVmZmVjdHMpe2ludm9rZUVmZmVjdHNJbkRldihmaWJlcixNb3VudFBhc3NpdmVEZXYsaW52b2tlUGFzc2l2ZUVmZmVjdFVubW91bnRJbkRFVik7fWludm9rZUVmZmVjdHNJbkRldihmaWJlcixNb3VudExheW91dERldixpbnZva2VMYXlvdXRFZmZlY3RNb3VudEluREVWKTtpZihoYXNQYXNzaXZlRWZmZWN0cyl7aW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLE1vdW50UGFzc2l2ZURldixpbnZva2VQYXNzaXZlRWZmZWN0TW91bnRJbkRFVik7fXJlc2V0Q3VycmVudEZpYmVyKCk7fX1mdW5jdGlvbiBpbnZva2VFZmZlY3RzSW5EZXYoZmlyc3RDaGlsZCxmaWJlckZsYWdzLGludm9rZUVmZmVjdEZuKXt7Ly8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbnZhciBjdXJyZW50PWZpcnN0Q2hpbGQ7dmFyIHN1YnRyZWVSb290PW51bGw7d2hpbGUoY3VycmVudCE9PW51bGwpe3ZhciBwcmltYXJ5U3VidHJlZUZsYWc9Y3VycmVudC5zdWJ0cmVlRmxhZ3MmZmliZXJGbGFncztpZihjdXJyZW50IT09c3VidHJlZVJvb3QmJmN1cnJlbnQuY2hpbGQhPT1udWxsJiZwcmltYXJ5U3VidHJlZUZsYWchPT1Ob0ZsYWdzKXtjdXJyZW50PWN1cnJlbnQuY2hpbGQ7fWVsc2V7aWYoKGN1cnJlbnQuZmxhZ3MmZmliZXJGbGFncykhPT1Ob0ZsYWdzKXtpbnZva2VFZmZlY3RGbihjdXJyZW50KTt9aWYoY3VycmVudC5zaWJsaW5nIT09bnVsbCl7Y3VycmVudD1jdXJyZW50LnNpYmxpbmc7fWVsc2V7Y3VycmVudD1zdWJ0cmVlUm9vdD1jdXJyZW50LnJldHVybjt9fX19fXZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50PW51bGw7ZnVuY3Rpb24gd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihmaWJlcil7e2lmKChleGVjdXRpb25Db250ZXh0JlJlbmRlckNvbnRleHQpIT09Tm9Db250ZXh0KXsvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxucmV0dXJuO31pZighKGZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpKXtyZXR1cm47fXZhciB0YWc9ZmliZXIudGFnO2lmKHRhZyE9PUluZGV0ZXJtaW5hdGVDb21wb25lbnQmJnRhZyE9PUhvc3RSb290JiZ0YWchPT1DbGFzc0NvbXBvbmVudCYmdGFnIT09RnVuY3Rpb25Db21wb25lbnQmJnRhZyE9PUZvcndhcmRSZWYmJnRhZyE9PU1lbW9Db21wb25lbnQmJnRhZyE9PVNpbXBsZU1lbW9Db21wb25lbnQpey8vIE9ubHkgd2FybiBmb3IgdXNlci1kZWZpbmVkIGNvbXBvbmVudHMsIG5vdCBpbnRlcm5hbCBvbmVzIGxpa2UgU3VzcGVuc2UuXG5yZXR1cm47fS8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2Vcbi8vIHRoZSBwcm9ibGVtYXRpYyBjb2RlIGFsbW9zdCBhbHdheXMgbGllcyBpbnNpZGUgdGhhdCBjb21wb25lbnQuXG52YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J1JlYWN0Q29tcG9uZW50JztpZihkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50IT09bnVsbCl7aWYoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpe3JldHVybjt9ZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7fWVsc2V7ZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudD1uZXcgU2V0KFtjb21wb25lbnROYW1lXSk7fXZhciBwcmV2aW91c0ZpYmVyPWN1cnJlbnQ7dHJ5e3NldEN1cnJlbnRGaWJlcihmaWJlcik7ZXJyb3IoXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGEgY29tcG9uZW50IHRoYXQgaGFzbid0IG1vdW50ZWQgeWV0LiBcIisnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJysnYXN5bmNocm9ub3VzbHkgbGF0ZXIgY2FsbHMgdHJpZXMgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQuIE1vdmUgdGhpcyB3b3JrIHRvICcrJ3VzZUVmZmVjdCBpbnN0ZWFkLicpO31maW5hbGx5e2lmKHByZXZpb3VzRmliZXIpe3NldEN1cnJlbnRGaWJlcihmaWJlcik7fWVsc2V7cmVzZXRDdXJyZW50RmliZXIoKTt9fX19dmFyIGJlZ2luV29yayQxO3t2YXIgZHVtbXlGaWJlcj1udWxsO2JlZ2luV29yayQxPWZ1bmN0aW9uKGN1cnJlbnQsdW5pdE9mV29yayxsYW5lcyl7Ly8gSWYgYSBjb21wb25lbnQgdGhyb3dzIGFuIGVycm9yLCB3ZSByZXBsYXkgaXQgYWdhaW4gaW4gYSBzeW5jaHJvbm91c2x5XG4vLyBkaXNwYXRjaGVkIGV2ZW50LCBzbyB0aGF0IHRoZSBkZWJ1Z2dlciB3aWxsIHRyZWF0IGl0IGFzIGFuIHVuY2F1Z2h0XG4vLyBlcnJvciBTZWUgUmVhY3RFcnJvclV0aWxzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuLy8gQmVmb3JlIGVudGVyaW5nIHRoZSBiZWdpbiBwaGFzZSwgY29weSB0aGUgd29yay1pbi1wcm9ncmVzcyBvbnRvIGEgZHVtbXlcbi8vIGZpYmVyLiBJZiBiZWdpbldvcmsgdGhyb3dzLCB3ZSdsbCB1c2UgdGhpcyB0byByZXNldCB0aGUgc3RhdGUuXG52YXIgb3JpZ2luYWxXb3JrSW5Qcm9ncmVzc0NvcHk9YXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlcix1bml0T2ZXb3JrKTt0cnl7cmV0dXJuIGJlZ2luV29yayhjdXJyZW50LHVuaXRPZldvcmssbGFuZXMpO31jYXRjaChvcmlnaW5hbEVycm9yKXtpZihkaWRTdXNwZW5kT3JFcnJvcldoaWxlSHlkcmF0aW5nREVWKCl8fG9yaWdpbmFsRXJyb3IhPT1udWxsJiZ0eXBlb2Ygb3JpZ2luYWxFcnJvcj09PSdvYmplY3QnJiZ0eXBlb2Ygb3JpZ2luYWxFcnJvci50aGVuPT09J2Z1bmN0aW9uJyl7Ly8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLlxuLy8gRG9uJ3QgcmVwbGF5IGVycm9ycyBpZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCBoYXZlIGFscmVhZHkgc3VzcGVuZGVkIG9yIGhhbmRsZWQgYW4gZXJyb3JcbnRocm93IG9yaWdpbmFsRXJyb3I7fS8vIEtlZXAgdGhpcyBjb2RlIGluIHN5bmMgd2l0aCBoYW5kbGVFcnJvcjsgYW55IGNoYW5nZXMgaGVyZSBtdXN0IGhhdmVcbi8vIGNvcnJlc3BvbmRpbmcgY2hhbmdlcyB0aGVyZS5cbnJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO3Jlc2V0SG9va3NBZnRlclRocm93KCk7Ly8gRG9uJ3QgcmVzZXQgY3VycmVudCBkZWJ1ZyBmaWJlciwgc2luY2Ugd2UncmUgYWJvdXQgdG8gd29yayBvbiB0aGVcbi8vIHNhbWUgZmliZXIgYWdhaW4uXG4vLyBVbndpbmQgdGhlIGZhaWxlZCBzdGFjayBmcmFtZVxudW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsdW5pdE9mV29yayk7Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvcGVydGllcyBvZiB0aGUgZmliZXIuXG5hc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5KTtpZih1bml0T2ZXb3JrLm1vZGUmUHJvZmlsZU1vZGUpey8vIFJlc2V0IHRoZSBwcm9maWxlciB0aW1lci5cbnN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTt9Ly8gUnVuIGJlZ2luV29yayBhZ2Fpbi5cbmludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLGJlZ2luV29yayxudWxsLGN1cnJlbnQsdW5pdE9mV29yayxsYW5lcyk7aWYoaGFzQ2F1Z2h0RXJyb3IoKSl7dmFyIHJlcGxheUVycm9yPWNsZWFyQ2F1Z2h0RXJyb3IoKTtpZih0eXBlb2YgcmVwbGF5RXJyb3I9PT0nb2JqZWN0JyYmcmVwbGF5RXJyb3IhPT1udWxsJiZyZXBsYXlFcnJvci5fc3VwcHJlc3NMb2dnaW5nJiZ0eXBlb2Ygb3JpZ2luYWxFcnJvcj09PSdvYmplY3QnJiZvcmlnaW5hbEVycm9yIT09bnVsbCYmIW9yaWdpbmFsRXJyb3IuX3N1cHByZXNzTG9nZ2luZyl7Ly8gSWYgc3VwcHJlc3NlZCwgbGV0IHRoZSBmbGFnIGNhcnJ5IG92ZXIgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHdoaWNoIGlzIHRoZSBvbmUgd2UnbGwgcmV0aHJvdy5cbm9yaWdpbmFsRXJyb3IuX3N1cHByZXNzTG9nZ2luZz10cnVlO319Ly8gV2UgYWx3YXlzIHRocm93IHRoZSBvcmlnaW5hbCBlcnJvciBpbiBjYXNlIHRoZSBzZWNvbmQgcmVuZGVyIHBhc3MgaXMgbm90IGlkZW1wb3RlbnQuXG4vLyBUaGlzIGNhbiBoYXBwZW4gaWYgYSBtZW1vaXplZCBmdW5jdGlvbiBvciBDb21tb25KUyBtb2R1bGUgZG9lc24ndCB0aHJvdyBhZnRlciBmaXJzdCBpbnZvY2F0aW9uLlxudGhyb3cgb3JpZ2luYWxFcnJvcjt9fTt9dmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyPWZhbHNlO3ZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQ7e2RpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudD1uZXcgU2V0KCk7fWZ1bmN0aW9uIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKXt7aWYoaXNSZW5kZXJpbmcmJiFnZXRJc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlSW5ERVYoKSl7c3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50Ont2YXIgcmVuZGVyaW5nQ29tcG9uZW50TmFtZT13b3JrSW5Qcm9ncmVzcyYmZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcyl8fCdVbmtub3duJzsvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cbnZhciBkZWR1cGVLZXk9cmVuZGVyaW5nQ29tcG9uZW50TmFtZTtpZighZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKXtkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuYWRkKGRlZHVwZUtleSk7dmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J1Vua25vd24nO2Vycm9yKCdDYW5ub3QgdXBkYXRlIGEgY29tcG9uZW50IChgJXNgKSB3aGlsZSByZW5kZXJpbmcgYSAnKydkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCAnKydmb2xsb3cgdGhlIHN0YWNrIHRyYWNlIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc2V0c3RhdGUtaW4tcmVuZGVyJyxzZXRTdGF0ZUNvbXBvbmVudE5hbWUscmVuZGVyaW5nQ29tcG9uZW50TmFtZSxyZW5kZXJpbmdDb21wb25lbnROYW1lKTt9YnJlYWs7fWNhc2UgQ2xhc3NDb21wb25lbnQ6e2lmKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlcil7ZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJysnd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSAnKydmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuJyk7ZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXI9dHJ1ZTt9YnJlYWs7fX19fX1mdW5jdGlvbiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsbGFuZXMpe3tpZihpc0RldlRvb2xzUHJlc2VudCl7dmFyIG1lbW9pemVkVXBkYXRlcnM9cm9vdC5tZW1vaXplZFVwZGF0ZXJzO21lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbihzY2hlZHVsaW5nRmliZXIpe2FkZEZpYmVyVG9MYW5lc01hcChyb290LHNjaGVkdWxpbmdGaWJlcixsYW5lcyk7fSk7Ly8gVGhpcyBmdW5jdGlvbiBpbnRlbnRpb25hbGx5IGRvZXMgbm90IGNsZWFyIG1lbW9pemVkIHVwZGF0ZXJzLlxuLy8gVGhvc2UgbWF5IHN0aWxsIGJlIHJlbGV2YW50IHRvIHRoZSBjdXJyZW50IGNvbW1pdFxuLy8gYW5kIGEgZnV0dXJlIG9uZSAoZS5nLiBTdXNwZW5zZSkuXG59fX12YXIgZmFrZUFjdENhbGxiYWNrTm9kZT17fTtmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrJDEocHJpb3JpdHlMZXZlbCxjYWxsYmFjayl7ey8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYW4gYGFjdGAgc2NvcGUsIGJ5cGFzcyBTY2hlZHVsZXIgYW5kIHB1c2ggdG9cbi8vIHRoZSBgYWN0YCBxdWV1ZSBpbnN0ZWFkLlxudmFyIGFjdFF1ZXVlPVJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudDtpZihhY3RRdWV1ZSE9PW51bGwpe2FjdFF1ZXVlLnB1c2goY2FsbGJhY2spO3JldHVybiBmYWtlQWN0Q2FsbGJhY2tOb2RlO31lbHNle3JldHVybiBzY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsY2FsbGJhY2spO319fWZ1bmN0aW9uIGNhbmNlbENhbGxiYWNrJDEoY2FsbGJhY2tOb2RlKXtpZihjYWxsYmFja05vZGU9PT1mYWtlQWN0Q2FsbGJhY2tOb2RlKXtyZXR1cm47fS8vIEluIHByb2R1Y3Rpb24sIGFsd2F5cyBjYWxsIFNjaGVkdWxlci4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHN0cmlwcGVkIG91dC5cbnJldHVybiBjYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpO31mdW5jdGlvbiBzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKXsvLyBOZXZlciBmb3JjZSBmbHVzaCBpbiBwcm9kdWN0aW9uLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBnZXQgc3RyaXBwZWQgb3V0LlxucmV0dXJuIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCE9PW51bGw7fWZ1bmN0aW9uIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcil7e2lmKGZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpe2lmKCFpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpKXsvLyBOb3QgaW4gYW4gYWN0IGVudmlyb25tZW50LiBObyBuZWVkIHRvIHdhcm4uXG5yZXR1cm47fX1lbHNley8vIExlZ2FjeSBtb2RlIGhhcyBhZGRpdGlvbmFsIGNhc2VzIHdoZXJlIHdlIHN1cHByZXNzIGEgd2FybmluZy5cbmlmKCFpc0xlZ2FjeUFjdEVudmlyb25tZW50KCkpey8vIE5vdCBpbiBhbiBhY3QgZW52aXJvbm1lbnQuIE5vIG5lZWQgdG8gd2Fybi5cbnJldHVybjt9aWYoZXhlY3V0aW9uQ29udGV4dCE9PU5vQ29udGV4dCl7Ly8gTGVnYWN5IG1vZGUgZG9lc24ndCB3YXJuIGlmIHRoZSB1cGRhdGUgaXMgYmF0Y2hlZCwgaS5lLlxuLy8gYmF0Y2hlZFVwZGF0ZXMgb3IgZmx1c2hTeW5jLlxucmV0dXJuO31pZihmaWJlci50YWchPT1GdW5jdGlvbkNvbXBvbmVudCYmZmliZXIudGFnIT09Rm9yd2FyZFJlZiYmZmliZXIudGFnIT09U2ltcGxlTWVtb0NvbXBvbmVudCl7Ly8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggcHJlLWhvb2tzIGNvZGUsIGxlZ2FjeSBtb2RlIG9ubHlcbi8vIHdhcm5zIGZvciB1cGRhdGVzIHRoYXQgb3JpZ2luYXRlIGZyb20gYSBob29rLlxucmV0dXJuO319aWYoUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50PT09bnVsbCl7dmFyIHByZXZpb3VzRmliZXI9Y3VycmVudDt0cnl7c2V0Q3VycmVudEZpYmVyKGZpYmVyKTtlcnJvcignQW4gdXBkYXRlIHRvICVzIGluc2lkZSBhIHRlc3Qgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicrJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSAnKyd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJysnYWN0KCgpID0+IHtcXG4nKycgIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxuJysnfSk7XFxuJysnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nK1wiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIisnaW4gdGhlIGJyb3dzZXIuJysnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpKTt9ZmluYWxseXtpZihwcmV2aW91c0ZpYmVyKXtzZXRDdXJyZW50RmliZXIoZmliZXIpO31lbHNle3Jlc2V0Q3VycmVudEZpYmVyKCk7fX19fX1mdW5jdGlvbiB3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFVihyb290KXt7aWYocm9vdC50YWchPT1MZWdhY3lSb290JiZpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpJiZSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQ9PT1udWxsKXtlcnJvcignQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50ICcrJ3dhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nKydXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCByZXNvbHZlcyBzdXNwZW5kZWQgZGF0YSBzaG91bGQgYmUgd3JhcHBlZCAnKydpbnRvIGFjdCguLi4pOlxcblxcbicrJ2FjdCgoKSA9PiB7XFxuJysnICAvKiBmaW5pc2ggbG9hZGluZyBzdXNwZW5kZWQgZGF0YSAqL1xcbicrJ30pO1xcbicrJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJytcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIrJ2luIHRoZSBicm93c2VyLicrJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0Jyk7fX19ZnVuY3Rpb24gc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGlzUnVubmluZyl7e2lzUnVubmluZ0luc2VydGlvbkVmZmVjdD1pc1J1bm5pbmc7fX0vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzICovdmFyIHJlc29sdmVGYW1pbHk9bnVsbDsvLyAkRmxvd0ZpeE1lIEZsb3cgZ2V0cyBjb25mdXNlZCBieSBhIFdlYWtTZXQgZmVhdHVyZSBjaGVjayBiZWxvdy5cbnZhciBmYWlsZWRCb3VuZGFyaWVzPW51bGw7dmFyIHNldFJlZnJlc2hIYW5kbGVyPWZ1bmN0aW9uKGhhbmRsZXIpe3tyZXNvbHZlRmFtaWx5PWhhbmRsZXI7fX07ZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpe3tpZihyZXNvbHZlRmFtaWx5PT09bnVsbCl7Ly8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbnJldHVybiB0eXBlO312YXIgZmFtaWx5PXJlc29sdmVGYW1pbHkodHlwZSk7aWYoZmFtaWx5PT09dW5kZWZpbmVkKXtyZXR1cm4gdHlwZTt9Ly8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5yZXR1cm4gZmFtaWx5LmN1cnJlbnQ7fX1mdW5jdGlvbiByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcodHlwZSl7Ly8gTm8gaW1wbGVtZW50YXRpb24gZGlmZmVyZW5jZXMuXG5yZXR1cm4gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO31mdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKXt7aWYocmVzb2x2ZUZhbWlseT09PW51bGwpey8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG5yZXR1cm4gdHlwZTt9dmFyIGZhbWlseT1yZXNvbHZlRmFtaWx5KHR5cGUpO2lmKGZhbWlseT09PXVuZGVmaW5lZCl7Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgcmVhbCBmb3J3YXJkUmVmLiBEb24ndCB3YW50IHRvIGNyYXNoIGVhcmx5LlxuaWYodHlwZSE9PW51bGwmJnR5cGUhPT11bmRlZmluZWQmJnR5cGVvZiB0eXBlLnJlbmRlcj09PSdmdW5jdGlvbicpey8vIEZvcndhcmRSZWYgaXMgc3BlY2lhbCBiZWNhdXNlIGl0cyByZXNvbHZlZCAudHlwZSBpcyBhbiBvYmplY3QsXG4vLyBidXQgaXQncyBwb3NzaWJsZSB0aGF0IHdlIG9ubHkgaGF2ZSBpdHMgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGluIHRoZSBtYXAuXG4vLyBJZiB0aGF0IGlubmVyIHJlbmRlciBmdW5jdGlvbiBpcyBkaWZmZXJlbnQsIHdlJ2xsIGJ1aWxkIGEgbmV3IGZvcndhcmRSZWYgdHlwZS5cbnZhciBjdXJyZW50UmVuZGVyPXJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcik7aWYodHlwZS5yZW5kZXIhPT1jdXJyZW50UmVuZGVyKXt2YXIgc3ludGhldGljVHlwZT17JCR0eXBlb2Y6UkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxyZW5kZXI6Y3VycmVudFJlbmRlcn07aWYodHlwZS5kaXNwbGF5TmFtZSE9PXVuZGVmaW5lZCl7c3ludGhldGljVHlwZS5kaXNwbGF5TmFtZT10eXBlLmRpc3BsYXlOYW1lO31yZXR1cm4gc3ludGhldGljVHlwZTt9fXJldHVybiB0eXBlO30vLyBVc2UgdGhlIGxhdGVzdCBrbm93biBpbXBsZW1lbnRhdGlvbi5cbnJldHVybiBmYW1pbHkuY3VycmVudDt9fWZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlcixlbGVtZW50KXt7aWYocmVzb2x2ZUZhbWlseT09PW51bGwpey8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG5yZXR1cm4gZmFsc2U7fXZhciBwcmV2VHlwZT1maWJlci5lbGVtZW50VHlwZTt2YXIgbmV4dFR5cGU9ZWxlbWVudC50eXBlOy8vIElmIHdlIGdvdCBoZXJlLCB3ZSBrbm93IHR5cGVzIGFyZW4ndCA9PT0gZXF1YWwuXG52YXIgbmVlZHNDb21wYXJlRmFtaWxpZXM9ZmFsc2U7dmFyICQkdHlwZW9mTmV4dFR5cGU9dHlwZW9mIG5leHRUeXBlPT09J29iamVjdCcmJm5leHRUeXBlIT09bnVsbD9uZXh0VHlwZS4kJHR5cGVvZjpudWxsO3N3aXRjaChmaWJlci50YWcpe2Nhc2UgQ2xhc3NDb21wb25lbnQ6e2lmKHR5cGVvZiBuZXh0VHlwZT09PSdmdW5jdGlvbicpe25lZWRzQ29tcGFyZUZhbWlsaWVzPXRydWU7fWJyZWFrO31jYXNlIEZ1bmN0aW9uQ29tcG9uZW50OntpZih0eXBlb2YgbmV4dFR5cGU9PT0nZnVuY3Rpb24nKXtuZWVkc0NvbXBhcmVGYW1pbGllcz10cnVlO31lbHNlIGlmKCQkdHlwZW9mTmV4dFR5cGU9PT1SRUFDVF9MQVpZX1RZUEUpey8vIFdlIGRvbid0IGtub3cgdGhlIGlubmVyIHR5cGUgeWV0LlxuLy8gV2UncmUgZ29pbmcgdG8gYXNzdW1lIHRoYXQgdGhlIGxhenkgaW5uZXIgdHlwZSBpcyBzdGFibGUsXG4vLyBhbmQgc28gaXQgaXMgc3VmZmljaWVudCB0byBhdm9pZCByZWNvbmNpbGluZyBpdCBhd2F5LlxuLy8gV2UncmUgbm90IGdvaW5nIHRvIHVud3JhcCBvciBhY3R1YWxseSB1c2UgdGhlIG5ldyBsYXp5IHR5cGUuXG5uZWVkc0NvbXBhcmVGYW1pbGllcz10cnVlO31icmVhazt9Y2FzZSBGb3J3YXJkUmVmOntpZigkJHR5cGVvZk5leHRUeXBlPT09UkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSl7bmVlZHNDb21wYXJlRmFtaWxpZXM9dHJ1ZTt9ZWxzZSBpZigkJHR5cGVvZk5leHRUeXBlPT09UkVBQ1RfTEFaWV9UWVBFKXtuZWVkc0NvbXBhcmVGYW1pbGllcz10cnVlO31icmVhazt9Y2FzZSBNZW1vQ29tcG9uZW50OmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7aWYoJCR0eXBlb2ZOZXh0VHlwZT09PVJFQUNUX01FTU9fVFlQRSl7Ly8gVE9ETzogaWYgaXQgd2FzIGJ1dCBjYW4gbm8gbG9uZ2VyIGJlIHNpbXBsZSxcbi8vIHdlIHNob3VsZG4ndCBzZXQgdGhpcy5cbm5lZWRzQ29tcGFyZUZhbWlsaWVzPXRydWU7fWVsc2UgaWYoJCR0eXBlb2ZOZXh0VHlwZT09PVJFQUNUX0xBWllfVFlQRSl7bmVlZHNDb21wYXJlRmFtaWxpZXM9dHJ1ZTt9YnJlYWs7fWRlZmF1bHQ6cmV0dXJuIGZhbHNlO30vLyBDaGVjayBpZiBib3RoIHR5cGVzIGhhdmUgYSBmYW1pbHkgYW5kIGl0J3MgdGhlIHNhbWUgb25lLlxuaWYobmVlZHNDb21wYXJlRmFtaWxpZXMpey8vIE5vdGU6IG1lbW8oKSBhbmQgZm9yd2FyZFJlZigpIHdlJ2xsIGNvbXBhcmUgb3V0ZXIgcmF0aGVyIHRoYW4gaW5uZXIgdHlwZS5cbi8vIFRoaXMgbWVhbnMgYm90aCBvZiB0aGVtIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCB0byBwcmVzZXJ2ZSBzdGF0ZS5cbi8vIElmIHdlIHVud3JhcHBlZCBhbmQgY29tcGFyZWQgdGhlIGlubmVyIHR5cGVzIGZvciB3cmFwcGVycyBpbnN0ZWFkLFxuLy8gdGhlbiB3ZSB3b3VsZCByaXNrIGZhbHNlbHkgc2F5aW5nIHR3byBzZXBhcmF0ZSBtZW1vKEZvbylcbi8vIGNhbGxzIGFyZSBlcXVpdmFsZW50IGJlY2F1c2UgdGhleSB3cmFwIHRoZSBzYW1lIEZvbyBmdW5jdGlvbi5cbnZhciBwcmV2RmFtaWx5PXJlc29sdmVGYW1pbHkocHJldlR5cGUpO2lmKHByZXZGYW1pbHkhPT11bmRlZmluZWQmJnByZXZGYW1pbHk9PT1yZXNvbHZlRmFtaWx5KG5leHRUeXBlKSl7cmV0dXJuIHRydWU7fX1yZXR1cm4gZmFsc2U7fX1mdW5jdGlvbiBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcil7e2lmKHJlc29sdmVGYW1pbHk9PT1udWxsKXsvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxucmV0dXJuO31pZih0eXBlb2YgV2Vha1NldCE9PSdmdW5jdGlvbicpe3JldHVybjt9aWYoZmFpbGVkQm91bmRhcmllcz09PW51bGwpe2ZhaWxlZEJvdW5kYXJpZXM9bmV3IFdlYWtTZXQoKTt9ZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpO319dmFyIHNjaGVkdWxlUmVmcmVzaD1mdW5jdGlvbihyb290LHVwZGF0ZSl7e2lmKHJlc29sdmVGYW1pbHk9PT1udWxsKXsvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxucmV0dXJuO312YXIgc3RhbGVGYW1pbGllcz11cGRhdGUuc3RhbGVGYW1pbGllcyx1cGRhdGVkRmFtaWxpZXM9dXBkYXRlLnVwZGF0ZWRGYW1pbGllcztmbHVzaFBhc3NpdmVFZmZlY3RzKCk7Zmx1c2hTeW5jKGZ1bmN0aW9uKCl7c2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsdXBkYXRlZEZhbWlsaWVzLHN0YWxlRmFtaWxpZXMpO30pO319O3ZhciBzY2hlZHVsZVJvb3Q9ZnVuY3Rpb24ocm9vdCxlbGVtZW50KXt7aWYocm9vdC5jb250ZXh0IT09ZW1wdHlDb250ZXh0T2JqZWN0KXsvLyBTdXBlciBlZGdlIGNhc2U6IHJvb3QgaGFzIGEgbGVnYWN5IF9yZW5kZXJTdWJ0cmVlIGNvbnRleHRcbi8vIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSBwYXJlbnRDb21wb25lbnQgc28gd2UgY2FuJ3QgcGFzcyBpdC5cbi8vIEp1c3QgaWdub3JlLiBXZSdsbCBkZWxldGUgdGhpcyB3aXRoIF9yZW5kZXJTdWJ0cmVlIGNvZGUgcGF0aCBsYXRlci5cbnJldHVybjt9Zmx1c2hQYXNzaXZlRWZmZWN0cygpO2ZsdXNoU3luYyhmdW5jdGlvbigpe3VwZGF0ZUNvbnRhaW5lcihlbGVtZW50LHJvb3QsbnVsbCxudWxsKTt9KTt9fTtmdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGZpYmVyLHVwZGF0ZWRGYW1pbGllcyxzdGFsZUZhbWlsaWVzKXt7dmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGUsY2hpbGQ9ZmliZXIuY2hpbGQsc2libGluZz1maWJlci5zaWJsaW5nLHRhZz1maWJlci50YWcsdHlwZT1maWJlci50eXBlO3ZhciBjYW5kaWRhdGVUeXBlPW51bGw7c3dpdGNoKHRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6Y2FzZSBDbGFzc0NvbXBvbmVudDpjYW5kaWRhdGVUeXBlPXR5cGU7YnJlYWs7Y2FzZSBGb3J3YXJkUmVmOmNhbmRpZGF0ZVR5cGU9dHlwZS5yZW5kZXI7YnJlYWs7fWlmKHJlc29sdmVGYW1pbHk9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlc29sdmVGYW1pbHkgdG8gYmUgc2V0IGR1cmluZyBob3QgcmVsb2FkLicpO312YXIgbmVlZHNSZW5kZXI9ZmFsc2U7dmFyIG5lZWRzUmVtb3VudD1mYWxzZTtpZihjYW5kaWRhdGVUeXBlIT09bnVsbCl7dmFyIGZhbWlseT1yZXNvbHZlRmFtaWx5KGNhbmRpZGF0ZVR5cGUpO2lmKGZhbWlseSE9PXVuZGVmaW5lZCl7aWYoc3RhbGVGYW1pbGllcy5oYXMoZmFtaWx5KSl7bmVlZHNSZW1vdW50PXRydWU7fWVsc2UgaWYodXBkYXRlZEZhbWlsaWVzLmhhcyhmYW1pbHkpKXtpZih0YWc9PT1DbGFzc0NvbXBvbmVudCl7bmVlZHNSZW1vdW50PXRydWU7fWVsc2V7bmVlZHNSZW5kZXI9dHJ1ZTt9fX19aWYoZmFpbGVkQm91bmRhcmllcyE9PW51bGwpe2lmKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKXx8YWx0ZXJuYXRlIT09bnVsbCYmZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSl7bmVlZHNSZW1vdW50PXRydWU7fX1pZihuZWVkc1JlbW91bnQpe2ZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudD10cnVlO31pZihuZWVkc1JlbW91bnR8fG5lZWRzUmVuZGVyKXt2YXIgX3Jvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihfcm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihfcm9vdCxmaWJlcixTeW5jTGFuZSxOb1RpbWVzdGFtcCk7fX1pZihjaGlsZCE9PW51bGwmJiFuZWVkc1JlbW91bnQpe3NjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoY2hpbGQsdXBkYXRlZEZhbWlsaWVzLHN0YWxlRmFtaWxpZXMpO31pZihzaWJsaW5nIT09bnVsbCl7c2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShzaWJsaW5nLHVwZGF0ZWRGYW1pbGllcyxzdGFsZUZhbWlsaWVzKTt9fX12YXIgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoPWZ1bmN0aW9uKHJvb3QsZmFtaWxpZXMpe3t2YXIgaG9zdEluc3RhbmNlcz1uZXcgU2V0KCk7dmFyIHR5cGVzPW5ldyBTZXQoZmFtaWxpZXMubWFwKGZ1bmN0aW9uKGZhbWlseSl7cmV0dXJuIGZhbWlseS5jdXJyZW50O30pKTtmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LHR5cGVzLGhvc3RJbnN0YW5jZXMpO3JldHVybiBob3N0SW5zdGFuY2VzO319O2Z1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShmaWJlcix0eXBlcyxob3N0SW5zdGFuY2VzKXt7dmFyIGNoaWxkPWZpYmVyLmNoaWxkLHNpYmxpbmc9ZmliZXIuc2libGluZyx0YWc9ZmliZXIudGFnLHR5cGU9ZmliZXIudHlwZTt2YXIgY2FuZGlkYXRlVHlwZT1udWxsO3N3aXRjaCh0YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OmNhc2UgQ2xhc3NDb21wb25lbnQ6Y2FuZGlkYXRlVHlwZT10eXBlO2JyZWFrO2Nhc2UgRm9yd2FyZFJlZjpjYW5kaWRhdGVUeXBlPXR5cGUucmVuZGVyO2JyZWFrO312YXIgZGlkTWF0Y2g9ZmFsc2U7aWYoY2FuZGlkYXRlVHlwZSE9PW51bGwpe2lmKHR5cGVzLmhhcyhjYW5kaWRhdGVUeXBlKSl7ZGlkTWF0Y2g9dHJ1ZTt9fWlmKGRpZE1hdGNoKXsvLyBXZSBoYXZlIGEgbWF0Y2guIFRoaXMgb25seSBkcmlsbHMgZG93biB0byB0aGUgY2xvc2VzdCBob3N0IGNvbXBvbmVudHMuXG4vLyBUaGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoIGRlZXBlciBiZWNhdXNlIGZvciB0aGUgcHVycG9zZSBvZiBnaXZpbmdcbi8vIHZpc3VhbCBmZWVkYmFjaywgXCJmbGFzaGluZ1wiIG91dGVybW9zdCBwYXJlbnQgcmVjdGFuZ2xlcyBpcyBzdWZmaWNpZW50LlxuZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlcixob3N0SW5zdGFuY2VzKTt9ZWxzZXsvLyBJZiB0aGVyZSdzIG5vIG1hdGNoLCBtYXliZSB0aGVyZSB3aWxsIGJlIG9uZSBmdXJ0aGVyIGRvd24gaW4gdGhlIGNoaWxkIHRyZWUuXG5pZihjaGlsZCE9PW51bGwpe2ZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShjaGlsZCx0eXBlcyxob3N0SW5zdGFuY2VzKTt9fWlmKHNpYmxpbmchPT1udWxsKXtmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoc2libGluZyx0eXBlcyxob3N0SW5zdGFuY2VzKTt9fX1mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLGhvc3RJbnN0YW5jZXMpe3t2YXIgZm91bmRIb3N0SW5zdGFuY2VzPWZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlcixob3N0SW5zdGFuY2VzKTtpZihmb3VuZEhvc3RJbnN0YW5jZXMpe3JldHVybjt9Ly8gSWYgd2UgZGlkbid0IGZpbmQgYW55IGhvc3QgY2hpbGRyZW4sIGZhbGxiYWNrIHRvIGNsb3Nlc3QgaG9zdCBwYXJlbnQuXG52YXIgbm9kZT1maWJlcjt3aGlsZSh0cnVlKXtzd2l0Y2gobm9kZS50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDpob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7cmV0dXJuO2Nhc2UgSG9zdFBvcnRhbDpob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtyZXR1cm47Y2FzZSBIb3N0Um9vdDpob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtyZXR1cm47fWlmKG5vZGUucmV0dXJuPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byByZWFjaCByb290IGZpcnN0LicpO31ub2RlPW5vZGUucmV0dXJuO319fWZ1bmN0aW9uIGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlcixob3N0SW5zdGFuY2VzKXt7dmFyIG5vZGU9ZmliZXI7dmFyIGZvdW5kSG9zdEluc3RhbmNlcz1mYWxzZTt3aGlsZSh0cnVlKXtpZihub2RlLnRhZz09PUhvc3RDb21wb25lbnQpey8vIFdlIGdvdCBhIG1hdGNoLlxuZm91bmRIb3N0SW5zdGFuY2VzPXRydWU7aG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpOy8vIFRoZXJlIG1heSBzdGlsbCBiZSBtb3JlLCBzbyBrZWVwIHNlYXJjaGluZy5cbn1lbHNlIGlmKG5vZGUuY2hpbGQhPT1udWxsKXtub2RlLmNoaWxkLnJldHVybj1ub2RlO25vZGU9bm9kZS5jaGlsZDtjb250aW51ZTt9aWYobm9kZT09PWZpYmVyKXtyZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO313aGlsZShub2RlLnNpYmxpbmc9PT1udWxsKXtpZihub2RlLnJldHVybj09PW51bGx8fG5vZGUucmV0dXJuPT09ZmliZXIpe3JldHVybiBmb3VuZEhvc3RJbnN0YW5jZXM7fW5vZGU9bm9kZS5yZXR1cm47fW5vZGUuc2libGluZy5yZXR1cm49bm9kZS5yZXR1cm47bm9kZT1ub2RlLnNpYmxpbmc7fX1yZXR1cm4gZmFsc2U7fXZhciBoYXNCYWRNYXBQb2x5ZmlsbDt7aGFzQmFkTWFwUG9seWZpbGw9ZmFsc2U7dHJ5e3ZhciBub25FeHRlbnNpYmxlT2JqZWN0PU9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7LyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsbnVsbF1dKTtuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7LyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi99Y2F0Y2goZSl7Ly8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG5oYXNCYWRNYXBQb2x5ZmlsbD10cnVlO319ZnVuY3Rpb24gRmliZXJOb2RlKHRhZyxwZW5kaW5nUHJvcHMsa2V5LG1vZGUpey8vIEluc3RhbmNlXG50aGlzLnRhZz10YWc7dGhpcy5rZXk9a2V5O3RoaXMuZWxlbWVudFR5cGU9bnVsbDt0aGlzLnR5cGU9bnVsbDt0aGlzLnN0YXRlTm9kZT1udWxsOy8vIEZpYmVyXG50aGlzLnJldHVybj1udWxsO3RoaXMuY2hpbGQ9bnVsbDt0aGlzLnNpYmxpbmc9bnVsbDt0aGlzLmluZGV4PTA7dGhpcy5yZWY9bnVsbDt0aGlzLnBlbmRpbmdQcm9wcz1wZW5kaW5nUHJvcHM7dGhpcy5tZW1vaXplZFByb3BzPW51bGw7dGhpcy51cGRhdGVRdWV1ZT1udWxsO3RoaXMubWVtb2l6ZWRTdGF0ZT1udWxsO3RoaXMuZGVwZW5kZW5jaWVzPW51bGw7dGhpcy5tb2RlPW1vZGU7Ly8gRWZmZWN0c1xudGhpcy5mbGFncz1Ob0ZsYWdzO3RoaXMuc3VidHJlZUZsYWdzPU5vRmxhZ3M7dGhpcy5kZWxldGlvbnM9bnVsbDt0aGlzLmxhbmVzPU5vTGFuZXM7dGhpcy5jaGlsZExhbmVzPU5vTGFuZXM7dGhpcy5hbHRlcm5hdGU9bnVsbDt7Ly8gTm90ZTogVGhlIGZvbGxvd2luZyBpcyBkb25lIHRvIGF2b2lkIGEgdjggcGVyZm9ybWFuY2UgY2xpZmYuXG4vL1xuLy8gSW5pdGlhbGl6aW5nIHRoZSBmaWVsZHMgYmVsb3cgdG8gc21pcyBhbmQgbGF0ZXIgdXBkYXRpbmcgdGhlbSB3aXRoXG4vLyBkb3VibGUgdmFsdWVzIHdpbGwgY2F1c2UgRmliZXJzIHRvIGVuZCB1cCBoYXZpbmcgc2VwYXJhdGUgc2hhcGVzLlxuLy8gVGhpcyBiZWhhdmlvci9idWcgaGFzIHNvbWV0aGluZyB0byBkbyB3aXRoIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9uKCkuXG4vLyBGb3J0dW5hdGVseSB0aGlzIG9ubHkgaW1wYWN0cyBERVYgYnVpbGRzLlxuLy8gVW5mb3J0dW5hdGVseSBpdCBtYWtlcyBSZWFjdCB1bnVzYWJseSBzbG93IGZvciBzb21lIGFwcGxpY2F0aW9ucy5cbi8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIGluaXRpYWxpemUgdGhlIGZpZWxkcyBiZWxvdyB3aXRoIGRvdWJsZXMuXG4vL1xuLy8gTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MzY1XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD04NTM4XG50aGlzLmFjdHVhbER1cmF0aW9uPU51bWJlci5OYU47dGhpcy5hY3R1YWxTdGFydFRpbWU9TnVtYmVyLk5hTjt0aGlzLnNlbGZCYXNlRHVyYXRpb249TnVtYmVyLk5hTjt0aGlzLnRyZWVCYXNlRHVyYXRpb249TnVtYmVyLk5hTjsvLyBJdCdzIG9rYXkgdG8gcmVwbGFjZSB0aGUgaW5pdGlhbCBkb3VibGVzIHdpdGggc21pcyBhZnRlciBpbml0aWFsaXphdGlvbi5cbi8vIFRoaXMgd29uJ3QgdHJpZ2dlciB0aGUgcGVyZm9ybWFuY2UgY2xpZmYgbWVudGlvbmVkIGFib3ZlLFxuLy8gYW5kIGl0IHNpbXBsaWZpZXMgb3RoZXIgcHJvZmlsZXIgY29kZSAoaW5jbHVkaW5nIERldlRvb2xzKS5cbnRoaXMuYWN0dWFsRHVyYXRpb249MDt0aGlzLmFjdHVhbFN0YXJ0VGltZT0tMTt0aGlzLnNlbGZCYXNlRHVyYXRpb249MDt0aGlzLnRyZWVCYXNlRHVyYXRpb249MDt9ey8vIFRoaXMgaXNuJ3QgZGlyZWN0bHkgdXNlZCBidXQgaXMgaGFuZHkgZm9yIGRlYnVnZ2luZyBpbnRlcm5hbHM6XG50aGlzLl9kZWJ1Z1NvdXJjZT1udWxsO3RoaXMuX2RlYnVnT3duZXI9bnVsbDt0aGlzLl9kZWJ1Z05lZWRzUmVtb3VudD1mYWxzZTt0aGlzLl9kZWJ1Z0hvb2tUeXBlcz1udWxsO2lmKCFoYXNCYWRNYXBQb2x5ZmlsbCYmdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucz09PSdmdW5jdGlvbicpe09iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTt9fX0vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlcj1mdW5jdGlvbih0YWcscGVuZGluZ1Byb3BzLGtleSxtb2RlKXsvLyAkRmxvd0ZpeE1lOiB0aGUgc2hhcGVzIGFyZSBleGFjdCBoZXJlIGJ1dCBGbG93IGRvZXNuJ3QgbGlrZSBjb25zdHJ1Y3RvcnNcbnJldHVybiBuZXcgRmliZXJOb2RlKHRhZyxwZW5kaW5nUHJvcHMsa2V5LG1vZGUpO307ZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KXt2YXIgcHJvdG90eXBlPUNvbXBvbmVudC5wcm90b3R5cGU7cmV0dXJuISEocHJvdG90eXBlJiZwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7fWZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSl7cmV0dXJuIHR5cGVvZiB0eXBlPT09J2Z1bmN0aW9uJyYmIXNob3VsZENvbnN0cnVjdCQxKHR5cGUpJiZ0eXBlLmRlZmF1bHRQcm9wcz09PXVuZGVmaW5lZDt9ZnVuY3Rpb24gcmVzb2x2ZUxhenlDb21wb25lbnRUYWcoQ29tcG9uZW50KXtpZih0eXBlb2YgQ29tcG9uZW50PT09J2Z1bmN0aW9uJyl7cmV0dXJuIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCk/Q2xhc3NDb21wb25lbnQ6RnVuY3Rpb25Db21wb25lbnQ7fWVsc2UgaWYoQ29tcG9uZW50IT09dW5kZWZpbmVkJiZDb21wb25lbnQhPT1udWxsKXt2YXIgJCR0eXBlb2Y9Q29tcG9uZW50LiQkdHlwZW9mO2lmKCQkdHlwZW9mPT09UkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSl7cmV0dXJuIEZvcndhcmRSZWY7fWlmKCQkdHlwZW9mPT09UkVBQ1RfTUVNT19UWVBFKXtyZXR1cm4gTWVtb0NvbXBvbmVudDt9fXJldHVybiBJbmRldGVybWluYXRlQ29tcG9uZW50O30vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCxwZW5kaW5nUHJvcHMpe3ZhciB3b3JrSW5Qcm9ncmVzcz1jdXJyZW50LmFsdGVybmF0ZTtpZih3b3JrSW5Qcm9ncmVzcz09PW51bGwpey8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbi8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbi8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG53b3JrSW5Qcm9ncmVzcz1jcmVhdGVGaWJlcihjdXJyZW50LnRhZyxwZW5kaW5nUHJvcHMsY3VycmVudC5rZXksY3VycmVudC5tb2RlKTt3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZT1jdXJyZW50LmVsZW1lbnRUeXBlO3dvcmtJblByb2dyZXNzLnR5cGU9Y3VycmVudC50eXBlO3dvcmtJblByb2dyZXNzLnN0YXRlTm9kZT1jdXJyZW50LnN0YXRlTm9kZTt7Ly8gREVWLW9ubHkgZmllbGRzXG53b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U9Y3VycmVudC5fZGVidWdTb3VyY2U7d29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXI9Y3VycmVudC5fZGVidWdPd25lcjt3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXM9Y3VycmVudC5fZGVidWdIb29rVHlwZXM7fXdvcmtJblByb2dyZXNzLmFsdGVybmF0ZT1jdXJyZW50O2N1cnJlbnQuYWx0ZXJuYXRlPXdvcmtJblByb2dyZXNzO31lbHNle3dvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcz1wZW5kaW5nUHJvcHM7Ly8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cbndvcmtJblByb2dyZXNzLnR5cGU9Y3VycmVudC50eXBlOy8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4vLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbndvcmtJblByb2dyZXNzLmZsYWdzPU5vRmxhZ3M7Ly8gVGhlIGVmZmVjdHMgYXJlIG5vIGxvbmdlciB2YWxpZC5cbndvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncz1Ob0ZsYWdzO3dvcmtJblByb2dyZXNzLmRlbGV0aW9ucz1udWxsO3svLyBXZSBpbnRlbnRpb25hbGx5IHJlc2V0LCByYXRoZXIgdGhhbiBjb3B5LCBhY3R1YWxEdXJhdGlvbiAmIGFjdHVhbFN0YXJ0VGltZS5cbi8vIFRoaXMgcHJldmVudHMgdGltZSBmcm9tIGVuZGxlc3NseSBhY2N1bXVsYXRpbmcgaW4gbmV3IGNvbW1pdHMuXG4vLyBUaGlzIGhhcyB0aGUgZG93bnNpZGUgb2YgcmVzZXR0aW5nIHZhbHVlcyBmb3IgZGlmZmVyZW50IHByaW9yaXR5IHJlbmRlcnMsXG4vLyBCdXQgd29ya3MgZm9yIHlpZWxkaW5nICh0aGUgY29tbW9uIGNhc2UpIGFuZCBzaG91bGQgc3VwcG9ydCByZXN1bWluZy5cbndvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uPTA7d29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lPS0xO319Ly8gUmVzZXQgYWxsIGVmZmVjdHMgZXhjZXB0IHN0YXRpYyBvbmVzLlxuLy8gU3RhdGljIGVmZmVjdHMgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlci5cbndvcmtJblByb2dyZXNzLmZsYWdzPWN1cnJlbnQuZmxhZ3MmU3RhdGljTWFzazt3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzPWN1cnJlbnQuY2hpbGRMYW5lczt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1jdXJyZW50LmxhbmVzO3dvcmtJblByb2dyZXNzLmNoaWxkPWN1cnJlbnQuY2hpbGQ7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcz1jdXJyZW50Lm1lbW9pemVkUHJvcHM7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9Y3VycmVudC51cGRhdGVRdWV1ZTsvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxudmFyIGN1cnJlbnREZXBlbmRlbmNpZXM9Y3VycmVudC5kZXBlbmRlbmNpZXM7d29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzPWN1cnJlbnREZXBlbmRlbmNpZXM9PT1udWxsP251bGw6e2xhbmVzOmN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsZmlyc3RDb250ZXh0OmN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0fTsvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxud29ya0luUHJvZ3Jlc3Muc2libGluZz1jdXJyZW50LnNpYmxpbmc7d29ya0luUHJvZ3Jlc3MuaW5kZXg9Y3VycmVudC5pbmRleDt3b3JrSW5Qcm9ncmVzcy5yZWY9Y3VycmVudC5yZWY7e3dvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb249Y3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO3dvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb249Y3VycmVudC50cmVlQmFzZUR1cmF0aW9uO317d29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50PWN1cnJlbnQuX2RlYnVnTmVlZHNSZW1vdW50O3N3aXRjaCh3b3JrSW5Qcm9ncmVzcy50YWcpe2Nhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp3b3JrSW5Qcm9ncmVzcy50eXBlPXJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO2JyZWFrO2Nhc2UgQ2xhc3NDb21wb25lbnQ6d29ya0luUHJvZ3Jlc3MudHlwZT1yZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTticmVhaztjYXNlIEZvcndhcmRSZWY6d29ya0luUHJvZ3Jlc3MudHlwZT1yZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO2JyZWFrO319cmV0dXJuIHdvcmtJblByb2dyZXNzO30vLyBVc2VkIHRvIHJldXNlIGEgRmliZXIgZm9yIGEgc2Vjb25kIHBhc3MuXG5mdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXsvLyBUaGlzIHJlc2V0cyB0aGUgRmliZXIgdG8gd2hhdCBjcmVhdGVGaWJlciBvciBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZFxuLy8gaGF2ZSBzZXQgdGhlIHZhbHVlcyB0byBiZWZvcmUgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJZGVhbGx5IHRoaXMgd291bGRuJ3Rcbi8vIGJlIG5lY2Vzc2FyeSBidXQgdW5mb3J0dW5hdGVseSBtYW55IGNvZGUgcGF0aHMgcmVhZHMgZnJvbSB0aGUgd29ya0luUHJvZ3Jlc3Ncbi8vIHdoZW4gdGhleSBzaG91bGQgYmUgcmVhZGluZyBmcm9tIGN1cnJlbnQgYW5kIHdyaXRpbmcgdG8gd29ya0luUHJvZ3Jlc3MuXG4vLyBXZSBhc3N1bWUgcGVuZGluZ1Byb3BzLCBpbmRleCwga2V5LCByZWYsIHJldHVybiBhcmUgc3RpbGwgdW50b3VjaGVkIHRvXG4vLyBhdm9pZCBkb2luZyBhbm90aGVyIHJlY29uY2lsaWF0aW9uLlxuLy8gUmVzZXQgdGhlIGVmZmVjdCBmbGFncyBidXQga2VlcCBhbnkgUGxhY2VtZW50IHRhZ3MsIHNpbmNlIHRoYXQncyBzb21ldGhpbmdcbi8vIHRoYXQgY2hpbGQgZmliZXIgaXMgc2V0dGluZywgbm90IHRoZSByZWNvbmNpbGlhdGlvbi5cbndvcmtJblByb2dyZXNzLmZsYWdzJj1TdGF0aWNNYXNrfFBsYWNlbWVudDsvLyBUaGUgZWZmZWN0cyBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxudmFyIGN1cnJlbnQ9d29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO2lmKGN1cnJlbnQ9PT1udWxsKXsvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxud29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcz1Ob0xhbmVzO3dvcmtJblByb2dyZXNzLmxhbmVzPXJlbmRlckxhbmVzO3dvcmtJblByb2dyZXNzLmNoaWxkPW51bGw7d29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzPU5vRmxhZ3M7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcz1udWxsO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1udWxsO3dvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcz1udWxsO3dvcmtJblByb2dyZXNzLnN0YXRlTm9kZT1udWxsO3svLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbi8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxud29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbj0wO3dvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb249MDt9fWVsc2V7Ly8gUmVzZXQgdG8gdGhlIGNsb25lZCB2YWx1ZXMgdGhhdCBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZCd2ZS5cbndvcmtJblByb2dyZXNzLmNoaWxkTGFuZXM9Y3VycmVudC5jaGlsZExhbmVzO3dvcmtJblByb2dyZXNzLmxhbmVzPWN1cnJlbnQubGFuZXM7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9Y3VycmVudC5jaGlsZDt3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3M9Tm9GbGFnczt3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnM9bnVsbDt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzPWN1cnJlbnQubWVtb2l6ZWRQcm9wczt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1jdXJyZW50LnVwZGF0ZVF1ZXVlOy8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG53b3JrSW5Qcm9ncmVzcy50eXBlPWN1cnJlbnQudHlwZTsvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxudmFyIGN1cnJlbnREZXBlbmRlbmNpZXM9Y3VycmVudC5kZXBlbmRlbmNpZXM7d29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzPWN1cnJlbnREZXBlbmRlbmNpZXM9PT1udWxsP251bGw6e2xhbmVzOmN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsZmlyc3RDb250ZXh0OmN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0fTt7Ly8gTm90ZTogV2UgZG9uJ3QgcmVzZXQgdGhlIGFjdHVhbFRpbWUgY291bnRzLiBJdCdzIHVzZWZ1bCB0byBhY2N1bXVsYXRlXG4vLyBhY3R1YWwgdGltZSBhY3Jvc3MgbXVsdGlwbGUgcmVuZGVyIHBhc3Nlcy5cbndvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb249Y3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO3dvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb249Y3VycmVudC50cmVlQmFzZUR1cmF0aW9uO319cmV0dXJuIHdvcmtJblByb2dyZXNzO31mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZyxpc1N0cmljdE1vZGUsY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSl7dmFyIG1vZGU7aWYodGFnPT09Q29uY3VycmVudFJvb3Qpe21vZGU9Q29uY3VycmVudE1vZGU7aWYoaXNTdHJpY3RNb2RlPT09dHJ1ZSl7bW9kZXw9U3RyaWN0TGVnYWN5TW9kZTt7bW9kZXw9U3RyaWN0RWZmZWN0c01vZGU7fX19ZWxzZXttb2RlPU5vTW9kZTt9aWYoaXNEZXZUb29sc1ByZXNlbnQpey8vIEFsd2F5cyBjb2xsZWN0IHByb2ZpbGUgdGltaW5ncyB3aGVuIERldlRvb2xzIGFyZSBwcmVzZW50LlxuLy8gVGhpcyBlbmFibGVzIERldlRvb2xzIHRvIHN0YXJ0IGNhcHR1cmluZyB0aW1pbmcgYXQgYW55IHBvaW504oCTXG4vLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG5tb2RlfD1Qcm9maWxlTW9kZTt9cmV0dXJuIGNyZWF0ZUZpYmVyKEhvc3RSb290LG51bGwsbnVsbCxtb2RlKTt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHR5cGUsLy8gUmVhY3QkRWxlbWVudFR5cGVcbmtleSxwZW5kaW5nUHJvcHMsb3duZXIsbW9kZSxsYW5lcyl7dmFyIGZpYmVyVGFnPUluZGV0ZXJtaW5hdGVDb21wb25lbnQ7Ly8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG52YXIgcmVzb2x2ZWRUeXBlPXR5cGU7aWYodHlwZW9mIHR5cGU9PT0nZnVuY3Rpb24nKXtpZihzaG91bGRDb25zdHJ1Y3QkMSh0eXBlKSl7ZmliZXJUYWc9Q2xhc3NDb21wb25lbnQ7e3Jlc29sdmVkVHlwZT1yZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTt9fWVsc2V7e3Jlc29sdmVkVHlwZT1yZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTt9fX1lbHNlIGlmKHR5cGVvZiB0eXBlPT09J3N0cmluZycpe2ZpYmVyVGFnPUhvc3RDb21wb25lbnQ7fWVsc2V7Z2V0VGFnOnN3aXRjaCh0eXBlKXtjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6cmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbixtb2RlLGxhbmVzLGtleSk7Y2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOmZpYmVyVGFnPU1vZGU7bW9kZXw9U3RyaWN0TGVnYWN5TW9kZTtpZigobW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGUpey8vIFN0cmljdCBlZmZlY3RzIHNob3VsZCBuZXZlciBydW4gb24gbGVnYWN5IHJvb3RzXG5tb2RlfD1TdHJpY3RFZmZlY3RzTW9kZTt9YnJlYWs7Y2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOnJldHVybiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihwZW5kaW5nUHJvcHMsbW9kZSxsYW5lcyxrZXkpO2Nhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpyZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLG1vZGUsbGFuZXMsa2V5KTtjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpyZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcyxtb2RlLGxhbmVzLGtleSk7Y2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpyZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcyxtb2RlLGxhbmVzLGtleSk7Y2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5jYXNlIFJFQUNUX1NDT1BFX1RZUEU6Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5jYXNlIFJFQUNUX0NBQ0hFX1RZUEU6Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5jYXNlIFJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEU6Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5jYXNlIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFOi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuZGVmYXVsdDp7aWYodHlwZW9mIHR5cGU9PT0nb2JqZWN0JyYmdHlwZSE9PW51bGwpe3N3aXRjaCh0eXBlLiQkdHlwZW9mKXtjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6ZmliZXJUYWc9Q29udGV4dFByb3ZpZGVyO2JyZWFrIGdldFRhZztjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTovLyBUaGlzIGlzIGEgY29uc3VtZXJcbmZpYmVyVGFnPUNvbnRleHRDb25zdW1lcjticmVhayBnZXRUYWc7Y2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOmZpYmVyVGFnPUZvcndhcmRSZWY7e3Jlc29sdmVkVHlwZT1yZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO31icmVhayBnZXRUYWc7Y2FzZSBSRUFDVF9NRU1PX1RZUEU6ZmliZXJUYWc9TWVtb0NvbXBvbmVudDticmVhayBnZXRUYWc7Y2FzZSBSRUFDVF9MQVpZX1RZUEU6ZmliZXJUYWc9TGF6eUNvbXBvbmVudDtyZXNvbHZlZFR5cGU9bnVsbDticmVhayBnZXRUYWc7fX12YXIgaW5mbz0nJzt7aWYodHlwZT09PXVuZGVmaW5lZHx8dHlwZW9mIHR5cGU9PT0nb2JqZWN0JyYmdHlwZSE9PW51bGwmJk9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aD09PTApe2luZm8rPScgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJytcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIrJ25hbWVkIGltcG9ydHMuJzt9dmFyIG93bmVyTmFtZT1vd25lcj9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKTpudWxsO2lmKG93bmVyTmFtZSl7aW5mbys9J1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnK293bmVyTmFtZSsnYC4nO319dGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiAnKydjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcrKFwiYnV0IGdvdDogXCIrKHR5cGU9PW51bGw/dHlwZTp0eXBlb2YgdHlwZSkrXCIuXCIraW5mbykpO319fXZhciBmaWJlcj1jcmVhdGVGaWJlcihmaWJlclRhZyxwZW5kaW5nUHJvcHMsa2V5LG1vZGUpO2ZpYmVyLmVsZW1lbnRUeXBlPXR5cGU7ZmliZXIudHlwZT1yZXNvbHZlZFR5cGU7ZmliZXIubGFuZXM9bGFuZXM7e2ZpYmVyLl9kZWJ1Z093bmVyPW93bmVyO31yZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCxtb2RlLGxhbmVzKXt2YXIgb3duZXI9bnVsbDt7b3duZXI9ZWxlbWVudC5fb3duZXI7fXZhciB0eXBlPWVsZW1lbnQudHlwZTt2YXIga2V5PWVsZW1lbnQua2V5O3ZhciBwZW5kaW5nUHJvcHM9ZWxlbWVudC5wcm9wczt2YXIgZmliZXI9Y3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHR5cGUsa2V5LHBlbmRpbmdQcm9wcyxvd25lcixtb2RlLGxhbmVzKTt7ZmliZXIuX2RlYnVnU291cmNlPWVsZW1lbnQuX3NvdXJjZTtmaWJlci5fZGVidWdPd25lcj1lbGVtZW50Ll9vd25lcjt9cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cyxtb2RlLGxhbmVzLGtleSl7dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKEZyYWdtZW50LGVsZW1lbnRzLGtleSxtb2RlKTtmaWJlci5sYW5lcz1sYW5lcztyZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcyxtb2RlLGxhbmVzLGtleSl7e2lmKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQhPT0nc3RyaW5nJyl7ZXJyb3IoJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgb2YgdHlwZSBgc3RyaW5nYCBhcyBhIHByb3AuIFJlY2VpdmVkIHRoZSB0eXBlIGAlc2AgaW5zdGVhZC4nLHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQpO319dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKFByb2ZpbGVyLHBlbmRpbmdQcm9wcyxrZXksbW9kZXxQcm9maWxlTW9kZSk7ZmliZXIuZWxlbWVudFR5cGU9UkVBQ1RfUFJPRklMRVJfVFlQRTtmaWJlci5sYW5lcz1sYW5lczt7ZmliZXIuc3RhdGVOb2RlPXtlZmZlY3REdXJhdGlvbjowLHBhc3NpdmVFZmZlY3REdXJhdGlvbjowfTt9cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsbW9kZSxsYW5lcyxrZXkpe3ZhciBmaWJlcj1jcmVhdGVGaWJlcihTdXNwZW5zZUNvbXBvbmVudCxwZW5kaW5nUHJvcHMsa2V5LG1vZGUpO2ZpYmVyLmVsZW1lbnRUeXBlPVJFQUNUX1NVU1BFTlNFX1RZUEU7ZmliZXIubGFuZXM9bGFuZXM7cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLG1vZGUsbGFuZXMsa2V5KXt2YXIgZmliZXI9Y3JlYXRlRmliZXIoU3VzcGVuc2VMaXN0Q29tcG9uZW50LHBlbmRpbmdQcm9wcyxrZXksbW9kZSk7ZmliZXIuZWxlbWVudFR5cGU9UkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO2ZpYmVyLmxhbmVzPWxhbmVzO3JldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcyxtb2RlLGxhbmVzLGtleSl7dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKE9mZnNjcmVlbkNvbXBvbmVudCxwZW5kaW5nUHJvcHMsa2V5LG1vZGUpO2ZpYmVyLmVsZW1lbnRUeXBlPVJFQUNUX09GRlNDUkVFTl9UWVBFO2ZpYmVyLmxhbmVzPWxhbmVzO3ZhciBwcmltYXJ5Q2hpbGRJbnN0YW5jZT17aXNIaWRkZW46ZmFsc2V9O2ZpYmVyLnN0YXRlTm9kZT1wcmltYXJ5Q2hpbGRJbnN0YW5jZTtyZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCxtb2RlLGxhbmVzKXt2YXIgZmliZXI9Y3JlYXRlRmliZXIoSG9zdFRleHQsY29udGVudCxudWxsLG1vZGUpO2ZpYmVyLmxhbmVzPWxhbmVzO3JldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKXt2YXIgZmliZXI9Y3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCxudWxsLG51bGwsTm9Nb2RlKTtmaWJlci5lbGVtZW50VHlwZT0nREVMRVRFRCc7cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoZGVoeWRyYXRlZE5vZGUpe3ZhciBmaWJlcj1jcmVhdGVGaWJlcihEZWh5ZHJhdGVkRnJhZ21lbnQsbnVsbCxudWxsLE5vTW9kZSk7ZmliZXIuc3RhdGVOb2RlPWRlaHlkcmF0ZWROb2RlO3JldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCxtb2RlLGxhbmVzKXt2YXIgcGVuZGluZ1Byb3BzPXBvcnRhbC5jaGlsZHJlbiE9PW51bGw/cG9ydGFsLmNoaWxkcmVuOltdO3ZhciBmaWJlcj1jcmVhdGVGaWJlcihIb3N0UG9ydGFsLHBlbmRpbmdQcm9wcyxwb3J0YWwua2V5LG1vZGUpO2ZpYmVyLmxhbmVzPWxhbmVzO2ZpYmVyLnN0YXRlTm9kZT17Y29udGFpbmVySW5mbzpwb3J0YWwuY29udGFpbmVySW5mbyxwZW5kaW5nQ2hpbGRyZW46bnVsbCwvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuaW1wbGVtZW50YXRpb246cG9ydGFsLmltcGxlbWVudGF0aW9ufTtyZXR1cm4gZmliZXI7fS8vIFVzZWQgZm9yIHN0YXNoaW5nIFdJUCBwcm9wZXJ0aWVzIHRvIHJlcGxheSBmYWlsZWQgd29yayBpbiBERVYuXG5mdW5jdGlvbiBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih0YXJnZXQsc291cmNlKXtpZih0YXJnZXQ9PT1udWxsKXsvLyBUaGlzIEZpYmVyJ3MgaW5pdGlhbCBwcm9wZXJ0aWVzIHdpbGwgYWx3YXlzIGJlIG92ZXJ3cml0dGVuLlxuLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxudGFyZ2V0PWNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsbnVsbCxudWxsLE5vTW9kZSk7fS8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIGFzIGEgbGlzdCBvZiBhbGwgcHJvcGVydGllcy5cbi8vIFdlIHRyaWVkIHRvIHVzZSBPYmplY3QuYXNzaWduKCkgaW5zdGVhZCBidXQgdGhpcyBpcyBjYWxsZWQgaW5cbi8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwMlxuLy8gVGhpcyBjb2RlIGlzIERFVi1vbmx5IHNvIHNpemUgaXMgbm90IGEgY29uY2Vybi5cbnRhcmdldC50YWc9c291cmNlLnRhZzt0YXJnZXQua2V5PXNvdXJjZS5rZXk7dGFyZ2V0LmVsZW1lbnRUeXBlPXNvdXJjZS5lbGVtZW50VHlwZTt0YXJnZXQudHlwZT1zb3VyY2UudHlwZTt0YXJnZXQuc3RhdGVOb2RlPXNvdXJjZS5zdGF0ZU5vZGU7dGFyZ2V0LnJldHVybj1zb3VyY2UucmV0dXJuO3RhcmdldC5jaGlsZD1zb3VyY2UuY2hpbGQ7dGFyZ2V0LnNpYmxpbmc9c291cmNlLnNpYmxpbmc7dGFyZ2V0LmluZGV4PXNvdXJjZS5pbmRleDt0YXJnZXQucmVmPXNvdXJjZS5yZWY7dGFyZ2V0LnBlbmRpbmdQcm9wcz1zb3VyY2UucGVuZGluZ1Byb3BzO3RhcmdldC5tZW1vaXplZFByb3BzPXNvdXJjZS5tZW1vaXplZFByb3BzO3RhcmdldC51cGRhdGVRdWV1ZT1zb3VyY2UudXBkYXRlUXVldWU7dGFyZ2V0Lm1lbW9pemVkU3RhdGU9c291cmNlLm1lbW9pemVkU3RhdGU7dGFyZ2V0LmRlcGVuZGVuY2llcz1zb3VyY2UuZGVwZW5kZW5jaWVzO3RhcmdldC5tb2RlPXNvdXJjZS5tb2RlO3RhcmdldC5mbGFncz1zb3VyY2UuZmxhZ3M7dGFyZ2V0LnN1YnRyZWVGbGFncz1zb3VyY2Uuc3VidHJlZUZsYWdzO3RhcmdldC5kZWxldGlvbnM9c291cmNlLmRlbGV0aW9uczt0YXJnZXQubGFuZXM9c291cmNlLmxhbmVzO3RhcmdldC5jaGlsZExhbmVzPXNvdXJjZS5jaGlsZExhbmVzO3RhcmdldC5hbHRlcm5hdGU9c291cmNlLmFsdGVybmF0ZTt7dGFyZ2V0LmFjdHVhbER1cmF0aW9uPXNvdXJjZS5hY3R1YWxEdXJhdGlvbjt0YXJnZXQuYWN0dWFsU3RhcnRUaW1lPXNvdXJjZS5hY3R1YWxTdGFydFRpbWU7dGFyZ2V0LnNlbGZCYXNlRHVyYXRpb249c291cmNlLnNlbGZCYXNlRHVyYXRpb247dGFyZ2V0LnRyZWVCYXNlRHVyYXRpb249c291cmNlLnRyZWVCYXNlRHVyYXRpb247fXRhcmdldC5fZGVidWdTb3VyY2U9c291cmNlLl9kZWJ1Z1NvdXJjZTt0YXJnZXQuX2RlYnVnT3duZXI9c291cmNlLl9kZWJ1Z093bmVyO3RhcmdldC5fZGVidWdOZWVkc1JlbW91bnQ9c291cmNlLl9kZWJ1Z05lZWRzUmVtb3VudDt0YXJnZXQuX2RlYnVnSG9va1R5cGVzPXNvdXJjZS5fZGVidWdIb29rVHlwZXM7cmV0dXJuIHRhcmdldDt9ZnVuY3Rpb24gRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLHRhZyxoeWRyYXRlLGlkZW50aWZpZXJQcmVmaXgsb25SZWNvdmVyYWJsZUVycm9yKXt0aGlzLnRhZz10YWc7dGhpcy5jb250YWluZXJJbmZvPWNvbnRhaW5lckluZm87dGhpcy5wZW5kaW5nQ2hpbGRyZW49bnVsbDt0aGlzLmN1cnJlbnQ9bnVsbDt0aGlzLnBpbmdDYWNoZT1udWxsO3RoaXMuZmluaXNoZWRXb3JrPW51bGw7dGhpcy50aW1lb3V0SGFuZGxlPW5vVGltZW91dDt0aGlzLmNvbnRleHQ9bnVsbDt0aGlzLnBlbmRpbmdDb250ZXh0PW51bGw7dGhpcy5jYWxsYmFja05vZGU9bnVsbDt0aGlzLmNhbGxiYWNrUHJpb3JpdHk9Tm9MYW5lO3RoaXMuZXZlbnRUaW1lcz1jcmVhdGVMYW5lTWFwKE5vTGFuZXMpO3RoaXMuZXhwaXJhdGlvblRpbWVzPWNyZWF0ZUxhbmVNYXAoTm9UaW1lc3RhbXApO3RoaXMucGVuZGluZ0xhbmVzPU5vTGFuZXM7dGhpcy5zdXNwZW5kZWRMYW5lcz1Ob0xhbmVzO3RoaXMucGluZ2VkTGFuZXM9Tm9MYW5lczt0aGlzLmV4cGlyZWRMYW5lcz1Ob0xhbmVzO3RoaXMubXV0YWJsZVJlYWRMYW5lcz1Ob0xhbmVzO3RoaXMuZmluaXNoZWRMYW5lcz1Ob0xhbmVzO3RoaXMuZW50YW5nbGVkTGFuZXM9Tm9MYW5lczt0aGlzLmVudGFuZ2xlbWVudHM9Y3JlYXRlTGFuZU1hcChOb0xhbmVzKTt0aGlzLmlkZW50aWZpZXJQcmVmaXg9aWRlbnRpZmllclByZWZpeDt0aGlzLm9uUmVjb3ZlcmFibGVFcnJvcj1vblJlY292ZXJhYmxlRXJyb3I7e3RoaXMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT1udWxsO317dGhpcy5lZmZlY3REdXJhdGlvbj0wO3RoaXMucGFzc2l2ZUVmZmVjdER1cmF0aW9uPTA7fXt0aGlzLm1lbW9pemVkVXBkYXRlcnM9bmV3IFNldCgpO3ZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwPXRoaXMucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcD1bXTtmb3IodmFyIF9pPTA7X2k8VG90YWxMYW5lcztfaSsrKXtwZW5kaW5nVXBkYXRlcnNMYW5lTWFwLnB1c2gobmV3IFNldCgpKTt9fXtzd2l0Y2godGFnKXtjYXNlIENvbmN1cnJlbnRSb290OnRoaXMuX2RlYnVnUm9vdFR5cGU9aHlkcmF0ZT8naHlkcmF0ZVJvb3QoKSc6J2NyZWF0ZVJvb3QoKSc7YnJlYWs7Y2FzZSBMZWdhY3lSb290OnRoaXMuX2RlYnVnUm9vdFR5cGU9aHlkcmF0ZT8naHlkcmF0ZSgpJzoncmVuZGVyKCknO2JyZWFrO319fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLHRhZyxoeWRyYXRlLGluaXRpYWxDaGlsZHJlbixoeWRyYXRpb25DYWxsYmFja3MsaXNTdHJpY3RNb2RlLGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsLy8gVE9ETzogV2UgaGF2ZSBzZXZlcmFsIG9mIHRoZXNlIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25jZXB0dWFsbHkgcGFydCBvZiB0aGVcbi8vIGhvc3QgY29uZmlnLCBidXQgYmVjYXVzZSB0aGV5IGFyZSBwYXNzZWQgaW4gYXQgcnVudGltZSwgd2UgaGF2ZSB0byB0aHJlYWRcbi8vIHRoZW0gdGhyb3VnaCB0aGUgcm9vdCBjb25zdHJ1Y3Rvci4gUGVyaGFwcyB3ZSBzaG91bGQgcHV0IHRoZW0gYWxsIGludG8gYVxuLy8gc2luZ2xlIHR5cGUsIGxpa2UgYSBEeW5hbWljSG9zdENvbmZpZyB0aGF0IGlzIGRlZmluZWQgYnkgdGhlIHJlbmRlcmVyLlxuaWRlbnRpZmllclByZWZpeCxvblJlY292ZXJhYmxlRXJyb3IsdHJhbnNpdGlvbkNhbGxiYWNrcyl7dmFyIHJvb3Q9bmV3IEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbyx0YWcsaHlkcmF0ZSxpZGVudGlmaWVyUHJlZml4LG9uUmVjb3ZlcmFibGVFcnJvcik7Ly8gc3RhdGVOb2RlIGlzIGFueS5cbnZhciB1bmluaXRpYWxpemVkRmliZXI9Y3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsaXNTdHJpY3RNb2RlKTtyb290LmN1cnJlbnQ9dW5pbml0aWFsaXplZEZpYmVyO3VuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGU9cm9vdDt7dmFyIF9pbml0aWFsU3RhdGU9e2VsZW1lbnQ6aW5pdGlhbENoaWxkcmVuLGlzRGVoeWRyYXRlZDpoeWRyYXRlLGNhY2hlOm51bGwsLy8gbm90IGVuYWJsZWQgeWV0XG50cmFuc2l0aW9uczpudWxsLHBlbmRpbmdTdXNwZW5zZUJvdW5kYXJpZXM6bnVsbH07dW5pbml0aWFsaXplZEZpYmVyLm1lbW9pemVkU3RhdGU9X2luaXRpYWxTdGF0ZTt9aW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHVuaW5pdGlhbGl6ZWRGaWJlcik7cmV0dXJuIHJvb3Q7fXZhciBSZWFjdFZlcnNpb249JzE4LjIuMCc7ZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLGNvbnRhaW5lckluZm8sLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKXt2YXIga2V5PWFyZ3VtZW50cy5sZW5ndGg+MyYmYXJndW1lbnRzWzNdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1szXTpudWxsO3tjaGVja0tleVN0cmluZ0NvZXJjaW9uKGtleSk7fXJldHVybnsvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4kJHR5cGVvZjpSRUFDVF9QT1JUQUxfVFlQRSxrZXk6a2V5PT1udWxsP251bGw6Jycra2V5LGNoaWxkcmVuOmNoaWxkcmVuLGNvbnRhaW5lckluZm86Y29udGFpbmVySW5mbyxpbXBsZW1lbnRhdGlvbjppbXBsZW1lbnRhdGlvbn07fXZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzO3ZhciBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZTt7ZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcz1mYWxzZTtkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZT17fTt9ZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KXtpZighcGFyZW50Q29tcG9uZW50KXtyZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O312YXIgZmliZXI9Z2V0KHBhcmVudENvbXBvbmVudCk7dmFyIHBhcmVudENvbnRleHQ9ZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO2lmKGZpYmVyLnRhZz09PUNsYXNzQ29tcG9uZW50KXt2YXIgQ29tcG9uZW50PWZpYmVyLnR5cGU7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7cmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsQ29tcG9uZW50LHBhcmVudENvbnRleHQpO319cmV0dXJuIHBhcmVudENvbnRleHQ7fWZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnQsbWV0aG9kTmFtZSl7e3ZhciBmaWJlcj1nZXQoY29tcG9uZW50KTtpZihmaWJlcj09PXVuZGVmaW5lZCl7aWYodHlwZW9mIGNvbXBvbmVudC5yZW5kZXI9PT0nZnVuY3Rpb24nKXt0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTt9ZWxzZXt2YXIga2V5cz1PYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTt0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIitrZXlzKTt9fXZhciBob3N0RmliZXI9ZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO2lmKGhvc3RGaWJlcj09PW51bGwpe3JldHVybiBudWxsO31pZihob3N0RmliZXIubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXt2YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCc7aWYoIWRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKXtkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXT10cnVlO3ZhciBwcmV2aW91c0ZpYmVyPWN1cnJlbnQ7dHJ5e3NldEN1cnJlbnRGaWJlcihob3N0RmliZXIpO2lmKGZpYmVyLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7ZXJyb3IoJyVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJysnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCBpcyBpbnNpZGUgU3RyaWN0TW9kZS4gJysnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJysnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJyxtZXRob2ROYW1lLG1ldGhvZE5hbWUsY29tcG9uZW50TmFtZSk7fWVsc2V7ZXJyb3IoJyVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJysnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCByZW5kZXJzIFN0cmljdE1vZGUgY2hpbGRyZW4uICcrJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcrJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsbWV0aG9kTmFtZSxtZXRob2ROYW1lLGNvbXBvbmVudE5hbWUpO319ZmluYWxseXsvLyBJZGVhbGx5IHRoaXMgc2hvdWxkIHJlc2V0IHRvIHByZXZpb3VzIGJ1dCB0aGlzIHNob3VsZG4ndCBiZSBjYWxsZWQgaW5cbi8vIHJlbmRlciBhbmQgdGhlcmUncyBhbm90aGVyIHdhcm5pbmcgZm9yIHRoYXQgYW55d2F5LlxuaWYocHJldmlvdXNGaWJlcil7c2V0Q3VycmVudEZpYmVyKHByZXZpb3VzRmliZXIpO31lbHNle3Jlc2V0Q3VycmVudEZpYmVyKCk7fX19fXJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO319ZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lckluZm8sdGFnLGh5ZHJhdGlvbkNhbGxiYWNrcyxpc1N0cmljdE1vZGUsY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxpZGVudGlmaWVyUHJlZml4LG9uUmVjb3ZlcmFibGVFcnJvcix0cmFuc2l0aW9uQ2FsbGJhY2tzKXt2YXIgaHlkcmF0ZT1mYWxzZTt2YXIgaW5pdGlhbENoaWxkcmVuPW51bGw7cmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLHRhZyxoeWRyYXRlLGluaXRpYWxDaGlsZHJlbixoeWRyYXRpb25DYWxsYmFja3MsaXNTdHJpY3RNb2RlLGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsaWRlbnRpZmllclByZWZpeCxvblJlY292ZXJhYmxlRXJyb3IpO31mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25Db250YWluZXIoaW5pdGlhbENoaWxkcmVuLC8vIFRPRE86IFJlbW92ZSBgY2FsbGJhY2tgIHdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLlxuY2FsbGJhY2ssY29udGFpbmVySW5mbyx0YWcsaHlkcmF0aW9uQ2FsbGJhY2tzLGlzU3RyaWN0TW9kZSxjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLGlkZW50aWZpZXJQcmVmaXgsb25SZWNvdmVyYWJsZUVycm9yLHRyYW5zaXRpb25DYWxsYmFja3Mpe3ZhciBoeWRyYXRlPXRydWU7dmFyIHJvb3Q9Y3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sdGFnLGh5ZHJhdGUsaW5pdGlhbENoaWxkcmVuLGh5ZHJhdGlvbkNhbGxiYWNrcyxpc1N0cmljdE1vZGUsY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxpZGVudGlmaWVyUHJlZml4LG9uUmVjb3ZlcmFibGVFcnJvcik7Ly8gVE9ETzogTW92ZSB0aGlzIHRvIEZpYmVyUm9vdCBjb25zdHJ1Y3Rvclxucm9vdC5jb250ZXh0PWdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpOy8vIFNjaGVkdWxlIHRoZSBpbml0aWFsIHJlbmRlci4gSW4gYSBoeWRyYXRpb24gcm9vdCwgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbVxuLy8gYSByZWd1bGFyIHVwZGF0ZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBtdXN0IG1hdGNoIHdhcyB3YXMgcmVuZGVyZWRcbi8vIG9uIHRoZSBzZXJ2ZXIuXG4vLyBOT1RFOiBUaGlzIHVwZGF0ZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgaGF2ZSBhIHBheWxvYWQuIFdlJ3JlIG9ubHkgdXNpbmdcbi8vIHRoZSB1cGRhdGUgdG8gc2NoZWR1bGUgd29yayBvbiB0aGUgcm9vdCBmaWJlciAoYW5kLCBmb3IgbGVnYWN5IHJvb3RzLCB0b1xuLy8gZW5xdWV1ZSB0aGUgY2FsbGJhY2sgaWYgb25lIGlzIHByb3ZpZGVkKS5cbnZhciBjdXJyZW50PXJvb3QuY3VycmVudDt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTt2YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50KTt2YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShldmVudFRpbWUsbGFuZSk7dXBkYXRlLmNhbGxiYWNrPWNhbGxiYWNrIT09dW5kZWZpbmVkJiZjYWxsYmFjayE9PW51bGw/Y2FsbGJhY2s6bnVsbDtlbnF1ZXVlVXBkYXRlKGN1cnJlbnQsdXBkYXRlLGxhbmUpO3NjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdChyb290LGxhbmUsZXZlbnRUaW1lKTtyZXR1cm4gcm9vdDt9ZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsY29udGFpbmVyLHBhcmVudENvbXBvbmVudCxjYWxsYmFjayl7e29uU2NoZWR1bGVSb290KGNvbnRhaW5lcixlbGVtZW50KTt9dmFyIGN1cnJlbnQkMT1jb250YWluZXIuY3VycmVudDt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTt2YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50JDEpO3ttYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO312YXIgY29udGV4dD1nZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO2lmKGNvbnRhaW5lci5jb250ZXh0PT09bnVsbCl7Y29udGFpbmVyLmNvbnRleHQ9Y29udGV4dDt9ZWxzZXtjb250YWluZXIucGVuZGluZ0NvbnRleHQ9Y29udGV4dDt9e2lmKGlzUmVuZGVyaW5nJiZjdXJyZW50IT09bnVsbCYmIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpe2RpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM9dHJ1ZTtlcnJvcignUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcrJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnKydJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbicrJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50KXx8J1Vua25vd24nKTt9fXZhciB1cGRhdGU9Y3JlYXRlVXBkYXRlKGV2ZW50VGltZSxsYW5lKTsvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4vLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG51cGRhdGUucGF5bG9hZD17ZWxlbWVudDplbGVtZW50fTtjYWxsYmFjaz1jYWxsYmFjaz09PXVuZGVmaW5lZD9udWxsOmNhbGxiYWNrO2lmKGNhbGxiYWNrIT09bnVsbCl7e2lmKHR5cGVvZiBjYWxsYmFjayE9PSdmdW5jdGlvbicpe2Vycm9yKCdyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcrJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLGNhbGxiYWNrKTt9fXVwZGF0ZS5jYWxsYmFjaz1jYWxsYmFjazt9dmFyIHJvb3Q9ZW5xdWV1ZVVwZGF0ZShjdXJyZW50JDEsdXBkYXRlLGxhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxjdXJyZW50JDEsbGFuZSxldmVudFRpbWUpO2VudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCxjdXJyZW50JDEsbGFuZSk7fXJldHVybiBsYW5lO31mdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoY29udGFpbmVyKXt2YXIgY29udGFpbmVyRmliZXI9Y29udGFpbmVyLmN1cnJlbnQ7aWYoIWNvbnRhaW5lckZpYmVyLmNoaWxkKXtyZXR1cm4gbnVsbDt9c3dpdGNoKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50OnJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO2RlZmF1bHQ6cmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTt9fWZ1bmN0aW9uIGF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiQxKGZpYmVyKXtzd2l0Y2goZmliZXIudGFnKXtjYXNlIEhvc3RSb290Ont2YXIgcm9vdD1maWJlci5zdGF0ZU5vZGU7aWYoaXNSb290RGVoeWRyYXRlZChyb290KSl7Ly8gRmx1c2ggdGhlIGZpcnN0IHNjaGVkdWxlZCBcInVwZGF0ZVwiLlxudmFyIGxhbmVzPWdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyhyb290KTtmbHVzaFJvb3Qocm9vdCxsYW5lcyk7fWJyZWFrO31jYXNlIFN1c3BlbnNlQ29tcG9uZW50OntmbHVzaFN5bmMoZnVuY3Rpb24oKXt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKHJvb3QhPT1udWxsKXt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixTeW5jTGFuZSxldmVudFRpbWUpO319KTsvLyBJZiB3ZSdyZSBzdGlsbCBibG9ja2VkIGFmdGVyIHRoaXMsIHdlIG5lZWQgdG8gaW5jcmVhc2Vcbi8vIHRoZSBwcmlvcml0eSBvZiBhbnkgcHJvbWlzZXMgcmVzb2x2aW5nIHdpdGhpbiB0aGlzXG4vLyBib3VuZGFyeSBzbyB0aGF0IHRoZXkgbmV4dCBhdHRlbXB0IGFsc28gaGFzIGhpZ2hlciBwcmkuXG52YXIgcmV0cnlMYW5lPVN5bmNMYW5lO21hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLHJldHJ5TGFuZSk7YnJlYWs7fX19ZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIscmV0cnlMYW5lKXt2YXIgc3VzcGVuc2VTdGF0ZT1maWJlci5tZW1vaXplZFN0YXRlO2lmKHN1c3BlbnNlU3RhdGUhPT1udWxsJiZzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQhPT1udWxsKXtzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZT1oaWdoZXJQcmlvcml0eUxhbmUoc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUscmV0cnlMYW5lKTt9fS8vIEluY3JlYXNlcyB0aGUgcHJpb3JpdHkgb2YgdGhlbmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIscmV0cnlMYW5lKXttYXJrUmV0cnlMYW5lSW1wbChmaWJlcixyZXRyeUxhbmUpO3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZSl7bWFya1JldHJ5TGFuZUltcGwoYWx0ZXJuYXRlLHJldHJ5TGFuZSk7fX1mdW5jdGlvbiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiQxKGZpYmVyKXtpZihmaWJlci50YWchPT1TdXNwZW5zZUNvbXBvbmVudCl7Ly8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2Vcbi8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4vLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuLy8gU3VzcGVuc2UuXG5yZXR1cm47fXZhciBsYW5lPVNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLGxhbmUpO2lmKHJvb3QhPT1udWxsKXt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixsYW5lLGV2ZW50VGltZSk7fW1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLGxhbmUpO31mdW5jdGlvbiBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkkMShmaWJlcil7aWYoZmliZXIudGFnIT09U3VzcGVuc2VDb21wb25lbnQpey8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4vLyB0aGVpciBwcmlvcml0eSBvdGhlciB0aGFuIHN5bmNocm9ub3VzbHkgZmx1c2ggaXQuXG5yZXR1cm47fXZhciBsYW5lPXJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsbGFuZSk7aWYocm9vdCE9PW51bGwpe3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLGxhbmUsZXZlbnRUaW1lKTt9bWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsbGFuZSk7fWZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGZpYmVyKXt2YXIgaG9zdEZpYmVyPWZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7aWYoaG9zdEZpYmVyPT09bnVsbCl7cmV0dXJuIG51bGw7fXJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO312YXIgc2hvdWxkRXJyb3JJbXBsPWZ1bmN0aW9uKGZpYmVyKXtyZXR1cm4gbnVsbDt9O2Z1bmN0aW9uIHNob3VsZEVycm9yKGZpYmVyKXtyZXR1cm4gc2hvdWxkRXJyb3JJbXBsKGZpYmVyKTt9dmFyIHNob3VsZFN1c3BlbmRJbXBsPWZ1bmN0aW9uKGZpYmVyKXtyZXR1cm4gZmFsc2U7fTtmdW5jdGlvbiBzaG91bGRTdXNwZW5kKGZpYmVyKXtyZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO312YXIgb3ZlcnJpZGVIb29rU3RhdGU9bnVsbDt2YXIgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoPW51bGw7dmFyIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aD1udWxsO3ZhciBvdmVycmlkZVByb3BzPW51bGw7dmFyIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoPW51bGw7dmFyIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoPW51bGw7dmFyIHNjaGVkdWxlVXBkYXRlPW51bGw7dmFyIHNldEVycm9ySGFuZGxlcj1udWxsO3ZhciBzZXRTdXNwZW5zZUhhbmRsZXI9bnVsbDt7dmFyIGNvcHlXaXRoRGVsZXRlSW1wbD1mdW5jdGlvbihvYmoscGF0aCxpbmRleCl7dmFyIGtleT1wYXRoW2luZGV4XTt2YXIgdXBkYXRlZD1pc0FycmF5KG9iaik/b2JqLnNsaWNlKCk6YXNzaWduKHt9LG9iaik7aWYoaW5kZXgrMT09PXBhdGgubGVuZ3RoKXtpZihpc0FycmF5KHVwZGF0ZWQpKXt1cGRhdGVkLnNwbGljZShrZXksMSk7fWVsc2V7ZGVsZXRlIHVwZGF0ZWRba2V5XTt9cmV0dXJuIHVwZGF0ZWQ7fS8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbnVwZGF0ZWRba2V5XT1jb3B5V2l0aERlbGV0ZUltcGwob2JqW2tleV0scGF0aCxpbmRleCsxKTtyZXR1cm4gdXBkYXRlZDt9O3ZhciBjb3B5V2l0aERlbGV0ZT1mdW5jdGlvbihvYmoscGF0aCl7cmV0dXJuIGNvcHlXaXRoRGVsZXRlSW1wbChvYmoscGF0aCwwKTt9O3ZhciBjb3B5V2l0aFJlbmFtZUltcGw9ZnVuY3Rpb24ob2JqLG9sZFBhdGgsbmV3UGF0aCxpbmRleCl7dmFyIG9sZEtleT1vbGRQYXRoW2luZGV4XTt2YXIgdXBkYXRlZD1pc0FycmF5KG9iaik/b2JqLnNsaWNlKCk6YXNzaWduKHt9LG9iaik7aWYoaW5kZXgrMT09PW9sZFBhdGgubGVuZ3RoKXt2YXIgbmV3S2V5PW5ld1BhdGhbaW5kZXhdOy8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbnVwZGF0ZWRbbmV3S2V5XT11cGRhdGVkW29sZEtleV07aWYoaXNBcnJheSh1cGRhdGVkKSl7dXBkYXRlZC5zcGxpY2Uob2xkS2V5LDEpO31lbHNle2RlbGV0ZSB1cGRhdGVkW29sZEtleV07fX1lbHNley8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbnVwZGF0ZWRbb2xkS2V5XT1jb3B5V2l0aFJlbmFtZUltcGwoLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxub2JqW29sZEtleV0sb2xkUGF0aCxuZXdQYXRoLGluZGV4KzEpO31yZXR1cm4gdXBkYXRlZDt9O3ZhciBjb3B5V2l0aFJlbmFtZT1mdW5jdGlvbihvYmosb2xkUGF0aCxuZXdQYXRoKXtpZihvbGRQYXRoLmxlbmd0aCE9PW5ld1BhdGgubGVuZ3RoKXt3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgb2YgdGhlIHNhbWUgbGVuZ3RoJyk7cmV0dXJuO31lbHNle2Zvcih2YXIgaT0wO2k8bmV3UGF0aC5sZW5ndGgtMTtpKyspe2lmKG9sZFBhdGhbaV0hPT1uZXdQYXRoW2ldKXt3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgdG8gYmUgdGhlIHNhbWUgZXhjZXB0IGZvciB0aGUgZGVlcGVzdCBrZXknKTtyZXR1cm47fX19cmV0dXJuIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosb2xkUGF0aCxuZXdQYXRoLDApO307dmFyIGNvcHlXaXRoU2V0SW1wbD1mdW5jdGlvbihvYmoscGF0aCxpbmRleCx2YWx1ZSl7aWYoaW5kZXg+PXBhdGgubGVuZ3RoKXtyZXR1cm4gdmFsdWU7fXZhciBrZXk9cGF0aFtpbmRleF07dmFyIHVwZGF0ZWQ9aXNBcnJheShvYmopP29iai5zbGljZSgpOmFzc2lnbih7fSxvYmopOy8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbnVwZGF0ZWRba2V5XT1jb3B5V2l0aFNldEltcGwob2JqW2tleV0scGF0aCxpbmRleCsxLHZhbHVlKTtyZXR1cm4gdXBkYXRlZDt9O3ZhciBjb3B5V2l0aFNldD1mdW5jdGlvbihvYmoscGF0aCx2YWx1ZSl7cmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmoscGF0aCwwLHZhbHVlKTt9O3ZhciBmaW5kSG9vaz1mdW5jdGlvbihmaWJlcixpZCl7Ly8gRm9yIG5vdywgdGhlIFwiaWRcIiBvZiBzdGF0ZWZ1bCBob29rcyBpcyBqdXN0IHRoZSBzdGF0ZWZ1bCBob29rIGluZGV4LlxuLy8gVGhpcyBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUgd2l0aCBlLmcuIG5lc3RlZCBob29rcy5cbnZhciBjdXJyZW50SG9vaz1maWJlci5tZW1vaXplZFN0YXRlO3doaWxlKGN1cnJlbnRIb29rIT09bnVsbCYmaWQ+MCl7Y3VycmVudEhvb2s9Y3VycmVudEhvb2submV4dDtpZC0tO31yZXR1cm4gY3VycmVudEhvb2s7fTsvLyBTdXBwb3J0IERldlRvb2xzIGVkaXRhYmxlIHZhbHVlcyBmb3IgdXNlU3RhdGUgYW5kIHVzZVJlZHVjZXIuXG5vdmVycmlkZUhvb2tTdGF0ZT1mdW5jdGlvbihmaWJlcixpZCxwYXRoLHZhbHVlKXt2YXIgaG9vaz1maW5kSG9vayhmaWJlcixpZCk7aWYoaG9vayE9PW51bGwpe3ZhciBuZXdTdGF0ZT1jb3B5V2l0aFNldChob29rLm1lbW9pemVkU3RhdGUscGF0aCx2YWx1ZSk7aG9vay5tZW1vaXplZFN0YXRlPW5ld1N0YXRlO2hvb2suYmFzZVN0YXRlPW5ld1N0YXRlOy8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbi8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4vLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbi8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5maWJlci5tZW1vaXplZFByb3BzPWFzc2lnbih7fSxmaWJlci5tZW1vaXplZFByb3BzKTt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixTeW5jTGFuZSxOb1RpbWVzdGFtcCk7fX19O292ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aD1mdW5jdGlvbihmaWJlcixpZCxwYXRoKXt2YXIgaG9vaz1maW5kSG9vayhmaWJlcixpZCk7aWYoaG9vayE9PW51bGwpe3ZhciBuZXdTdGF0ZT1jb3B5V2l0aERlbGV0ZShob29rLm1lbW9pemVkU3RhdGUscGF0aCk7aG9vay5tZW1vaXplZFN0YXRlPW5ld1N0YXRlO2hvb2suYmFzZVN0YXRlPW5ld1N0YXRlOy8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbi8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4vLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbi8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5maWJlci5tZW1vaXplZFByb3BzPWFzc2lnbih7fSxmaWJlci5tZW1vaXplZFByb3BzKTt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixTeW5jTGFuZSxOb1RpbWVzdGFtcCk7fX19O292ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aD1mdW5jdGlvbihmaWJlcixpZCxvbGRQYXRoLG5ld1BhdGgpe3ZhciBob29rPWZpbmRIb29rKGZpYmVyLGlkKTtpZihob29rIT09bnVsbCl7dmFyIG5ld1N0YXRlPWNvcHlXaXRoUmVuYW1lKGhvb2subWVtb2l6ZWRTdGF0ZSxvbGRQYXRoLG5ld1BhdGgpO2hvb2subWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTtob29rLmJhc2VTdGF0ZT1uZXdTdGF0ZTsvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4vLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbi8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4vLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuZmliZXIubWVtb2l6ZWRQcm9wcz1hc3NpZ24oe30sZmliZXIubWVtb2l6ZWRQcm9wcyk7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsU3luY0xhbmUsTm9UaW1lc3RhbXApO319fTsvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cbm92ZXJyaWRlUHJvcHM9ZnVuY3Rpb24oZmliZXIscGF0aCx2YWx1ZSl7ZmliZXIucGVuZGluZ1Byb3BzPWNvcHlXaXRoU2V0KGZpYmVyLm1lbW9pemVkUHJvcHMscGF0aCx2YWx1ZSk7aWYoZmliZXIuYWx0ZXJuYXRlKXtmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzPWZpYmVyLnBlbmRpbmdQcm9wczt9dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsU3luY0xhbmUsTm9UaW1lc3RhbXApO319O292ZXJyaWRlUHJvcHNEZWxldGVQYXRoPWZ1bmN0aW9uKGZpYmVyLHBhdGgpe2ZpYmVyLnBlbmRpbmdQcm9wcz1jb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLHBhdGgpO2lmKGZpYmVyLmFsdGVybmF0ZSl7ZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcz1maWJlci5wZW5kaW5nUHJvcHM7fXZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLFN5bmNMYW5lLE5vVGltZXN0YW1wKTt9fTtvdmVycmlkZVByb3BzUmVuYW1lUGF0aD1mdW5jdGlvbihmaWJlcixvbGRQYXRoLG5ld1BhdGgpe2ZpYmVyLnBlbmRpbmdQcm9wcz1jb3B5V2l0aFJlbmFtZShmaWJlci5tZW1vaXplZFByb3BzLG9sZFBhdGgsbmV3UGF0aCk7aWYoZmliZXIuYWx0ZXJuYXRlKXtmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzPWZpYmVyLnBlbmRpbmdQcm9wczt9dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsU3luY0xhbmUsTm9UaW1lc3RhbXApO319O3NjaGVkdWxlVXBkYXRlPWZ1bmN0aW9uKGZpYmVyKXt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixTeW5jTGFuZSxOb1RpbWVzdGFtcCk7fX07c2V0RXJyb3JIYW5kbGVyPWZ1bmN0aW9uKG5ld1Nob3VsZEVycm9ySW1wbCl7c2hvdWxkRXJyb3JJbXBsPW5ld1Nob3VsZEVycm9ySW1wbDt9O3NldFN1c3BlbnNlSGFuZGxlcj1mdW5jdGlvbihuZXdTaG91bGRTdXNwZW5kSW1wbCl7c2hvdWxkU3VzcGVuZEltcGw9bmV3U2hvdWxkU3VzcGVuZEltcGw7fTt9ZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIoZmliZXIpe3ZhciBob3N0RmliZXI9ZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO2lmKGhvc3RGaWJlcj09PW51bGwpe3JldHVybiBudWxsO31yZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTt9ZnVuY3Rpb24gZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSl7cmV0dXJuIG51bGw7fWZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCl7cmV0dXJuIGN1cnJlbnQ7fWZ1bmN0aW9uIGluamVjdEludG9EZXZUb29scyhkZXZUb29sc0NvbmZpZyl7dmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlPWRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO3ZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7cmV0dXJuIGluamVjdEludGVybmFscyh7YnVuZGxlVHlwZTpkZXZUb29sc0NvbmZpZy5idW5kbGVUeXBlLHZlcnNpb246ZGV2VG9vbHNDb25maWcudmVyc2lvbixyZW5kZXJlclBhY2thZ2VOYW1lOmRldlRvb2xzQ29uZmlnLnJlbmRlcmVyUGFja2FnZU5hbWUscmVuZGVyZXJDb25maWc6ZGV2VG9vbHNDb25maWcucmVuZGVyZXJDb25maWcsb3ZlcnJpZGVIb29rU3RhdGU6b3ZlcnJpZGVIb29rU3RhdGUsb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCxvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg6b3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLG92ZXJyaWRlUHJvcHM6b3ZlcnJpZGVQcm9wcyxvdmVycmlkZVByb3BzRGVsZXRlUGF0aDpvdmVycmlkZVByb3BzRGVsZXRlUGF0aCxvdmVycmlkZVByb3BzUmVuYW1lUGF0aDpvdmVycmlkZVByb3BzUmVuYW1lUGF0aCxzZXRFcnJvckhhbmRsZXI6c2V0RXJyb3JIYW5kbGVyLHNldFN1c3BlbnNlSGFuZGxlcjpzZXRTdXNwZW5zZUhhbmRsZXIsc2NoZWR1bGVVcGRhdGU6c2NoZWR1bGVVcGRhdGUsY3VycmVudERpc3BhdGNoZXJSZWY6UmVhY3RDdXJyZW50RGlzcGF0Y2hlcixmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjpmaW5kSG9zdEluc3RhbmNlQnlGaWJlcixmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpmaW5kRmliZXJCeUhvc3RJbnN0YW5jZXx8ZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSwvLyBSZWFjdCBSZWZyZXNoXG5maW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g6ZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoLHNjaGVkdWxlUmVmcmVzaDpzY2hlZHVsZVJlZnJlc2gsc2NoZWR1bGVSb290OnNjaGVkdWxlUm9vdCxzZXRSZWZyZXNoSGFuZGxlcjpzZXRSZWZyZXNoSGFuZGxlciwvLyBFbmFibGVzIERldlRvb2xzIHRvIGFwcGVuZCBvd25lciBzdGFja3MgdG8gZXJyb3IgbWVzc2FnZXMgaW4gREVWIG1vZGUuXG5nZXRDdXJyZW50RmliZXI6Z2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMsLy8gRW5hYmxlcyBEZXZUb29scyB0byBkZXRlY3QgcmVjb25jaWxlciB2ZXJzaW9uIHJhdGhlciB0aGFuIHJlbmRlcmVyIHZlcnNpb25cbi8vIHdoaWNoIG1heSBub3QgbWF0Y2ggZm9yIHRoaXJkIHBhcnR5IHJlbmRlcmVycy5cbnJlY29uY2lsZXJWZXJzaW9uOlJlYWN0VmVyc2lvbn0pO30vKiBnbG9iYWwgcmVwb3J0RXJyb3IgKi92YXIgZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvcj10eXBlb2YgcmVwb3J0RXJyb3I9PT0nZnVuY3Rpb24nPy8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbi8vIGVtdWxhdGluZyBhbiB1bmNhdWdodCBKYXZhU2NyaXB0IGVycm9yLlxucmVwb3J0RXJyb3I6ZnVuY3Rpb24oZXJyb3Ipey8vIEluIG9sZGVyIGJyb3dzZXJzIGFuZCB0ZXN0IGVudmlyb25tZW50cywgZmFsbGJhY2sgdG8gY29uc29sZS5lcnJvci5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcbmNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpO307ZnVuY3Rpb24gUmVhY3RET01Sb290KGludGVybmFsUm9vdCl7dGhpcy5faW50ZXJuYWxSb290PWludGVybmFsUm9vdDt9UmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS5yZW5kZXI9UmVhY3RET01Sb290LnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oY2hpbGRyZW4pe3ZhciByb290PXRoaXMuX2ludGVybmFsUm9vdDtpZihyb290PT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGFuIHVubW91bnRlZCByb290LicpO317aWYodHlwZW9mIGFyZ3VtZW50c1sxXT09PSdmdW5jdGlvbicpe2Vycm9yKCdyZW5kZXIoLi4uKTogZG9lcyBub3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiAnKydUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIGEgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTt9ZWxzZSBpZihpc1ZhbGlkQ29udGFpbmVyKGFyZ3VtZW50c1sxXSkpe2Vycm9yKCdZb3UgcGFzc2VkIGEgY29udGFpbmVyIHRvIHRoZSBzZWNvbmQgYXJndW1lbnQgb2Ygcm9vdC5yZW5kZXIoLi4uKS4gJytcIllvdSBkb24ndCBuZWVkIHRvIHBhc3MgaXQgYWdhaW4gc2luY2UgeW91IGFscmVhZHkgcGFzc2VkIGl0IHRvIGNyZWF0ZSB0aGUgcm9vdC5cIik7fWVsc2UgaWYodHlwZW9mIGFyZ3VtZW50c1sxXSE9PSd1bmRlZmluZWQnKXtlcnJvcignWW91IHBhc3NlZCBhIHNlY29uZCBhcmd1bWVudCB0byByb290LnJlbmRlciguLi4pIGJ1dCBpdCBvbmx5IGFjY2VwdHMgJysnb25lIGFyZ3VtZW50LicpO312YXIgY29udGFpbmVyPXJvb3QuY29udGFpbmVySW5mbztpZihjb250YWluZXIubm9kZVR5cGUhPT1DT01NRU5UX05PREUpe3ZhciBob3N0SW5zdGFuY2U9ZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMocm9vdC5jdXJyZW50KTtpZihob3N0SW5zdGFuY2Upe2lmKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlIT09Y29udGFpbmVyKXtlcnJvcigncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhlICcrJ3Jvb3QgY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcrJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJytcInJvb3QudW5tb3VudCgpIHRvIGVtcHR5IGEgcm9vdCdzIGNvbnRhaW5lci5cIik7fX19fXVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbixyb290LG51bGwsbnVsbCk7fTtSZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnVubW91bnQ9UmVhY3RET01Sb290LnByb3RvdHlwZS51bm1vdW50PWZ1bmN0aW9uKCl7e2lmKHR5cGVvZiBhcmd1bWVudHNbMF09PT0nZnVuY3Rpb24nKXtlcnJvcigndW5tb3VudCguLi4pOiBkb2VzIG5vdCBzdXBwb3J0IGEgY2FsbGJhY2sgYXJndW1lbnQuICcrJ1RvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gYSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO319dmFyIHJvb3Q9dGhpcy5faW50ZXJuYWxSb290O2lmKHJvb3QhPT1udWxsKXt0aGlzLl9pbnRlcm5hbFJvb3Q9bnVsbDt2YXIgY29udGFpbmVyPXJvb3QuY29udGFpbmVySW5mbzt7aWYoaXNBbHJlYWR5UmVuZGVyaW5nKCkpe2Vycm9yKCdBdHRlbXB0ZWQgdG8gc3luY2hyb25vdXNseSB1bm1vdW50IGEgcm9vdCB3aGlsZSBSZWFjdCB3YXMgYWxyZWFkeSAnKydyZW5kZXJpbmcuIFJlYWN0IGNhbm5vdCBmaW5pc2ggdW5tb3VudGluZyB0aGUgcm9vdCB1bnRpbCB0aGUgJysnY3VycmVudCByZW5kZXIgaGFzIGNvbXBsZXRlZCwgd2hpY2ggbWF5IGxlYWQgdG8gYSByYWNlIGNvbmRpdGlvbi4nKTt9fWZsdXNoU3luYyhmdW5jdGlvbigpe3VwZGF0ZUNvbnRhaW5lcihudWxsLHJvb3QsbnVsbCxudWxsKTt9KTt1bm1hcmtDb250YWluZXJBc1Jvb3QoY29udGFpbmVyKTt9fTtmdW5jdGlvbiBjcmVhdGVSb290KGNvbnRhaW5lcixvcHRpb25zKXtpZighaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKXt0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVJvb3QoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKTt9d2FybklmUmVhY3RET01Db250YWluZXJJbkRFVihjb250YWluZXIpO3ZhciBpc1N0cmljdE1vZGU9ZmFsc2U7dmFyIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGU9ZmFsc2U7dmFyIGlkZW50aWZpZXJQcmVmaXg9Jyc7dmFyIG9uUmVjb3ZlcmFibGVFcnJvcj1kZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yO3ZhciB0cmFuc2l0aW9uQ2FsbGJhY2tzPW51bGw7aWYob3B0aW9ucyE9PW51bGwmJm9wdGlvbnMhPT11bmRlZmluZWQpe3tpZihvcHRpb25zLmh5ZHJhdGUpe3dhcm4oJ2h5ZHJhdGUgdGhyb3VnaCBjcmVhdGVSb290IGlzIGRlcHJlY2F0ZWQuIFVzZSBSZWFjdERPTUNsaWVudC5oeWRyYXRlUm9vdChjb250YWluZXIsIDxBcHAgLz4pIGluc3RlYWQuJyk7fWVsc2V7aWYodHlwZW9mIG9wdGlvbnM9PT0nb2JqZWN0JyYmb3B0aW9ucyE9PW51bGwmJm9wdGlvbnMuJCR0eXBlb2Y9PT1SRUFDVF9FTEVNRU5UX1RZUEUpe2Vycm9yKCdZb3UgcGFzc2VkIGEgSlNYIGVsZW1lbnQgdG8gY3JlYXRlUm9vdC4gWW91IHByb2JhYmx5IG1lYW50IHRvICcrJ2NhbGwgcm9vdC5yZW5kZXIgaW5zdGVhZC4gJysnRXhhbXBsZSB1c2FnZTpcXG5cXG4nKycgIGxldCByb290ID0gY3JlYXRlUm9vdChkb21Db250YWluZXIpO1xcbicrJyAgcm9vdC5yZW5kZXIoPEFwcCAvPik7Jyk7fX19aWYob3B0aW9ucy51bnN0YWJsZV9zdHJpY3RNb2RlPT09dHJ1ZSl7aXNTdHJpY3RNb2RlPXRydWU7fWlmKG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCE9PXVuZGVmaW5lZCl7aWRlbnRpZmllclByZWZpeD1vcHRpb25zLmlkZW50aWZpZXJQcmVmaXg7fWlmKG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yIT09dW5kZWZpbmVkKXtvblJlY292ZXJhYmxlRXJyb3I9b3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3I7fWlmKG9wdGlvbnMudHJhbnNpdGlvbkNhbGxiYWNrcyE9PXVuZGVmaW5lZCl7dHJhbnNpdGlvbkNhbGxiYWNrcz1vcHRpb25zLnRyYW5zaXRpb25DYWxsYmFja3M7fX12YXIgcm9vdD1jcmVhdGVDb250YWluZXIoY29udGFpbmVyLENvbmN1cnJlbnRSb290LG51bGwsaXNTdHJpY3RNb2RlLGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsaWRlbnRpZmllclByZWZpeCxvblJlY292ZXJhYmxlRXJyb3IpO21hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LGNvbnRhaW5lcik7dmFyIHJvb3RDb250YWluZXJFbGVtZW50PWNvbnRhaW5lci5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERT9jb250YWluZXIucGFyZW50Tm9kZTpjb250YWluZXI7bGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpO3JldHVybiBuZXcgUmVhY3RET01Sb290KHJvb3QpO31mdW5jdGlvbiBSZWFjdERPTUh5ZHJhdGlvblJvb3QoaW50ZXJuYWxSb290KXt0aGlzLl9pbnRlcm5hbFJvb3Q9aW50ZXJuYWxSb290O31mdW5jdGlvbiBzY2hlZHVsZUh5ZHJhdGlvbih0YXJnZXQpe2lmKHRhcmdldCl7cXVldWVFeHBsaWNpdEh5ZHJhdGlvblRhcmdldCh0YXJnZXQpO319UmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS51bnN0YWJsZV9zY2hlZHVsZUh5ZHJhdGlvbj1zY2hlZHVsZUh5ZHJhdGlvbjtmdW5jdGlvbiBoeWRyYXRlUm9vdChjb250YWluZXIsaW5pdGlhbENoaWxkcmVuLG9wdGlvbnMpe2lmKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpe3Rocm93IG5ldyBFcnJvcignaHlkcmF0ZVJvb3QoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKTt9d2FybklmUmVhY3RET01Db250YWluZXJJbkRFVihjb250YWluZXIpO3tpZihpbml0aWFsQ2hpbGRyZW49PT11bmRlZmluZWQpe2Vycm9yKCdNdXN0IHByb3ZpZGUgaW5pdGlhbCBjaGlsZHJlbiBhcyBzZWNvbmQgYXJndW1lbnQgdG8gaHlkcmF0ZVJvb3QuICcrJ0V4YW1wbGUgdXNhZ2U6IGh5ZHJhdGVSb290KGRvbUNvbnRhaW5lciwgPEFwcCAvPiknKTt9fS8vIEZvciBub3cgd2UgcmV1c2UgdGhlIHdob2xlIGJhZyBvZiBvcHRpb25zIHNpbmNlIHRoZXkgY29udGFpblxuLy8gdGhlIGh5ZHJhdGlvbiBjYWxsYmFja3MuXG52YXIgaHlkcmF0aW9uQ2FsbGJhY2tzPW9wdGlvbnMhPW51bGw/b3B0aW9uczpudWxsOy8vIFRPRE86IERlbGV0ZSB0aGlzIG9wdGlvblxudmFyIG11dGFibGVTb3VyY2VzPW9wdGlvbnMhPW51bGwmJm9wdGlvbnMuaHlkcmF0ZWRTb3VyY2VzfHxudWxsO3ZhciBpc1N0cmljdE1vZGU9ZmFsc2U7dmFyIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGU9ZmFsc2U7dmFyIGlkZW50aWZpZXJQcmVmaXg9Jyc7dmFyIG9uUmVjb3ZlcmFibGVFcnJvcj1kZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yO2lmKG9wdGlvbnMhPT1udWxsJiZvcHRpb25zIT09dW5kZWZpbmVkKXtpZihvcHRpb25zLnVuc3RhYmxlX3N0cmljdE1vZGU9PT10cnVlKXtpc1N0cmljdE1vZGU9dHJ1ZTt9aWYob3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IT09dW5kZWZpbmVkKXtpZGVudGlmaWVyUHJlZml4PW9wdGlvbnMuaWRlbnRpZmllclByZWZpeDt9aWYob3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3IhPT11bmRlZmluZWQpe29uUmVjb3ZlcmFibGVFcnJvcj1vcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvcjt9fXZhciByb290PWNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sbnVsbCxjb250YWluZXIsQ29uY3VycmVudFJvb3QsaHlkcmF0aW9uQ2FsbGJhY2tzLGlzU3RyaWN0TW9kZSxjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLGlkZW50aWZpZXJQcmVmaXgsb25SZWNvdmVyYWJsZUVycm9yKTttYXJrQ29udGFpbmVyQXNSb290KHJvb3QuY3VycmVudCxjb250YWluZXIpOy8vIFRoaXMgY2FuJ3QgYmUgYSBjb21tZW50IG5vZGUgc2luY2UgaHlkcmF0aW9uIGRvZXNuJ3Qgd29yayBvbiBjb21tZW50IG5vZGVzIGFueXdheS5cbmxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKGNvbnRhaW5lcik7aWYobXV0YWJsZVNvdXJjZXMpe2Zvcih2YXIgaT0wO2k8bXV0YWJsZVNvdXJjZXMubGVuZ3RoO2krKyl7dmFyIG11dGFibGVTb3VyY2U9bXV0YWJsZVNvdXJjZXNbaV07cmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsbXV0YWJsZVNvdXJjZSk7fX1yZXR1cm4gbmV3IFJlYWN0RE9NSHlkcmF0aW9uUm9vdChyb290KTt9ZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKXtyZXR1cm4hIShub2RlJiYobm9kZS5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERXx8bm9kZS5ub2RlVHlwZT09PURPQ1VNRU5UX05PREV8fG5vZGUubm9kZVR5cGU9PT1ET0NVTUVOVF9GUkFHTUVOVF9OT0RFfHwhZGlzYWJsZUNvbW1lbnRzQXNET01Db250YWluZXJzKSk7fS8vIFRPRE86IFJlbW92ZSB0aGlzIGZ1bmN0aW9uIHdoaWNoIGFsc28gaW5jbHVkZXMgY29tbWVudCBub2Rlcy5cbi8vIFdlIG9ubHkgdXNlIGl0IGluIHBsYWNlcyB0aGF0IGFyZSBjdXJyZW50bHkgbW9yZSByZWxheGVkLlxuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lckxlZ2FjeShub2RlKXtyZXR1cm4hIShub2RlJiYobm9kZS5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERXx8bm9kZS5ub2RlVHlwZT09PURPQ1VNRU5UX05PREV8fG5vZGUubm9kZVR5cGU9PT1ET0NVTUVOVF9GUkFHTUVOVF9OT0RFfHxub2RlLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFJiZub2RlLm5vZGVWYWx1ZT09PScgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO31mdW5jdGlvbiB3YXJuSWZSZWFjdERPTUNvbnRhaW5lckluREVWKGNvbnRhaW5lcil7e2lmKGNvbnRhaW5lci5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERSYmY29udGFpbmVyLnRhZ05hbWUmJmNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCk9PT0nQk9EWScpe2Vycm9yKCdjcmVhdGVSb290KCk6IENyZWF0aW5nIHJvb3RzIGRpcmVjdGx5IHdpdGggZG9jdW1lbnQuYm9keSBpcyAnKydkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnKydzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcrJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHVzaW5nIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnKydmb3IgeW91ciBhcHAuJyk7fWlmKGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikpe2lmKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKXtlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcrJ3Bhc3NlZCB0byBSZWFjdERPTS5yZW5kZXIoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLicpO31lbHNle2Vycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpIG9uIGEgY29udGFpbmVyIHRoYXQgJysnaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gY3JlYXRlUm9vdCgpIGJlZm9yZS4gSW5zdGVhZCwgY2FsbCAnKydyb290LnJlbmRlcigpIG9uIHRoZSBleGlzdGluZyByb290IGluc3RlYWQgaWYgeW91IHdhbnQgdG8gdXBkYXRlIGl0LicpO319fX12YXIgUmVhY3RDdXJyZW50T3duZXIkMz1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjt2YXIgdG9wTGV2ZWxVcGRhdGVXYXJuaW5nczt7dG9wTGV2ZWxVcGRhdGVXYXJuaW5ncz1mdW5jdGlvbihjb250YWluZXIpe2lmKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyJiZjb250YWluZXIubm9kZVR5cGUhPT1DT01NRU5UX05PREUpe3ZhciBob3N0SW5zdGFuY2U9ZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIuY3VycmVudCk7aWYoaG9zdEluc3RhbmNlKXtpZihob3N0SW5zdGFuY2UucGFyZW50Tm9kZSE9PWNvbnRhaW5lcil7ZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoaXMgJysnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcrJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJysnUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSB0byBlbXB0eSBhIGNvbnRhaW5lci4nKTt9fX12YXIgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdD0hIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO3ZhciByb290RWw9Z2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7dmFyIGhhc05vblJvb3RSZWFjdENoaWxkPSEhKHJvb3RFbCYmZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpKTtpZihoYXNOb25Sb290UmVhY3RDaGlsZCYmIWlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3Qpe2Vycm9yKCdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnKydjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJysneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnKydhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO31pZihjb250YWluZXIubm9kZVR5cGU9PT1FTEVNRU5UX05PREUmJmNvbnRhaW5lci50YWdOYW1lJiZjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpPT09J0JPRFknKXtlcnJvcigncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnKydkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnKydzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcrJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnKydmb3IgeW91ciBhcHAuJyk7fX07fWZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpe2lmKCFjb250YWluZXIpe3JldHVybiBudWxsO31pZihjb250YWluZXIubm9kZVR5cGU9PT1ET0NVTUVOVF9OT0RFKXtyZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDt9ZWxzZXtyZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7fX1mdW5jdGlvbiBub29wT25SZWNvdmVyYWJsZUVycm9yKCl7Ly8gVGhpcyBpc24ndCByZWFjaGFibGUgYmVjYXVzZSBvblJlY292ZXJhYmxlRXJyb3IgaXNuJ3QgY2FsbGVkIGluIHRoZVxuLy8gbGVnYWN5IEFQSS5cbn1mdW5jdGlvbiBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsaW5pdGlhbENoaWxkcmVuLHBhcmVudENvbXBvbmVudCxjYWxsYmFjayxpc0h5ZHJhdGlvbkNvbnRhaW5lcil7aWYoaXNIeWRyYXRpb25Db250YWluZXIpe2lmKHR5cGVvZiBjYWxsYmFjaz09PSdmdW5jdGlvbicpe3ZhciBvcmlnaW5hbENhbGxiYWNrPWNhbGxiYWNrO2NhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIGluc3RhbmNlPWdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtvcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO307fXZhciByb290PWNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sY2FsbGJhY2ssY29udGFpbmVyLExlZ2FjeVJvb3QsbnVsbCwvLyBoeWRyYXRpb25DYWxsYmFja3NcbmZhbHNlLC8vIGlzU3RyaWN0TW9kZVxuZmFsc2UsLy8gY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxcbicnLC8vIGlkZW50aWZpZXJQcmVmaXhcbm5vb3BPblJlY292ZXJhYmxlRXJyb3IpO2NvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyPXJvb3Q7bWFya0NvbnRhaW5lckFzUm9vdChyb290LmN1cnJlbnQsY29udGFpbmVyKTt2YXIgcm9vdENvbnRhaW5lckVsZW1lbnQ9Y29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFP2NvbnRhaW5lci5wYXJlbnROb2RlOmNvbnRhaW5lcjtsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhyb290Q29udGFpbmVyRWxlbWVudCk7Zmx1c2hTeW5jKCk7cmV0dXJuIHJvb3Q7fWVsc2V7Ly8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG52YXIgcm9vdFNpYmxpbmc7d2hpbGUocm9vdFNpYmxpbmc9Y29udGFpbmVyLmxhc3RDaGlsZCl7Y29udGFpbmVyLnJlbW92ZUNoaWxkKHJvb3RTaWJsaW5nKTt9aWYodHlwZW9mIGNhbGxiYWNrPT09J2Z1bmN0aW9uJyl7dmFyIF9vcmlnaW5hbENhbGxiYWNrPWNhbGxiYWNrO2NhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIGluc3RhbmNlPWdldFB1YmxpY1Jvb3RJbnN0YW5jZShfcm9vdCk7X29yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7fTt9dmFyIF9yb290PWNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsTGVnYWN5Um9vdCxudWxsLC8vIGh5ZHJhdGlvbkNhbGxiYWNrc1xuZmFsc2UsLy8gaXNTdHJpY3RNb2RlXG5mYWxzZSwvLyBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuJycsLy8gaWRlbnRpZmllclByZWZpeFxubm9vcE9uUmVjb3ZlcmFibGVFcnJvcik7Y29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI9X3Jvb3Q7bWFya0NvbnRhaW5lckFzUm9vdChfcm9vdC5jdXJyZW50LGNvbnRhaW5lcik7dmFyIF9yb290Q29udGFpbmVyRWxlbWVudD1jb250YWluZXIubm9kZVR5cGU9PT1DT01NRU5UX05PREU/Y29udGFpbmVyLnBhcmVudE5vZGU6Y29udGFpbmVyO2xpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKF9yb290Q29udGFpbmVyRWxlbWVudCk7Ly8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG5mbHVzaFN5bmMoZnVuY3Rpb24oKXt1cGRhdGVDb250YWluZXIoaW5pdGlhbENoaWxkcmVuLF9yb290LHBhcmVudENvbXBvbmVudCxjYWxsYmFjayk7fSk7cmV0dXJuIF9yb290O319ZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssY2FsbGVyTmFtZSl7e2lmKGNhbGxiYWNrIT09bnVsbCYmdHlwZW9mIGNhbGxiYWNrIT09J2Z1bmN0aW9uJyl7ZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnKydmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJyxjYWxsZXJOYW1lLGNhbGxiYWNrKTt9fX1mdW5jdGlvbiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsY2hpbGRyZW4sY29udGFpbmVyLGZvcmNlSHlkcmF0ZSxjYWxsYmFjayl7e3RvcExldmVsVXBkYXRlV2FybmluZ3MoY29udGFpbmVyKTt3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjaz09PXVuZGVmaW5lZD9udWxsOmNhbGxiYWNrLCdyZW5kZXInKTt9dmFyIG1heWJlUm9vdD1jb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjt2YXIgcm9vdDtpZighbWF5YmVSb290KXsvLyBJbml0aWFsIG1vdW50XG5yb290PWxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lcixjaGlsZHJlbixwYXJlbnRDb21wb25lbnQsY2FsbGJhY2ssZm9yY2VIeWRyYXRlKTt9ZWxzZXtyb290PW1heWJlUm9vdDtpZih0eXBlb2YgY2FsbGJhY2s9PT0nZnVuY3Rpb24nKXt2YXIgb3JpZ2luYWxDYWxsYmFjaz1jYWxsYmFjaztjYWxsYmFjaz1mdW5jdGlvbigpe3ZhciBpbnN0YW5jZT1nZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7b3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTt9O30vLyBVcGRhdGVcbnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbixyb290LHBhcmVudENvbXBvbmVudCxjYWxsYmFjayk7fXJldHVybiBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7fWZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCl7e3ZhciBvd25lcj1SZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQ7aWYob3duZXIhPT1udWxsJiZvd25lci5zdGF0ZU5vZGUhPT1udWxsKXt2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI9b3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtpZighd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIpe2Vycm9yKCclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJysncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnKyduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnKydyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnKydjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKXx8J0EgY29tcG9uZW50Jyk7fW93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI9dHJ1ZTt9fWlmKGNvbXBvbmVudE9yRWxlbWVudD09bnVsbCl7cmV0dXJuIG51bGw7fWlmKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERSl7cmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDt9e3JldHVybiBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcoY29tcG9uZW50T3JFbGVtZW50LCdmaW5kRE9NTm9kZScpO319ZnVuY3Rpb24gaHlkcmF0ZShlbGVtZW50LGNvbnRhaW5lcixjYWxsYmFjayl7e2Vycm9yKCdSZWFjdERPTS5oeWRyYXRlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBoeWRyYXRlUm9vdCAnKydpbnN0ZWFkLiBVbnRpbCB5b3Ugc3dpdGNoIHRvIHRoZSBuZXcgQVBJLCB5b3VyIGFwcCB3aWxsIGJlaGF2ZSBhcyAnK1wiaWYgaXQncyBydW5uaW5nIFJlYWN0IDE3LiBMZWFybiBcIisnbW9yZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N3aXRjaC10by1jcmVhdGVyb290Jyk7fWlmKCFpc1ZhbGlkQ29udGFpbmVyTGVnYWN5KGNvbnRhaW5lcikpe3Rocm93IG5ldyBFcnJvcignVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKTt9e3ZhciBpc01vZGVyblJvb3Q9aXNDb250YWluZXJNYXJrZWRBc1Jvb3QoY29udGFpbmVyKSYmY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI9PT11bmRlZmluZWQ7aWYoaXNNb2Rlcm5Sb290KXtlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLmh5ZHJhdGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcrJ3Bhc3NlZCB0byBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gJysnRGlkIHlvdSBtZWFuIHRvIGNhbGwgaHlkcmF0ZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KT8nKTt9fS8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbnJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLGVsZW1lbnQsY29udGFpbmVyLHRydWUsY2FsbGJhY2spO31mdW5jdGlvbiByZW5kZXIoZWxlbWVudCxjb250YWluZXIsY2FsbGJhY2spe3tlcnJvcignUmVhY3RET00ucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290ICcrJ2luc3RlYWQuIFVudGlsIHlvdSBzd2l0Y2ggdG8gdGhlIG5ldyBBUEksIHlvdXIgYXBwIHdpbGwgYmVoYXZlIGFzICcrXCJpZiBpdCdzIHJ1bm5pbmcgUmVhY3QgMTcuIExlYXJuIFwiKydtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTt9aWYoIWlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyKSl7dGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO317dmFyIGlzTW9kZXJuUm9vdD1pc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpJiZjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcj09PXVuZGVmaW5lZDtpZihpc01vZGVyblJvb3Qpe2Vycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnKydwYXNzZWQgdG8gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcrJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QucmVuZGVyKGVsZW1lbnQpPycpO319cmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsZWxlbWVudCxjb250YWluZXIsZmFsc2UsY2FsbGJhY2spO31mdW5jdGlvbiB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsZWxlbWVudCxjb250YWluZXJOb2RlLGNhbGxiYWNrKXt7ZXJyb3IoJ1JlYWN0RE9NLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCAnKydpbiBSZWFjdCAxOC4gQ29uc2lkZXIgdXNpbmcgYSBwb3J0YWwgaW5zdGVhZC4gVW50aWwgeW91IHN3aXRjaCB0byAnK1widGhlIGNyZWF0ZVJvb3QgQVBJLCB5b3VyIGFwcCB3aWxsIGJlaGF2ZSBhcyBpZiBpdCdzIHJ1bm5pbmcgUmVhY3QgXCIrJzE3LiBMZWFybiBtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTt9aWYoIWlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyTm9kZSkpe3Rocm93IG5ldyBFcnJvcignVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKTt9aWYocGFyZW50Q29tcG9uZW50PT1udWxsfHwhaGFzKHBhcmVudENvbXBvbmVudCkpe3Rocm93IG5ldyBFcnJvcigncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKTt9cmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCxlbGVtZW50LGNvbnRhaW5lck5vZGUsZmFsc2UsY2FsbGJhY2spO31mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcil7aWYoIWlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyKSl7dGhyb3cgbmV3IEVycm9yKCd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7fXt2YXIgaXNNb2Rlcm5Sb290PWlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikmJmNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyPT09dW5kZWZpbmVkO2lmKGlzTW9kZXJuUm9vdCl7ZXJyb3IoJ1lvdSBhcmUgY2FsbGluZyBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnKydwYXNzZWQgdG8gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QudW5tb3VudCgpPycpO319aWYoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpe3t2YXIgcm9vdEVsPWdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO3ZhciByZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3Q9cm9vdEVsJiYhZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO2lmKHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCl7ZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIrJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJyk7fX0vLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbmZsdXNoU3luYyhmdW5jdGlvbigpe2xlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsbnVsbCxjb250YWluZXIsZmFsc2UsZnVuY3Rpb24oKXsvLyAkRmxvd0ZpeE1lIFRoaXMgc2hvdWxkIHByb2JhYmx5IHVzZSBgZGVsZXRlIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyYFxuY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbDt1bm1hcmtDb250YWluZXJBc1Jvb3QoY29udGFpbmVyKTt9KTt9KTsvLyBJZiB5b3UgY2FsbCB1bm1vdW50Q29tcG9uZW50QXROb2RlIHR3aWNlIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHlvdSdsbFxuLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG5yZXR1cm4gdHJ1ZTt9ZWxzZXt7dmFyIF9yb290RWw9Z2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7dmFyIGhhc05vblJvb3RSZWFjdENoaWxkPSEhKF9yb290RWwmJmdldEluc3RhbmNlRnJvbU5vZGUoX3Jvb3RFbCkpOy8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxudmFyIGlzQ29udGFpbmVyUmVhY3RSb290PWNvbnRhaW5lci5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERSYmaXNWYWxpZENvbnRhaW5lckxlZ2FjeShjb250YWluZXIucGFyZW50Tm9kZSkmJiEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihoYXNOb25Sb290UmVhY3RDaGlsZCl7ZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIrJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLGlzQ29udGFpbmVyUmVhY3RSb290PydZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcrJ29mIGl0cyBjb250YWluZXIuJzonSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnKydyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJyk7fX1yZXR1cm4gZmFsc2U7fX1zZXRBdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uJDEpO3NldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uJDEpO3NldEF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkkMSk7c2V0R2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSk7c2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkocnVuV2l0aFByaW9yaXR5KTt7aWYodHlwZW9mIE1hcCE9PSdmdW5jdGlvbid8fC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgTWFwIGhhcyBubyBwcm90b3R5cGVcbk1hcC5wcm90b3R5cGU9PW51bGx8fHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ghPT0nZnVuY3Rpb24nfHx0eXBlb2YgU2V0IT09J2Z1bmN0aW9uJ3x8Ly8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBTZXQgaGFzIG5vIHByb3RvdHlwZVxuU2V0LnByb3RvdHlwZT09bnVsbHx8dHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIhPT0nZnVuY3Rpb24nfHx0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoIT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJysncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTt9fXNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbihyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMpO3NldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oYmF0Y2hlZFVwZGF0ZXMkMSxkaXNjcmV0ZVVwZGF0ZXMsZmx1c2hTeW5jKTtmdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbixjb250YWluZXIpe3ZhciBrZXk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOm51bGw7aWYoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSl7dGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO30vLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuLy8gJEZsb3dGaXhNZSBUaGUgRmxvdyB0eXBlIGlzIG9wYXF1ZSBidXQgdGhlcmUncyBubyB3YXkgdG8gYWN0dWFsbHkgY3JlYXRlIGl0LlxucmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbixjb250YWluZXIsbnVsbCxrZXkpO31mdW5jdGlvbiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsZWxlbWVudCxjb250YWluZXJOb2RlLGNhbGxiYWNrKXtyZXR1cm4gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LGVsZW1lbnQsY29udGFpbmVyTm9kZSxjYWxsYmFjayk7fXZhciBJbnRlcm5hbHM9e3VzaW5nQ2xpZW50RW50cnlQb2ludDpmYWxzZSwvLyBLZWVwIGluIHN5bmMgd2l0aCBSZWFjdFRlc3RVdGlscy5qcy5cbi8vIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG5FdmVudHM6W2dldEluc3RhbmNlRnJvbU5vZGUsZ2V0Tm9kZUZyb21JbnN0YW5jZSxnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlLGVucXVldWVTdGF0ZVJlc3RvcmUscmVzdG9yZVN0YXRlSWZOZWVkZWQsYmF0Y2hlZFVwZGF0ZXMkMV19O2Z1bmN0aW9uIGNyZWF0ZVJvb3QkMShjb250YWluZXIsb3B0aW9ucyl7e2lmKCFJbnRlcm5hbHMudXNpbmdDbGllbnRFbnRyeVBvaW50JiYhZmFsc2Upe2Vycm9yKCdZb3UgYXJlIGltcG9ydGluZyBjcmVhdGVSb290IGZyb20gXCJyZWFjdC1kb21cIiB3aGljaCBpcyBub3Qgc3VwcG9ydGVkLiAnKydZb3Ugc2hvdWxkIGluc3RlYWQgaW1wb3J0IGl0IGZyb20gXCJyZWFjdC1kb20vY2xpZW50XCIuJyk7fX1yZXR1cm4gY3JlYXRlUm9vdChjb250YWluZXIsb3B0aW9ucyk7fWZ1bmN0aW9uIGh5ZHJhdGVSb290JDEoY29udGFpbmVyLGluaXRpYWxDaGlsZHJlbixvcHRpb25zKXt7aWYoIUludGVybmFscy51c2luZ0NsaWVudEVudHJ5UG9pbnQmJiFmYWxzZSl7ZXJyb3IoJ1lvdSBhcmUgaW1wb3J0aW5nIGh5ZHJhdGVSb290IGZyb20gXCJyZWFjdC1kb21cIiB3aGljaCBpcyBub3Qgc3VwcG9ydGVkLiAnKydZb3Ugc2hvdWxkIGluc3RlYWQgaW1wb3J0IGl0IGZyb20gXCJyZWFjdC1kb20vY2xpZW50XCIuJyk7fX1yZXR1cm4gaHlkcmF0ZVJvb3QoY29udGFpbmVyLGluaXRpYWxDaGlsZHJlbixvcHRpb25zKTt9Ly8gT3ZlcmxvYWQgdGhlIGRlZmluaXRpb24gdG8gdGhlIHR3byB2YWxpZCBzaWduYXR1cmVzLlxuLy8gV2FybmluZywgdGhpcyBvcHRzLW91dCBvZiBjaGVja2luZyB0aGUgZnVuY3Rpb24gYm9keS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGZsdXNoU3luYyQxKGZuKXt7aWYoaXNBbHJlYWR5UmVuZGVyaW5nKCkpe2Vycm9yKCdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIFJlYWN0IGNhbm5vdCAnKydmbHVzaCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLiBDb25zaWRlciBtb3ZpbmcgdGhpcyBjYWxsIHRvICcrJ2Egc2NoZWR1bGVyIHRhc2sgb3IgbWljcm8gdGFzay4nKTt9fXJldHVybiBmbHVzaFN5bmMoZm4pO312YXIgZm91bmREZXZUb29scz1pbmplY3RJbnRvRGV2VG9vbHMoe2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLGJ1bmRsZVR5cGU6MSx2ZXJzaW9uOlJlYWN0VmVyc2lvbixyZW5kZXJlclBhY2thZ2VOYW1lOidyZWFjdC1kb20nfSk7e2lmKCFmb3VuZERldlRvb2xzJiZjYW5Vc2VET00mJndpbmRvdy50b3A9PT13aW5kb3cuc2VsZil7Ly8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG5pZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpPi0xJiZuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKT09PS0xfHxuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKT4tMSl7dmFyIHByb3RvY29sPXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDsvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG5pZigvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcbmNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJysnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scycrKHByb3RvY29sPT09J2ZpbGU6Jz8nXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scy1mYXEnOicnKSwnZm9udC13ZWlnaHQ6Ym9sZCcpO319fX1leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEPUludGVybmFscztleHBvcnRzLmNyZWF0ZVBvcnRhbD1jcmVhdGVQb3J0YWwkMTtleHBvcnRzLmNyZWF0ZVJvb3Q9Y3JlYXRlUm9vdCQxO2V4cG9ydHMuZmluZERPTU5vZGU9ZmluZERPTU5vZGU7ZXhwb3J0cy5mbHVzaFN5bmM9Zmx1c2hTeW5jJDE7ZXhwb3J0cy5oeWRyYXRlPWh5ZHJhdGU7ZXhwb3J0cy5oeWRyYXRlUm9vdD1oeWRyYXRlUm9vdCQxO2V4cG9ydHMucmVuZGVyPXJlbmRlcjtleHBvcnRzLnVubW91bnRDb21wb25lbnRBdE5vZGU9dW5tb3VudENvbXBvbmVudEF0Tm9kZTtleHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPWJhdGNoZWRVcGRhdGVzJDE7ZXhwb3J0cy51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcj1yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtleHBvcnRzLnZlcnNpb249UmVhY3RWZXJzaW9uOy8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9pZih0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIT09J3VuZGVmaW5lZCcmJnR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3A9PT0nZnVuY3Rpb24nKXtfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO319KSgpO30iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcz8wMjQyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n    var hasSymbol = typeof Symbol === 'function' && Symbol.for;\n    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\n    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\n    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\n    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\n    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\n    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\n    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n    // (unstable) APIs that have been removed. Can we remove the symbols?\n\n    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\n    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\n    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\n    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\n    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\n    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\n    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\n    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\n    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n    function isValidElementType(type) {\n      return typeof type === 'string' || typeof type === 'function' ||\n      // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n    }\n    function typeOf(object) {\n      if (typeof object === 'object' && object !== null) {\n        var $$typeof = object.$$typeof;\n        switch ($$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = object.type;\n            switch (type) {\n              case REACT_ASYNC_MODE_TYPE:\n              case REACT_CONCURRENT_MODE_TYPE:\n              case REACT_FRAGMENT_TYPE:\n              case REACT_PROFILER_TYPE:\n              case REACT_STRICT_MODE_TYPE:\n              case REACT_SUSPENSE_TYPE:\n                return type;\n              default:\n                var $$typeofType = type && type.$$typeof;\n                switch ($$typeofType) {\n                  case REACT_CONTEXT_TYPE:\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_LAZY_TYPE:\n                  case REACT_MEMO_TYPE:\n                  case REACT_PROVIDER_TYPE:\n                    return $$typeofType;\n                  default:\n                    return $$typeof;\n                }\n            }\n          case REACT_PORTAL_TYPE:\n            return $$typeof;\n        }\n      }\n      return undefined;\n    } // AsyncMode is deprecated along with isAsyncMode\n\n    var AsyncMode = REACT_ASYNC_MODE_TYPE;\n    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n    var ContextConsumer = REACT_CONTEXT_TYPE;\n    var ContextProvider = REACT_PROVIDER_TYPE;\n    var Element = REACT_ELEMENT_TYPE;\n    var ForwardRef = REACT_FORWARD_REF_TYPE;\n    var Fragment = REACT_FRAGMENT_TYPE;\n    var Lazy = REACT_LAZY_TYPE;\n    var Memo = REACT_MEMO_TYPE;\n    var Portal = REACT_PORTAL_TYPE;\n    var Profiler = REACT_PROFILER_TYPE;\n    var StrictMode = REACT_STRICT_MODE_TYPE;\n    var Suspense = REACT_SUSPENSE_TYPE;\n    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\n    function isAsyncMode(object) {\n      {\n        if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n          hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n          console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n        }\n      }\n      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n    }\n    function isConcurrentMode(object) {\n      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n    }\n    function isContextConsumer(object) {\n      return typeOf(object) === REACT_CONTEXT_TYPE;\n    }\n    function isContextProvider(object) {\n      return typeOf(object) === REACT_PROVIDER_TYPE;\n    }\n    function isElement(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n    function isForwardRef(object) {\n      return typeOf(object) === REACT_FORWARD_REF_TYPE;\n    }\n    function isFragment(object) {\n      return typeOf(object) === REACT_FRAGMENT_TYPE;\n    }\n    function isLazy(object) {\n      return typeOf(object) === REACT_LAZY_TYPE;\n    }\n    function isMemo(object) {\n      return typeOf(object) === REACT_MEMO_TYPE;\n    }\n    function isPortal(object) {\n      return typeOf(object) === REACT_PORTAL_TYPE;\n    }\n    function isProfiler(object) {\n      return typeOf(object) === REACT_PROFILER_TYPE;\n    }\n    function isStrictMode(object) {\n      return typeOf(object) === REACT_STRICT_MODE_TYPE;\n    }\n    function isSuspense(object) {\n      return typeOf(object) === REACT_SUSPENSE_TYPE;\n    }\n    exports.AsyncMode = AsyncMode;\n    exports.ConcurrentMode = ConcurrentMode;\n    exports.ContextConsumer = ContextConsumer;\n    exports.ContextProvider = ContextProvider;\n    exports.Element = Element;\n    exports.ForwardRef = ForwardRef;\n    exports.Fragment = Fragment;\n    exports.Lazy = Lazy;\n    exports.Memo = Memo;\n    exports.Portal = Portal;\n    exports.Profiler = Profiler;\n    exports.StrictMode = StrictMode;\n    exports.Suspense = Suspense;\n    exports.isAsyncMode = isAsyncMode;\n    exports.isConcurrentMode = isConcurrentMode;\n    exports.isContextConsumer = isContextConsumer;\n    exports.isContextProvider = isContextProvider;\n    exports.isElement = isElement;\n    exports.isForwardRef = isForwardRef;\n    exports.isFragment = isFragment;\n    exports.isLazy = isLazy;\n    exports.isMemo = isMemo;\n    exports.isPortal = isPortal;\n    exports.isProfiler = isProfiler;\n    exports.isStrictMode = isStrictMode;\n    exports.isSuspense = isSuspense;\n    exports.isValidElementType = isValidElementType;\n    exports.typeOf = typeOf;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzPzJlZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4gICAgLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuICAgIHZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG4gICAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbiAgICB2YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbiAgICB2YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG4gICAgdmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xuICAgIHZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbiAgICB2YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG4gICAgdmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4gICAgLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbiAgICB2YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xuICAgIHZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xuICAgIHZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbiAgICB2YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG4gICAgdmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbiAgICB2YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xuICAgIHZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG4gICAgdmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xuICAgIHZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbiAgICB2YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbiAgICB2YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gICAgICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbiAgICB2YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xuICAgIHZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xuICAgIHZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG4gICAgdmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG4gICAgdmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gICAgdmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xuICAgIHZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgdmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG4gICAgdmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG4gICAgdmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xuICAgIHZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gICAgdmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICAgIHZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gICAgdmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG4gICAgZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICAgIH1cbiAgICBleHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbiAgICBleHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG4gICAgZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG4gICAgZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbiAgICBleHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbiAgICBleHBvcnRzLkxhenkgPSBMYXp5O1xuICAgIGV4cG9ydHMuTWVtbyA9IE1lbW87XG4gICAgZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG4gICAgZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuICAgIGV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG4gICAgZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuICAgIGV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbiAgICBleHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuICAgIGV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbiAgICBleHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG4gICAgZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG4gICAgZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbiAgICBleHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbiAgICBleHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbiAgICBleHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG4gICAgZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbiAgICBleHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbiAgICBleHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuICAgIGV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuICAgIGV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/cjs/react-is.development.js\n");

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/NWI5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-is/index.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var ReactVersion = '18.2.0';\n\n    // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n    var REACT_ELEMENT_TYPE = Symbol.for('react.element');\n    var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol.for('react.memo');\n    var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n      return null;\n    }\n\n    /**\n     * Keeps track of the current dispatcher.\n     */\n    var ReactCurrentDispatcher = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n\n    /**\n     * Keeps track of the current batch's configuration such as how long an update\n     * should suspend for if it needs to.\n     */\n    var ReactCurrentBatchConfig = {\n      transition: null\n    };\n    var ReactCurrentActQueue = {\n      current: null,\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n      isBatchingLegacy: false,\n      didScheduleLegacyUpdate: false\n    };\n\n    /**\n     * Keeps track of the current owner.\n     *\n     * The current owner is the component who should own any components that are\n     * currently being constructed.\n     */\n    var ReactCurrentOwner = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    var ReactDebugCurrentFrame = {};\n    var currentExtraStackFrame = null;\n    function setExtraStackFrame(stack) {\n      {\n        currentExtraStackFrame = stack;\n      }\n    }\n    {\n      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n        {\n          currentExtraStackFrame = stack;\n        }\n      }; // Stack implementation injected by the current renderer.\n\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFrame.getStackAddendum = function () {\n        var stack = ''; // Add an extra top frame while an element is being validated\n\n        if (currentExtraStackFrame) {\n          stack += currentExtraStackFrame;\n        } // Delegate to the injected renderer-specific implementation\n\n        var impl = ReactDebugCurrentFrame.getCurrentStack;\n        if (impl) {\n          stack += impl() || '';\n        }\n        return stack;\n      };\n    }\n\n    // -----------------------------------------------------------------------------\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var ReactSharedInternals = {\n      ReactCurrentDispatcher: ReactCurrentDispatcher,\n      ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n      ReactCurrentOwner: ReactCurrentOwner\n    };\n    {\n      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n    }\n\n    // by calls to these methods by a Babel plugin.\n    //\n    // In PROD (or in packages without access to React internals),\n    // they are left as they are instead.\n\n    function warn(format) {\n      {\n        {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          printWarning('warn', format, args);\n        }\n      }\n    }\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n          printWarning('error', format, args);\n        }\n      }\n    }\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n    var didWarnStateUpdateForUnmountedComponent = {};\n    function warnNoop(publicInstance, callerName) {\n      {\n        var _constructor = publicInstance.constructor;\n        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n        var warningKey = componentName + \".\" + callerName;\n        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n          return;\n        }\n        error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n      }\n    }\n    /**\n     * This is the abstract API for an update queue.\n     */\n\n    var ReactNoopUpdateQueue = {\n      /**\n       * Checks whether or not this composite component is mounted.\n       * @param {ReactClass} publicInstance The instance we want to test.\n       * @return {boolean} True if mounted, false otherwise.\n       * @protected\n       * @final\n       */\n      isMounted: function (publicInstance) {\n        return false;\n      },\n      /**\n       * Forces an update. This should only be invoked when it is known with\n       * certainty that we are **not** in a DOM transaction.\n       *\n       * You may want to call this when you know that some deeper aspect of the\n       * component's state has changed but `setState` was not called.\n       *\n       * This will not invoke `shouldComponentUpdate`, but it will invoke\n       * `componentWillUpdate` and `componentDidUpdate`.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueForceUpdate: function (publicInstance, callback, callerName) {\n        warnNoop(publicInstance, 'forceUpdate');\n      },\n      /**\n       * Replaces all of the state. Always use this or `setState` to mutate state.\n       * You should treat `this.state` as immutable.\n       *\n       * There is no guarantee that `this.state` will be immediately updated, so\n       * accessing `this.state` after calling this method may return the old value.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} completeState Next state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n        warnNoop(publicInstance, 'replaceState');\n      },\n      /**\n       * Sets a subset of the state. This only exists because _pendingState is\n       * internal. This provides a merging strategy that is not available to deep\n       * properties which is confusing. TODO: Expose pendingState or don't use it\n       * during the merge.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} partialState Next partial state to be merged with state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} Name of the calling function in the public API.\n       * @internal\n       */\n      enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n        warnNoop(publicInstance, 'setState');\n      }\n    };\n    var assign = Object.assign;\n    var emptyObject = {};\n    {\n      Object.freeze(emptyObject);\n    }\n    /**\n     * Base class helpers for the updating state of a component.\n     */\n\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n      // renderer.\n\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    Component.prototype.isReactComponent = {};\n    /**\n     * Sets a subset of the state. Always use this to mutate\n     * state. You should treat `this.state` as immutable.\n     *\n     * There is no guarantee that `this.state` will be immediately updated, so\n     * accessing `this.state` after calling this method may return the old value.\n     *\n     * There is no guarantee that calls to `setState` will run synchronously,\n     * as they may eventually be batched together.  You can provide an optional\n     * callback that will be executed when the call to setState is actually\n     * completed.\n     *\n     * When a function is provided to setState, it will be called at some point in\n     * the future (not synchronously). It will be called with the up to date\n     * component arguments (state, props, context). These values can be different\n     * from this.* because your function may be called after receiveProps but before\n     * shouldComponentUpdate, and this new state, props, and context will not yet be\n     * assigned to this.\n     *\n     * @param {object|function} partialState Next partial state or function to\n     *        produce next partial state to be merged with current state.\n     * @param {?function} callback Called after state is updated.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.setState = function (partialState, callback) {\n      if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n      }\n      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n    };\n    /**\n     * Forces an update. This should only be invoked when it is known with\n     * certainty that we are **not** in a DOM transaction.\n     *\n     * You may want to call this when you know that some deeper aspect of the\n     * component's state has changed but `setState` was not called.\n     *\n     * This will not invoke `shouldComponentUpdate`, but it will invoke\n     * `componentWillUpdate` and `componentDidUpdate`.\n     *\n     * @param {?function} callback Called after update is complete.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n    };\n    /**\n     * Deprecated APIs. These APIs used to exist on classic React classes but since\n     * we would like to deprecate them, we're not going to move them over to this\n     * modern base class. Instead, we define a getter that warns if it's accessed.\n     */\n\n    {\n      var deprecatedAPIs = {\n        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n      };\n      var defineDeprecationWarning = function (methodName, info) {\n        Object.defineProperty(Component.prototype, methodName, {\n          get: function () {\n            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n            return undefined;\n          }\n        });\n      };\n      for (var fnName in deprecatedAPIs) {\n        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n        }\n      }\n    }\n    function ComponentDummy() {}\n    ComponentDummy.prototype = Component.prototype;\n    /**\n     * Convenience component with default shallow equality check for sCU.\n     */\n\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n    assign(pureComponentPrototype, Component.prototype);\n    pureComponentPrototype.isPureReactComponent = true;\n\n    // an immutable object with a single mutable value\n    function createRef() {\n      var refObject = {\n        current: null\n      };\n      {\n        Object.seal(refObject);\n      }\n      return refObject;\n    }\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n      if (displayName) {\n        return displayName;\n      }\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n      if (typeof type === 'string') {\n        return type;\n      }\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n            if (outerName !== null) {\n              return outerName;\n            }\n            return getComponentNameFromType(type.type) || 'Memo';\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n\n      return null;\n    }\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      var warnAboutAccessingKey = function () {\n        {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingKey.isReactWarning = true;\n      Object.defineProperty(props, 'key', {\n        get: warnAboutAccessingKey,\n        configurable: true\n      });\n    }\n    function defineRefPropWarningGetter(props, displayName) {\n      var warnAboutAccessingRef = function () {\n        {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n    function warnIfStringRefCannotBeAutoConverted(config) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * Create and return a new ReactElement of the given type.\n     * See https://reactjs.org/docs/react-api.html#createelement\n     */\n\n    function createElement(type, config, children) {\n      var propName; // Reserved names are extracted\n\n      var props = {};\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          {\n            warnIfStringRefCannotBeAutoConverted(config);\n          }\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        {\n          if (Object.freeze) {\n            Object.freeze(childArray);\n          }\n        }\n        props.children = childArray;\n      } // Resolve default props\n\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n      {\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n      }\n      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n      return newElement;\n    }\n    /**\n     * Clone and return a new ReactElement using element as the starting point.\n     * See https://reactjs.org/docs/react-api.html#cloneelement\n     */\n\n    function cloneElement(element, config, children) {\n      if (element === null || element === undefined) {\n        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n      }\n      var propName; // Original props are copied\n\n      var props = assign({}, element.props); // Reserved names are extracted\n\n      var key = element.key;\n      var ref = element.ref; // Self is preserved since the owner is preserved.\n\n      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n\n      var source = element._source; // Owner will be preserved, unless ref is overridden\n\n      var owner = element._owner;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        } // Remaining properties override existing props\n\n        var defaultProps;\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n    /**\n     * Escape and wrap key so it is safe to use as a reactid\n     *\n     * @param {string} key to be escaped.\n     * @return {string} the escaped key.\n     */\n\n    function escape(key) {\n      var escapeRegex = /[=:]/g;\n      var escaperLookup = {\n        '=': '=0',\n        ':': '=2'\n      };\n      var escapedString = key.replace(escapeRegex, function (match) {\n        return escaperLookup[match];\n      });\n      return '$' + escapedString;\n    }\n    /**\n     * TODO: Test that a single child and an array with one item have the same key\n     * pattern.\n     */\n\n    var didWarnAboutMaps = false;\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n    function escapeUserProvidedKey(text) {\n      return text.replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n    /**\n     * Generate a key string that identifies a element within a set.\n     *\n     * @param {*} element A element that could contain a manual key.\n     * @param {number} index Index that is used if a manual key is not provided.\n     * @return {string}\n     */\n\n    function getElementKey(element, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if (typeof element === 'object' && element !== null && element.key != null) {\n        // Explicit key\n        {\n          checkKeyStringCoercion(element.key);\n        }\n        return escape('' + element.key);\n      } // Implicit key determined by the index in the set\n\n      return index.toString(36);\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = typeof children;\n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n      var invokeCallback = false;\n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n        }\n      }\n      if (invokeCallback) {\n        var _child = children;\n        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n        // so that it's consistent if the number of children grows:\n\n        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n        if (isArray(mappedChild)) {\n          var escapedChildKey = '';\n          if (childKey != null) {\n            escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n          }\n          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n            return c;\n          });\n        } else if (mappedChild != null) {\n          if (isValidElement(mappedChild)) {\n            {\n              // The `if` statement here prevents auto-disabling of the safe\n              // coercion ESLint rule, so we must manually disable it below.\n              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                checkKeyStringCoercion(mappedChild.key);\n              }\n            }\n            mappedChild = cloneAndReplaceKey(mappedChild,\n            // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            escapedPrefix + (\n            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            mappedChild.key && (!_child || _child.key !== mappedChild.key) ?\n            // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n          }\n          array.push(mappedChild);\n        }\n        return 1;\n      }\n      var child;\n      var nextName;\n      var subtreeCount = 0; // Count of children found in the current subtree.\n\n      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getElementKey(child, i);\n          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          var iterableChildren = children;\n          {\n            // Warn about using Maps as children\n            if (iteratorFn === iterableChildren.entries) {\n              if (!didWarnAboutMaps) {\n                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n              }\n              didWarnAboutMaps = true;\n            }\n          }\n          var iterator = iteratorFn.call(iterableChildren);\n          var step;\n          var ii = 0;\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getElementKey(child, ii++);\n            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n          }\n        } else if (type === 'object') {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          var childrenString = String(children);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n      }\n      return subtreeCount;\n    }\n\n    /**\n     * Maps children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n     *\n     * The provided mapFunction(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} func The map function.\n     * @param {*} context Context for mapFunction.\n     * @return {object} Object containing the ordered map of results.\n     */\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n      var result = [];\n      var count = 0;\n      mapIntoArray(children, result, '', '', function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    /**\n     * Count the number of children that are typically specified as\n     * `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n     *\n     * @param {?*} children Children tree container.\n     * @return {number} The number of children.\n     */\n\n    function countChildren(children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++; // Don't return anything\n      });\n\n      return n;\n    }\n\n    /**\n     * Iterates through children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n     *\n     * The provided forEachFunc(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} forEachFunc\n     * @param {*} forEachContext Context for forEachContext.\n     */\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      mapChildren(children, function () {\n        forEachFunc.apply(this, arguments); // Don't return anything.\n      }, forEachContext);\n    }\n    /**\n     * Flatten a children object (typically specified as `props.children`) and\n     * return an array with appropriately re-keyed children.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n     */\n\n    function toArray(children) {\n      return mapChildren(children, function (child) {\n        return child;\n      }) || [];\n    }\n    /**\n     * Returns the first child in a collection of children and verifies that there\n     * is only one child in the collection.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n     *\n     * The current implementation of this function assumes that a single child gets\n     * passed without a wrapper, but the purpose of this helper function is to\n     * abstract away the particular structure of children.\n     *\n     * @param {?object} children Child collection structure.\n     * @return {ReactElement} The first and only `ReactElement` contained in the\n     * structure.\n     */\n\n    function onlyChild(children) {\n      if (!isValidElement(children)) {\n        throw new Error('React.Children.only expected to receive a single React element child.');\n      }\n      return children;\n    }\n    function createContext(defaultValue) {\n      // TODO: Second argument used to be an optional `calculateChangedBits`\n      // function. Warn to reserve for future use?\n      var context = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        // As a workaround to support multiple concurrent renderers, we categorize\n        // some renderers as primary and others as secondary. We only expect\n        // there to be two concurrent renderers at most: React Native (primary) and\n        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n        // Secondary renderers store their context values on separate fields.\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        // Used to track how many concurrent renderers this context currently\n        // supports within in a single renderer. Such as parallel server rendering.\n        _threadCount: 0,\n        // These are circular\n        Provider: null,\n        Consumer: null,\n        // Add these to use same hidden class in VM as ServerContext\n        _defaultValue: null,\n        _globalName: null\n      };\n      context.Provider = {\n        $$typeof: REACT_PROVIDER_TYPE,\n        _context: context\n      };\n      var hasWarnedAboutUsingNestedContextConsumers = false;\n      var hasWarnedAboutUsingConsumerProvider = false;\n      var hasWarnedAboutDisplayNameOnConsumer = false;\n      {\n        // A separate object, but proxies back to the original context object for\n        // backwards compatibility. It has a different $$typeof, so we can properly\n        // warn for the incorrect usage of Context as a Consumer.\n        var Consumer = {\n          $$typeof: REACT_CONTEXT_TYPE,\n          _context: context\n        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n        Object.defineProperties(Consumer, {\n          Provider: {\n            get: function () {\n              if (!hasWarnedAboutUsingConsumerProvider) {\n                hasWarnedAboutUsingConsumerProvider = true;\n                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n              }\n              return context.Provider;\n            },\n            set: function (_Provider) {\n              context.Provider = _Provider;\n            }\n          },\n          _currentValue: {\n            get: function () {\n              return context._currentValue;\n            },\n            set: function (_currentValue) {\n              context._currentValue = _currentValue;\n            }\n          },\n          _currentValue2: {\n            get: function () {\n              return context._currentValue2;\n            },\n            set: function (_currentValue2) {\n              context._currentValue2 = _currentValue2;\n            }\n          },\n          _threadCount: {\n            get: function () {\n              return context._threadCount;\n            },\n            set: function (_threadCount) {\n              context._threadCount = _threadCount;\n            }\n          },\n          Consumer: {\n            get: function () {\n              if (!hasWarnedAboutUsingNestedContextConsumers) {\n                hasWarnedAboutUsingNestedContextConsumers = true;\n                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n              }\n              return context.Consumer;\n            }\n          },\n          displayName: {\n            get: function () {\n              return context.displayName;\n            },\n            set: function (displayName) {\n              if (!hasWarnedAboutDisplayNameOnConsumer) {\n                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                hasWarnedAboutDisplayNameOnConsumer = true;\n              }\n            }\n          }\n        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n        context.Consumer = Consumer;\n      }\n      {\n        context._currentRenderer = null;\n        context._currentRenderer2 = null;\n      }\n      return context;\n    }\n    var Uninitialized = -1;\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n    function lazyInitializer(payload) {\n      if (payload._status === Uninitialized) {\n        var ctor = payload._result;\n        var thenable = ctor(); // Transition to the next state.\n        // This might throw either because it's missing or throws. If so, we treat it\n        // as still uninitialized and try again next time. Which is the same as what\n        // happens if the ctor or any wrappers processing the ctor throws. This might\n        // end up fixing it if the resolution was a concurrency bug.\n\n        thenable.then(function (moduleObject) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var resolved = payload;\n            resolved._status = Resolved;\n            resolved._result = moduleObject;\n          }\n        }, function (error) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var rejected = payload;\n            rejected._status = Rejected;\n            rejected._result = error;\n          }\n        });\n        if (payload._status === Uninitialized) {\n          // In case, we're still uninitialized, then we're waiting for the thenable\n          // to resolve. Set it as pending in the meantime.\n          var pending = payload;\n          pending._status = Pending;\n          pending._result = thenable;\n        }\n      }\n      if (payload._status === Resolved) {\n        var moduleObject = payload._result;\n        {\n          if (moduleObject === undefined) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n          }\n        }\n        {\n          if (!('default' in moduleObject)) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n          }\n        }\n        return moduleObject.default;\n      } else {\n        throw payload._result;\n      }\n    }\n    function lazy(ctor) {\n      var payload = {\n        // We use these fields to store the result.\n        _status: Uninitialized,\n        _result: ctor\n      };\n      var lazyType = {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: payload,\n        _init: lazyInitializer\n      };\n      {\n        // In production, this would just set it on the object.\n        var defaultProps;\n        var propTypes; // $FlowFixMe\n\n        Object.defineProperties(lazyType, {\n          defaultProps: {\n            configurable: true,\n            get: function () {\n              return defaultProps;\n            },\n            set: function (newDefaultProps) {\n              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              defaultProps = newDefaultProps; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'defaultProps', {\n                enumerable: true\n              });\n            }\n          },\n          propTypes: {\n            configurable: true,\n            get: function () {\n              return propTypes;\n            },\n            set: function (newPropTypes) {\n              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              propTypes = newPropTypes; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'propTypes', {\n                enumerable: true\n              });\n            }\n          }\n        });\n      }\n      return lazyType;\n    }\n    function forwardRef(render) {\n      {\n        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n        } else if (typeof render !== 'function') {\n          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n        } else {\n          if (render.length !== 0 && render.length !== 2) {\n            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n          }\n        }\n        if (render != null) {\n          if (render.defaultProps != null || render.propTypes != null) {\n            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n          }\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_FORWARD_REF_TYPE,\n        render: render\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function () {\n            return ownName;\n          },\n          set: function (name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.forwardRef((props, ref) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!render.name && !render.displayName) {\n              render.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    var REACT_MODULE_REFERENCE;\n    {\n      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n    }\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function memo(type, compare) {\n      {\n        if (!isValidElementType(type)) {\n          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: compare === undefined ? null : compare\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function () {\n            return ownName;\n          },\n          set: function (name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.memo((props) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!type.name && !type.displayName) {\n              type.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactCurrentDispatcher.current;\n      {\n        if (dispatcher === null) {\n          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n      } // Will result in a null access error if accessed outside render phase. We\n      // intentionally don't throw our own error because this is in a hot path.\n      // Also helps ensure this is inlined.\n\n      return dispatcher;\n    }\n    function useContext(Context) {\n      var dispatcher = resolveDispatcher();\n      {\n        // TODO: add a more generic warning for invalid values.\n        if (Context._context !== undefined) {\n          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n          // and nobody should be using this in existing code.\n\n          if (realContext.Consumer === Context) {\n            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n          } else if (realContext.Provider === Context) {\n            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n          }\n        }\n      }\n      return dispatcher.useContext(Context);\n    }\n    function useState(initialState) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useState(initialState);\n    }\n    function useReducer(reducer, initialArg, init) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useReducer(reducer, initialArg, init);\n    }\n    function useRef(initialValue) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useRef(initialValue);\n    }\n    function useEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useEffect(create, deps);\n    }\n    function useInsertionEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useInsertionEffect(create, deps);\n    }\n    function useLayoutEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useLayoutEffect(create, deps);\n    }\n    function useCallback(callback, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useCallback(callback, deps);\n    }\n    function useMemo(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useMemo(create, deps);\n    }\n    function useImperativeHandle(ref, create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useImperativeHandle(ref, create, deps);\n    }\n    function useDebugValue(value, formatterFn) {\n      {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useDebugValue(value, formatterFn);\n      }\n    }\n    function useTransition() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useTransition();\n    }\n    function useDeferredValue(value) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useDeferredValue(value);\n    }\n    function useId() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useId();\n    }\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n\n    // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n    function disabledLog() {}\n    disabledLog.__reactDisabledLog = true;\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n    function reenableLogs() {\n      {\n        disabledDepth--;\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n        return '\\n' + prefix + name;\n      }\n    }\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n      {\n        var frame = componentFrameCache.get(fn);\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher$1.current = null;\n        disableLogs();\n      }\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher$1.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n      return '';\n    }\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          setExtraStackFrame(stack);\n        } else {\n          setExtraStackFrame(null);\n        }\n      }\n    }\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    function getDeclarationErrorAddendum() {\n      if (ReactCurrentOwner.current) {\n        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n        if (name) {\n          return '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendum(source) {\n      if (source !== undefined) {\n        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n        var lineNumber = source.lineNumber;\n        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendumForProps(elementProps) {\n      if (elementProps !== null && elementProps !== undefined) {\n        return getSourceInfoErrorAddendum(elementProps.__source);\n      }\n      return '';\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n    var ownerHasKeyUseWarning = {};\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = getDeclarationErrorAddendum();\n      if (!info) {\n        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n        if (parentName) {\n          info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n        }\n      }\n      return info;\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n    function validateExplicitKey(element, parentType) {\n      if (!element._store || element._store.validated || element.key != null) {\n        return;\n      }\n      element._store.validated = true;\n      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n        return;\n      }\n      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n      // property, it may be the creator of the child that's responsible for\n      // assigning it a key.\n\n      var childOwner = '';\n      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n        // Give the component that originally created this child.\n        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n      }\n      {\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n    function validateChildKeys(node, parentType) {\n      if (typeof node !== 'object') {\n        return;\n      }\n      if (isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          var child = node[i];\n          if (isValidElement(child)) {\n            validateExplicitKey(child, parentType);\n          }\n        }\n      } else if (isValidElement(node)) {\n        // This element was passed in a valid location.\n        if (node._store) {\n          node._store.validated = true;\n        }\n      } else if (node) {\n        var iteratorFn = getIteratorFn(node);\n        if (typeof iteratorFn === 'function') {\n          // Entry iterators used to provide implicit keys,\n          // but now we print a separate warning for them later.\n          if (iteratorFn !== node.entries) {\n            var iterator = iteratorFn.call(node);\n            var step;\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n        var propTypes;\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n    function createElementWithValidation(type, props, children) {\n      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n\n      if (!validType) {\n        var info = '';\n        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n        }\n        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n        if (sourceInfo) {\n          info += sourceInfo;\n        } else {\n          info += getDeclarationErrorAddendum();\n        }\n        var typeString;\n        if (type === null) {\n          typeString = 'null';\n        } else if (isArray(type)) {\n          typeString = 'array';\n        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n          typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n          info = ' Did you accidentally export a JSX literal instead of a component?';\n        } else {\n          typeString = typeof type;\n        }\n        {\n          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n      }\n      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n      // TODO: Drop this when these are no longer allowed as the type argument.\n\n      if (element == null) {\n        return element;\n      } // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing errors.\n      // We don't want exception behavior to differ between dev and prod.\n      // (Rendering will throw with a helpful message and as soon as the type is\n      // fixed, the key warnings will appear.)\n\n      if (validType) {\n        for (var i = 2; i < arguments.length; i++) {\n          validateChildKeys(arguments[i], type);\n        }\n      }\n      if (type === REACT_FRAGMENT_TYPE) {\n        validateFragmentProps(element);\n      } else {\n        validatePropTypes(element);\n      }\n      return element;\n    }\n    var didWarnAboutDeprecatedCreateFactory = false;\n    function createFactoryWithValidation(type) {\n      var validatedFactory = createElementWithValidation.bind(null, type);\n      validatedFactory.type = type;\n      {\n        if (!didWarnAboutDeprecatedCreateFactory) {\n          didWarnAboutDeprecatedCreateFactory = true;\n          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n        } // Legacy hook: remove it\n\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function () {\n            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n      return validatedFactory;\n    }\n    function cloneElementWithValidation(element, props, children) {\n      var newElement = cloneElement.apply(this, arguments);\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], newElement.type);\n      }\n      validatePropTypes(newElement);\n      return newElement;\n    }\n    function startTransition(scope, options) {\n      var prevTransition = ReactCurrentBatchConfig.transition;\n      ReactCurrentBatchConfig.transition = {};\n      var currentTransition = ReactCurrentBatchConfig.transition;\n      {\n        ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n      }\n      try {\n        scope();\n      } finally {\n        ReactCurrentBatchConfig.transition = prevTransition;\n        {\n          if (prevTransition === null && currentTransition._updatedFibers) {\n            var updatedFibersCount = currentTransition._updatedFibers.size;\n            if (updatedFibersCount > 10) {\n              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n            }\n            currentTransition._updatedFibers.clear();\n          }\n        }\n      }\n    }\n    var didWarnAboutMessageChannel = false;\n    var enqueueTaskImpl = null;\n    function enqueueTask(task) {\n      if (enqueueTaskImpl === null) {\n        try {\n          // read require off the module object to get around the bundlers.\n          // we don't want them to detect a require and bundle a Node polyfill.\n          var requireString = ('require' + Math.random()).slice(0, 7);\n          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n          // version of setImmediate, bypassing fake timers if any.\n\n          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n        } catch (_err) {\n          // we're in a browser\n          // we can't use regular timers because they may still be faked\n          // so we try MessageChannel+postMessage instead\n          enqueueTaskImpl = function (callback) {\n            {\n              if (didWarnAboutMessageChannel === false) {\n                didWarnAboutMessageChannel = true;\n                if (typeof MessageChannel === 'undefined') {\n                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n                }\n              }\n            }\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(undefined);\n          };\n        }\n      }\n      return enqueueTaskImpl(task);\n    }\n    var actScopeDepth = 0;\n    var didWarnNoAwaitAct = false;\n    function act(callback) {\n      {\n        // `act` calls can be nested, so we track the depth. This represents the\n        // number of `act` scopes on the stack.\n        var prevActScopeDepth = actScopeDepth;\n        actScopeDepth++;\n        if (ReactCurrentActQueue.current === null) {\n          // This is the outermost `act` scope. Initialize the queue. The reconciler\n          // will detect the queue and use it instead of Scheduler.\n          ReactCurrentActQueue.current = [];\n        }\n        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n        var result;\n        try {\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n          // set to `true` while the given callback is executed, not for updates\n          // triggered during an async event, because this is how the legacy\n          // implementation of `act` behaved.\n          ReactCurrentActQueue.isBatchingLegacy = true;\n          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n          // which flushed updates immediately after the scope function exits, even\n          // if it's an async function.\n\n          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n            var queue = ReactCurrentActQueue.current;\n            if (queue !== null) {\n              ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n              flushActQueue(queue);\n            }\n          }\n        } catch (error) {\n          popActScope(prevActScopeDepth);\n          throw error;\n        } finally {\n          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n        }\n        if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n          // for it to resolve before exiting the current scope.\n\n          var wasAwaited = false;\n          var thenable = {\n            then: function (resolve, reject) {\n              wasAwaited = true;\n              thenableResult.then(function (returnValue) {\n                popActScope(prevActScopeDepth);\n                if (actScopeDepth === 0) {\n                  // We've exited the outermost act scope. Recursively flush the\n                  // queue until there's no remaining work.\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }, function (error) {\n                // The callback threw an error.\n                popActScope(prevActScopeDepth);\n                reject(error);\n              });\n            }\n          };\n          {\n            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n              // eslint-disable-next-line no-undef\n              Promise.resolve().then(function () {}).then(function () {\n                if (!wasAwaited) {\n                  didWarnNoAwaitAct = true;\n                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n                }\n              });\n            }\n          }\n          return thenable;\n        } else {\n          var returnValue = result; // The callback is not an async function. Exit the current scope\n          // immediately, without awaiting.\n\n          popActScope(prevActScopeDepth);\n          if (actScopeDepth === 0) {\n            // Exiting the outermost act scope. Flush the queue.\n            var _queue = ReactCurrentActQueue.current;\n            if (_queue !== null) {\n              flushActQueue(_queue);\n              ReactCurrentActQueue.current = null;\n            } // Return a thenable. If the user awaits it, we'll flush again in\n            // case additional work was scheduled by a microtask.\n\n            var _thenable = {\n              then: function (resolve, reject) {\n                // Confirm we haven't re-entered another `act` scope, in case\n                // the user does something weird like await the thenable\n                // multiple times.\n                if (ReactCurrentActQueue.current === null) {\n                  // Recursively flush the queue until there's no remaining work.\n                  ReactCurrentActQueue.current = [];\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }\n            };\n            return _thenable;\n          } else {\n            // Since we're inside a nested `act` scope, the returned thenable\n            // immediately resolves. The outer scope will flush the queue.\n            var _thenable2 = {\n              then: function (resolve, reject) {\n                resolve(returnValue);\n              }\n            };\n            return _thenable2;\n          }\n        }\n      }\n    }\n    function popActScope(prevActScopeDepth) {\n      {\n        if (prevActScopeDepth !== actScopeDepth - 1) {\n          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n        }\n        actScopeDepth = prevActScopeDepth;\n      }\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      {\n        var queue = ReactCurrentActQueue.current;\n        if (queue !== null) {\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              if (queue.length === 0) {\n                // No additional work was scheduled. Finish.\n                ReactCurrentActQueue.current = null;\n                resolve(returnValue);\n              } else {\n                // Keep flushing work until there's none left.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n              }\n            });\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          resolve(returnValue);\n        }\n      }\n    }\n    var isFlushing = false;\n    function flushActQueue(queue) {\n      {\n        if (!isFlushing) {\n          // Prevent re-entrance.\n          isFlushing = true;\n          var i = 0;\n          try {\n            for (; i < queue.length; i++) {\n              var callback = queue[i];\n              do {\n                callback = callback(true);\n              } while (callback !== null);\n            }\n            queue.length = 0;\n          } catch (error) {\n            // If something throws, leave the remaining callbacks on the queue.\n            queue = queue.slice(i + 1);\n            throw error;\n          } finally {\n            isFlushing = false;\n          }\n        }\n      }\n    }\n    var createElement$1 = createElementWithValidation;\n    var cloneElement$1 = cloneElementWithValidation;\n    var createFactory = createFactoryWithValidation;\n    var Children = {\n      map: mapChildren,\n      forEach: forEachChildren,\n      count: countChildren,\n      toArray: toArray,\n      only: onlyChild\n    };\n    exports.Children = Children;\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n    exports.cloneElement = cloneElement$1;\n    exports.createContext = createContext;\n    exports.createElement = createElement$1;\n    exports.createFactory = createFactory;\n    exports.createRef = createRef;\n    exports.forwardRef = forwardRef;\n    exports.isValidElement = isValidElement;\n    exports.lazy = lazy;\n    exports.memo = memo;\n    exports.startTransition = startTransition;\n    exports.unstable_act = act;\n    exports.useCallback = useCallback;\n    exports.useContext = useContext;\n    exports.useDebugValue = useDebugValue;\n    exports.useDeferredValue = useDeferredValue;\n    exports.useEffect = useEffect;\n    exports.useId = useId;\n    exports.useImperativeHandle = useImperativeHandle;\n    exports.useInsertionEffect = useInsertionEffect;\n    exports.useLayoutEffect = useLayoutEffect;\n    exports.useMemo = useMemo;\n    exports.useReducer = useReducer;\n    exports.useRef = useRef;\n    exports.useState = useState;\n    exports.useSyncExternalStore = useSyncExternalStore;\n    exports.useTransition = useTransition;\n    exports.version = ReactVersion;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzP2QwYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0VmVyc2lvbiA9ICcxOC4yLjAnO1xuXG4gICAgLy8gQVRURU5USU9OXG4gICAgLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuICAgIC8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbiAgICAvLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbiAgICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xuICAgIHZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICAgIHZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgICB2YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gICAgdmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICAgIHZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgICB2YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xuICAgIHZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgICB2YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gICAgdmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgICB2YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xuICAgIHZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG4gICAgdmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gICAgdmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gICAgICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICAgICAqL1xuICAgIHZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICAgICAqL1xuICAgICAgY3VycmVudDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAgICAgKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gICAgICovXG4gICAgdmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICAgICAgdHJhbnNpdGlvbjogbnVsbFxuICAgIH07XG4gICAgdmFyIFJlYWN0Q3VycmVudEFjdFF1ZXVlID0ge1xuICAgICAgY3VycmVudDogbnVsbCxcbiAgICAgIC8vIFVzZWQgdG8gcmVwcm9kdWNlIGJlaGF2aW9yIG9mIGBiYXRjaGVkVXBkYXRlc2AgaW4gbGVnYWN5IG1vZGUuXG4gICAgICBpc0JhdGNoaW5nTGVnYWN5OiBmYWxzZSxcbiAgICAgIGRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlOiBmYWxzZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAgICAgKlxuICAgICAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAgICAgKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gICAgICovXG4gICAgdmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICAgICAqL1xuICAgICAgY3VycmVudDogbnVsbFxuICAgIH07XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbiAgICB2YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gICAgICB7XG4gICAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICAgICAge1xuICAgICAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICAgICAgfVxuICAgICAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgICAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cbiAgICAgICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICAgICAgaWYgKGltcGwpIHtcbiAgICAgICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbiAgICB2YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG4gICAgdmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbiAgICB2YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuICAgIC8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbiAgICAvLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxuICAgIHZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbiAgICB2YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICAgICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyXG4gICAgfTtcbiAgICB7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEFjdFF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWU7XG4gICAgfVxuXG4gICAgLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbiAgICAvL1xuICAgIC8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4gICAgLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG4gICAgZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgfVxuICAgICAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gICAgICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgICAgIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICAgICAge1xuICAgICAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG4gICAgICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICAgICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICAgICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcbiAgICBmdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICAgICAge1xuICAgICAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuICAgICAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICAgICAqL1xuXG4gICAgdmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBmaW5hbFxuICAgICAgICovXG4gICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAgICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAgICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAgICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgICAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAgICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAgICAgKlxuICAgICAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICAgICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgICAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgICAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAgICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICAgICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAqL1xuICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4gICAgdmFyIGVtcHR5T2JqZWN0ID0ge307XG4gICAge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gICAgICAvLyByZW5kZXJlci5cblxuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAgICAgKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgICAqXG4gICAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICAgICAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICAgICAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gICAgICogY29tcGxldGVkLlxuICAgICAqXG4gICAgICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gICAgICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gICAgICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAgICAgKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICAgICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gICAgICogYXNzaWduZWQgdG8gdGhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gICAgICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgIT09ICdmdW5jdGlvbicgJiYgcGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhICcgKyAnZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gICAgICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAgICAgKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAgICAgKi9cblxuICAgIHtcbiAgICAgIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgICAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICAgICAgfTtcbiAgICAgIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICAgICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG4gICAgQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG4gICAgfVxuICAgIHZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbiAgICBwdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbiAgICBhc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgcHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbiAgICAvLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgICAgIHZhciByZWZPYmplY3QgPSB7XG4gICAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICAgIH07XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmT2JqZWN0O1xuICAgIH1cbiAgICB2YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgICAgIHJldHVybiBpc0FycmF5SW1wbChhKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICAgICAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gICAgICpcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gICAgICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICAgICAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gICAgICovXG4gICAgLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbiAgICBmdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICAgICAge1xuICAgICAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgICAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG4gICAgZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAgICAgIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gICAgICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAgICAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAgICAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gICAgICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAgICAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gICAgICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgICAgIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAgICAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgICAgIC8vXG4gICAgICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gICAgICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gICAgICAvL1xuICAgICAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgICAgIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAgICAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAgICAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgICAgIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgICAgIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgICAgIC8vXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIHJldHVybiAnJyArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuICAgICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG4gICAgICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG4gICAgfSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuICAgIGZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0JztcbiAgICB9IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1BvcnRhbCc7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1N1c3BlbnNlJztcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gICAgICBrZXk6IHRydWUsXG4gICAgICByZWY6IHRydWUsXG4gICAgICBfX3NlbGY6IHRydWUsXG4gICAgICBfX3NvdXJjZTogdHJ1ZVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcbiAgICB7XG4gICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICAgICAge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICAgICAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gICAgICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gICAgICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdHlwZVxuICAgICAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gICAgICogQHBhcmFtIHsqfSBvd25lclxuICAgICAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICAgICAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAgICAgKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICAgICAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAgICAgKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gICAgICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cblxuICAgIHZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAgICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgICAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICAgICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAgICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgICAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAgICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgIHZhciBrZXkgPSBudWxsO1xuICAgICAgdmFyIHJlZiA9IG51bGw7XG4gICAgICB2YXIgc2VsZiA9IG51bGw7XG4gICAgICB2YXIgc291cmNlID0gbnVsbDtcbiAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICAgICAge1xuICAgICAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgICAgICB9XG4gICAgICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICAgICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gICAgICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cbiAgICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB7XG4gICAgICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICAgICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgICAgIHJldHVybiBuZXdFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIik7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICAgICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgICAgIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAgICAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAgICAgLy8gdHJ1ZSBvd25lci5cblxuICAgICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgICAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gICAgICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICAgIH1cbiAgICB2YXIgU0VQQVJBVE9SID0gJy4nO1xuICAgIHZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4gICAgLyoqXG4gICAgICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgICAgIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gICAgICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAgICAgJz0nOiAnPTAnLFxuICAgICAgICAnOic6ICc9MidcbiAgICAgIH07XG4gICAgICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gICAgICogcGF0dGVybi5cbiAgICAgKi9cblxuICAgIHZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gICAgdmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbiAgICBmdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEV4cGxpY2l0IGtleVxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihlbGVtZW50LmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgICAgIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuICAgICAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG4gICAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgICAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICAgICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcbiAgICAgICAgaWYgKGlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuICAgICAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGBpZmAgc3RhdGVtZW50IGhlcmUgcHJldmVudHMgYXV0by1kaXNhYmxpbmcgb2YgdGhlIHNhZmVcbiAgICAgICAgICAgICAgLy8gY29lcmNpb24gRVNMaW50IHJ1bGUsIHNvIHdlIG11c3QgbWFudWFsbHkgZGlzYWJsZSBpdCBiZWxvdy5cbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgICAgICAgIGlmIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSkge1xuICAgICAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWFwcGVkQ2hpbGQua2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAgICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgICAgICBlc2NhcGVkUHJlZml4ICsgKFxuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkO1xuICAgICAgdmFyIG5leHROYW1lO1xuICAgICAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgICAgIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG4gICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VidHJlZUNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gICAgICpcbiAgICAgKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICAgICAqIGxlYWYgY2hpbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICAgICAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gICAgICogYHByb3BzLmNoaWxkcmVuYC5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICAgICAqXG4gICAgICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAgICAgKiBsZWFmIGNoaWxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICAgICAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgICAgIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgICAgIH0sIGZvckVhY2hDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAgICAgKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSkgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICAgICAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICAgICAqXG4gICAgICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICAgICAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gICAgICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICAgICAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAgICAgKiBzdHJ1Y3R1cmUuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAvLyBUT0RPOiBTZWNvbmQgYXJndW1lbnQgdXNlZCB0byBiZSBhbiBvcHRpb25hbCBgY2FsY3VsYXRlQ2hhbmdlZEJpdHNgXG4gICAgICAvLyBmdW5jdGlvbi4gV2FybiB0byByZXNlcnZlIGZvciBmdXR1cmUgdXNlP1xuICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgICAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAgICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgICAgICBQcm92aWRlcjogbnVsbCxcbiAgICAgICAgQ29uc3VtZXI6IG51bGwsXG4gICAgICAgIC8vIEFkZCB0aGVzZSB0byB1c2Ugc2FtZSBoaWRkZW4gY2xhc3MgaW4gVk0gYXMgU2VydmVyQ29udGV4dFxuICAgICAgICBfZGVmYXVsdFZhbHVlOiBudWxsLFxuICAgICAgICBfZ2xvYmFsTmFtZTogbnVsbFxuICAgICAgfTtcbiAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgICAgICBfY29udGV4dDogY29udGV4dFxuICAgICAgfTtcbiAgICAgIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICAgICAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gICAgICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcbiAgICAgIHtcbiAgICAgICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAgICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICAgIF9jb250ZXh0OiBjb250ZXh0XG4gICAgICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICAgICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICB2YXIgVW5pbml0aWFsaXplZCA9IC0xO1xuICAgIHZhciBQZW5kaW5nID0gMDtcbiAgICB2YXIgUmVzb2x2ZWQgPSAxO1xuICAgIHZhciBSZWplY3RlZCA9IDI7XG4gICAgZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgLy8gVGhpcyBtaWdodCB0aHJvdyBlaXRoZXIgYmVjYXVzZSBpdCdzIG1pc3Npbmcgb3IgdGhyb3dzLiBJZiBzbywgd2UgdHJlYXQgaXRcbiAgICAgICAgLy8gYXMgc3RpbGwgdW5pbml0aWFsaXplZCBhbmQgdHJ5IGFnYWluIG5leHQgdGltZS4gV2hpY2ggaXMgdGhlIHNhbWUgYXMgd2hhdFxuICAgICAgICAvLyBoYXBwZW5zIGlmIHRoZSBjdG9yIG9yIGFueSB3cmFwcGVycyBwcm9jZXNzaW5nIHRoZSBjdG9yIHRocm93cy4gVGhpcyBtaWdodFxuICAgICAgICAvLyBlbmQgdXAgZml4aW5nIGl0IGlmIHRoZSByZXNvbHV0aW9uIHdhcyBhIGNvbmN1cnJlbmN5IGJ1Zy5cblxuICAgICAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAvLyBJbiBjYXNlLCB3ZSdyZSBzdGlsbCB1bmluaXRpYWxpemVkLCB0aGVuIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSB0aGVuYWJsZVxuICAgICAgICAgIC8vIHRvIHJlc29sdmUuIFNldCBpdCBhcyBwZW5kaW5nIGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgICAgICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICAgICAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICAgICAgdmFyIG1vZHVsZU9iamVjdCA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChtb2R1bGVPYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcCcgKyAnb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgK1xuICAgICAgICAgICAgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXFxuXFxuXCIgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcHV0IGN1cmx5IGJyYWNlcyBhcm91bmQgdGhlIGltcG9ydD8nLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCEoJ2RlZmF1bHQnIGluIG1vZHVsZU9iamVjdCkpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICtcbiAgICAgICAgICAgIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICAgICAgX3N0YXR1czogVW5pbml0aWFsaXplZCxcbiAgICAgICAgX3Jlc3VsdDogY3RvclxuICAgICAgfTtcbiAgICAgIHZhciBsYXp5VHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICAgICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgICAgIH07XG4gICAgICB7XG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICAgICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcbiAgICAgICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcbiAgICAgICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGF6eVR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgICAgICByZW5kZXI6IHJlbmRlclxuICAgICAgfTtcbiAgICAgIHtcbiAgICAgICAgdmFyIG93bk5hbWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgb3duTmFtZSA9IG5hbWU7IC8vIFRoZSBpbm5lciBjb21wb25lbnQgc2hvdWxkbid0IGluaGVyaXQgdGhpcyBkaXNwbGF5IG5hbWUgaW4gbW9zdCBjYXNlcyxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgICAgICAvLyBCdXQgaXQncyBuaWNlIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHRvIGluaGVyaXQgdGhlIG5hbWUsXG4gICAgICAgICAgICAvLyBzbyB0aGF0IG91ciBjb21wb25lbnQtc3RhY2sgZ2VuZXJhdGlvbiBsb2dpYyB3aWxsIGRpc3BsYXkgdGhlaXIgZnJhbWVzLlxuICAgICAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgICAgIC8vICAgUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gey4uLn0pO1xuICAgICAgICAgICAgLy8gVGhpcyBraW5kIG9mIGlubmVyIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIGVsc2V3aGVyZSBzbyB0aGUgc2lkZSBlZmZlY3QgaXMgb2theS5cblxuICAgICAgICAgICAgaWYgKCFyZW5kZXIubmFtZSAmJiAhcmVuZGVyLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcbiAgICB9XG4gICAgdmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG4gICAge1xuICAgICAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJIHx8IGVuYWJsZUNhY2hlRWxlbWVudCB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8XG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAgICAgLy8gd2l0aC5cbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gICAgICB9O1xuICAgICAge1xuICAgICAgICB2YXIgb3duTmFtZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBvd25OYW1lID0gbmFtZTsgLy8gVGhlIGlubmVyIGNvbXBvbmVudCBzaG91bGRuJ3QgaW5oZXJpdCB0aGlzIGRpc3BsYXkgbmFtZSBpbiBtb3N0IGNhc2VzLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cbiAgICAgICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgb3VyIGNvbXBvbmVudC1zdGFjayBnZW5lcmF0aW9uIGxvZ2ljIHdpbGwgZGlzcGxheSB0aGVpciBmcmFtZXMuXG4gICAgICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAgICAgLy8gICBSZWFjdC5tZW1vKChwcm9wcykgPT4gey4uLn0pO1xuICAgICAgICAgICAgLy8gVGhpcyBraW5kIG9mIGlubmVyIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIGVsc2V3aGVyZSBzbyB0aGUgc2lkZSBlZmZlY3QgaXMgb2theS5cblxuICAgICAgICAgICAgaWYgKCF0eXBlLm5hbWUgJiYgIXR5cGUuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgICAgIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBlcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdpbGwgcmVzdWx0IGluIGEgbnVsbCBhY2Nlc3MgZXJyb3IgaWYgYWNjZXNzZWQgb3V0c2lkZSByZW5kZXIgcGhhc2UuIFdlXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGRvbid0IHRocm93IG91ciBvd24gZXJyb3IgYmVjYXVzZSB0aGlzIGlzIGluIGEgaG90IHBhdGguXG4gICAgICAvLyBBbHNvIGhlbHBzIGVuc3VyZSB0aGlzIGlzIGlubGluZWQuXG5cbiAgICAgIHJldHVybiBkaXNwYXRjaGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuICAgICAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VUcmFuc2l0aW9uKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VJZCgpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUlkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfVxuXG4gICAgLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuICAgIC8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4gICAgLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuICAgIC8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxuICAgIHZhciBkaXNhYmxlZERlcHRoID0gMDtcbiAgICB2YXIgcHJldkxvZztcbiAgICB2YXIgcHJldkluZm87XG4gICAgdmFyIHByZXZXYXJuO1xuICAgIHZhciBwcmV2RXJyb3I7XG4gICAgdmFyIHByZXZHcm91cDtcbiAgICB2YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xuICAgIHZhciBwcmV2R3JvdXBFbmQ7XG4gICAgZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICAgIH1cblxuICAgICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIHtcbiAgICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuICAgIHZhciBwcmVmaXg7XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG4gICAgICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZWVudHJ5ID0gZmFsc2U7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG4gICAge1xuICAgICAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY29udHJvbDtcbiAgICAgIHJlZW50cnkgPSB0cnVlO1xuICAgICAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHtcbiAgICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgICAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBkaXNhYmxlTG9ncygpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgICBjLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlZW50cnkgPSBmYWxzZTtcbiAgICAgICAge1xuICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG4gICAgICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICAgICAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ludGhldGljRnJhbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gICAgICB7XG4gICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAgICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICAgICAge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgICAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcbiAgICAgICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICAgICAge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuICAgIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gICAgICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAgICogdXBkYXRlcy5cbiAgICAgKi9cblxuICAgIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICAgICAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICAgICAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICAgICAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICAgICAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICAgICAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICAgICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuICAgICAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICAgICAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICAgICAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gICAgICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAgICAgKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wVHlwZXM7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gICAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG4gICAgICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG4gICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcbiAgICAgICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcbiAgICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZVN0cmluZztcbiAgICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cbiAgICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICB2YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICAgICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG4gICAgICB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG4gICAgICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICAgICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgICAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzY29wZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSB7fTtcbiAgICAgIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG4gICAgICB7XG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzY29wZSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZEZpYmVyc0NvdW50ID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgICAgICB3YXJuKCdEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uICcgKyAnSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gJyArICdPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSBmYWxzZTtcbiAgICB2YXIgZW5xdWV1ZVRhc2tJbXBsID0gbnVsbDtcbiAgICBmdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gICAgICBpZiAoZW5xdWV1ZVRhc2tJbXBsID09PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gcmVhZCByZXF1aXJlIG9mZiB0aGUgbW9kdWxlIG9iamVjdCB0byBnZXQgYXJvdW5kIHRoZSBidW5kbGVycy5cbiAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZW0gdG8gZGV0ZWN0IGEgcmVxdWlyZSBhbmQgYnVuZGxlIGEgTm9kZSBwb2x5ZmlsbC5cbiAgICAgICAgICB2YXIgcmVxdWlyZVN0cmluZyA9ICgncmVxdWlyZScgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgwLCA3KTtcbiAgICAgICAgICB2YXIgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddOyAvLyBhc3N1bWluZyB3ZSdyZSBpbiBub2RlLCBsZXQncyB0cnkgdG8gZ2V0IG5vZGUnc1xuICAgICAgICAgIC8vIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLCBieXBhc3NpbmcgZmFrZSB0aW1lcnMgaWYgYW55LlxuXG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gbm9kZVJlcXVpcmUuY2FsbChtb2R1bGUsICd0aW1lcnMnKS5zZXRJbW1lZGlhdGU7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAvLyB3ZSdyZSBpbiBhIGJyb3dzZXJcbiAgICAgICAgICAvLyB3ZSBjYW4ndCB1c2UgcmVndWxhciB0aW1lcnMgYmVjYXVzZSB0aGV5IG1heSBzdGlsbCBiZSBmYWtlZFxuICAgICAgICAgIC8vIHNvIHdlIHRyeSBNZXNzYWdlQ2hhbm5lbCtwb3N0TWVzc2FnZSBpbnN0ZWFkXG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3QgaGF2ZSBhIE1lc3NhZ2VDaGFubmVsIGltcGxlbWVudGF0aW9uLCAnICsgJ3NvIGVucXVldWluZyB0YXNrcyB2aWEgYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLikgd2lsbCBmYWlsLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMgJyArICdpZiB5b3UgZW5jb3VudGVyIHRoaXMgd2FybmluZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSh1bmRlZmluZWQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnF1ZXVlVGFza0ltcGwodGFzayk7XG4gICAgfVxuICAgIHZhciBhY3RTY29wZURlcHRoID0gMDtcbiAgICB2YXIgZGlkV2Fybk5vQXdhaXRBY3QgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBhY3QoY2FsbGJhY2spIHtcbiAgICAgIHtcbiAgICAgICAgLy8gYGFjdGAgY2FsbHMgY2FuIGJlIG5lc3RlZCwgc28gd2UgdHJhY2sgdGhlIGRlcHRoLiBUaGlzIHJlcHJlc2VudHMgdGhlXG4gICAgICAgIC8vIG51bWJlciBvZiBgYWN0YCBzY29wZXMgb24gdGhlIHN0YWNrLlxuICAgICAgICB2YXIgcHJldkFjdFNjb3BlRGVwdGggPSBhY3RTY29wZURlcHRoO1xuICAgICAgICBhY3RTY29wZURlcHRoKys7XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb3V0ZXJtb3N0IGBhY3RgIHNjb3BlLiBJbml0aWFsaXplIHRoZSBxdWV1ZS4gVGhlIHJlY29uY2lsZXJcbiAgICAgICAgICAvLyB3aWxsIGRldGVjdCB0aGUgcXVldWUgYW5kIHVzZSBpdCBpbnN0ZWFkIG9mIFNjaGVkdWxlci5cbiAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZJc0JhdGNoaW5nTGVnYWN5ID0gUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLiBPbmx5XG4gICAgICAgICAgLy8gc2V0IHRvIGB0cnVlYCB3aGlsZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgaXMgZXhlY3V0ZWQsIG5vdCBmb3IgdXBkYXRlc1xuICAgICAgICAgIC8vIHRyaWdnZXJlZCBkdXJpbmcgYW4gYXN5bmMgZXZlbnQsIGJlY2F1c2UgdGhpcyBpcyBob3cgdGhlIGxlZ2FjeVxuICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIGBhY3RgIGJlaGF2ZWQuXG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2soKTsgLy8gUmVwbGljYXRlIGJlaGF2aW9yIG9mIG9yaWdpbmFsIGBhY3RgIGltcGxlbWVudGF0aW9uIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgICAgIC8vIHdoaWNoIGZsdXNoZWQgdXBkYXRlcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgc2NvcGUgZnVuY3Rpb24gZXhpdHMsIGV2ZW5cbiAgICAgICAgICAvLyBpZiBpdCdzIGFuIGFzeW5jIGZ1bmN0aW9uLlxuXG4gICAgICAgICAgaWYgKCFwcmV2SXNCYXRjaGluZ0xlZ2FjeSAmJiBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmlzQmF0Y2hpbmdMZWdhY3kgPSBwcmV2SXNCYXRjaGluZ0xlZ2FjeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0aGVuYWJsZVJlc3VsdCA9IHJlc3VsdDsgLy8gVGhlIGNhbGxiYWNrIGlzIGFuIGFzeW5jIGZ1bmN0aW9uIChpLmUuIHJldHVybmVkIGEgcHJvbWlzZSkuIFdhaXRcbiAgICAgICAgICAvLyBmb3IgaXQgdG8gcmVzb2x2ZSBiZWZvcmUgZXhpdGluZyB0aGUgY3VycmVudCBzY29wZS5cblxuICAgICAgICAgIHZhciB3YXNBd2FpdGVkID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlID0ge1xuICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB3YXNBd2FpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhlbmFibGVSZXN1bHQudGhlbihmdW5jdGlvbiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdFNjb3BlRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aXRlZCB0aGUgb3V0ZXJtb3N0IGFjdCBzY29wZS4gUmVjdXJzaXZlbHkgZmx1c2ggdGhlXG4gICAgICAgICAgICAgICAgICAvLyBxdWV1ZSB1bnRpbCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLlxuICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFkaWRXYXJuTm9Bd2FpdEFjdCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge30pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghd2FzQXdhaXRlZCkge1xuICAgICAgICAgICAgICAgICAgZGlkV2Fybk5vQXdhaXRBY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ1lvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gJyArICdUaGlzIGNvdWxkIGxlYWQgdG8gdW5leHBlY3RlZCB0ZXN0aW5nIGJlaGF2aW91ciwgJyArICdpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgJyArICdzY29wZXMuICcgKyAnWW91IHNob3VsZCAtIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pOycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSByZXN1bHQ7IC8vIFRoZSBjYWxsYmFjayBpcyBub3QgYW4gYXN5bmMgZnVuY3Rpb24uIEV4aXQgdGhlIGN1cnJlbnQgc2NvcGVcbiAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2l0aG91dCBhd2FpdGluZy5cblxuICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICBpZiAoYWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRXhpdGluZyB0aGUgb3V0ZXJtb3N0IGFjdCBzY29wZS4gRmx1c2ggdGhlIHF1ZXVlLlxuICAgICAgICAgICAgdmFyIF9xdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoX3F1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGZsdXNoQWN0UXVldWUoX3F1ZXVlKTtcbiAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9IC8vIFJldHVybiBhIHRoZW5hYmxlLiBJZiB0aGUgdXNlciBhd2FpdHMgaXQsIHdlJ2xsIGZsdXNoIGFnYWluIGluXG4gICAgICAgICAgICAvLyBjYXNlIGFkZGl0aW9uYWwgd29yayB3YXMgc2NoZWR1bGVkIGJ5IGEgbWljcm90YXNrLlxuXG4gICAgICAgICAgICB2YXIgX3RoZW5hYmxlID0ge1xuICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ29uZmlybSB3ZSBoYXZlbid0IHJlLWVudGVyZWQgYW5vdGhlciBgYWN0YCBzY29wZSwgaW4gY2FzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHdlaXJkIGxpa2UgYXdhaXQgdGhlIHRoZW5hYmxlXG4gICAgICAgICAgICAgICAgLy8gbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAgICAgICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsdXNoIHRoZSBxdWV1ZSB1bnRpbCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLlxuICAgICAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF90aGVuYWJsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UncmUgaW5zaWRlIGEgbmVzdGVkIGBhY3RgIHNjb3BlLCB0aGUgcmV0dXJuZWQgdGhlbmFibGVcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmVzLiBUaGUgb3V0ZXIgc2NvcGUgd2lsbCBmbHVzaCB0aGUgcXVldWUuXG4gICAgICAgICAgICB2YXIgX3RoZW5hYmxlMiA9IHtcbiAgICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF90aGVuYWJsZTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEpIHtcbiAgICAgICAgICBlcnJvcignWW91IHNlZW0gdG8gaGF2ZSBvdmVybGFwcGluZyBhY3QoKSBjYWxscywgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0JlIHN1cmUgdG8gYXdhaXQgcHJldmlvdXMgYWN0KCkgY2FsbHMgYmVmb3JlIG1ha2luZyBhIG5ldyBvbmUuICcpO1xuICAgICAgICB9XG4gICAgICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG4gICAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgICAgIGVucXVldWVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGFkZGl0aW9uYWwgd29yayB3YXMgc2NoZWR1bGVkLiBGaW5pc2guXG4gICAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCBmbHVzaGluZyB3b3JrIHVudGlsIHRoZXJlJ3Mgbm9uZSBsZWZ0LlxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGZsdXNoQWN0UXVldWUocXVldWUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFpc0ZsdXNoaW5nKSB7XG4gICAgICAgICAgLy8gUHJldmVudCByZS1lbnRyYW5jZS5cbiAgICAgICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgICAgICBxdWV1ZSA9IHF1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjcmVhdGVFbGVtZW50JDEgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb247XG4gICAgdmFyIGNsb25lRWxlbWVudCQxID0gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb247XG4gICAgdmFyIGNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb247XG4gICAgdmFyIENoaWxkcmVuID0ge1xuICAgICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgICAgdG9BcnJheTogdG9BcnJheSxcbiAgICAgIG9ubHk6IG9ubHlDaGlsZFxuICAgIH07XG4gICAgZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuICAgIGV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICAgIGV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG4gICAgZXhwb3J0cy5TdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgICBleHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgICBleHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG4gICAgZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuICAgIGV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbiAgICBleHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuICAgIGV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuICAgIGV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG4gICAgZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuICAgIGV4cG9ydHMubGF6eSA9IGxhenk7XG4gICAgZXhwb3J0cy5tZW1vID0gbWVtbztcbiAgICBleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IHN0YXJ0VHJhbnNpdGlvbjtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2FjdCA9IGFjdDtcbiAgICBleHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG4gICAgZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbiAgICBleHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuICAgIGV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IHVzZURlZmVycmVkVmFsdWU7XG4gICAgZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG4gICAgZXhwb3J0cy51c2VJZCA9IHVzZUlkO1xuICAgIGV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG4gICAgZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3Q7XG4gICAgZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG4gICAgZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbiAgICBleHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuICAgIGV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuICAgIGV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbiAgICBleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmU7XG4gICAgZXhwb3J0cy51c2VUcmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbjtcbiAgICBleHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xuICAgIH1cbiAgfSkoKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/OGY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n");

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var enableSchedulerDebugging = false;\n    var enableProfiling = false;\n    var frameYieldMs = 5;\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      siftUp(heap, node, index);\n    }\n    function peek(heap) {\n      return heap.length === 0 ? null : heap[0];\n    }\n    function pop(heap) {\n      if (heap.length === 0) {\n        return null;\n      }\n      var first = heap[0];\n      var last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n      }\n      return first;\n    }\n    function siftUp(heap, node, i) {\n      var index = i;\n      while (index > 0) {\n        var parentIndex = index - 1 >>> 1;\n        var parent = heap[parentIndex];\n        if (compare(parent, node) > 0) {\n          // The parent is larger. Swap positions.\n          heap[parentIndex] = node;\n          heap[index] = parent;\n          index = parentIndex;\n        } else {\n          // The parent is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function siftDown(heap, node, i) {\n      var index = i;\n      var length = heap.length;\n      var halfLength = length >>> 1;\n      while (index < halfLength) {\n        var leftIndex = (index + 1) * 2 - 1;\n        var left = heap[leftIndex];\n        var rightIndex = leftIndex + 1;\n        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n        if (compare(left, node) < 0) {\n          if (rightIndex < length && compare(right, left) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n          } else {\n            heap[index] = left;\n            heap[leftIndex] = node;\n            index = leftIndex;\n          }\n        } else if (rightIndex < length && compare(right, node) < 0) {\n          heap[index] = right;\n          heap[rightIndex] = node;\n          index = rightIndex;\n        } else {\n          // Neither child is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function compare(a, b) {\n      // Compare sort index first, then task id.\n      var diff = a.sortIndex - b.sortIndex;\n      return diff !== 0 ? diff : a.id - b.id;\n    }\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n    function markTaskErrored(task, ms) {}\n\n    /* eslint-disable no-var */\n\n    var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    if (hasPerformanceNow) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      var initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\n    var taskQueue = [];\n    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\n    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\n    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\n    var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      var timer = peek(timerQueue);\n      while (timer !== null) {\n        if (timer.callback === null) {\n          // Timer was cancelled.\n          pop(timerQueue);\n        } else if (timer.startTime <= currentTime) {\n          // Timer fired. Transfer to the task queue.\n          pop(timerQueue);\n          timer.sortIndex = timer.expirationTime;\n          push(taskQueue, timer);\n        } else {\n          // Remaining timers are pending.\n          return;\n        }\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else {\n          var firstTimer = peek(timerQueue);\n          if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n          }\n        }\n      }\n    }\n    function flushWork(hasTimeRemaining, initialTime) {\n      isHostCallbackScheduled = false;\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n      isPerformingWork = true;\n      var previousPriorityLevel = currentPriorityLevel;\n      try {\n        if (enableProfiling) {\n          try {\n            return workLoop(hasTimeRemaining, initialTime);\n          } catch (error) {\n            if (currentTask !== null) {\n              var currentTime = exports.unstable_now();\n              markTaskErrored(currentTask, currentTime);\n              currentTask.isQueued = false;\n            }\n            throw error;\n          }\n        } else {\n          // No catch in prod code path.\n          return workLoop(hasTimeRemaining, initialTime);\n        }\n      } finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n      }\n    }\n    function workLoop(hasTimeRemaining, initialTime) {\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      currentTask = peek(taskQueue);\n      while (currentTask !== null && !enableSchedulerDebugging) {\n        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n          // This currentTask hasn't expired, and we've reached the deadline.\n          break;\n        }\n        var callback = currentTask.callback;\n        if (typeof callback === 'function') {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n          var continuationCallback = callback(didUserCallbackTimeout);\n          currentTime = exports.unstable_now();\n          if (typeof continuationCallback === 'function') {\n            currentTask.callback = continuationCallback;\n          } else {\n            if (currentTask === peek(taskQueue)) {\n              pop(taskQueue);\n            }\n          }\n          advanceTimers(currentTime);\n        } else {\n          pop(taskQueue);\n        }\n        currentTask = peek(taskQueue);\n      } // Return whether there's additional work\n\n      if (currentTask !== null) {\n        return true;\n      } else {\n        var firstTimer = peek(timerQueue);\n        if (firstTimer !== null) {\n          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n        return false;\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n      if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n      } else {\n        startTime = currentTime;\n      }\n      var timeout;\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n          break;\n        case UserBlockingPriority:\n          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n          break;\n        case IdlePriority:\n          timeout = IDLE_PRIORITY_TIMEOUT;\n          break;\n        case LowPriority:\n          timeout = LOW_PRIORITY_TIMEOUT;\n          break;\n        case NormalPriority:\n        default:\n          timeout = NORMAL_PRIORITY_TIMEOUT;\n          break;\n      }\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        sortIndex: -1\n      };\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          } // Schedule a timeout.\n\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask);\n        // wait until the next time we yield.\n\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n      return newTask;\n    }\n    function unstable_pauseExecution() {}\n    function unstable_continueExecution() {\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n    function unstable_getFirstCallbackNode() {\n      return peek(taskQueue);\n    }\n    function unstable_cancelCallback(task) {\n      // remove from the queue because you can't remove arbitrary nodes from an\n      // array based heap, only the first one.)\n\n      task.callback = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    var isMessageLoopRunning = false;\n    var scheduledHostCallback = null;\n    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n    // thread, like user events. By default, it yields multiple times per frame.\n    // It does not attempt to align with frame boundaries, since most tasks don't\n    // need to be frame aligned; for those that do, use requestAnimationFrame.\n\n    var frameInterval = frameYieldMs;\n    var startTime = -1;\n    function shouldYieldToHost() {\n      var timeElapsed = exports.unstable_now() - startTime;\n      if (timeElapsed < frameInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n      } // The main thread has been blocked for a non-negligible amount of time. We\n\n      return true;\n    }\n    function requestPaint() {}\n    function forceFrameRate(fps) {\n      if (fps < 0 || fps > 125) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n        return;\n      }\n      if (fps > 0) {\n        frameInterval = Math.floor(1000 / fps);\n      } else {\n        // reset the framerate\n        frameInterval = frameYieldMs;\n      }\n    }\n    var performWorkUntilDeadline = function () {\n      if (scheduledHostCallback !== null) {\n        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n        // has been blocked.\n\n        startTime = currentTime;\n        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n        var hasMoreWork = true;\n        try {\n          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        } finally {\n          if (hasMoreWork) {\n            // If there's more work, schedule the next message event at the end\n            // of the preceding one.\n            schedulePerformWorkUntilDeadline();\n          } else {\n            isMessageLoopRunning = false;\n            scheduledHostCallback = null;\n          }\n        }\n      } else {\n        isMessageLoopRunning = false;\n      } // Yielding to the browser will give it a chance to paint, so we can\n    };\n\n    var schedulePerformWorkUntilDeadline;\n    if (typeof localSetImmediate === 'function') {\n      // Node.js and old IE.\n      // There's a few reasons for why we prefer setImmediate.\n      //\n      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n      // (Even though this is a DOM fork of the Scheduler, you could get here\n      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n      // https://github.com/facebook/react/issues/20756\n      //\n      // But also, it runs earlier which is the semantic we want.\n      // If other browsers ever implement it, it's better to use it.\n      // Although both of these would be inferior to native scheduling.\n      schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    } else if (typeof MessageChannel !== 'undefined') {\n      // DOM and Worker environments.\n      // We prefer MessageChannel because of the 4ms setTimeout clamping.\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else {\n      // We should only fallback here in non-browser environments.\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    }\n    function requestHostCallback(callback) {\n      scheduledHostCallback = callback;\n      if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n      }\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    function cancelHostTimeout() {\n      localClearTimeout(taskTimeoutID);\n      taskTimeoutID = -1;\n    }\n    var unstable_requestPaint = requestPaint;\n    var unstable_Profiling = null;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_Profiling = unstable_Profiling;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_forceFrameRate = forceFrameRate;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n    exports.unstable_next = unstable_next;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanM/YTVmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbiAgICB9XG4gICAgdmFyIGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyA9IGZhbHNlO1xuICAgIHZhciBlbmFibGVQcm9maWxpbmcgPSBmYWxzZTtcbiAgICB2YXIgZnJhbWVZaWVsZE1zID0gNTtcbiAgICBmdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgICAgIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICAgICAgaGVhcC5wdXNoKG5vZGUpO1xuICAgICAgc2lmdFVwKGhlYXAsIG5vZGUsIGluZGV4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gICAgICByZXR1cm4gaGVhcC5sZW5ndGggPT09IDAgPyBudWxsIDogaGVhcFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgICAgIGlmIChoZWFwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdCA9IGhlYXBbMF07XG4gICAgICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG4gICAgICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICAgICAgaGVhcFswXSA9IGxhc3Q7XG4gICAgICAgIHNpZnREb3duKGhlYXAsIGxhc3QsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWZ0VXAoaGVhcCwgbm9kZSwgaSkge1xuICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXggLSAxID4+PiAxO1xuICAgICAgICB2YXIgcGFyZW50ID0gaGVhcFtwYXJlbnRJbmRleF07XG4gICAgICAgIGlmIChjb21wYXJlKHBhcmVudCwgbm9kZSkgPiAwKSB7XG4gICAgICAgICAgLy8gVGhlIHBhcmVudCBpcyBsYXJnZXIuIFN3YXAgcG9zaXRpb25zLlxuICAgICAgICAgIGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZTtcbiAgICAgICAgICBoZWFwW2luZGV4XSA9IHBhcmVudDtcbiAgICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBwYXJlbnQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgIHZhciBsZW5ndGggPSBoZWFwLmxlbmd0aDtcbiAgICAgIHZhciBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICAgICAgd2hpbGUgKGluZGV4IDwgaGFsZkxlbmd0aCkge1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICAgICAgdmFyIGxlZnQgPSBoZWFwW2xlZnRJbmRleF07XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICAgICAgaWYgKGNvbXBhcmUobGVmdCwgbm9kZSkgPCAwKSB7XG4gICAgICAgICAgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgY29tcGFyZShyaWdodCwgbGVmdCkgPCAwKSB7XG4gICAgICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYXBbaW5kZXhdID0gbGVmdDtcbiAgICAgICAgICAgIGhlYXBbbGVmdEluZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBpbmRleCA9IGxlZnRJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiBjb21wYXJlKHJpZ2h0LCBub2RlKSA8IDApIHtcbiAgICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOZWl0aGVyIGNoaWxkIGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgLy8gQ29tcGFyZSBzb3J0IGluZGV4IGZpcnN0LCB0aGVuIHRhc2sgaWQuXG4gICAgICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gICAgICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2Ugc3ltYm9scz9cbiAgICB2YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xuICAgIHZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG4gICAgdmFyIE5vcm1hbFByaW9yaXR5ID0gMztcbiAgICB2YXIgTG93UHJpb3JpdHkgPSA0O1xuICAgIHZhciBJZGxlUHJpb3JpdHkgPSA1O1xuICAgIGZ1bmN0aW9uIG1hcmtUYXNrRXJyb3JlZCh0YXNrLCBtcykge31cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG4gICAgdmFyIGhhc1BlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICAgICAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcbiAgICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhbERhdGUgPSBEYXRlO1xuICAgICAgdmFyIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgICAgIH07XG4gICAgfSAvLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbiAgICAvLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4gICAgLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxuICAgIHZhciBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7IC8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxuXG4gICAgdmFyIElNTUVESUFURV9QUklPUklUWV9USU1FT1VUID0gLTE7IC8vIEV2ZW50dWFsbHkgdGltZXMgb3V0XG5cbiAgICB2YXIgVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUID0gMjUwO1xuICAgIHZhciBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCA9IDUwMDA7XG4gICAgdmFyIExPV19QUklPUklUWV9USU1FT1VUID0gMTAwMDA7IC8vIE5ldmVyIHRpbWVzIG91dFxuXG4gICAgdmFyIElETEVfUFJJT1JJVFlfVElNRU9VVCA9IG1heFNpZ25lZDMxQml0SW50OyAvLyBUYXNrcyBhcmUgc3RvcmVkIG9uIGEgbWluIGhlYXBcblxuICAgIHZhciB0YXNrUXVldWUgPSBbXTtcbiAgICB2YXIgdGltZXJRdWV1ZSA9IFtdOyAvLyBJbmNyZW1lbnRpbmcgaWQgY291bnRlci4gVXNlZCB0byBtYWludGFpbiBpbnNlcnRpb24gb3JkZXIuXG5cbiAgICB2YXIgdGFza0lkQ291bnRlciA9IDE7IC8vIFBhdXNpbmcgdGhlIHNjaGVkdWxlciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICB2YXIgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIHZhciBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5OyAvLyBUaGlzIGlzIHNldCB3aGlsZSBwZXJmb3JtaW5nIHdvcmssIHRvIHByZXZlbnQgcmUtZW50cmFuY2UuXG5cbiAgICB2YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuICAgIHZhciBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7IC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuXG4gICAgdmFyIGxvY2FsU2V0VGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IG51bGw7XG4gICAgdmFyIGxvY2FsQ2xlYXJUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IG51bGw7XG4gICAgdmFyIGxvY2FsU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRJbW1lZGlhdGUgOiBudWxsOyAvLyBJRSBhbmQgTm9kZS5qcyArIGpzZG9tXG5cbiAgICB2YXIgaXNJbnB1dFBlbmRpbmcgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3Iuc2NoZWR1bGluZyAhPT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nICE9PSB1bmRlZmluZWQgPyBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZy5iaW5kKG5hdmlnYXRvci5zY2hlZHVsaW5nKSA6IG51bGw7XG4gICAgZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAgICAgLy8gQ2hlY2sgZm9yIHRhc2tzIHRoYXQgYXJlIG5vIGxvbmdlciBkZWxheWVkIGFuZCBhZGQgdGhlbSB0byB0aGUgcXVldWUuXG4gICAgICB2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgd2hpbGUgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgICAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hXb3JrKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAgICAgLy8gV2Ugc2NoZWR1bGVkIGEgdGltZW91dCBidXQgaXQncyBubyBsb25nZXIgbmVlZGVkLiBDYW5jZWwgaXQuXG4gICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICAgIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVuYWJsZVByb2ZpbGluZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICAgICAgbWFya1Rhc2tFcnJvcmVkKGN1cnJlbnRUYXNrLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlIHBhdGguXG4gICAgICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gaW5pdGlhbFRpbWU7XG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgd2hpbGUgKGN1cnJlbnRUYXNrICE9PSBudWxsICYmICFlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgKCFoYXNUaW1lUmVtYWluaW5nIHx8IHNob3VsZFlpZWxkVG9Ib3N0KCkpKSB7XG4gICAgICAgICAgLy8gVGhpcyBjdXJyZW50VGFzayBoYXNuJ3QgZXhwaXJlZCwgYW5kIHdlJ3ZlIHJlYWNoZWQgdGhlIGRlYWRsaW5lLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICB2YXIgZGlkVXNlckNhbGxiYWNrVGltZW91dCA9IGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKGRpZFVzZXJDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSkge1xuICAgICAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICB9IC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXG5cbiAgICAgIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3RhYmxlX25leHQoZXZlbnRIYW5kbGVyKSB7XG4gICAgICB2YXIgcHJpb3JpdHlMZXZlbDtcbiAgICAgIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV93cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZm9yayBvZiBydW5XaXRoUHJpb3JpdHksIGlubGluZWQgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgIHZhciBzdGFydFRpbWU7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICB2YXIgdGltZW91dDtcbiAgICAgIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICAgIHRpbWVvdXQgPSBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgICAgICB0aW1lb3V0ID0gVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgICAgIHRpbWVvdXQgPSBMT1dfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyB0aW1lb3V0O1xuICAgICAgdmFyIG5ld1Rhc2sgPSB7XG4gICAgICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgc29ydEluZGV4OiAtMVxuICAgICAgfTtcbiAgICAgIGlmIChzdGFydFRpbWUgPiBjdXJyZW50VGltZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZGVsYXllZCB0YXNrLlxuICAgICAgICBuZXdUYXNrLnNvcnRJbmRleCA9IHN0YXJ0VGltZTtcbiAgICAgICAgcHVzaCh0aW1lclF1ZXVlLCBuZXdUYXNrKTtcbiAgICAgICAgaWYgKHBlZWsodGFza1F1ZXVlKSA9PT0gbnVsbCAmJiBuZXdUYXNrID09PSBwZWVrKHRpbWVyUXVldWUpKSB7XG4gICAgICAgICAgLy8gQWxsIHRhc2tzIGFyZSBkZWxheWVkLCBhbmQgdGhpcyBpcyB0aGUgdGFzayB3aXRoIHRoZSBlYXJsaWVzdCBkZWxheS5cbiAgICAgICAgICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgICAgICAgICAgLy8gQ2FuY2VsIGFuIGV4aXN0aW5nIHRpbWVvdXQuXG4gICAgICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIFNjaGVkdWxlIGEgdGltZW91dC5cblxuICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBzdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Rhc2suc29ydEluZGV4ID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuXG4gICAgICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3VGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7fVxuICAgIGZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUoKSB7XG4gICAgICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gICAgICAvLyByZW1vdmUgZnJvbSB0aGUgcXVldWUgYmVjYXVzZSB5b3UgY2FuJ3QgcmVtb3ZlIGFyYml0cmFyeSBub2RlcyBmcm9tIGFuXG4gICAgICAvLyBhcnJheSBiYXNlZCBoZWFwLCBvbmx5IHRoZSBmaXJzdCBvbmUuKVxuXG4gICAgICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gICAgICByZXR1cm4gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgfVxuICAgIHZhciBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgIHZhciBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICAgIHZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuICAgIC8vIHRocmVhZCwgbGlrZSB1c2VyIGV2ZW50cy4gQnkgZGVmYXVsdCwgaXQgeWllbGRzIG11bHRpcGxlIHRpbWVzIHBlciBmcmFtZS5cbiAgICAvLyBJdCBkb2VzIG5vdCBhdHRlbXB0IHRvIGFsaWduIHdpdGggZnJhbWUgYm91bmRhcmllcywgc2luY2UgbW9zdCB0YXNrcyBkb24ndFxuICAgIC8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbiAgICB2YXIgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbiAgICB2YXIgc3RhcnRUaW1lID0gLTE7XG4gICAgZnVuY3Rpb24gc2hvdWxkWWllbGRUb0hvc3QoKSB7XG4gICAgICB2YXIgdGltZUVsYXBzZWQgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgaWYgKHRpbWVFbGFwc2VkIDwgZnJhbWVJbnRlcnZhbCkge1xuICAgICAgICAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIG9ubHkgYmVlbiBibG9ja2VkIGZvciBhIHJlYWxseSBzaG9ydCBhbW91bnQgb2YgdGltZTtcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lLiBEb24ndCB5aWVsZCB5ZXQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBiZWVuIGJsb2NrZWQgZm9yIGEgbm9uLW5lZ2xpZ2libGUgYW1vdW50IG9mIHRpbWUuIFdlXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0UGFpbnQoKSB7fVxuICAgIGZ1bmN0aW9uIGZvcmNlRnJhbWVSYXRlKGZwcykge1xuICAgICAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgICBjb25zb2xlWydlcnJvciddKCdmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgJyArICdmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnBzID4gMCkge1xuICAgICAgICBmcmFtZUludGVydmFsID0gTWF0aC5mbG9vcigxMDAwIC8gZnBzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBmcmFtZXJhdGVcbiAgICAgICAgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgc3RhcnQgdGltZSBzbyB3ZSBjYW4gbWVhc3VyZSBob3cgbG9uZyB0aGUgbWFpbiB0aHJlYWRcbiAgICAgICAgLy8gaGFzIGJlZW4gYmxvY2tlZC5cblxuICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgdmFyIGhhc1RpbWVSZW1haW5pbmcgPSB0cnVlOyAvLyBJZiBhIHNjaGVkdWxlciB0YXNrIHRocm93cywgZXhpdCB0aGUgY3VycmVudCBicm93c2VyIHRhc2sgc28gdGhlXG4gICAgICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYSB0cnktY2F0Y2gsIHNpbmNlIHRoYXQgbWFrZXMgc29tZSBkZWJ1Z2dpbmdcbiAgICAgICAgLy8gdGVjaG5pcXVlcyBoYXJkZXIuIEluc3RlYWQsIGlmIGBzY2hlZHVsZWRIb3N0Q2FsbGJhY2tgIGVycm9ycywgdGhlblxuICAgICAgICAvLyBgaGFzTW9yZVdvcmtgIHdpbGwgcmVtYWluIHRydWUsIGFuZCB3ZSdsbCBjb250aW51ZSB0aGUgd29yayBsb29wLlxuXG4gICAgICAgIHZhciBoYXNNb3JlV29yayA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGFzTW9yZVdvcmsgPSBzY2hlZHVsZWRIb3N0Q2FsbGJhY2soaGFzVGltZVJlbWFpbmluZywgY3VycmVudFRpbWUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoYXNNb3JlV29yaykge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHdvcmssIHNjaGVkdWxlIHRoZSBuZXh0IG1lc3NhZ2UgZXZlbnQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgLy8gb2YgdGhlIHByZWNlZGluZyBvbmUuXG4gICAgICAgICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgICB9IC8vIFlpZWxkaW5nIHRvIHRoZSBicm93c2VyIHdpbGwgZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCwgc28gd2UgY2FuXG4gICAgfTtcblxuICAgIHZhciBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbiAgICBpZiAodHlwZW9mIGxvY2FsU2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBOb2RlLmpzIGFuZCBvbGQgSUUuXG4gICAgICAvLyBUaGVyZSdzIGEgZmV3IHJlYXNvbnMgZm9yIHdoeSB3ZSBwcmVmZXIgc2V0SW1tZWRpYXRlLlxuICAgICAgLy9cbiAgICAgIC8vIFVubGlrZSBNZXNzYWdlQ2hhbm5lbCwgaXQgZG9lc24ndCBwcmV2ZW50IGEgTm9kZS5qcyBwcm9jZXNzIGZyb20gZXhpdGluZy5cbiAgICAgIC8vIChFdmVuIHRob3VnaCB0aGlzIGlzIGEgRE9NIGZvcmsgb2YgdGhlIFNjaGVkdWxlciwgeW91IGNvdWxkIGdldCBoZXJlXG4gICAgICAvLyB3aXRoIGEgbWl4IG9mIE5vZGUuanMgMTUrLCB3aGljaCBoYXMgYSBNZXNzYWdlQ2hhbm5lbCwgYW5kIGpzZG9tLilcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjA3NTZcbiAgICAgIC8vXG4gICAgICAvLyBCdXQgYWxzbywgaXQgcnVucyBlYXJsaWVyIHdoaWNoIGlzIHRoZSBzZW1hbnRpYyB3ZSB3YW50LlxuICAgICAgLy8gSWYgb3RoZXIgYnJvd3NlcnMgZXZlciBpbXBsZW1lbnQgaXQsIGl0J3MgYmV0dGVyIHRvIHVzZSBpdC5cbiAgICAgIC8vIEFsdGhvdWdoIGJvdGggb2YgdGhlc2Ugd291bGQgYmUgaW5mZXJpb3IgdG8gbmF0aXZlIHNjaGVkdWxpbmcuXG4gICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWxTZXRJbW1lZGlhdGUocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBET00gYW5kIFdvcmtlciBlbnZpcm9ubWVudHMuXG4gICAgICAvLyBXZSBwcmVmZXIgTWVzc2FnZUNoYW5uZWwgYmVjYXVzZSBvZiB0aGUgNG1zIHNldFRpbWVvdXQgY2xhbXBpbmcuXG4gICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG4gICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNob3VsZCBvbmx5IGZhbGxiYWNrIGhlcmUgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0VGltZW91dChwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUsIDApO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICBpZiAoIWlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICAgICAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWxIb3N0VGltZW91dCgpIHtcbiAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuICAgICAgdGFza1RpbWVvdXRJRCA9IC0xO1xuICAgIH1cbiAgICB2YXIgdW5zdGFibGVfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xuICAgIHZhciB1bnN0YWJsZV9Qcm9maWxpbmcgPSBudWxsO1xuICAgIGV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuICAgIGV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5ID0gTG93UHJpb3JpdHk7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgIGV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gdW5zdGFibGVfUHJvZmlsaW5nO1xuICAgIGV4cG9ydHMudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uO1xuICAgIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmb3JjZUZyYW1lUmF0ZTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlO1xuICAgIGV4cG9ydHMudW5zdGFibGVfbmV4dCA9IHVuc3RhYmxlX25leHQ7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuICAgIGV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gdW5zdGFibGVfcmVxdWVzdFBhaW50O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5O1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IHNob3VsZFlpZWxkVG9Ib3N0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrID0gdW5zdGFibGVfd3JhcENhbGxiYWNrO1xuICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbiAgICB9XG4gIH0pKCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"./node_modules/scheduler/cjs/scheduler.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcz83MWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/scheduler/index.js\n");

/***/ }),

/***/ "./node_modules/shallowequal/index.js":
/*!********************************************!*\
  !*** ./node_modules/shallowequal/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("//\n\nmodule.exports = function shallowEqual(objA, objB, compare, compareContext) {\n  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n  if (ret !== void 0) {\n    return !!ret;\n  }\n  if (objA === objB) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n    return false;\n  }\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n\n  // Test for A's keys different from B.\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx];\n    if (!bHasOwnProperty(key)) {\n      return false;\n    }\n    var valueA = objA[key];\n    var valueB = objB[key];\n    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n    if (ret === false || ret === void 0 && valueA !== valueB) {\n      return false;\n    }\n  }\n  return true;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhbGxvd2VxdWFsL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qcz8zMWEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIsIGNvbXBhcmUsIGNvbXBhcmVDb250ZXh0KSB7XG4gIHZhciByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCBvYmpBLCBvYmpCKSA6IHZvaWQgMDtcbiAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuICEhcmV0O1xuICB9XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8ICFvYmpBIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8ICFvYmpCKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBiSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwga2V5c0EubGVuZ3RoOyBpZHgrKykge1xuICAgIHZhciBrZXkgPSBrZXlzQVtpZHhdO1xuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlQSA9IG9iakFba2V5XTtcbiAgICB2YXIgdmFsdWVCID0gb2JqQltrZXldO1xuICAgIHJldCA9IGNvbXBhcmUgPyBjb21wYXJlLmNhbGwoY29tcGFyZUNvbnRleHQsIHZhbHVlQSwgdmFsdWVCLCBrZXkpIDogdm9pZCAwO1xuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IHJldCA9PT0gdm9pZCAwICYmIHZhbHVlQSAhPT0gdmFsdWVCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/shallowequal/index.js\n");

/***/ }),

/***/ "./node_modules/sockjs-client/dist/sockjs.js":
/*!***************************************************!*\
  !*** ./node_modules/sockjs-client/dist/sockjs.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* sockjs-client v1.6.1 | http://sockjs.org | MIT license */\n(function (f) {\n  if (true) {\n    module.exports = f();\n  } else { var g; }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = undefined;\n            if (!f && c) return require(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n        return n[i].exports;\n      }\n      for (var u = undefined, i = 0; i < t.length; i++) o(t[i]);\n      return o;\n    }\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          var transportList = require('./transport-list');\n          module.exports = require('./main')(transportList);\n\n          // TODO can't get rid of this until all servers do\n          if ('_sockjs_onload' in global) {\n            setTimeout(global._sockjs_onload, 1);\n          }\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./main\": 14,\n      \"./transport-list\": 16\n    }],\n    2: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        Event = require('./event');\n      function CloseEvent() {\n        Event.call(this);\n        this.initEvent('close', false, false);\n        this.wasClean = false;\n        this.code = 0;\n        this.reason = '';\n      }\n      inherits(CloseEvent, Event);\n      module.exports = CloseEvent;\n    }, {\n      \"./event\": 4,\n      \"inherits\": 57\n    }],\n    3: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        EventTarget = require('./eventtarget');\n      function EventEmitter() {\n        EventTarget.call(this);\n      }\n      inherits(EventEmitter, EventTarget);\n      EventEmitter.prototype.removeAllListeners = function (type) {\n        if (type) {\n          delete this._listeners[type];\n        } else {\n          this._listeners = {};\n        }\n      };\n      EventEmitter.prototype.once = function (type, listener) {\n        var self = this,\n          fired = false;\n        function g() {\n          self.removeListener(type, g);\n          if (!fired) {\n            fired = true;\n            listener.apply(this, arguments);\n          }\n        }\n        this.on(type, g);\n      };\n      EventEmitter.prototype.emit = function () {\n        var type = arguments[0];\n        var listeners = this._listeners[type];\n        if (!listeners) {\n          return;\n        }\n        // equivalent of Array.prototype.slice.call(arguments, 1);\n        var l = arguments.length;\n        var args = new Array(l - 1);\n        for (var ai = 1; ai < l; ai++) {\n          args[ai - 1] = arguments[ai];\n        }\n        for (var i = 0; i < listeners.length; i++) {\n          listeners[i].apply(this, args);\n        }\n      };\n      EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;\n      EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;\n      module.exports.EventEmitter = EventEmitter;\n    }, {\n      \"./eventtarget\": 5,\n      \"inherits\": 57\n    }],\n    4: [function (require, module, exports) {\n      'use strict';\n\n      function Event(eventType) {\n        this.type = eventType;\n      }\n      Event.prototype.initEvent = function (eventType, canBubble, cancelable) {\n        this.type = eventType;\n        this.bubbles = canBubble;\n        this.cancelable = cancelable;\n        this.timeStamp = +new Date();\n        return this;\n      };\n      Event.prototype.stopPropagation = function () {};\n      Event.prototype.preventDefault = function () {};\n      Event.CAPTURING_PHASE = 1;\n      Event.AT_TARGET = 2;\n      Event.BUBBLING_PHASE = 3;\n      module.exports = Event;\n    }, {}],\n    5: [function (require, module, exports) {\n      'use strict';\n\n      /* Simplified implementation of DOM2 EventTarget.\n       *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n       */\n      function EventTarget() {\n        this._listeners = {};\n      }\n      EventTarget.prototype.addEventListener = function (eventType, listener) {\n        if (!(eventType in this._listeners)) {\n          this._listeners[eventType] = [];\n        }\n        var arr = this._listeners[eventType];\n        // #4\n        if (arr.indexOf(listener) === -1) {\n          // Make a copy so as not to interfere with a current dispatchEvent.\n          arr = arr.concat([listener]);\n        }\n        this._listeners[eventType] = arr;\n      };\n      EventTarget.prototype.removeEventListener = function (eventType, listener) {\n        var arr = this._listeners[eventType];\n        if (!arr) {\n          return;\n        }\n        var idx = arr.indexOf(listener);\n        if (idx !== -1) {\n          if (arr.length > 1) {\n            // Make a copy so as not to interfere with a current dispatchEvent.\n            this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));\n          } else {\n            delete this._listeners[eventType];\n          }\n          return;\n        }\n      };\n      EventTarget.prototype.dispatchEvent = function () {\n        var event = arguments[0];\n        var t = event.type;\n        // equivalent of Array.prototype.slice.call(arguments, 0);\n        var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);\n        // TODO: This doesn't match the real behavior; per spec, onfoo get\n        // their place in line from the /first/ time they're set from\n        // non-null. Although WebKit bumps it to the end every time it's\n        // set.\n        if (this['on' + t]) {\n          this['on' + t].apply(this, args);\n        }\n        if (t in this._listeners) {\n          // Grab a reference to the listeners list. removeEventListener may alter the list.\n          var listeners = this._listeners[t];\n          for (var i = 0; i < listeners.length; i++) {\n            listeners[i].apply(this, args);\n          }\n        }\n      };\n      module.exports = EventTarget;\n    }, {}],\n    6: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        Event = require('./event');\n      function TransportMessageEvent(data) {\n        Event.call(this);\n        this.initEvent('message', false, false);\n        this.data = data;\n      }\n      inherits(TransportMessageEvent, Event);\n      module.exports = TransportMessageEvent;\n    }, {\n      \"./event\": 4,\n      \"inherits\": 57\n    }],\n    7: [function (require, module, exports) {\n      'use strict';\n\n      var iframeUtils = require('./utils/iframe');\n      function FacadeJS(transport) {\n        this._transport = transport;\n        transport.on('message', this._transportMessage.bind(this));\n        transport.on('close', this._transportClose.bind(this));\n      }\n      FacadeJS.prototype._transportClose = function (code, reason) {\n        iframeUtils.postMessage('c', JSON.stringify([code, reason]));\n      };\n      FacadeJS.prototype._transportMessage = function (frame) {\n        iframeUtils.postMessage('t', frame);\n      };\n      FacadeJS.prototype._send = function (data) {\n        this._transport.send(data);\n      };\n      FacadeJS.prototype._close = function () {\n        this._transport.close();\n        this._transport.removeAllListeners();\n      };\n      module.exports = FacadeJS;\n    }, {\n      \"./utils/iframe\": 47\n    }],\n    8: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var urlUtils = require('./utils/url'),\n            eventUtils = require('./utils/event'),\n            FacadeJS = require('./facade'),\n            InfoIframeReceiver = require('./info-iframe-receiver'),\n            iframeUtils = require('./utils/iframe'),\n            loc = require('./location');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:iframe-bootstrap');\n          }\n          module.exports = function (SockJS, availableTransports) {\n            var transportMap = {};\n            availableTransports.forEach(function (at) {\n              if (at.facadeTransport) {\n                transportMap[at.facadeTransport.transportName] = at.facadeTransport;\n              }\n            });\n\n            // hard-coded for the info iframe\n            // TODO see if we can make this more dynamic\n            transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;\n            var parentOrigin;\n\n            /* eslint-disable camelcase */\n            SockJS.bootstrap_iframe = function () {\n              /* eslint-enable camelcase */\n              var facade;\n              iframeUtils.currentWindowId = loc.hash.slice(1);\n              var onMessage = function (e) {\n                if (e.source !== parent) {\n                  return;\n                }\n                if (typeof parentOrigin === 'undefined') {\n                  parentOrigin = e.origin;\n                }\n                if (e.origin !== parentOrigin) {\n                  return;\n                }\n                var iframeMessage;\n                try {\n                  iframeMessage = JSON.parse(e.data);\n                } catch (ignored) {\n                  debug('bad json', e.data);\n                  return;\n                }\n                if (iframeMessage.windowId !== iframeUtils.currentWindowId) {\n                  return;\n                }\n                switch (iframeMessage.type) {\n                  case 's':\n                    var p;\n                    try {\n                      p = JSON.parse(iframeMessage.data);\n                    } catch (ignored) {\n                      debug('bad json', iframeMessage.data);\n                      break;\n                    }\n                    var version = p[0];\n                    var transport = p[1];\n                    var transUrl = p[2];\n                    var baseUrl = p[3];\n                    debug(version, transport, transUrl, baseUrl);\n                    // change this to semver logic\n                    if (version !== SockJS.version) {\n                      throw new Error('Incompatible SockJS! Main site uses:' + ' \"' + version + '\", the iframe:' + ' \"' + SockJS.version + '\".');\n                    }\n                    if (!urlUtils.isOriginEqual(transUrl, loc.href) || !urlUtils.isOriginEqual(baseUrl, loc.href)) {\n                      throw new Error('Can\\'t connect to different domain from within an ' + 'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');\n                    }\n                    facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));\n                    break;\n                  case 'm':\n                    facade._send(iframeMessage.data);\n                    break;\n                  case 'c':\n                    if (facade) {\n                      facade._close();\n                    }\n                    facade = null;\n                    break;\n                }\n              };\n              eventUtils.attachEvent('message', onMessage);\n\n              // Start\n              iframeUtils.postMessage('s');\n            };\n          };\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"./facade\": 7,\n      \"./info-iframe-receiver\": 10,\n      \"./location\": 13,\n      \"./utils/event\": 46,\n      \"./utils/iframe\": 47,\n      \"./utils/url\": 52,\n      \"debug\": 55\n    }],\n    9: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var EventEmitter = require('events').EventEmitter,\n            inherits = require('inherits'),\n            objectUtils = require('./utils/object');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:info-ajax');\n          }\n          function InfoAjax(url, AjaxObject) {\n            EventEmitter.call(this);\n            var self = this;\n            var t0 = +new Date();\n            this.xo = new AjaxObject('GET', url);\n            this.xo.once('finish', function (status, text) {\n              var info, rtt;\n              if (status === 200) {\n                rtt = +new Date() - t0;\n                if (text) {\n                  try {\n                    info = JSON.parse(text);\n                  } catch (e) {\n                    debug('bad json', text);\n                  }\n                }\n                if (!objectUtils.isObject(info)) {\n                  info = {};\n                }\n              }\n              self.emit('finish', info, rtt);\n              self.removeAllListeners();\n            });\n          }\n          inherits(InfoAjax, EventEmitter);\n          InfoAjax.prototype.close = function () {\n            this.removeAllListeners();\n            this.xo.close();\n          };\n          module.exports = InfoAjax;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"./utils/object\": 49,\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    10: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        EventEmitter = require('events').EventEmitter,\n        XHRLocalObject = require('./transport/sender/xhr-local'),\n        InfoAjax = require('./info-ajax');\n      function InfoReceiverIframe(transUrl) {\n        var self = this;\n        EventEmitter.call(this);\n        this.ir = new InfoAjax(transUrl, XHRLocalObject);\n        this.ir.once('finish', function (info, rtt) {\n          self.ir = null;\n          self.emit('message', JSON.stringify([info, rtt]));\n        });\n      }\n      inherits(InfoReceiverIframe, EventEmitter);\n      InfoReceiverIframe.transportName = 'iframe-info-receiver';\n      InfoReceiverIframe.prototype.close = function () {\n        if (this.ir) {\n          this.ir.close();\n          this.ir = null;\n        }\n        this.removeAllListeners();\n      };\n      module.exports = InfoReceiverIframe;\n    }, {\n      \"./info-ajax\": 9,\n      \"./transport/sender/xhr-local\": 37,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    11: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n\n          var EventEmitter = require('events').EventEmitter,\n            inherits = require('inherits'),\n            utils = require('./utils/event'),\n            IframeTransport = require('./transport/iframe'),\n            InfoReceiverIframe = require('./info-iframe-receiver');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:info-iframe');\n          }\n          function InfoIframe(baseUrl, url) {\n            var self = this;\n            EventEmitter.call(this);\n            var go = function () {\n              var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);\n              ifr.once('message', function (msg) {\n                if (msg) {\n                  var d;\n                  try {\n                    d = JSON.parse(msg);\n                  } catch (e) {\n                    debug('bad json', msg);\n                    self.emit('finish');\n                    self.close();\n                    return;\n                  }\n                  var info = d[0],\n                    rtt = d[1];\n                  self.emit('finish', info, rtt);\n                }\n                self.close();\n              });\n              ifr.once('close', function () {\n                self.emit('finish');\n                self.close();\n              });\n            };\n\n            // TODO this seems the same as the 'needBody' from transports\n            if (!global.document.body) {\n              utils.attachEvent('load', go);\n            } else {\n              go();\n            }\n          }\n          inherits(InfoIframe, EventEmitter);\n          InfoIframe.enabled = function () {\n            return IframeTransport.enabled();\n          };\n          InfoIframe.prototype.close = function () {\n            if (this.ifr) {\n              this.ifr.close();\n            }\n            this.removeAllListeners();\n            this.ifr = null;\n          };\n          module.exports = InfoIframe;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      }, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./info-iframe-receiver\": 10,\n      \"./transport/iframe\": 22,\n      \"./utils/event\": 46,\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    12: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var EventEmitter = require('events').EventEmitter,\n            inherits = require('inherits'),\n            urlUtils = require('./utils/url'),\n            XDR = require('./transport/sender/xdr'),\n            XHRCors = require('./transport/sender/xhr-cors'),\n            XHRLocal = require('./transport/sender/xhr-local'),\n            XHRFake = require('./transport/sender/xhr-fake'),\n            InfoIframe = require('./info-iframe'),\n            InfoAjax = require('./info-ajax');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:info-receiver');\n          }\n          function InfoReceiver(baseUrl, urlInfo) {\n            debug(baseUrl);\n            var self = this;\n            EventEmitter.call(this);\n            setTimeout(function () {\n              self.doXhr(baseUrl, urlInfo);\n            }, 0);\n          }\n          inherits(InfoReceiver, EventEmitter);\n\n          // TODO this is currently ignoring the list of available transports and the whitelist\n\n          InfoReceiver._getReceiver = function (baseUrl, url, urlInfo) {\n            // determine method of CORS support (if needed)\n            if (urlInfo.sameOrigin) {\n              return new InfoAjax(url, XHRLocal);\n            }\n            if (XHRCors.enabled) {\n              return new InfoAjax(url, XHRCors);\n            }\n            if (XDR.enabled && urlInfo.sameScheme) {\n              return new InfoAjax(url, XDR);\n            }\n            if (InfoIframe.enabled()) {\n              return new InfoIframe(baseUrl, url);\n            }\n            return new InfoAjax(url, XHRFake);\n          };\n          InfoReceiver.prototype.doXhr = function (baseUrl, urlInfo) {\n            var self = this,\n              url = urlUtils.addPath(baseUrl, '/info');\n            debug('doXhr', url);\n            this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);\n            this.timeoutRef = setTimeout(function () {\n              debug('timeout');\n              self._cleanup(false);\n              self.emit('finish');\n            }, InfoReceiver.timeout);\n            this.xo.once('finish', function (info, rtt) {\n              debug('finish', info, rtt);\n              self._cleanup(true);\n              self.emit('finish', info, rtt);\n            });\n          };\n          InfoReceiver.prototype._cleanup = function (wasClean) {\n            debug('_cleanup');\n            clearTimeout(this.timeoutRef);\n            this.timeoutRef = null;\n            if (!wasClean && this.xo) {\n              this.xo.close();\n            }\n            this.xo = null;\n          };\n          InfoReceiver.prototype.close = function () {\n            debug('close');\n            this.removeAllListeners();\n            this._cleanup(false);\n          };\n          InfoReceiver.timeout = 8000;\n          module.exports = InfoReceiver;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"./info-ajax\": 9,\n      \"./info-iframe\": 11,\n      \"./transport/sender/xdr\": 34,\n      \"./transport/sender/xhr-cors\": 35,\n      \"./transport/sender/xhr-fake\": 36,\n      \"./transport/sender/xhr-local\": 37,\n      \"./utils/url\": 52,\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    13: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          module.exports = global.location || {\n            origin: 'http://localhost:80',\n            protocol: 'http:',\n            host: 'localhost',\n            port: 80,\n            href: 'http://localhost/',\n            hash: ''\n          };\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    14: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n\n          require('./shims');\n          var URL = require('url-parse'),\n            inherits = require('inherits'),\n            random = require('./utils/random'),\n            escape = require('./utils/escape'),\n            urlUtils = require('./utils/url'),\n            eventUtils = require('./utils/event'),\n            transport = require('./utils/transport'),\n            objectUtils = require('./utils/object'),\n            browser = require('./utils/browser'),\n            log = require('./utils/log'),\n            Event = require('./event/event'),\n            EventTarget = require('./event/eventtarget'),\n            loc = require('./location'),\n            CloseEvent = require('./event/close'),\n            TransportMessageEvent = require('./event/trans-message'),\n            InfoReceiver = require('./info-receiver');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:main');\n          }\n          var transports;\n\n          // follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface\n          function SockJS(url, protocols, options) {\n            if (!(this instanceof SockJS)) {\n              return new SockJS(url, protocols, options);\n            }\n            if (arguments.length < 1) {\n              throw new TypeError(\"Failed to construct 'SockJS: 1 argument required, but only 0 present\");\n            }\n            EventTarget.call(this);\n            this.readyState = SockJS.CONNECTING;\n            this.extensions = '';\n            this.protocol = '';\n\n            // non-standard extension\n            options = options || {};\n            if (options.protocols_whitelist) {\n              log.warn(\"'protocols_whitelist' is DEPRECATED. Use 'transports' instead.\");\n            }\n            this._transportsWhitelist = options.transports;\n            this._transportOptions = options.transportOptions || {};\n            this._timeout = options.timeout || 0;\n            var sessionId = options.sessionId || 8;\n            if (typeof sessionId === 'function') {\n              this._generateSessionId = sessionId;\n            } else if (typeof sessionId === 'number') {\n              this._generateSessionId = function () {\n                return random.string(sessionId);\n              };\n            } else {\n              throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');\n            }\n            this._server = options.server || random.numberString(1000);\n\n            // Step 1 of WS spec - parse and validate the url. Issue #8\n            var parsedUrl = new URL(url);\n            if (!parsedUrl.host || !parsedUrl.protocol) {\n              throw new SyntaxError(\"The URL '\" + url + \"' is invalid\");\n            } else if (parsedUrl.hash) {\n              throw new SyntaxError('The URL must not contain a fragment');\n            } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\n              throw new SyntaxError(\"The URL's scheme must be either 'http:' or 'https:'. '\" + parsedUrl.protocol + \"' is not allowed.\");\n            }\n            var secure = parsedUrl.protocol === 'https:';\n            // Step 2 - don't allow secure origin with an insecure protocol\n            if (loc.protocol === 'https:' && !secure) {\n              // exception is 127.0.0.0/8 and ::1 urls\n              if (!urlUtils.isLoopbackAddr(parsedUrl.hostname)) {\n                throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');\n              }\n            }\n\n            // Step 3 - check port access - no need here\n            // Step 4 - parse protocols argument\n            if (!protocols) {\n              protocols = [];\n            } else if (!Array.isArray(protocols)) {\n              protocols = [protocols];\n            }\n\n            // Step 5 - check protocols argument\n            var sortedProtocols = protocols.sort();\n            sortedProtocols.forEach(function (proto, i) {\n              if (!proto) {\n                throw new SyntaxError(\"The protocols entry '\" + proto + \"' is invalid.\");\n              }\n              if (i < sortedProtocols.length - 1 && proto === sortedProtocols[i + 1]) {\n                throw new SyntaxError(\"The protocols entry '\" + proto + \"' is duplicated.\");\n              }\n            });\n\n            // Step 6 - convert origin\n            var o = urlUtils.getOrigin(loc.href);\n            this._origin = o ? o.toLowerCase() : null;\n\n            // remove the trailing slash\n            parsedUrl.set('pathname', parsedUrl.pathname.replace(/\\/+$/, ''));\n\n            // store the sanitized url\n            this.url = parsedUrl.href;\n            debug('using url', this.url);\n\n            // Step 7 - start connection in background\n            // obtain server info\n            // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26\n            this._urlInfo = {\n              nullOrigin: !browser.hasDomain(),\n              sameOrigin: urlUtils.isOriginEqual(this.url, loc.href),\n              sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)\n            };\n            this._ir = new InfoReceiver(this.url, this._urlInfo);\n            this._ir.once('finish', this._receiveInfo.bind(this));\n          }\n          inherits(SockJS, EventTarget);\n          function userSetCode(code) {\n            return code === 1000 || code >= 3000 && code <= 4999;\n          }\n          SockJS.prototype.close = function (code, reason) {\n            // Step 1\n            if (code && !userSetCode(code)) {\n              throw new Error('InvalidAccessError: Invalid code');\n            }\n            // Step 2.4 states the max is 123 bytes, but we are just checking length\n            if (reason && reason.length > 123) {\n              throw new SyntaxError('reason argument has an invalid length');\n            }\n\n            // Step 3.1\n            if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {\n              return;\n            }\n\n            // TODO look at docs to determine how to set this\n            var wasClean = true;\n            this._close(code || 1000, reason || 'Normal closure', wasClean);\n          };\n          SockJS.prototype.send = function (data) {\n            // #13 - convert anything non-string to string\n            // TODO this currently turns objects into [object Object]\n            if (typeof data !== 'string') {\n              data = '' + data;\n            }\n            if (this.readyState === SockJS.CONNECTING) {\n              throw new Error('InvalidStateError: The connection has not been established yet');\n            }\n            if (this.readyState !== SockJS.OPEN) {\n              return;\n            }\n            this._transport.send(escape.quote(data));\n          };\n          SockJS.version = require('./version');\n          SockJS.CONNECTING = 0;\n          SockJS.OPEN = 1;\n          SockJS.CLOSING = 2;\n          SockJS.CLOSED = 3;\n          SockJS.prototype._receiveInfo = function (info, rtt) {\n            debug('_receiveInfo', rtt);\n            this._ir = null;\n            if (!info) {\n              this._close(1002, 'Cannot connect to server');\n              return;\n            }\n\n            // establish a round-trip timeout (RTO) based on the\n            // round-trip time (RTT)\n            this._rto = this.countRTO(rtt);\n            // allow server to override url used for the actual transport\n            this._transUrl = info.base_url ? info.base_url : this.url;\n            info = objectUtils.extend(info, this._urlInfo);\n            debug('info', info);\n            // determine list of desired and supported transports\n            var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);\n            this._transports = enabledTransports.main;\n            debug(this._transports.length + ' enabled transports');\n            this._connect();\n          };\n          SockJS.prototype._connect = function () {\n            for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {\n              debug('attempt', Transport.transportName);\n              if (Transport.needBody) {\n                if (!global.document.body || typeof global.document.readyState !== 'undefined' && global.document.readyState !== 'complete' && global.document.readyState !== 'interactive') {\n                  debug('waiting for body');\n                  this._transports.unshift(Transport);\n                  eventUtils.attachEvent('load', this._connect.bind(this));\n                  return;\n                }\n              }\n\n              // calculate timeout based on RTO and round trips. Default to 5s\n              var timeoutMs = Math.max(this._timeout, this._rto * Transport.roundTrips || 5000);\n              this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);\n              debug('using timeout', timeoutMs);\n              var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());\n              var options = this._transportOptions[Transport.transportName];\n              debug('transport url', transportUrl);\n              var transportObj = new Transport(transportUrl, this._transUrl, options);\n              transportObj.on('message', this._transportMessage.bind(this));\n              transportObj.once('close', this._transportClose.bind(this));\n              transportObj.transportName = Transport.transportName;\n              this._transport = transportObj;\n              return;\n            }\n            this._close(2000, 'All transports failed', false);\n          };\n          SockJS.prototype._transportTimeout = function () {\n            debug('_transportTimeout');\n            if (this.readyState === SockJS.CONNECTING) {\n              if (this._transport) {\n                this._transport.close();\n              }\n              this._transportClose(2007, 'Transport timed out');\n            }\n          };\n          SockJS.prototype._transportMessage = function (msg) {\n            debug('_transportMessage', msg);\n            var self = this,\n              type = msg.slice(0, 1),\n              content = msg.slice(1),\n              payload;\n\n            // first check for messages that don't need a payload\n            switch (type) {\n              case 'o':\n                this._open();\n                return;\n              case 'h':\n                this.dispatchEvent(new Event('heartbeat'));\n                debug('heartbeat', this.transport);\n                return;\n            }\n            if (content) {\n              try {\n                payload = JSON.parse(content);\n              } catch (e) {\n                debug('bad json', content);\n              }\n            }\n            if (typeof payload === 'undefined') {\n              debug('empty payload', content);\n              return;\n            }\n            switch (type) {\n              case 'a':\n                if (Array.isArray(payload)) {\n                  payload.forEach(function (p) {\n                    debug('message', self.transport, p);\n                    self.dispatchEvent(new TransportMessageEvent(p));\n                  });\n                }\n                break;\n              case 'm':\n                debug('message', this.transport, payload);\n                this.dispatchEvent(new TransportMessageEvent(payload));\n                break;\n              case 'c':\n                if (Array.isArray(payload) && payload.length === 2) {\n                  this._close(payload[0], payload[1], true);\n                }\n                break;\n            }\n          };\n          SockJS.prototype._transportClose = function (code, reason) {\n            debug('_transportClose', this.transport, code, reason);\n            if (this._transport) {\n              this._transport.removeAllListeners();\n              this._transport = null;\n              this.transport = null;\n            }\n            if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {\n              this._connect();\n              return;\n            }\n            this._close(code, reason);\n          };\n          SockJS.prototype._open = function () {\n            debug('_open', this._transport && this._transport.transportName, this.readyState);\n            if (this.readyState === SockJS.CONNECTING) {\n              if (this._transportTimeoutId) {\n                clearTimeout(this._transportTimeoutId);\n                this._transportTimeoutId = null;\n              }\n              this.readyState = SockJS.OPEN;\n              this.transport = this._transport.transportName;\n              this.dispatchEvent(new Event('open'));\n              debug('connected', this.transport);\n            } else {\n              // The server might have been restarted, and lost track of our\n              // connection.\n              this._close(1006, 'Server lost session');\n            }\n          };\n          SockJS.prototype._close = function (code, reason, wasClean) {\n            debug('_close', this.transport, code, reason, wasClean, this.readyState);\n            var forceFail = false;\n            if (this._ir) {\n              forceFail = true;\n              this._ir.close();\n              this._ir = null;\n            }\n            if (this._transport) {\n              this._transport.close();\n              this._transport = null;\n              this.transport = null;\n            }\n            if (this.readyState === SockJS.CLOSED) {\n              throw new Error('InvalidStateError: SockJS has already been closed');\n            }\n            this.readyState = SockJS.CLOSING;\n            setTimeout(function () {\n              this.readyState = SockJS.CLOSED;\n              if (forceFail) {\n                this.dispatchEvent(new Event('error'));\n              }\n              var e = new CloseEvent('close');\n              e.wasClean = wasClean || false;\n              e.code = code || 1000;\n              e.reason = reason;\n              this.dispatchEvent(e);\n              this.onmessage = this.onclose = this.onerror = null;\n              debug('disconnected');\n            }.bind(this), 0);\n          };\n\n          // See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\n          // and RFC 2988.\n          SockJS.prototype.countRTO = function (rtt) {\n            // In a local environment, when using IE8/9 and the `jsonp-polling`\n            // transport the time needed to establish a connection (the time that pass\n            // from the opening of the transport to the call of `_dispatchOpen`) is\n            // around 200msec (the lower bound used in the article above) and this\n            // causes spurious timeouts. For this reason we calculate a value slightly\n            // larger than that used in the article.\n            if (rtt > 100) {\n              return 4 * rtt; // rto > 400msec\n            }\n\n            return 300 + rtt; // 300msec < rto <= 400msec\n          };\n\n          module.exports = function (availableTransports) {\n            transports = transport(availableTransports);\n            require('./iframe-bootstrap')(SockJS, availableTransports);\n            return SockJS;\n          };\n        }).call(this);\n      }).call(this, {\n        env: {}\n      }, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./event/close\": 2,\n      \"./event/event\": 4,\n      \"./event/eventtarget\": 5,\n      \"./event/trans-message\": 6,\n      \"./iframe-bootstrap\": 8,\n      \"./info-receiver\": 12,\n      \"./location\": 13,\n      \"./shims\": 15,\n      \"./utils/browser\": 44,\n      \"./utils/escape\": 45,\n      \"./utils/event\": 46,\n      \"./utils/log\": 48,\n      \"./utils/object\": 49,\n      \"./utils/random\": 50,\n      \"./utils/transport\": 51,\n      \"./utils/url\": 52,\n      \"./version\": 53,\n      \"debug\": 55,\n      \"inherits\": 57,\n      \"url-parse\": 60\n    }],\n    15: [function (require, module, exports) {\n      /* eslint-disable */\n      /* jscs: disable */\n      'use strict';\n\n      // pulled specific shims from https://github.com/es-shims/es5-shim\n      var ArrayPrototype = Array.prototype;\n      var ObjectPrototype = Object.prototype;\n      var FunctionPrototype = Function.prototype;\n      var StringPrototype = String.prototype;\n      var array_slice = ArrayPrototype.slice;\n      var _toString = ObjectPrototype.toString;\n      var isFunction = function (val) {\n        return ObjectPrototype.toString.call(val) === '[object Function]';\n      };\n      var isArray = function isArray(obj) {\n        return _toString.call(obj) === '[object Array]';\n      };\n      var isString = function isString(obj) {\n        return _toString.call(obj) === '[object String]';\n      };\n      var supportsDescriptors = Object.defineProperty && function () {\n        try {\n          Object.defineProperty({}, 'x', {});\n          return true;\n        } catch (e) {\n          /* this is ES3 */\n          return false;\n        }\n      }();\n\n      // Define configurable, writable and non-enumerable props\n      // if they don't exist.\n      var defineProperty;\n      if (supportsDescriptors) {\n        defineProperty = function (object, name, method, forceAssign) {\n          if (!forceAssign && name in object) {\n            return;\n          }\n          Object.defineProperty(object, name, {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: method\n          });\n        };\n      } else {\n        defineProperty = function (object, name, method, forceAssign) {\n          if (!forceAssign && name in object) {\n            return;\n          }\n          object[name] = method;\n        };\n      }\n      var defineProperties = function (object, map, forceAssign) {\n        for (var name in map) {\n          if (ObjectPrototype.hasOwnProperty.call(map, name)) {\n            defineProperty(object, name, map[name], forceAssign);\n          }\n        }\n      };\n      var toObject = function (o) {\n        if (o == null) {\n          // this matches both null and undefined\n          throw new TypeError(\"can't convert \" + o + ' to object');\n        }\n        return Object(o);\n      };\n\n      //\n      // Util\n      // ======\n      //\n\n      // ES5 9.4\n      // http://es5.github.com/#x9.4\n      // http://jsperf.com/to-integer\n\n      function toInteger(num) {\n        var n = +num;\n        if (n !== n) {\n          // isNaN\n          n = 0;\n        } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\n        }\n        return n;\n      }\n      function ToUint32(x) {\n        return x >>> 0;\n      }\n\n      //\n      // Function\n      // ========\n      //\n\n      // ES-5 15.3.4.5\n      // http://es5.github.com/#x15.3.4.5\n\n      function Empty() {}\n      defineProperties(FunctionPrototype, {\n        bind: function bind(that) {\n          // .length is 1\n          // 1. Let Target be the this value.\n          var target = this;\n          // 2. If IsCallable(Target) is false, throw a TypeError exception.\n          if (!isFunction(target)) {\n            throw new TypeError('Function.prototype.bind called on incompatible ' + target);\n          }\n          // 3. Let A be a new (possibly empty) internal list of all of the\n          //   argument values provided after thisArg (arg1, arg2 etc), in order.\n          // XXX slicedArgs will stand in for \"A\" if used\n          var args = array_slice.call(arguments, 1); // for normal call\n          // 4. Let F be a new native ECMAScript object.\n          // 11. Set the [[Prototype]] internal property of F to the standard\n          //   built-in Function prototype object as specified in 15.3.3.1.\n          // 12. Set the [[Call]] internal property of F as described in\n          //   15.3.4.5.1.\n          // 13. Set the [[Construct]] internal property of F as described in\n          //   15.3.4.5.2.\n          // 14. Set the [[HasInstance]] internal property of F as described in\n          //   15.3.4.5.3.\n          var binder = function () {\n            if (this instanceof bound) {\n              // 15.3.4.5.2 [[Construct]]\n              // When the [[Construct]] internal method of a function object,\n              // F that was created using the bind function is called with a\n              // list of arguments ExtraArgs, the following steps are taken:\n              // 1. Let target be the value of F's [[TargetFunction]]\n              //   internal property.\n              // 2. If target has no [[Construct]] internal method, a\n              //   TypeError exception is thrown.\n              // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\n              //   property.\n              // 4. Let args be a new list containing the same values as the\n              //   list boundArgs in the same order followed by the same\n              //   values as the list ExtraArgs in the same order.\n              // 5. Return the result of calling the [[Construct]] internal\n              //   method of target providing args as the arguments.\n\n              var result = target.apply(this, args.concat(array_slice.call(arguments)));\n              if (Object(result) === result) {\n                return result;\n              }\n              return this;\n            } else {\n              // 15.3.4.5.1 [[Call]]\n              // When the [[Call]] internal method of a function object, F,\n              // which was created using the bind function is called with a\n              // this value and a list of arguments ExtraArgs, the following\n              // steps are taken:\n              // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\n              //   property.\n              // 2. Let boundThis be the value of F's [[BoundThis]] internal\n              //   property.\n              // 3. Let target be the value of F's [[TargetFunction]] internal\n              //   property.\n              // 4. Let args be a new list containing the same values as the\n              //   list boundArgs in the same order followed by the same\n              //   values as the list ExtraArgs in the same order.\n              // 5. Return the result of calling the [[Call]] internal method\n              //   of target providing boundThis as the this value and\n              //   providing args as the arguments.\n\n              // equiv: target.call(this, ...boundArgs, ...args)\n              return target.apply(that, args.concat(array_slice.call(arguments)));\n            }\n          };\n\n          // 15. If the [[Class]] internal property of Target is \"Function\", then\n          //     a. Let L be the length property of Target minus the length of A.\n          //     b. Set the length own property of F to either 0 or L, whichever is\n          //       larger.\n          // 16. Else set the length own property of F to 0.\n\n          var boundLength = Math.max(0, target.length - args.length);\n\n          // 17. Set the attributes of the length own property of F to the values\n          //   specified in 15.3.5.1.\n          var boundArgs = [];\n          for (var i = 0; i < boundLength; i++) {\n            boundArgs.push('$' + i);\n          }\n\n          // XXX Build a dynamic function with desired amount of arguments is the only\n          // way to set the length property of a function.\n          // In environments where Content Security Policies enabled (Chrome extensions,\n          // for ex.) all use of eval or Function costructor throws an exception.\n          // However in all of these environments Function.prototype.bind exists\n          // and so this code will never be executed.\n          var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n          if (target.prototype) {\n            Empty.prototype = target.prototype;\n            bound.prototype = new Empty();\n            // Clean up dangling references.\n            Empty.prototype = null;\n          }\n\n          // TODO\n          // 18. Set the [[Extensible]] internal property of F to true.\n\n          // TODO\n          // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\n          // 20. Call the [[DefineOwnProperty]] internal method of F with\n          //   arguments \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\n          //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\n          //   false.\n          // 21. Call the [[DefineOwnProperty]] internal method of F with\n          //   arguments \"arguments\", PropertyDescriptor {[[Get]]: thrower,\n          //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\n          //   and false.\n\n          // TODO\n          // NOTE Function objects created using Function.prototype.bind do not\n          // have a prototype property or the [[Code]], [[FormalParameters]], and\n          // [[Scope]] internal properties.\n          // XXX can't delete prototype in pure-js.\n\n          // 22. Return F.\n          return bound;\n        }\n      });\n\n      //\n      // Array\n      // =====\n      //\n\n      // ES5 15.4.3.2\n      // http://es5.github.com/#x15.4.3.2\n      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\n      defineProperties(Array, {\n        isArray: isArray\n      });\n      var boxedString = Object('a');\n      var splitString = boxedString[0] !== 'a' || !(0 in boxedString);\n      var properlyBoxesContext = function properlyBoxed(method) {\n        // Check node 0.6.21 bug where third parameter is not boxed\n        var properlyBoxesNonStrict = true;\n        var properlyBoxesStrict = true;\n        if (method) {\n          method.call('foo', function (_, __, context) {\n            if (typeof context !== 'object') {\n              properlyBoxesNonStrict = false;\n            }\n          });\n          method.call([1], function () {\n            'use strict';\n\n            properlyBoxesStrict = typeof this === 'string';\n          }, 'x');\n        }\n        return !!method && properlyBoxesNonStrict && properlyBoxesStrict;\n      };\n      defineProperties(ArrayPrototype, {\n        forEach: function forEach(fun /*, thisp*/) {\n          var object = toObject(this),\n            self = splitString && isString(this) ? this.split('') : object,\n            thisp = arguments[1],\n            i = -1,\n            length = self.length >>> 0;\n\n          // If no callback function or if callback is not a callable function\n          if (!isFunction(fun)) {\n            throw new TypeError(); // TODO message\n          }\n\n          while (++i < length) {\n            if (i in self) {\n              // Invoke the callback function with call, passing arguments:\n              // context, property value, property key, thisArg object\n              // context\n              fun.call(thisp, self[i], i, object);\n            }\n          }\n        }\n      }, !properlyBoxesContext(ArrayPrototype.forEach));\n\n      // ES5 15.4.4.14\n      // http://es5.github.com/#x15.4.4.14\n      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\n      var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;\n      defineProperties(ArrayPrototype, {\n        indexOf: function indexOf(sought /*, fromIndex */) {\n          var self = splitString && isString(this) ? this.split('') : toObject(this),\n            length = self.length >>> 0;\n          if (!length) {\n            return -1;\n          }\n          var i = 0;\n          if (arguments.length > 1) {\n            i = toInteger(arguments[1]);\n          }\n\n          // handle negative indices\n          i = i >= 0 ? i : Math.max(0, length + i);\n          for (; i < length; i++) {\n            if (i in self && self[i] === sought) {\n              return i;\n            }\n          }\n          return -1;\n        }\n      }, hasFirefox2IndexOfBug);\n\n      //\n      // String\n      // ======\n      //\n\n      // ES5 15.5.4.14\n      // http://es5.github.com/#x15.5.4.14\n\n      // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]\n      // Many browsers do not split properly with regular expressions or they\n      // do not perform the split correctly under obscure conditions.\n      // See http://blog.stevenlevithan.com/archives/cross-browser-split\n      // I've tested in many browsers and this seems to cover the deviant ones:\n      //    'ab'.split(/(?:ab)*/) should be [\"\", \"\"], not [\"\"]\n      //    '.'.split(/(.?)(.?)/) should be [\"\", \".\", \"\", \"\"], not [\"\", \"\"]\n      //    'tesst'.split(/(s)*/) should be [\"t\", undefined, \"e\", \"s\", \"t\"], not\n      //       [undefined, \"t\", undefined, \"e\", ...]\n      //    ''.split(/.?/) should be [], not [\"\"]\n      //    '.'.split(/()()/) should be [\".\"], not [\"\", \"\", \".\"]\n\n      var string_split = StringPrototype.split;\n      if ('ab'.split(/(?:ab)*/).length !== 2 || '.'.split(/(.?)(.?)/).length !== 4 || 'tesst'.split(/(s)*/)[1] === 't' || 'test'.split(/(?:)/, -1).length !== 4 || ''.split(/.?/).length || '.'.split(/()()/).length > 1) {\n        (function () {\n          var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group\n\n          StringPrototype.split = function (separator, limit) {\n            var string = this;\n            if (separator === void 0 && limit === 0) {\n              return [];\n            }\n\n            // If `separator` is not a regex, use native split\n            if (_toString.call(separator) !== '[object RegExp]') {\n              return string_split.call(this, separator, limit);\n            }\n            var output = [],\n              flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.extended ? 'x' : '') + (\n              // Proposed for ES6\n              separator.sticky ? 'y' : ''),\n              // Firefox 3+\n              lastLastIndex = 0,\n              // Make `global` and avoid `lastIndex` issues by working with a copy\n              separator2,\n              match,\n              lastIndex,\n              lastLength;\n            separator = new RegExp(separator.source, flags + 'g');\n            string += ''; // Type-convert\n            if (!compliantExecNpcg) {\n              // Doesn't need flags gy, but they don't hurt\n              separator2 = new RegExp('^' + separator.source + '$(?!\\\\s)', flags);\n            }\n            /* Values for `limit`, per the spec:\n             * If undefined: 4294967295 // Math.pow(2, 32) - 1\n             * If 0, Infinity, or NaN: 0\n             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n             * If other: Type-convert, then use the above rules\n             */\n            limit = limit === void 0 ? -1 >>> 0 :\n            // Math.pow(2, 32) - 1\n            ToUint32(limit);\n            while (match = separator.exec(string)) {\n              // `separator.lastIndex` is not reliable cross-browser\n              lastIndex = match.index + match[0].length;\n              if (lastIndex > lastLastIndex) {\n                output.push(string.slice(lastLastIndex, match.index));\n                // Fix browsers whose `exec` methods don't consistently return `undefined` for\n                // nonparticipating capturing groups\n                if (!compliantExecNpcg && match.length > 1) {\n                  match[0].replace(separator2, function () {\n                    for (var i = 1; i < arguments.length - 2; i++) {\n                      if (arguments[i] === void 0) {\n                        match[i] = void 0;\n                      }\n                    }\n                  });\n                }\n                if (match.length > 1 && match.index < string.length) {\n                  ArrayPrototype.push.apply(output, match.slice(1));\n                }\n                lastLength = match[0].length;\n                lastLastIndex = lastIndex;\n                if (output.length >= limit) {\n                  break;\n                }\n              }\n              if (separator.lastIndex === match.index) {\n                separator.lastIndex++; // Avoid an infinite loop\n              }\n            }\n\n            if (lastLastIndex === string.length) {\n              if (lastLength || !separator.test('')) {\n                output.push('');\n              }\n            } else {\n              output.push(string.slice(lastLastIndex));\n            }\n            return output.length > limit ? output.slice(0, limit) : output;\n          };\n        })();\n\n        // [bugfix, chrome]\n        // If separator is undefined, then the result array contains just one String,\n        // which is the this value (converted to a String). If limit is not undefined,\n        // then the output array is truncated so that it contains no more than limit\n        // elements.\n        // \"0\".split(undefined, 0) -> []\n      } else if ('0'.split(void 0, 0).length) {\n        StringPrototype.split = function split(separator, limit) {\n          if (separator === void 0 && limit === 0) {\n            return [];\n          }\n          return string_split.call(this, separator, limit);\n        };\n      }\n\n      // ECMA-262, 3rd B.2.3\n      // Not an ECMAScript standard, although ECMAScript 3rd Edition has a\n      // non-normative section suggesting uniform semantics and it should be\n      // normalized across all browsers\n      // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE\n      var string_substr = StringPrototype.substr;\n      var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';\n      defineProperties(StringPrototype, {\n        substr: function substr(start, length) {\n          return string_substr.call(this, start < 0 ? (start = this.length + start) < 0 ? 0 : start : start, length);\n        }\n      }, hasNegativeSubstrBug);\n    }, {}],\n    16: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = [\n      // streaming transports\n      require('./transport/websocket'), require('./transport/xhr-streaming'), require('./transport/xdr-streaming'), require('./transport/eventsource'), require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))\n\n      // polling transports\n      , require('./transport/htmlfile'), require('./transport/lib/iframe-wrap')(require('./transport/htmlfile')), require('./transport/xhr-polling'), require('./transport/xdr-polling'), require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling')), require('./transport/jsonp-polling')];\n    }, {\n      \"./transport/eventsource\": 20,\n      \"./transport/htmlfile\": 21,\n      \"./transport/jsonp-polling\": 23,\n      \"./transport/lib/iframe-wrap\": 26,\n      \"./transport/websocket\": 38,\n      \"./transport/xdr-polling\": 39,\n      \"./transport/xdr-streaming\": 40,\n      \"./transport/xhr-polling\": 41,\n      \"./transport/xhr-streaming\": 42\n    }],\n    17: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n\n          var EventEmitter = require('events').EventEmitter,\n            inherits = require('inherits'),\n            utils = require('../../utils/event'),\n            urlUtils = require('../../utils/url'),\n            XHR = global.XMLHttpRequest;\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:browser:xhr');\n          }\n          function AbstractXHRObject(method, url, payload, opts) {\n            debug(method, url);\n            var self = this;\n            EventEmitter.call(this);\n            setTimeout(function () {\n              self._start(method, url, payload, opts);\n            }, 0);\n          }\n          inherits(AbstractXHRObject, EventEmitter);\n          AbstractXHRObject.prototype._start = function (method, url, payload, opts) {\n            var self = this;\n            try {\n              this.xhr = new XHR();\n            } catch (x) {\n              // intentionally empty\n            }\n            if (!this.xhr) {\n              debug('no xhr');\n              this.emit('finish', 0, 'no xhr support');\n              this._cleanup();\n              return;\n            }\n\n            // several browsers cache POSTs\n            url = urlUtils.addQuery(url, 't=' + +new Date());\n\n            // Explorer tends to keep connection open, even after the\n            // tab gets closed: http://bugs.jquery.com/ticket/5280\n            this.unloadRef = utils.unloadAdd(function () {\n              debug('unload cleanup');\n              self._cleanup(true);\n            });\n            try {\n              this.xhr.open(method, url, true);\n              if (this.timeout && 'timeout' in this.xhr) {\n                this.xhr.timeout = this.timeout;\n                this.xhr.ontimeout = function () {\n                  debug('xhr timeout');\n                  self.emit('finish', 0, '');\n                  self._cleanup(false);\n                };\n              }\n            } catch (e) {\n              debug('exception', e);\n              // IE raises an exception on wrong port.\n              this.emit('finish', 0, '');\n              this._cleanup(false);\n              return;\n            }\n            if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {\n              debug('withCredentials');\n              // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\n              // \"This never affects same-site requests.\"\n\n              this.xhr.withCredentials = true;\n            }\n            if (opts && opts.headers) {\n              for (var key in opts.headers) {\n                this.xhr.setRequestHeader(key, opts.headers[key]);\n              }\n            }\n            this.xhr.onreadystatechange = function () {\n              if (self.xhr) {\n                var x = self.xhr;\n                var text, status;\n                debug('readyState', x.readyState);\n                switch (x.readyState) {\n                  case 3:\n                    // IE doesn't like peeking into responseText or status\n                    // on Microsoft.XMLHTTP and readystate=3\n                    try {\n                      status = x.status;\n                      text = x.responseText;\n                    } catch (e) {\n                      // intentionally empty\n                    }\n                    debug('status', status);\n                    // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n                    if (status === 1223) {\n                      status = 204;\n                    }\n\n                    // IE does return readystate == 3 for 404 answers.\n                    if (status === 200 && text && text.length > 0) {\n                      debug('chunk');\n                      self.emit('chunk', status, text);\n                    }\n                    break;\n                  case 4:\n                    status = x.status;\n                    debug('status', status);\n                    // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n                    if (status === 1223) {\n                      status = 204;\n                    }\n                    // IE returns this for a bad port\n                    // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx\n                    if (status === 12005 || status === 12029) {\n                      status = 0;\n                    }\n                    debug('finish', status, x.responseText);\n                    self.emit('finish', status, x.responseText);\n                    self._cleanup(false);\n                    break;\n                }\n              }\n            };\n            try {\n              self.xhr.send(payload);\n            } catch (e) {\n              self.emit('finish', 0, '');\n              self._cleanup(false);\n            }\n          };\n          AbstractXHRObject.prototype._cleanup = function (abort) {\n            debug('cleanup');\n            if (!this.xhr) {\n              return;\n            }\n            this.removeAllListeners();\n            utils.unloadDel(this.unloadRef);\n\n            // IE needs this field to be a function\n            this.xhr.onreadystatechange = function () {};\n            if (this.xhr.ontimeout) {\n              this.xhr.ontimeout = null;\n            }\n            if (abort) {\n              try {\n                this.xhr.abort();\n              } catch (x) {\n                // intentionally empty\n              }\n            }\n            this.unloadRef = this.xhr = null;\n          };\n          AbstractXHRObject.prototype.close = function () {\n            debug('close');\n            this._cleanup(true);\n          };\n          AbstractXHRObject.enabled = !!XHR;\n          // override XMLHttpRequest for IE6/7\n          // obfuscate to avoid firewalls\n          var axo = ['Active'].concat('Object').join('X');\n          if (!AbstractXHRObject.enabled && axo in global) {\n            debug('overriding xmlhttprequest');\n            XHR = function () {\n              try {\n                return new global[axo]('Microsoft.XMLHTTP');\n              } catch (e) {\n                return null;\n              }\n            };\n            AbstractXHRObject.enabled = !!new XHR();\n          }\n          var cors = false;\n          try {\n            cors = 'withCredentials' in new XHR();\n          } catch (ignored) {\n            // intentionally empty\n          }\n          AbstractXHRObject.supportsCORS = cors;\n          module.exports = AbstractXHRObject;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      }, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../../utils/event\": 46,\n      \"../../utils/url\": 52,\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    18: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          module.exports = global.EventSource;\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    19: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          var Driver = global.WebSocket || global.MozWebSocket;\n          if (Driver) {\n            module.exports = function WebSocketBrowserDriver(url) {\n              return new Driver(url);\n            };\n          } else {\n            module.exports = undefined;\n          }\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    20: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        AjaxBasedTransport = require('./lib/ajax-based'),\n        EventSourceReceiver = require('./receiver/eventsource'),\n        XHRCorsObject = require('./sender/xhr-cors'),\n        EventSourceDriver = require('eventsource');\n      function EventSourceTransport(transUrl) {\n        if (!EventSourceTransport.enabled()) {\n          throw new Error('Transport created when disabled');\n        }\n        AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);\n      }\n      inherits(EventSourceTransport, AjaxBasedTransport);\n      EventSourceTransport.enabled = function () {\n        return !!EventSourceDriver;\n      };\n      EventSourceTransport.transportName = 'eventsource';\n      EventSourceTransport.roundTrips = 2;\n      module.exports = EventSourceTransport;\n    }, {\n      \"./lib/ajax-based\": 24,\n      \"./receiver/eventsource\": 29,\n      \"./sender/xhr-cors\": 35,\n      \"eventsource\": 18,\n      \"inherits\": 57\n    }],\n    21: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        HtmlfileReceiver = require('./receiver/htmlfile'),\n        XHRLocalObject = require('./sender/xhr-local'),\n        AjaxBasedTransport = require('./lib/ajax-based');\n      function HtmlFileTransport(transUrl) {\n        if (!HtmlfileReceiver.enabled) {\n          throw new Error('Transport created when disabled');\n        }\n        AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);\n      }\n      inherits(HtmlFileTransport, AjaxBasedTransport);\n      HtmlFileTransport.enabled = function (info) {\n        return HtmlfileReceiver.enabled && info.sameOrigin;\n      };\n      HtmlFileTransport.transportName = 'htmlfile';\n      HtmlFileTransport.roundTrips = 2;\n      module.exports = HtmlFileTransport;\n    }, {\n      \"./lib/ajax-based\": 24,\n      \"./receiver/htmlfile\": 30,\n      \"./sender/xhr-local\": 37,\n      \"inherits\": 57\n    }],\n    22: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          // Few cool transports do work only for same-origin. In order to make\n          // them work cross-domain we shall use iframe, served from the\n          // remote domain. New browsers have capabilities to communicate with\n          // cross domain iframe using postMessage(). In IE it was implemented\n          // from IE 8+, but of course, IE got some details wrong:\n          //    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\n          //    http://stevesouders.com/misc/test-postmessage.php\n          var inherits = require('inherits'),\n            EventEmitter = require('events').EventEmitter,\n            version = require('../version'),\n            urlUtils = require('../utils/url'),\n            iframeUtils = require('../utils/iframe'),\n            eventUtils = require('../utils/event'),\n            random = require('../utils/random');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:transport:iframe');\n          }\n          function IframeTransport(transport, transUrl, baseUrl) {\n            if (!IframeTransport.enabled()) {\n              throw new Error('Transport created when disabled');\n            }\n            EventEmitter.call(this);\n            var self = this;\n            this.origin = urlUtils.getOrigin(baseUrl);\n            this.baseUrl = baseUrl;\n            this.transUrl = transUrl;\n            this.transport = transport;\n            this.windowId = random.string(8);\n            var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;\n            debug(transport, transUrl, iframeUrl);\n            this.iframeObj = iframeUtils.createIframe(iframeUrl, function (r) {\n              debug('err callback');\n              self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');\n              self.close();\n            });\n            this.onmessageCallback = this._message.bind(this);\n            eventUtils.attachEvent('message', this.onmessageCallback);\n          }\n          inherits(IframeTransport, EventEmitter);\n          IframeTransport.prototype.close = function () {\n            debug('close');\n            this.removeAllListeners();\n            if (this.iframeObj) {\n              eventUtils.detachEvent('message', this.onmessageCallback);\n              try {\n                // When the iframe is not loaded, IE raises an exception\n                // on 'contentWindow'.\n                this.postMessage('c');\n              } catch (x) {\n                // intentionally empty\n              }\n              this.iframeObj.cleanup();\n              this.iframeObj = null;\n              this.onmessageCallback = this.iframeObj = null;\n            }\n          };\n          IframeTransport.prototype._message = function (e) {\n            debug('message', e.data);\n            if (!urlUtils.isOriginEqual(e.origin, this.origin)) {\n              debug('not same origin', e.origin, this.origin);\n              return;\n            }\n            var iframeMessage;\n            try {\n              iframeMessage = JSON.parse(e.data);\n            } catch (ignored) {\n              debug('bad json', e.data);\n              return;\n            }\n            if (iframeMessage.windowId !== this.windowId) {\n              debug('mismatched window id', iframeMessage.windowId, this.windowId);\n              return;\n            }\n            switch (iframeMessage.type) {\n              case 's':\n                this.iframeObj.loaded();\n                // window global dependency\n                this.postMessage('s', JSON.stringify([version, this.transport, this.transUrl, this.baseUrl]));\n                break;\n              case 't':\n                this.emit('message', iframeMessage.data);\n                break;\n              case 'c':\n                var cdata;\n                try {\n                  cdata = JSON.parse(iframeMessage.data);\n                } catch (ignored) {\n                  debug('bad json', iframeMessage.data);\n                  return;\n                }\n                this.emit('close', cdata[0], cdata[1]);\n                this.close();\n                break;\n            }\n          };\n          IframeTransport.prototype.postMessage = function (type, data) {\n            debug('postMessage', type, data);\n            this.iframeObj.post(JSON.stringify({\n              windowId: this.windowId,\n              type: type,\n              data: data || ''\n            }), this.origin);\n          };\n          IframeTransport.prototype.send = function (message) {\n            debug('send', message);\n            this.postMessage('m', message);\n          };\n          IframeTransport.enabled = function () {\n            return iframeUtils.iframeEnabled;\n          };\n          IframeTransport.transportName = 'iframe';\n          IframeTransport.roundTrips = 2;\n          module.exports = IframeTransport;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"../utils/event\": 46,\n      \"../utils/iframe\": 47,\n      \"../utils/random\": 50,\n      \"../utils/url\": 52,\n      \"../version\": 53,\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    23: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          // The simplest and most robust transport, using the well-know cross\n          // domain hack - JSONP. This transport is quite inefficient - one\n          // message could use up to one http request. But at least it works almost\n          // everywhere.\n          // Known limitations:\n          //   o you will get a spinning cursor\n          //   o for Konqueror a dumb timer is needed to detect errors\n          var inherits = require('inherits'),\n            SenderReceiver = require('./lib/sender-receiver'),\n            JsonpReceiver = require('./receiver/jsonp'),\n            jsonpSender = require('./sender/jsonp');\n          function JsonPTransport(transUrl) {\n            if (!JsonPTransport.enabled()) {\n              throw new Error('Transport created when disabled');\n            }\n            SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);\n          }\n          inherits(JsonPTransport, SenderReceiver);\n          JsonPTransport.enabled = function () {\n            return !!global.document;\n          };\n          JsonPTransport.transportName = 'jsonp-polling';\n          JsonPTransport.roundTrips = 1;\n          JsonPTransport.needBody = true;\n          module.exports = JsonPTransport;\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./lib/sender-receiver\": 28,\n      \"./receiver/jsonp\": 31,\n      \"./sender/jsonp\": 33,\n      \"inherits\": 57\n    }],\n    24: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var inherits = require('inherits'),\n            urlUtils = require('../../utils/url'),\n            SenderReceiver = require('./sender-receiver');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:ajax-based');\n          }\n          function createAjaxSender(AjaxObject) {\n            return function (url, payload, callback) {\n              debug('create ajax sender', url, payload);\n              var opt = {};\n              if (typeof payload === 'string') {\n                opt.headers = {\n                  'Content-type': 'text/plain'\n                };\n              }\n              var ajaxUrl = urlUtils.addPath(url, '/xhr_send');\n              var xo = new AjaxObject('POST', ajaxUrl, payload, opt);\n              xo.once('finish', function (status) {\n                debug('finish', status);\n                xo = null;\n                if (status !== 200 && status !== 204) {\n                  return callback(new Error('http status ' + status));\n                }\n                callback();\n              });\n              return function () {\n                debug('abort');\n                xo.close();\n                xo = null;\n                var err = new Error('Aborted');\n                err.code = 1000;\n                callback(err);\n              };\n            };\n          }\n          function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {\n            SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);\n          }\n          inherits(AjaxBasedTransport, SenderReceiver);\n          module.exports = AjaxBasedTransport;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"../../utils/url\": 52,\n      \"./sender-receiver\": 28,\n      \"debug\": 55,\n      \"inherits\": 57\n    }],\n    25: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var inherits = require('inherits'),\n            EventEmitter = require('events').EventEmitter;\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:buffered-sender');\n          }\n          function BufferedSender(url, sender) {\n            debug(url);\n            EventEmitter.call(this);\n            this.sendBuffer = [];\n            this.sender = sender;\n            this.url = url;\n          }\n          inherits(BufferedSender, EventEmitter);\n          BufferedSender.prototype.send = function (message) {\n            debug('send', message);\n            this.sendBuffer.push(message);\n            if (!this.sendStop) {\n              this.sendSchedule();\n            }\n          };\n\n          // For polling transports in a situation when in the message callback,\n          // new message is being send. If the sending connection was started\n          // before receiving one, it is possible to saturate the network and\n          // timeout due to the lack of receiving socket. To avoid that we delay\n          // sending messages by some small time, in order to let receiving\n          // connection be started beforehand. This is only a halfmeasure and\n          // does not fix the big problem, but it does make the tests go more\n          // stable on slow networks.\n          BufferedSender.prototype.sendScheduleWait = function () {\n            debug('sendScheduleWait');\n            var self = this;\n            var tref;\n            this.sendStop = function () {\n              debug('sendStop');\n              self.sendStop = null;\n              clearTimeout(tref);\n            };\n            tref = setTimeout(function () {\n              debug('timeout');\n              self.sendStop = null;\n              self.sendSchedule();\n            }, 25);\n          };\n          BufferedSender.prototype.sendSchedule = function () {\n            debug('sendSchedule', this.sendBuffer.length);\n            var self = this;\n            if (this.sendBuffer.length > 0) {\n              var payload = '[' + this.sendBuffer.join(',') + ']';\n              this.sendStop = this.sender(this.url, payload, function (err) {\n                self.sendStop = null;\n                if (err) {\n                  debug('error', err);\n                  self.emit('close', err.code || 1006, 'Sending error: ' + err);\n                  self.close();\n                } else {\n                  self.sendScheduleWait();\n                }\n              });\n              this.sendBuffer = [];\n            }\n          };\n          BufferedSender.prototype._cleanup = function () {\n            debug('_cleanup');\n            this.removeAllListeners();\n          };\n          BufferedSender.prototype.close = function () {\n            debug('close');\n            this._cleanup();\n            if (this.sendStop) {\n              this.sendStop();\n              this.sendStop = null;\n            }\n          };\n          module.exports = BufferedSender;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    26: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          var inherits = require('inherits'),\n            IframeTransport = require('../iframe'),\n            objectUtils = require('../../utils/object');\n          module.exports = function (transport) {\n            function IframeWrapTransport(transUrl, baseUrl) {\n              IframeTransport.call(this, transport.transportName, transUrl, baseUrl);\n            }\n            inherits(IframeWrapTransport, IframeTransport);\n            IframeWrapTransport.enabled = function (url, info) {\n              if (!global.document) {\n                return false;\n              }\n              var iframeInfo = objectUtils.extend({}, info);\n              iframeInfo.sameOrigin = true;\n              return transport.enabled(iframeInfo) && IframeTransport.enabled();\n            };\n            IframeWrapTransport.transportName = 'iframe-' + transport.transportName;\n            IframeWrapTransport.needBody = true;\n            IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)\n\n            IframeWrapTransport.facadeTransport = transport;\n            return IframeWrapTransport;\n          };\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../../utils/object\": 49,\n      \"../iframe\": 22,\n      \"inherits\": 57\n    }],\n    27: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var inherits = require('inherits'),\n            EventEmitter = require('events').EventEmitter;\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:polling');\n          }\n          function Polling(Receiver, receiveUrl, AjaxObject) {\n            debug(receiveUrl);\n            EventEmitter.call(this);\n            this.Receiver = Receiver;\n            this.receiveUrl = receiveUrl;\n            this.AjaxObject = AjaxObject;\n            this._scheduleReceiver();\n          }\n          inherits(Polling, EventEmitter);\n          Polling.prototype._scheduleReceiver = function () {\n            debug('_scheduleReceiver');\n            var self = this;\n            var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);\n            poll.on('message', function (msg) {\n              debug('message', msg);\n              self.emit('message', msg);\n            });\n            poll.once('close', function (code, reason) {\n              debug('close', code, reason, self.pollIsClosing);\n              self.poll = poll = null;\n              if (!self.pollIsClosing) {\n                if (reason === 'network') {\n                  self._scheduleReceiver();\n                } else {\n                  self.emit('close', code || 1006, reason);\n                  self.removeAllListeners();\n                }\n              }\n            });\n          };\n          Polling.prototype.abort = function () {\n            debug('abort');\n            this.removeAllListeners();\n            this.pollIsClosing = true;\n            if (this.poll) {\n              this.poll.abort();\n            }\n          };\n          module.exports = Polling;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    28: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var inherits = require('inherits'),\n            urlUtils = require('../../utils/url'),\n            BufferedSender = require('./buffered-sender'),\n            Polling = require('./polling');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:sender-receiver');\n          }\n          function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {\n            var pollUrl = urlUtils.addPath(transUrl, urlSuffix);\n            debug(pollUrl);\n            var self = this;\n            BufferedSender.call(this, transUrl, senderFunc);\n            this.poll = new Polling(Receiver, pollUrl, AjaxObject);\n            this.poll.on('message', function (msg) {\n              debug('poll message', msg);\n              self.emit('message', msg);\n            });\n            this.poll.once('close', function (code, reason) {\n              debug('poll close', code, reason);\n              self.poll = null;\n              self.emit('close', code, reason);\n              self.close();\n            });\n          }\n          inherits(SenderReceiver, BufferedSender);\n          SenderReceiver.prototype.close = function () {\n            BufferedSender.prototype.close.call(this);\n            debug('close');\n            this.removeAllListeners();\n            if (this.poll) {\n              this.poll.abort();\n              this.poll = null;\n            }\n          };\n          module.exports = SenderReceiver;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"../../utils/url\": 52,\n      \"./buffered-sender\": 25,\n      \"./polling\": 27,\n      \"debug\": 55,\n      \"inherits\": 57\n    }],\n    29: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var inherits = require('inherits'),\n            EventEmitter = require('events').EventEmitter,\n            EventSourceDriver = require('eventsource');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:receiver:eventsource');\n          }\n          function EventSourceReceiver(url) {\n            debug(url);\n            EventEmitter.call(this);\n            var self = this;\n            var es = this.es = new EventSourceDriver(url);\n            es.onmessage = function (e) {\n              debug('message', e.data);\n              self.emit('message', decodeURI(e.data));\n            };\n            es.onerror = function (e) {\n              debug('error', es.readyState, e);\n              // ES on reconnection has readyState = 0 or 1.\n              // on network error it's CLOSED = 2\n              var reason = es.readyState !== 2 ? 'network' : 'permanent';\n              self._cleanup();\n              self._close(reason);\n            };\n          }\n          inherits(EventSourceReceiver, EventEmitter);\n          EventSourceReceiver.prototype.abort = function () {\n            debug('abort');\n            this._cleanup();\n            this._close('user');\n          };\n          EventSourceReceiver.prototype._cleanup = function () {\n            debug('cleanup');\n            var es = this.es;\n            if (es) {\n              es.onmessage = es.onerror = null;\n              es.close();\n              this.es = null;\n            }\n          };\n          EventSourceReceiver.prototype._close = function (reason) {\n            debug('close', reason);\n            var self = this;\n            // Safari and chrome < 15 crash if we close window before\n            // waiting for ES cleanup. See:\n            // https://code.google.com/p/chromium/issues/detail?id=89155\n            setTimeout(function () {\n              self.emit('close', null, reason);\n              self.removeAllListeners();\n            }, 200);\n          };\n          module.exports = EventSourceReceiver;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"debug\": 55,\n      \"events\": 3,\n      \"eventsource\": 18,\n      \"inherits\": 57\n    }],\n    30: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n\n          var inherits = require('inherits'),\n            iframeUtils = require('../../utils/iframe'),\n            urlUtils = require('../../utils/url'),\n            EventEmitter = require('events').EventEmitter,\n            random = require('../../utils/random');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:receiver:htmlfile');\n          }\n          function HtmlfileReceiver(url) {\n            debug(url);\n            EventEmitter.call(this);\n            var self = this;\n            iframeUtils.polluteGlobalNamespace();\n            this.id = 'a' + random.string(6);\n            url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));\n            debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);\n            var constructFunc = HtmlfileReceiver.htmlfileEnabled ? iframeUtils.createHtmlfile : iframeUtils.createIframe;\n            global[iframeUtils.WPrefix][this.id] = {\n              start: function () {\n                debug('start');\n                self.iframeObj.loaded();\n              },\n              message: function (data) {\n                debug('message', data);\n                self.emit('message', data);\n              },\n              stop: function () {\n                debug('stop');\n                self._cleanup();\n                self._close('network');\n              }\n            };\n            this.iframeObj = constructFunc(url, function () {\n              debug('callback');\n              self._cleanup();\n              self._close('permanent');\n            });\n          }\n          inherits(HtmlfileReceiver, EventEmitter);\n          HtmlfileReceiver.prototype.abort = function () {\n            debug('abort');\n            this._cleanup();\n            this._close('user');\n          };\n          HtmlfileReceiver.prototype._cleanup = function () {\n            debug('_cleanup');\n            if (this.iframeObj) {\n              this.iframeObj.cleanup();\n              this.iframeObj = null;\n            }\n            delete global[iframeUtils.WPrefix][this.id];\n          };\n          HtmlfileReceiver.prototype._close = function (reason) {\n            debug('_close', reason);\n            this.emit('close', null, reason);\n            this.removeAllListeners();\n          };\n          HtmlfileReceiver.htmlfileEnabled = false;\n\n          // obfuscate to avoid firewalls\n          var axo = ['Active'].concat('Object').join('X');\n          if (axo in global) {\n            try {\n              HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');\n            } catch (x) {\n              // intentionally empty\n            }\n          }\n          HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;\n          module.exports = HtmlfileReceiver;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      }, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../../utils/iframe\": 47,\n      \"../../utils/random\": 50,\n      \"../../utils/url\": 52,\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    31: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n\n          var utils = require('../../utils/iframe'),\n            random = require('../../utils/random'),\n            browser = require('../../utils/browser'),\n            urlUtils = require('../../utils/url'),\n            inherits = require('inherits'),\n            EventEmitter = require('events').EventEmitter;\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:receiver:jsonp');\n          }\n          function JsonpReceiver(url) {\n            debug(url);\n            var self = this;\n            EventEmitter.call(this);\n            utils.polluteGlobalNamespace();\n            this.id = 'a' + random.string(6);\n            var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));\n            global[utils.WPrefix][this.id] = this._callback.bind(this);\n            this._createScript(urlWithId);\n\n            // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\n            this.timeoutId = setTimeout(function () {\n              debug('timeout');\n              self._abort(new Error('JSONP script loaded abnormally (timeout)'));\n            }, JsonpReceiver.timeout);\n          }\n          inherits(JsonpReceiver, EventEmitter);\n          JsonpReceiver.prototype.abort = function () {\n            debug('abort');\n            if (global[utils.WPrefix][this.id]) {\n              var err = new Error('JSONP user aborted read');\n              err.code = 1000;\n              this._abort(err);\n            }\n          };\n          JsonpReceiver.timeout = 35000;\n          JsonpReceiver.scriptErrorTimeout = 1000;\n          JsonpReceiver.prototype._callback = function (data) {\n            debug('_callback', data);\n            this._cleanup();\n            if (this.aborting) {\n              return;\n            }\n            if (data) {\n              debug('message', data);\n              this.emit('message', data);\n            }\n            this.emit('close', null, 'network');\n            this.removeAllListeners();\n          };\n          JsonpReceiver.prototype._abort = function (err) {\n            debug('_abort', err);\n            this._cleanup();\n            this.aborting = true;\n            this.emit('close', err.code, err.message);\n            this.removeAllListeners();\n          };\n          JsonpReceiver.prototype._cleanup = function () {\n            debug('_cleanup');\n            clearTimeout(this.timeoutId);\n            if (this.script2) {\n              this.script2.parentNode.removeChild(this.script2);\n              this.script2 = null;\n            }\n            if (this.script) {\n              var script = this.script;\n              // Unfortunately, you can't really abort script loading of\n              // the script.\n              script.parentNode.removeChild(script);\n              script.onreadystatechange = script.onerror = script.onload = script.onclick = null;\n              this.script = null;\n            }\n            delete global[utils.WPrefix][this.id];\n          };\n          JsonpReceiver.prototype._scriptError = function () {\n            debug('_scriptError');\n            var self = this;\n            if (this.errorTimer) {\n              return;\n            }\n            this.errorTimer = setTimeout(function () {\n              if (!self.loadedOkay) {\n                self._abort(new Error('JSONP script loaded abnormally (onerror)'));\n              }\n            }, JsonpReceiver.scriptErrorTimeout);\n          };\n          JsonpReceiver.prototype._createScript = function (url) {\n            debug('_createScript', url);\n            var self = this;\n            var script = this.script = global.document.createElement('script');\n            var script2; // Opera synchronous load trick.\n\n            script.id = 'a' + random.string(8);\n            script.src = url;\n            script.type = 'text/javascript';\n            script.charset = 'UTF-8';\n            script.onerror = this._scriptError.bind(this);\n            script.onload = function () {\n              debug('onload');\n              self._abort(new Error('JSONP script loaded abnormally (onload)'));\n            };\n\n            // IE9 fires 'error' event after onreadystatechange or before, in random order.\n            // Use loadedOkay to determine if actually errored\n            script.onreadystatechange = function () {\n              debug('onreadystatechange', script.readyState);\n              if (/loaded|closed/.test(script.readyState)) {\n                if (script && script.htmlFor && script.onclick) {\n                  self.loadedOkay = true;\n                  try {\n                    // In IE, actually execute the script.\n                    script.onclick();\n                  } catch (x) {\n                    // intentionally empty\n                  }\n                }\n                if (script) {\n                  self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));\n                }\n              }\n            };\n            // IE: event/htmlFor/onclick trick.\n            // One can't rely on proper order for onreadystatechange. In order to\n            // make sure, set a 'htmlFor' and 'event' properties, so that\n            // script code will be installed as 'onclick' handler for the\n            // script object. Later, onreadystatechange, manually execute this\n            // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\n            // set. For reference see:\n            //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n            // Also, read on that about script ordering:\n            //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n            if (typeof script.async === 'undefined' && global.document.attachEvent) {\n              // According to mozilla docs, in recent browsers script.async defaults\n              // to 'true', so we may use it to detect a good browser:\n              // https://developer.mozilla.org/en/HTML/Element/script\n              if (!browser.isOpera()) {\n                // Naively assume we're in IE\n                try {\n                  script.htmlFor = script.id;\n                  script.event = 'onclick';\n                } catch (x) {\n                  // intentionally empty\n                }\n                script.async = true;\n              } else {\n                // Opera, second sync script hack\n                script2 = this.script2 = global.document.createElement('script');\n                script2.text = \"try{var a = document.getElementById('\" + script.id + \"'); if(a)a.onerror();}catch(x){};\";\n                script.async = script2.async = false;\n              }\n            }\n            if (typeof script.async !== 'undefined') {\n              script.async = true;\n            }\n            var head = global.document.getElementsByTagName('head')[0];\n            head.insertBefore(script, head.firstChild);\n            if (script2) {\n              head.insertBefore(script2, head.firstChild);\n            }\n          };\n          module.exports = JsonpReceiver;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      }, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../../utils/browser\": 44,\n      \"../../utils/iframe\": 47,\n      \"../../utils/random\": 50,\n      \"../../utils/url\": 52,\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    32: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var inherits = require('inherits'),\n            EventEmitter = require('events').EventEmitter;\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:receiver:xhr');\n          }\n          function XhrReceiver(url, AjaxObject) {\n            debug(url);\n            EventEmitter.call(this);\n            var self = this;\n            this.bufferPosition = 0;\n            this.xo = new AjaxObject('POST', url, null);\n            this.xo.on('chunk', this._chunkHandler.bind(this));\n            this.xo.once('finish', function (status, text) {\n              debug('finish', status, text);\n              self._chunkHandler(status, text);\n              self.xo = null;\n              var reason = status === 200 ? 'network' : 'permanent';\n              debug('close', reason);\n              self.emit('close', null, reason);\n              self._cleanup();\n            });\n          }\n          inherits(XhrReceiver, EventEmitter);\n          XhrReceiver.prototype._chunkHandler = function (status, text) {\n            debug('_chunkHandler', status);\n            if (status !== 200 || !text) {\n              return;\n            }\n            for (var idx = -1;; this.bufferPosition += idx + 1) {\n              var buf = text.slice(this.bufferPosition);\n              idx = buf.indexOf('\\n');\n              if (idx === -1) {\n                break;\n              }\n              var msg = buf.slice(0, idx);\n              if (msg) {\n                debug('message', msg);\n                this.emit('message', msg);\n              }\n            }\n          };\n          XhrReceiver.prototype._cleanup = function () {\n            debug('_cleanup');\n            this.removeAllListeners();\n          };\n          XhrReceiver.prototype.abort = function () {\n            debug('abort');\n            if (this.xo) {\n              this.xo.close();\n              debug('close');\n              this.emit('close', null, 'user');\n              this.xo = null;\n            }\n            this._cleanup();\n          };\n          module.exports = XhrReceiver;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    33: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n\n          var random = require('../../utils/random'),\n            urlUtils = require('../../utils/url');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:sender:jsonp');\n          }\n          var form, area;\n          function createIframe(id) {\n            debug('createIframe', id);\n            try {\n              // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n              return global.document.createElement('<iframe name=\"' + id + '\">');\n            } catch (x) {\n              var iframe = global.document.createElement('iframe');\n              iframe.name = id;\n              return iframe;\n            }\n          }\n          function createForm() {\n            debug('createForm');\n            form = global.document.createElement('form');\n            form.style.display = 'none';\n            form.style.position = 'absolute';\n            form.method = 'POST';\n            form.enctype = 'application/x-www-form-urlencoded';\n            form.acceptCharset = 'UTF-8';\n            area = global.document.createElement('textarea');\n            area.name = 'd';\n            form.appendChild(area);\n            global.document.body.appendChild(form);\n          }\n          module.exports = function (url, payload, callback) {\n            debug(url, payload);\n            if (!form) {\n              createForm();\n            }\n            var id = 'a' + random.string(8);\n            form.target = id;\n            form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);\n            var iframe = createIframe(id);\n            iframe.id = id;\n            iframe.style.display = 'none';\n            form.appendChild(iframe);\n            try {\n              area.value = payload;\n            } catch (e) {\n              // seriously broken browsers get here\n            }\n            form.submit();\n            var completed = function (err) {\n              debug('completed', id, err);\n              if (!iframe.onerror) {\n                return;\n              }\n              iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\n              // Opera mini doesn't like if we GC iframe\n              // immediately, thus this timeout.\n              setTimeout(function () {\n                debug('cleaning up', id);\n                iframe.parentNode.removeChild(iframe);\n                iframe = null;\n              }, 500);\n              area.value = '';\n              // It is not possible to detect if the iframe succeeded or\n              // failed to submit our form.\n              callback(err);\n            };\n            iframe.onerror = function () {\n              debug('onerror', id);\n              completed();\n            };\n            iframe.onload = function () {\n              debug('onload', id);\n              completed();\n            };\n            iframe.onreadystatechange = function (e) {\n              debug('onreadystatechange', id, iframe.readyState, e);\n              if (iframe.readyState === 'complete') {\n                completed();\n              }\n            };\n            return function () {\n              debug('aborted', id);\n              completed(new Error('Aborted'));\n            };\n          };\n        }).call(this);\n      }).call(this, {\n        env: {}\n      }, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../../utils/random\": 50,\n      \"../../utils/url\": 52,\n      \"debug\": 55\n    }],\n    34: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n\n          var EventEmitter = require('events').EventEmitter,\n            inherits = require('inherits'),\n            eventUtils = require('../../utils/event'),\n            browser = require('../../utils/browser'),\n            urlUtils = require('../../utils/url');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:sender:xdr');\n          }\n\n          // References:\n          //   http://ajaxian.com/archives/100-line-ajax-wrapper\n          //   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\n\n          function XDRObject(method, url, payload) {\n            debug(method, url);\n            var self = this;\n            EventEmitter.call(this);\n            setTimeout(function () {\n              self._start(method, url, payload);\n            }, 0);\n          }\n          inherits(XDRObject, EventEmitter);\n          XDRObject.prototype._start = function (method, url, payload) {\n            debug('_start');\n            var self = this;\n            var xdr = new global.XDomainRequest();\n            // IE caches even POSTs\n            url = urlUtils.addQuery(url, 't=' + +new Date());\n            xdr.onerror = function () {\n              debug('onerror');\n              self._error();\n            };\n            xdr.ontimeout = function () {\n              debug('ontimeout');\n              self._error();\n            };\n            xdr.onprogress = function () {\n              debug('progress', xdr.responseText);\n              self.emit('chunk', 200, xdr.responseText);\n            };\n            xdr.onload = function () {\n              debug('load');\n              self.emit('finish', 200, xdr.responseText);\n              self._cleanup(false);\n            };\n            this.xdr = xdr;\n            this.unloadRef = eventUtils.unloadAdd(function () {\n              self._cleanup(true);\n            });\n            try {\n              // Fails with AccessDenied if port number is bogus\n              this.xdr.open(method, url);\n              if (this.timeout) {\n                this.xdr.timeout = this.timeout;\n              }\n              this.xdr.send(payload);\n            } catch (x) {\n              this._error();\n            }\n          };\n          XDRObject.prototype._error = function () {\n            this.emit('finish', 0, '');\n            this._cleanup(false);\n          };\n          XDRObject.prototype._cleanup = function (abort) {\n            debug('cleanup', abort);\n            if (!this.xdr) {\n              return;\n            }\n            this.removeAllListeners();\n            eventUtils.unloadDel(this.unloadRef);\n            this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;\n            if (abort) {\n              try {\n                this.xdr.abort();\n              } catch (x) {\n                // intentionally empty\n              }\n            }\n            this.unloadRef = this.xdr = null;\n          };\n          XDRObject.prototype.close = function () {\n            debug('close');\n            this._cleanup(true);\n          };\n\n          // IE 8/9 if the request target uses the same scheme - #79\n          XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());\n          module.exports = XDRObject;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      }, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../../utils/browser\": 44,\n      \"../../utils/event\": 46,\n      \"../../utils/url\": 52,\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    35: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        XhrDriver = require('../driver/xhr');\n      function XHRCorsObject(method, url, payload, opts) {\n        XhrDriver.call(this, method, url, payload, opts);\n      }\n      inherits(XHRCorsObject, XhrDriver);\n      XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;\n      module.exports = XHRCorsObject;\n    }, {\n      \"../driver/xhr\": 17,\n      \"inherits\": 57\n    }],\n    36: [function (require, module, exports) {\n      'use strict';\n\n      var EventEmitter = require('events').EventEmitter,\n        inherits = require('inherits');\n      function XHRFake( /* method, url, payload, opts */\n      ) {\n        var self = this;\n        EventEmitter.call(this);\n        this.to = setTimeout(function () {\n          self.emit('finish', 200, '{}');\n        }, XHRFake.timeout);\n      }\n      inherits(XHRFake, EventEmitter);\n      XHRFake.prototype.close = function () {\n        clearTimeout(this.to);\n      };\n      XHRFake.timeout = 2000;\n      module.exports = XHRFake;\n    }, {\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    37: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        XhrDriver = require('../driver/xhr');\n      function XHRLocalObject(method, url, payload /*, opts */) {\n        XhrDriver.call(this, method, url, payload, {\n          noCredentials: true\n        });\n      }\n      inherits(XHRLocalObject, XhrDriver);\n      XHRLocalObject.enabled = XhrDriver.enabled;\n      module.exports = XHRLocalObject;\n    }, {\n      \"../driver/xhr\": 17,\n      \"inherits\": 57\n    }],\n    38: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var utils = require('../utils/event'),\n            urlUtils = require('../utils/url'),\n            inherits = require('inherits'),\n            EventEmitter = require('events').EventEmitter,\n            WebsocketDriver = require('./driver/websocket');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:websocket');\n          }\n          function WebSocketTransport(transUrl, ignore, options) {\n            if (!WebSocketTransport.enabled()) {\n              throw new Error('Transport created when disabled');\n            }\n            EventEmitter.call(this);\n            debug('constructor', transUrl);\n            var self = this;\n            var url = urlUtils.addPath(transUrl, '/websocket');\n            if (url.slice(0, 5) === 'https') {\n              url = 'wss' + url.slice(5);\n            } else {\n              url = 'ws' + url.slice(4);\n            }\n            this.url = url;\n            this.ws = new WebsocketDriver(this.url, [], options);\n            this.ws.onmessage = function (e) {\n              debug('message event', e.data);\n              self.emit('message', e.data);\n            };\n            // Firefox has an interesting bug. If a websocket connection is\n            // created after onunload, it stays alive even when user\n            // navigates away from the page. In such situation let's lie -\n            // let's not open the ws connection at all. See:\n            // https://github.com/sockjs/sockjs-client/issues/28\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\n            this.unloadRef = utils.unloadAdd(function () {\n              debug('unload');\n              self.ws.close();\n            });\n            this.ws.onclose = function (e) {\n              debug('close event', e.code, e.reason);\n              self.emit('close', e.code, e.reason);\n              self._cleanup();\n            };\n            this.ws.onerror = function (e) {\n              debug('error event', e);\n              self.emit('close', 1006, 'WebSocket connection broken');\n              self._cleanup();\n            };\n          }\n          inherits(WebSocketTransport, EventEmitter);\n          WebSocketTransport.prototype.send = function (data) {\n            var msg = '[' + data + ']';\n            debug('send', msg);\n            this.ws.send(msg);\n          };\n          WebSocketTransport.prototype.close = function () {\n            debug('close');\n            var ws = this.ws;\n            this._cleanup();\n            if (ws) {\n              ws.close();\n            }\n          };\n          WebSocketTransport.prototype._cleanup = function () {\n            debug('_cleanup');\n            var ws = this.ws;\n            if (ws) {\n              ws.onmessage = ws.onclose = ws.onerror = null;\n            }\n            utils.unloadDel(this.unloadRef);\n            this.unloadRef = this.ws = null;\n            this.removeAllListeners();\n          };\n          WebSocketTransport.enabled = function () {\n            debug('enabled');\n            return !!WebsocketDriver;\n          };\n          WebSocketTransport.transportName = 'websocket';\n\n          // In theory, ws should require 1 round trip. But in chrome, this is\n          // not very stable over SSL. Most likely a ws connection requires a\n          // separate SSL connection, in which case 2 round trips are an\n          // absolute minumum.\n          WebSocketTransport.roundTrips = 2;\n          module.exports = WebSocketTransport;\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"../utils/event\": 46,\n      \"../utils/url\": 52,\n      \"./driver/websocket\": 19,\n      \"debug\": 55,\n      \"events\": 3,\n      \"inherits\": 57\n    }],\n    39: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        AjaxBasedTransport = require('./lib/ajax-based'),\n        XdrStreamingTransport = require('./xdr-streaming'),\n        XhrReceiver = require('./receiver/xhr'),\n        XDRObject = require('./sender/xdr');\n      function XdrPollingTransport(transUrl) {\n        if (!XDRObject.enabled) {\n          throw new Error('Transport created when disabled');\n        }\n        AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);\n      }\n      inherits(XdrPollingTransport, AjaxBasedTransport);\n      XdrPollingTransport.enabled = XdrStreamingTransport.enabled;\n      XdrPollingTransport.transportName = 'xdr-polling';\n      XdrPollingTransport.roundTrips = 2; // preflight, ajax\n\n      module.exports = XdrPollingTransport;\n    }, {\n      \"./lib/ajax-based\": 24,\n      \"./receiver/xhr\": 32,\n      \"./sender/xdr\": 34,\n      \"./xdr-streaming\": 40,\n      \"inherits\": 57\n    }],\n    40: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        AjaxBasedTransport = require('./lib/ajax-based'),\n        XhrReceiver = require('./receiver/xhr'),\n        XDRObject = require('./sender/xdr');\n\n      // According to:\n      //   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\n      //   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n\n      function XdrStreamingTransport(transUrl) {\n        if (!XDRObject.enabled) {\n          throw new Error('Transport created when disabled');\n        }\n        AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);\n      }\n      inherits(XdrStreamingTransport, AjaxBasedTransport);\n      XdrStreamingTransport.enabled = function (info) {\n        if (info.cookie_needed || info.nullOrigin) {\n          return false;\n        }\n        return XDRObject.enabled && info.sameScheme;\n      };\n      XdrStreamingTransport.transportName = 'xdr-streaming';\n      XdrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n      module.exports = XdrStreamingTransport;\n    }, {\n      \"./lib/ajax-based\": 24,\n      \"./receiver/xhr\": 32,\n      \"./sender/xdr\": 34,\n      \"inherits\": 57\n    }],\n    41: [function (require, module, exports) {\n      'use strict';\n\n      var inherits = require('inherits'),\n        AjaxBasedTransport = require('./lib/ajax-based'),\n        XhrReceiver = require('./receiver/xhr'),\n        XHRCorsObject = require('./sender/xhr-cors'),\n        XHRLocalObject = require('./sender/xhr-local');\n      function XhrPollingTransport(transUrl) {\n        if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\n          throw new Error('Transport created when disabled');\n        }\n        AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);\n      }\n      inherits(XhrPollingTransport, AjaxBasedTransport);\n      XhrPollingTransport.enabled = function (info) {\n        if (info.nullOrigin) {\n          return false;\n        }\n        if (XHRLocalObject.enabled && info.sameOrigin) {\n          return true;\n        }\n        return XHRCorsObject.enabled;\n      };\n      XhrPollingTransport.transportName = 'xhr-polling';\n      XhrPollingTransport.roundTrips = 2; // preflight, ajax\n\n      module.exports = XhrPollingTransport;\n    }, {\n      \"./lib/ajax-based\": 24,\n      \"./receiver/xhr\": 32,\n      \"./sender/xhr-cors\": 35,\n      \"./sender/xhr-local\": 37,\n      \"inherits\": 57\n    }],\n    42: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          var inherits = require('inherits'),\n            AjaxBasedTransport = require('./lib/ajax-based'),\n            XhrReceiver = require('./receiver/xhr'),\n            XHRCorsObject = require('./sender/xhr-cors'),\n            XHRLocalObject = require('./sender/xhr-local'),\n            browser = require('../utils/browser');\n          function XhrStreamingTransport(transUrl) {\n            if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\n              throw new Error('Transport created when disabled');\n            }\n            AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);\n          }\n          inherits(XhrStreamingTransport, AjaxBasedTransport);\n          XhrStreamingTransport.enabled = function (info) {\n            if (info.nullOrigin) {\n              return false;\n            }\n            // Opera doesn't support xhr-streaming #60\n            // But it might be able to #92\n            if (browser.isOpera()) {\n              return false;\n            }\n            return XHRCorsObject.enabled;\n          };\n          XhrStreamingTransport.transportName = 'xhr-streaming';\n          XhrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n          // Safari gets confused when a streaming ajax request is started\n          // before onload. This causes the load indicator to spin indefinetely.\n          // Only require body when used in a browser\n          XhrStreamingTransport.needBody = !!global.document;\n          module.exports = XhrStreamingTransport;\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../utils/browser\": 44,\n      \"./lib/ajax-based\": 24,\n      \"./receiver/xhr\": 32,\n      \"./sender/xhr-cors\": 35,\n      \"./sender/xhr-local\": 37,\n      \"inherits\": 57\n    }],\n    43: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          if (global.crypto && global.crypto.getRandomValues) {\n            module.exports.randomBytes = function (length) {\n              var bytes = new Uint8Array(length);\n              global.crypto.getRandomValues(bytes);\n              return bytes;\n            };\n          } else {\n            module.exports.randomBytes = function (length) {\n              var bytes = new Array(length);\n              for (var i = 0; i < length; i++) {\n                bytes[i] = Math.floor(Math.random() * 256);\n              }\n              return bytes;\n            };\n          }\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    44: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          module.exports = {\n            isOpera: function () {\n              return global.navigator && /opera/i.test(global.navigator.userAgent);\n            },\n            isKonqueror: function () {\n              return global.navigator && /konqueror/i.test(global.navigator.userAgent);\n            }\n\n            // #187 wrap document.domain in try/catch because of WP8 from file:///\n            ,\n            hasDomain: function () {\n              // non-browser client always has a domain\n              if (!global.document) {\n                return true;\n              }\n              try {\n                return !!global.document.domain;\n              } catch (e) {\n                return false;\n              }\n            }\n          };\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    45: [function (require, module, exports) {\n      'use strict';\n\n      // Some extra characters that Chrome gets wrong, and substitutes with\n      // something else on the wire.\n      // eslint-disable-next-line no-control-regex, no-misleading-character-class\n      var extraEscapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g,\n        extraLookup;\n\n      // This may be quite slow, so let's delay until user actually uses bad\n      // characters.\n      var unrollLookup = function (escapable) {\n        var i;\n        var unrolled = {};\n        var c = [];\n        for (i = 0; i < 65536; i++) {\n          c.push(String.fromCharCode(i));\n        }\n        escapable.lastIndex = 0;\n        c.join('').replace(escapable, function (a) {\n          unrolled[a] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n          return '';\n        });\n        escapable.lastIndex = 0;\n        return unrolled;\n      };\n\n      // Quote string, also taking care of unicode characters that browsers\n      // often break. Especially, take care of unicode surrogates:\n      // http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\n      module.exports = {\n        quote: function (string) {\n          var quoted = JSON.stringify(string);\n\n          // In most cases this should be very fast and good enough.\n          extraEscapable.lastIndex = 0;\n          if (!extraEscapable.test(quoted)) {\n            return quoted;\n          }\n          if (!extraLookup) {\n            extraLookup = unrollLookup(extraEscapable);\n          }\n          return quoted.replace(extraEscapable, function (a) {\n            return extraLookup[a];\n          });\n        }\n      };\n    }, {}],\n    46: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          var random = require('./random');\n          var onUnload = {},\n            afterUnload = false\n            // detect google chrome packaged apps because they don't allow the 'unload' event\n            ,\n            isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime;\n          module.exports = {\n            attachEvent: function (event, listener) {\n              if (typeof global.addEventListener !== 'undefined') {\n                global.addEventListener(event, listener, false);\n              } else if (global.document && global.attachEvent) {\n                // IE quirks.\n                // According to: http://stevesouders.com/misc/test-postmessage.php\n                // the message gets delivered only to 'document', not 'window'.\n                global.document.attachEvent('on' + event, listener);\n                // I get 'window' for ie8.\n                global.attachEvent('on' + event, listener);\n              }\n            },\n            detachEvent: function (event, listener) {\n              if (typeof global.addEventListener !== 'undefined') {\n                global.removeEventListener(event, listener, false);\n              } else if (global.document && global.detachEvent) {\n                global.document.detachEvent('on' + event, listener);\n                global.detachEvent('on' + event, listener);\n              }\n            },\n            unloadAdd: function (listener) {\n              if (isChromePackagedApp) {\n                return null;\n              }\n              var ref = random.string(8);\n              onUnload[ref] = listener;\n              if (afterUnload) {\n                setTimeout(this.triggerUnloadCallbacks, 0);\n              }\n              return ref;\n            },\n            unloadDel: function (ref) {\n              if (ref in onUnload) {\n                delete onUnload[ref];\n              }\n            },\n            triggerUnloadCallbacks: function () {\n              for (var ref in onUnload) {\n                onUnload[ref]();\n                delete onUnload[ref];\n              }\n            }\n          };\n          var unloadTriggered = function () {\n            if (afterUnload) {\n              return;\n            }\n            afterUnload = true;\n            module.exports.triggerUnloadCallbacks();\n          };\n\n          // 'unload' alone is not reliable in opera within an iframe, but we\n          // can't use `beforeunload` as IE fires it on javascript: links.\n          if (!isChromePackagedApp) {\n            module.exports.attachEvent('unload', unloadTriggered);\n          }\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./random\": 50\n    }],\n    47: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n\n          var eventUtils = require('./event'),\n            browser = require('./browser');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:utils:iframe');\n          }\n          module.exports = {\n            WPrefix: '_jp',\n            currentWindowId: null,\n            polluteGlobalNamespace: function () {\n              if (!(module.exports.WPrefix in global)) {\n                global[module.exports.WPrefix] = {};\n              }\n            },\n            postMessage: function (type, data) {\n              if (global.parent !== global) {\n                global.parent.postMessage(JSON.stringify({\n                  windowId: module.exports.currentWindowId,\n                  type: type,\n                  data: data || ''\n                }), '*');\n              } else {\n                debug('Cannot postMessage, no parent window.', type, data);\n              }\n            },\n            createIframe: function (iframeUrl, errorCallback) {\n              var iframe = global.document.createElement('iframe');\n              var tref, unloadRef;\n              var unattach = function () {\n                debug('unattach');\n                clearTimeout(tref);\n                // Explorer had problems with that.\n                try {\n                  iframe.onload = null;\n                } catch (x) {\n                  // intentionally empty\n                }\n                iframe.onerror = null;\n              };\n              var cleanup = function () {\n                debug('cleanup');\n                if (iframe) {\n                  unattach();\n                  // This timeout makes chrome fire onbeforeunload event\n                  // within iframe. Without the timeout it goes straight to\n                  // onunload.\n                  setTimeout(function () {\n                    if (iframe) {\n                      iframe.parentNode.removeChild(iframe);\n                    }\n                    iframe = null;\n                  }, 0);\n                  eventUtils.unloadDel(unloadRef);\n                }\n              };\n              var onerror = function (err) {\n                debug('onerror', err);\n                if (iframe) {\n                  cleanup();\n                  errorCallback(err);\n                }\n              };\n              var post = function (msg, origin) {\n                debug('post', msg, origin);\n                setTimeout(function () {\n                  try {\n                    // When the iframe is not loaded, IE raises an exception\n                    // on 'contentWindow'.\n                    if (iframe && iframe.contentWindow) {\n                      iframe.contentWindow.postMessage(msg, origin);\n                    }\n                  } catch (x) {\n                    // intentionally empty\n                  }\n                }, 0);\n              };\n              iframe.src = iframeUrl;\n              iframe.style.display = 'none';\n              iframe.style.position = 'absolute';\n              iframe.onerror = function () {\n                onerror('onerror');\n              };\n              iframe.onload = function () {\n                debug('onload');\n                // `onload` is triggered before scripts on the iframe are\n                // executed. Give it few seconds to actually load stuff.\n                clearTimeout(tref);\n                tref = setTimeout(function () {\n                  onerror('onload timeout');\n                }, 2000);\n              };\n              global.document.body.appendChild(iframe);\n              tref = setTimeout(function () {\n                onerror('timeout');\n              }, 15000);\n              unloadRef = eventUtils.unloadAdd(cleanup);\n              return {\n                post: post,\n                cleanup: cleanup,\n                loaded: unattach\n              };\n            }\n\n            /* eslint no-undef: \"off\", new-cap: \"off\" */,\n            createHtmlfile: function (iframeUrl, errorCallback) {\n              var axo = ['Active'].concat('Object').join('X');\n              var doc = new global[axo]('htmlfile');\n              var tref, unloadRef;\n              var iframe;\n              var unattach = function () {\n                clearTimeout(tref);\n                iframe.onerror = null;\n              };\n              var cleanup = function () {\n                if (doc) {\n                  unattach();\n                  eventUtils.unloadDel(unloadRef);\n                  iframe.parentNode.removeChild(iframe);\n                  iframe = doc = null;\n                  CollectGarbage();\n                }\n              };\n              var onerror = function (r) {\n                debug('onerror', r);\n                if (doc) {\n                  cleanup();\n                  errorCallback(r);\n                }\n              };\n              var post = function (msg, origin) {\n                try {\n                  // When the iframe is not loaded, IE raises an exception\n                  // on 'contentWindow'.\n                  setTimeout(function () {\n                    if (iframe && iframe.contentWindow) {\n                      iframe.contentWindow.postMessage(msg, origin);\n                    }\n                  }, 0);\n                } catch (x) {\n                  // intentionally empty\n                }\n              };\n              doc.open();\n              doc.write('<html><s' + 'cript>' + 'document.domain=\"' + global.document.domain + '\";' + '</s' + 'cript></html>');\n              doc.close();\n              doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];\n              var c = doc.createElement('div');\n              doc.body.appendChild(c);\n              iframe = doc.createElement('iframe');\n              c.appendChild(iframe);\n              iframe.src = iframeUrl;\n              iframe.onerror = function () {\n                onerror('onerror');\n              };\n              tref = setTimeout(function () {\n                onerror('timeout');\n              }, 15000);\n              unloadRef = eventUtils.unloadAdd(cleanup);\n              return {\n                post: post,\n                cleanup: cleanup,\n                loaded: unattach\n              };\n            }\n          };\n          module.exports.iframeEnabled = false;\n          if (global.document) {\n            // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\n            // huge delay, or not at all.\n            module.exports.iframeEnabled = (typeof global.postMessage === 'function' || typeof global.postMessage === 'object') && !browser.isKonqueror();\n          }\n        }).call(this);\n      }).call(this, {\n        env: {}\n      }, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./browser\": 44,\n      \"./event\": 46,\n      \"debug\": 55\n    }],\n    48: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          var logObject = {};\n          ['log', 'debug', 'warn'].forEach(function (level) {\n            var levelExists;\n            try {\n              levelExists = global.console && global.console[level] && global.console[level].apply;\n            } catch (e) {\n              // do nothing\n            }\n            logObject[level] = levelExists ? function () {\n              return global.console[level].apply(global.console, arguments);\n            } : level === 'log' ? function () {} : logObject.log;\n          });\n          module.exports = logObject;\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    49: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = {\n        isObject: function (obj) {\n          var type = typeof obj;\n          return type === 'function' || type === 'object' && !!obj;\n        },\n        extend: function (obj) {\n          if (!this.isObject(obj)) {\n            return obj;\n          }\n          var source, prop;\n          for (var i = 1, length = arguments.length; i < length; i++) {\n            source = arguments[i];\n            for (prop in source) {\n              if (Object.prototype.hasOwnProperty.call(source, prop)) {\n                obj[prop] = source[prop];\n              }\n            }\n          }\n          return obj;\n        }\n      };\n    }, {}],\n    50: [function (require, module, exports) {\n      'use strict';\n\n      var crypto = require('crypto');\n\n      // This string has length 32, a power of 2, so the modulus doesn't introduce a\n      // bias.\n      var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';\n      module.exports = {\n        string: function (length) {\n          var max = _randomStringChars.length;\n          var bytes = crypto.randomBytes(length);\n          var ret = [];\n          for (var i = 0; i < length; i++) {\n            ret.push(_randomStringChars.substr(bytes[i] % max, 1));\n          }\n          return ret.join('');\n        },\n        number: function (max) {\n          return Math.floor(Math.random() * max);\n        },\n        numberString: function (max) {\n          var t = ('' + (max - 1)).length;\n          var p = new Array(t + 1).join('0');\n          return (p + this.number(max)).slice(-t);\n        }\n      };\n    }, {\n      \"crypto\": 43\n    }],\n    51: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:utils:transport');\n          }\n          module.exports = function (availableTransports) {\n            return {\n              filterToEnabled: function (transportsWhitelist, info) {\n                var transports = {\n                  main: [],\n                  facade: []\n                };\n                if (!transportsWhitelist) {\n                  transportsWhitelist = [];\n                } else if (typeof transportsWhitelist === 'string') {\n                  transportsWhitelist = [transportsWhitelist];\n                }\n                availableTransports.forEach(function (trans) {\n                  if (!trans) {\n                    return;\n                  }\n                  if (trans.transportName === 'websocket' && info.websocket === false) {\n                    debug('disabled from server', 'websocket');\n                    return;\n                  }\n                  if (transportsWhitelist.length && transportsWhitelist.indexOf(trans.transportName) === -1) {\n                    debug('not in whitelist', trans.transportName);\n                    return;\n                  }\n                  if (trans.enabled(info)) {\n                    debug('enabled', trans.transportName);\n                    transports.main.push(trans);\n                    if (trans.facadeTransport) {\n                      transports.facade.push(trans.facadeTransport);\n                    }\n                  } else {\n                    debug('disabled', trans.transportName);\n                  }\n                });\n                return transports;\n              }\n            };\n          };\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"debug\": 55\n    }],\n    52: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var URL = require('url-parse');\n          var debug = function () {};\n          if (process.env.NODE_ENV !== 'production') {\n            debug = require('debug')('sockjs-client:utils:url');\n          }\n          module.exports = {\n            getOrigin: function (url) {\n              if (!url) {\n                return null;\n              }\n              var p = new URL(url);\n              if (p.protocol === 'file:') {\n                return null;\n              }\n              var port = p.port;\n              if (!port) {\n                port = p.protocol === 'https:' ? '443' : '80';\n              }\n              return p.protocol + '//' + p.hostname + ':' + port;\n            },\n            isOriginEqual: function (a, b) {\n              var res = this.getOrigin(a) === this.getOrigin(b);\n              debug('same', a, b, res);\n              return res;\n            },\n            isSchemeEqual: function (a, b) {\n              return a.split(':')[0] === b.split(':')[0];\n            },\n            addPath: function (url, path) {\n              var qs = url.split('?');\n              return qs[0] + path + (qs[1] ? '?' + qs[1] : '');\n            },\n            addQuery: function (url, q) {\n              return url + (url.indexOf('?') === -1 ? '?' + q : '&' + q);\n            },\n            isLoopbackAddr: function (addr) {\n              return /^127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^\\[::1\\]$/.test(addr);\n            }\n          };\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"debug\": 55,\n      \"url-parse\": 60\n    }],\n    53: [function (require, module, exports) {\n      module.exports = '1.6.1';\n    }, {}],\n    54: [function (require, module, exports) {\n      /**\n       * Helpers.\n       */\n\n      var s = 1000;\n      var m = s * 60;\n      var h = m * 60;\n      var d = h * 24;\n      var w = d * 7;\n      var y = d * 365.25;\n\n      /**\n       * Parse or format the given `val`.\n       *\n       * Options:\n       *\n       *  - `long` verbose formatting [false]\n       *\n       * @param {String|Number} val\n       * @param {Object} [options]\n       * @throws {Error} throw an error if val is not a non-empty string or a number\n       * @return {String|Number}\n       * @api public\n       */\n\n      module.exports = function (val, options) {\n        options = options || {};\n        var type = typeof val;\n        if (type === 'string' && val.length > 0) {\n          return parse(val);\n        } else if (type === 'number' && isFinite(val)) {\n          return options.long ? fmtLong(val) : fmtShort(val);\n        }\n        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n      };\n\n      /**\n       * Parse the given `str` and return milliseconds.\n       *\n       * @param {String} str\n       * @return {Number}\n       * @api private\n       */\n\n      function parse(str) {\n        str = String(str);\n        if (str.length > 100) {\n          return;\n        }\n        var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n        if (!match) {\n          return;\n        }\n        var n = parseFloat(match[1]);\n        var type = (match[2] || 'ms').toLowerCase();\n        switch (type) {\n          case 'years':\n          case 'year':\n          case 'yrs':\n          case 'yr':\n          case 'y':\n            return n * y;\n          case 'weeks':\n          case 'week':\n          case 'w':\n            return n * w;\n          case 'days':\n          case 'day':\n          case 'd':\n            return n * d;\n          case 'hours':\n          case 'hour':\n          case 'hrs':\n          case 'hr':\n          case 'h':\n            return n * h;\n          case 'minutes':\n          case 'minute':\n          case 'mins':\n          case 'min':\n          case 'm':\n            return n * m;\n          case 'seconds':\n          case 'second':\n          case 'secs':\n          case 'sec':\n          case 's':\n            return n * s;\n          case 'milliseconds':\n          case 'millisecond':\n          case 'msecs':\n          case 'msec':\n          case 'ms':\n            return n;\n          default:\n            return undefined;\n        }\n      }\n\n      /**\n       * Short format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n      function fmtShort(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n          return Math.round(ms / d) + 'd';\n        }\n        if (msAbs >= h) {\n          return Math.round(ms / h) + 'h';\n        }\n        if (msAbs >= m) {\n          return Math.round(ms / m) + 'm';\n        }\n        if (msAbs >= s) {\n          return Math.round(ms / s) + 's';\n        }\n        return ms + 'ms';\n      }\n\n      /**\n       * Long format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n      function fmtLong(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n          return plural(ms, msAbs, d, 'day');\n        }\n        if (msAbs >= h) {\n          return plural(ms, msAbs, h, 'hour');\n        }\n        if (msAbs >= m) {\n          return plural(ms, msAbs, m, 'minute');\n        }\n        if (msAbs >= s) {\n          return plural(ms, msAbs, s, 'second');\n        }\n        return ms + ' ms';\n      }\n\n      /**\n       * Pluralization helper.\n       */\n\n      function plural(ms, msAbs, n, name) {\n        var isPlural = msAbs >= n * 1.5;\n        return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n      }\n    }, {}],\n    55: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          /* eslint-env browser */\n\n          /**\n           * This is the web browser implementation of `debug()`.\n           */\n\n          exports.formatArgs = formatArgs;\n          exports.save = save;\n          exports.load = load;\n          exports.useColors = useColors;\n          exports.storage = localstorage();\n          exports.destroy = (() => {\n            let warned = false;\n            return () => {\n              if (!warned) {\n                warned = true;\n                console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n              }\n            };\n          })();\n\n          /**\n           * Colors.\n           */\n\n          exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n\n          /**\n           * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n           * and the Firebug extension (any Firefox version) are known\n           * to support \"%c\" CSS customizations.\n           *\n           * TODO: add a `localStorage` variable to explicitly enable/disable colors\n           */\n\n          // eslint-disable-next-line complexity\n          function useColors() {\n            // NB: In an Electron preload script, document will be defined but not fully\n            // initialized. Since we know we're in Chrome, we'll just detect this case\n            // explicitly\n            if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n              return true;\n            }\n\n            // Internet Explorer and Edge do not support colors.\n            if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n              return false;\n            }\n\n            // Is webkit? http://stackoverflow.com/a/16459606/376773\n            // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n            return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\n            // Is firebug? http://stackoverflow.com/a/398120/376773\n            typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\n            // Is firefox >= v31?\n            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n            typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n            // Double check webkit in userAgent just in case we are in a worker\n            typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n          }\n\n          /**\n           * Colorize log arguments if enabled.\n           *\n           * @api public\n           */\n\n          function formatArgs(args) {\n            args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n            if (!this.useColors) {\n              return;\n            }\n            const c = 'color: ' + this.color;\n            args.splice(1, 0, c, 'color: inherit');\n\n            // The final \"%c\" is somewhat tricky, because there could be other\n            // arguments passed either before or after the %c, so we need to\n            // figure out the correct index to insert the CSS into\n            let index = 0;\n            let lastC = 0;\n            args[0].replace(/%[a-zA-Z%]/g, match => {\n              if (match === '%%') {\n                return;\n              }\n              index++;\n              if (match === '%c') {\n                // We only are interested in the *last* %c\n                // (the user may have provided their own)\n                lastC = index;\n              }\n            });\n            args.splice(lastC, 0, c);\n          }\n\n          /**\n           * Invokes `console.debug()` when available.\n           * No-op when `console.debug` is not a \"function\".\n           * If `console.debug` is not available, falls back\n           * to `console.log`.\n           *\n           * @api public\n           */\n          exports.log = console.debug || console.log || (() => {});\n\n          /**\n           * Save `namespaces`.\n           *\n           * @param {String} namespaces\n           * @api private\n           */\n          function save(namespaces) {\n            try {\n              if (namespaces) {\n                exports.storage.setItem('debug', namespaces);\n              } else {\n                exports.storage.removeItem('debug');\n              }\n            } catch (error) {\n              // Swallow\n              // XXX (@Qix-) should we be logging these?\n            }\n          }\n\n          /**\n           * Load `namespaces`.\n           *\n           * @return {String} returns the previously persisted debug modes\n           * @api private\n           */\n          function load() {\n            let r;\n            try {\n              r = exports.storage.getItem('debug');\n            } catch (error) {\n              // Swallow\n              // XXX (@Qix-) should we be logging these?\n            }\n\n            // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n            if (!r && typeof process !== 'undefined' && 'env' in process) {\n              r = process.env.DEBUG;\n            }\n            return r;\n          }\n\n          /**\n           * Localstorage attempts to return the localstorage.\n           *\n           * This is necessary because safari throws\n           * when a user disables cookies/localstorage\n           * and you attempt to access it.\n           *\n           * @return {LocalStorage}\n           * @api private\n           */\n\n          function localstorage() {\n            try {\n              // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n              // The Browser also has localStorage in the global context.\n              return localStorage;\n            } catch (error) {\n              // Swallow\n              // XXX (@Qix-) should we be logging these?\n            }\n          }\n          module.exports = require('./common')(exports);\n          const {\n            formatters\n          } = module.exports;\n\n          /**\n           * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n           */\n\n          formatters.j = function (v) {\n            try {\n              return JSON.stringify(v);\n            } catch (error) {\n              return '[UnexpectedJSONParseError]: ' + error.message;\n            }\n          };\n        }).call(this);\n      }).call(this, {\n        env: {}\n      });\n    }, {\n      \"./common\": 56\n    }],\n    56: [function (require, module, exports) {\n      /**\n       * This is the common logic for both the Node.js and web browser\n       * implementations of `debug()`.\n       */\n\n      function setup(env) {\n        createDebug.debug = createDebug;\n        createDebug.default = createDebug;\n        createDebug.coerce = coerce;\n        createDebug.disable = disable;\n        createDebug.enable = enable;\n        createDebug.enabled = enabled;\n        createDebug.humanize = require('ms');\n        createDebug.destroy = destroy;\n        Object.keys(env).forEach(key => {\n          createDebug[key] = env[key];\n        });\n\n        /**\n        * The currently active debug mode names, and names to skip.\n        */\n\n        createDebug.names = [];\n        createDebug.skips = [];\n\n        /**\n        * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n        *\n        * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n        */\n        createDebug.formatters = {};\n\n        /**\n        * Selects a color for a debug namespace\n        * @param {String} namespace The namespace string for the debug instance to be colored\n        * @return {Number|String} An ANSI color code for the given namespace\n        * @api private\n        */\n        function selectColor(namespace) {\n          let hash = 0;\n          for (let i = 0; i < namespace.length; i++) {\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n          }\n\n          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n        }\n        createDebug.selectColor = selectColor;\n\n        /**\n        * Create a debugger with the given `namespace`.\n        *\n        * @param {String} namespace\n        * @return {Function}\n        * @api public\n        */\n        function createDebug(namespace) {\n          let prevTime;\n          let enableOverride = null;\n          let namespacesCache;\n          let enabledCache;\n          function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n              return;\n            }\n            const self = debug;\n\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== 'string') {\n              // Anything else let's inspect with %O\n              args.unshift('%O');\n            }\n\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n              // If we encounter an escaped % then don't increase the array index\n              if (match === '%%') {\n                return '%';\n              }\n              index++;\n              const formatter = createDebug.formatters[format];\n              if (typeof formatter === 'function') {\n                const val = args[index];\n                match = formatter.call(self, val);\n\n                // Now we need to remove `args[index]` since it's inlined in the `format`\n                args.splice(index, 1);\n                index--;\n              }\n              return match;\n            });\n\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n          }\n          debug.namespace = namespace;\n          debug.useColors = createDebug.useColors();\n          debug.color = createDebug.selectColor(namespace);\n          debug.extend = extend;\n          debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n          Object.defineProperty(debug, 'enabled', {\n            enumerable: true,\n            configurable: false,\n            get: () => {\n              if (enableOverride !== null) {\n                return enableOverride;\n              }\n              if (namespacesCache !== createDebug.namespaces) {\n                namespacesCache = createDebug.namespaces;\n                enabledCache = createDebug.enabled(namespace);\n              }\n              return enabledCache;\n            },\n            set: v => {\n              enableOverride = v;\n            }\n          });\n\n          // Env-specific initialization logic for debug instances\n          if (typeof createDebug.init === 'function') {\n            createDebug.init(debug);\n          }\n          return debug;\n        }\n        function extend(namespace, delimiter) {\n          const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n          newDebug.log = this.log;\n          return newDebug;\n        }\n\n        /**\n        * Enables a debug mode by namespaces. This can include modes\n        * separated by a colon and wildcards.\n        *\n        * @param {String} namespaces\n        * @api public\n        */\n        function enable(namespaces) {\n          createDebug.save(namespaces);\n          createDebug.namespaces = namespaces;\n          createDebug.names = [];\n          createDebug.skips = [];\n          let i;\n          const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n          const len = split.length;\n          for (i = 0; i < len; i++) {\n            if (!split[i]) {\n              // ignore empty strings\n              continue;\n            }\n            namespaces = split[i].replace(/\\*/g, '.*?');\n            if (namespaces[0] === '-') {\n              createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n            } else {\n              createDebug.names.push(new RegExp('^' + namespaces + '$'));\n            }\n          }\n        }\n\n        /**\n        * Disable debug output.\n        *\n        * @return {String} namespaces\n        * @api public\n        */\n        function disable() {\n          const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');\n          createDebug.enable('');\n          return namespaces;\n        }\n\n        /**\n        * Returns true if the given mode name is enabled, false otherwise.\n        *\n        * @param {String} name\n        * @return {Boolean}\n        * @api public\n        */\n        function enabled(name) {\n          if (name[name.length - 1] === '*') {\n            return true;\n          }\n          let i;\n          let len;\n          for (i = 0, len = createDebug.skips.length; i < len; i++) {\n            if (createDebug.skips[i].test(name)) {\n              return false;\n            }\n          }\n          for (i = 0, len = createDebug.names.length; i < len; i++) {\n            if (createDebug.names[i].test(name)) {\n              return true;\n            }\n          }\n          return false;\n        }\n\n        /**\n        * Convert regexp to namespace\n        *\n        * @param {RegExp} regxep\n        * @return {String} namespace\n        * @api private\n        */\n        function toNamespace(regexp) {\n          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n        }\n\n        /**\n        * Coerce `val`.\n        *\n        * @param {Mixed} val\n        * @return {Mixed}\n        * @api private\n        */\n        function coerce(val) {\n          if (val instanceof Error) {\n            return val.stack || val.message;\n          }\n          return val;\n        }\n\n        /**\n        * XXX DO NOT USE. This is a temporary stub function.\n        * XXX It WILL be removed in the next major release.\n        */\n        function destroy() {\n          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n        }\n        createDebug.enable(createDebug.load());\n        return createDebug;\n      }\n      module.exports = setup;\n    }, {\n      \"ms\": 54\n    }],\n    57: [function (require, module, exports) {\n      if (typeof Object.create === 'function') {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n          if (superCtor) {\n            ctor.super_ = superCtor;\n            ctor.prototype = Object.create(superCtor.prototype, {\n              constructor: {\n                value: ctor,\n                enumerable: false,\n                writable: true,\n                configurable: true\n              }\n            });\n          }\n        };\n      } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n          if (superCtor) {\n            ctor.super_ = superCtor;\n            var TempCtor = function () {};\n            TempCtor.prototype = superCtor.prototype;\n            ctor.prototype = new TempCtor();\n            ctor.prototype.constructor = ctor;\n          }\n        };\n      }\n    }, {}],\n    58: [function (require, module, exports) {\n      'use strict';\n\n      var has = Object.prototype.hasOwnProperty,\n        undef;\n\n      /**\n       * Decode a URI encoded string.\n       *\n       * @param {String} input The URI encoded string.\n       * @returns {String|Null} The decoded string.\n       * @api private\n       */\n      function decode(input) {\n        try {\n          return decodeURIComponent(input.replace(/\\+/g, ' '));\n        } catch (e) {\n          return null;\n        }\n      }\n\n      /**\n       * Attempts to encode a given input.\n       *\n       * @param {String} input The string that needs to be encoded.\n       * @returns {String|Null} The encoded string.\n       * @api private\n       */\n      function encode(input) {\n        try {\n          return encodeURIComponent(input);\n        } catch (e) {\n          return null;\n        }\n      }\n\n      /**\n       * Simple query string parser.\n       *\n       * @param {String} query The query string that needs to be parsed.\n       * @returns {Object}\n       * @api public\n       */\n      function querystring(query) {\n        var parser = /([^=?&]+)=?([^&]*)/g,\n          result = {},\n          part;\n        while (part = parser.exec(query)) {\n          var key = decode(part[1]),\n            value = decode(part[2]);\n\n          //\n          // Prevent overriding of existing properties. This ensures that build-in\n          // methods like `toString` or __proto__ are not overriden by malicious\n          // querystrings.\n          //\n          // In the case if failed decoding, we want to omit the key/value pairs\n          // from the result.\n          //\n          if (key === null || value === null || key in result) continue;\n          result[key] = value;\n        }\n        return result;\n      }\n\n      /**\n       * Transform a query string to an object.\n       *\n       * @param {Object} obj Object that should be transformed.\n       * @param {String} prefix Optional prefix.\n       * @returns {String}\n       * @api public\n       */\n      function querystringify(obj, prefix) {\n        prefix = prefix || '';\n        var pairs = [],\n          value,\n          key;\n\n        //\n        // Optionally prefix with a '?' if needed\n        //\n        if ('string' !== typeof prefix) prefix = '?';\n        for (key in obj) {\n          if (has.call(obj, key)) {\n            value = obj[key];\n\n            //\n            // Edge cases where we actually want to encode the value to an empty\n            // string instead of the stringified value.\n            //\n            if (!value && (value === null || value === undef || isNaN(value))) {\n              value = '';\n            }\n            key = encodeURIComponent(key);\n            value = encodeURIComponent(value);\n\n            //\n            // If we failed to encode the strings, we should bail out as we don't\n            // want to add invalid strings to the query.\n            //\n            if (key === null || value === null) continue;\n            pairs.push(key + '=' + value);\n          }\n        }\n        return pairs.length ? prefix + pairs.join('&') : '';\n      }\n\n      //\n      // Expose the module.\n      //\n      exports.stringify = querystringify;\n      exports.parse = querystring;\n    }, {}],\n    59: [function (require, module, exports) {\n      'use strict';\n\n      /**\n       * Check if we're required to add a port number.\n       *\n       * @see https://url.spec.whatwg.org/#default-port\n       * @param {Number|String} port Port number we need to check\n       * @param {String} protocol Protocol we need to check against.\n       * @returns {Boolean} Is it a default port for the given protocol\n       * @api private\n       */\n      module.exports = function required(port, protocol) {\n        protocol = protocol.split(':')[0];\n        port = +port;\n        if (!port) return false;\n        switch (protocol) {\n          case 'http':\n          case 'ws':\n            return port !== 80;\n          case 'https':\n          case 'wss':\n            return port !== 443;\n          case 'ftp':\n            return port !== 21;\n          case 'gopher':\n            return port !== 70;\n          case 'file':\n            return false;\n        }\n        return port !== 0;\n      };\n    }, {}],\n    60: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          var required = require('requires-port'),\n            qs = require('querystringify'),\n            controlOrWhitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/,\n            CRHTLF = /[\\n\\r\\t]/g,\n            slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//,\n            port = /:\\d+$/,\n            protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i,\n            windowsDriveLetter = /^[a-zA-Z]:/;\n\n          /**\n           * Remove control characters and whitespace from the beginning of a string.\n           *\n           * @param {Object|String} str String to trim.\n           * @returns {String} A new string representing `str` stripped of control\n           *     characters and whitespace from its beginning.\n           * @public\n           */\n          function trimLeft(str) {\n            return (str ? str : '').toString().replace(controlOrWhitespace, '');\n          }\n\n          /**\n           * These are the parse rules for the URL parser, it informs the parser\n           * about:\n           *\n           * 0. The char it Needs to parse, if it's a string it should be done using\n           *    indexOf, RegExp using exec and NaN means set as current value.\n           * 1. The property we should set when parsing this value.\n           * 2. Indication if it's backwards or forward parsing, when set as number it's\n           *    the value of extra chars that should be split off.\n           * 3. Inherit from location if non existing in the parser.\n           * 4. `toLowerCase` the resulting value.\n           */\n          var rules = [['#', 'hash'],\n          // Extract from the back.\n          ['?', 'query'],\n          // Extract from the back.\n          function sanitize(address, url) {\n            // Sanitize what is left of the address\n            return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n          }, ['/', 'pathname'],\n          // Extract from the back.\n          ['@', 'auth', 1],\n          // Extract from the front.\n          [NaN, 'host', undefined, 1, 1],\n          // Set left over value.\n          [/:(\\d*)$/, 'port', undefined, 1],\n          // RegExp the back.\n          [NaN, 'hostname', undefined, 1, 1] // Set left over.\n          ];\n\n          /**\n           * These properties should not be copied or inherited from. This is only needed\n           * for all non blob URL's as a blob URL does not include a hash, only the\n           * origin.\n           *\n           * @type {Object}\n           * @private\n           */\n          var ignore = {\n            hash: 1,\n            query: 1\n          };\n\n          /**\n           * The location object differs when your code is loaded through a normal page,\n           * Worker or through a worker using a blob. And with the blobble begins the\n           * trouble as the location object will contain the URL of the blob, not the\n           * location of the page where our code is loaded in. The actual origin is\n           * encoded in the `pathname` so we can thankfully generate a good \"default\"\n           * location from it so we can generate proper relative URL's again.\n           *\n           * @param {Object|String} loc Optional default location object.\n           * @returns {Object} lolcation object.\n           * @public\n           */\n          function lolcation(loc) {\n            var globalVar;\n            if (typeof window !== 'undefined') globalVar = window;else if (typeof global !== 'undefined') globalVar = global;else if (typeof self !== 'undefined') globalVar = self;else globalVar = {};\n            var location = globalVar.location || {};\n            loc = loc || location;\n            var finaldestination = {},\n              type = typeof loc,\n              key;\n            if ('blob:' === loc.protocol) {\n              finaldestination = new Url(unescape(loc.pathname), {});\n            } else if ('string' === type) {\n              finaldestination = new Url(loc, {});\n              for (key in ignore) delete finaldestination[key];\n            } else if ('object' === type) {\n              for (key in loc) {\n                if (key in ignore) continue;\n                finaldestination[key] = loc[key];\n              }\n              if (finaldestination.slashes === undefined) {\n                finaldestination.slashes = slashes.test(loc.href);\n              }\n            }\n            return finaldestination;\n          }\n\n          /**\n           * Check whether a protocol scheme is special.\n           *\n           * @param {String} The protocol scheme of the URL\n           * @return {Boolean} `true` if the protocol scheme is special, else `false`\n           * @private\n           */\n          function isSpecial(scheme) {\n            return scheme === 'file:' || scheme === 'ftp:' || scheme === 'http:' || scheme === 'https:' || scheme === 'ws:' || scheme === 'wss:';\n          }\n\n          /**\n           * @typedef ProtocolExtract\n           * @type Object\n           * @property {String} protocol Protocol matched in the URL, in lowercase.\n           * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n           * @property {String} rest Rest of the URL that is not part of the protocol.\n           */\n\n          /**\n           * Extract protocol information from a URL with/without double slash (\"//\").\n           *\n           * @param {String} address URL we want to extract from.\n           * @param {Object} location\n           * @return {ProtocolExtract} Extracted information.\n           * @private\n           */\n          function extractProtocol(address, location) {\n            address = trimLeft(address);\n            address = address.replace(CRHTLF, '');\n            location = location || {};\n            var match = protocolre.exec(address);\n            var protocol = match[1] ? match[1].toLowerCase() : '';\n            var forwardSlashes = !!match[2];\n            var otherSlashes = !!match[3];\n            var slashesCount = 0;\n            var rest;\n            if (forwardSlashes) {\n              if (otherSlashes) {\n                rest = match[2] + match[3] + match[4];\n                slashesCount = match[2].length + match[3].length;\n              } else {\n                rest = match[2] + match[4];\n                slashesCount = match[2].length;\n              }\n            } else {\n              if (otherSlashes) {\n                rest = match[3] + match[4];\n                slashesCount = match[3].length;\n              } else {\n                rest = match[4];\n              }\n            }\n            if (protocol === 'file:') {\n              if (slashesCount >= 2) {\n                rest = rest.slice(2);\n              }\n            } else if (isSpecial(protocol)) {\n              rest = match[4];\n            } else if (protocol) {\n              if (forwardSlashes) {\n                rest = rest.slice(2);\n              }\n            } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n              rest = match[4];\n            }\n            return {\n              protocol: protocol,\n              slashes: forwardSlashes || isSpecial(protocol),\n              slashesCount: slashesCount,\n              rest: rest\n            };\n          }\n\n          /**\n           * Resolve a relative URL pathname against a base URL pathname.\n           *\n           * @param {String} relative Pathname of the relative URL.\n           * @param {String} base Pathname of the base URL.\n           * @return {String} Resolved pathname.\n           * @private\n           */\n          function resolve(relative, base) {\n            if (relative === '') return base;\n            var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),\n              i = path.length,\n              last = path[i - 1],\n              unshift = false,\n              up = 0;\n            while (i--) {\n              if (path[i] === '.') {\n                path.splice(i, 1);\n              } else if (path[i] === '..') {\n                path.splice(i, 1);\n                up++;\n              } else if (up) {\n                if (i === 0) unshift = true;\n                path.splice(i, 1);\n                up--;\n              }\n            }\n            if (unshift) path.unshift('');\n            if (last === '.' || last === '..') path.push('');\n            return path.join('/');\n          }\n\n          /**\n           * The actual URL instance. Instead of returning an object we've opted-in to\n           * create an actual constructor as it's much more memory efficient and\n           * faster and it pleases my OCD.\n           *\n           * It is worth noting that we should not use `URL` as class name to prevent\n           * clashes with the global URL instance that got introduced in browsers.\n           *\n           * @constructor\n           * @param {String} address URL we want to parse.\n           * @param {Object|String} [location] Location defaults for relative paths.\n           * @param {Boolean|Function} [parser] Parser for the query string.\n           * @private\n           */\n          function Url(address, location, parser) {\n            address = trimLeft(address);\n            address = address.replace(CRHTLF, '');\n            if (!(this instanceof Url)) {\n              return new Url(address, location, parser);\n            }\n            var relative,\n              extracted,\n              parse,\n              instruction,\n              index,\n              key,\n              instructions = rules.slice(),\n              type = typeof location,\n              url = this,\n              i = 0;\n\n            //\n            // The following if statements allows this module two have compatibility with\n            // 2 different API:\n            //\n            // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n            //    where the boolean indicates that the query string should also be parsed.\n            //\n            // 2. The `URL` interface of the browser which accepts a URL, object as\n            //    arguments. The supplied object will be used as default values / fall-back\n            //    for relative paths.\n            //\n            if ('object' !== type && 'string' !== type) {\n              parser = location;\n              location = null;\n            }\n            if (parser && 'function' !== typeof parser) parser = qs.parse;\n            location = lolcation(location);\n\n            //\n            // Extract protocol information before running the instructions.\n            //\n            extracted = extractProtocol(address || '', location);\n            relative = !extracted.protocol && !extracted.slashes;\n            url.slashes = extracted.slashes || relative && location.slashes;\n            url.protocol = extracted.protocol || location.protocol || '';\n            address = extracted.rest;\n\n            //\n            // When the authority component is absent the URL starts with a path\n            // component.\n            //\n            if (extracted.protocol === 'file:' && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {\n              instructions[3] = [/(.*)/, 'pathname'];\n            }\n            for (; i < instructions.length; i++) {\n              instruction = instructions[i];\n              if (typeof instruction === 'function') {\n                address = instruction(address, url);\n                continue;\n              }\n              parse = instruction[0];\n              key = instruction[1];\n              if (parse !== parse) {\n                url[key] = address;\n              } else if ('string' === typeof parse) {\n                index = parse === '@' ? address.lastIndexOf(parse) : address.indexOf(parse);\n                if (~index) {\n                  if ('number' === typeof instruction[2]) {\n                    url[key] = address.slice(0, index);\n                    address = address.slice(index + instruction[2]);\n                  } else {\n                    url[key] = address.slice(index);\n                    address = address.slice(0, index);\n                  }\n                }\n              } else if (index = parse.exec(address)) {\n                url[key] = index[1];\n                address = address.slice(0, index.index);\n              }\n              url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : '');\n\n              //\n              // Hostname, host and protocol should be lowercased so they can be used to\n              // create a proper `origin`.\n              //\n              if (instruction[4]) url[key] = url[key].toLowerCase();\n            }\n\n            //\n            // Also parse the supplied query string in to an object. If we're supplied\n            // with a custom parser as function use that instead of the default build-in\n            // parser.\n            //\n            if (parser) url.query = parser(url.query);\n\n            //\n            // If the URL is relative, resolve the pathname against the base URL.\n            //\n            if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {\n              url.pathname = resolve(url.pathname, location.pathname);\n            }\n\n            //\n            // Default to a / for pathname if none exists. This normalizes the URL\n            // to always have a /\n            //\n            if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n              url.pathname = '/' + url.pathname;\n            }\n\n            //\n            // We should not add port numbers if they are already the default port number\n            // for a given protocol. As the host also contains the port number we're going\n            // override it with the hostname which contains no port number.\n            //\n            if (!required(url.port, url.protocol)) {\n              url.host = url.hostname;\n              url.port = '';\n            }\n\n            //\n            // Parse down the `auth` for the username and password.\n            //\n            url.username = url.password = '';\n            if (url.auth) {\n              index = url.auth.indexOf(':');\n              if (~index) {\n                url.username = url.auth.slice(0, index);\n                url.username = encodeURIComponent(decodeURIComponent(url.username));\n                url.password = url.auth.slice(index + 1);\n                url.password = encodeURIComponent(decodeURIComponent(url.password));\n              } else {\n                url.username = encodeURIComponent(decodeURIComponent(url.auth));\n              }\n              url.auth = url.password ? url.username + ':' + url.password : url.username;\n            }\n            url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null';\n\n            //\n            // The href is just the compiled result.\n            //\n            url.href = url.toString();\n          }\n\n          /**\n           * This is convenience method for changing properties in the URL instance to\n           * insure that they all propagate correctly.\n           *\n           * @param {String} part          Property we need to adjust.\n           * @param {Mixed} value          The newly assigned value.\n           * @param {Boolean|Function} fn  When setting the query, it will be the function\n           *                               used to parse the query.\n           *                               When setting the protocol, double slash will be\n           *                               removed from the final url if it is true.\n           * @returns {URL} URL instance for chaining.\n           * @public\n           */\n          function set(part, value, fn) {\n            var url = this;\n            switch (part) {\n              case 'query':\n                if ('string' === typeof value && value.length) {\n                  value = (fn || qs.parse)(value);\n                }\n                url[part] = value;\n                break;\n              case 'port':\n                url[part] = value;\n                if (!required(value, url.protocol)) {\n                  url.host = url.hostname;\n                  url[part] = '';\n                } else if (value) {\n                  url.host = url.hostname + ':' + value;\n                }\n                break;\n              case 'hostname':\n                url[part] = value;\n                if (url.port) value += ':' + url.port;\n                url.host = value;\n                break;\n              case 'host':\n                url[part] = value;\n                if (port.test(value)) {\n                  value = value.split(':');\n                  url.port = value.pop();\n                  url.hostname = value.join(':');\n                } else {\n                  url.hostname = value;\n                  url.port = '';\n                }\n                break;\n              case 'protocol':\n                url.protocol = value.toLowerCase();\n                url.slashes = !fn;\n                break;\n              case 'pathname':\n              case 'hash':\n                if (value) {\n                  var char = part === 'pathname' ? '/' : '#';\n                  url[part] = value.charAt(0) !== char ? char + value : value;\n                } else {\n                  url[part] = value;\n                }\n                break;\n              case 'username':\n              case 'password':\n                url[part] = encodeURIComponent(value);\n                break;\n              case 'auth':\n                var index = value.indexOf(':');\n                if (~index) {\n                  url.username = value.slice(0, index);\n                  url.username = encodeURIComponent(decodeURIComponent(url.username));\n                  url.password = value.slice(index + 1);\n                  url.password = encodeURIComponent(decodeURIComponent(url.password));\n                } else {\n                  url.username = encodeURIComponent(decodeURIComponent(value));\n                }\n            }\n            for (var i = 0; i < rules.length; i++) {\n              var ins = rules[i];\n              if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n            }\n            url.auth = url.password ? url.username + ':' + url.password : url.username;\n            url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null';\n            url.href = url.toString();\n            return url;\n          }\n\n          /**\n           * Transform the properties back in to a valid and full URL string.\n           *\n           * @param {Function} stringify Optional query stringify function.\n           * @returns {String} Compiled version of the URL.\n           * @public\n           */\n          function toString(stringify) {\n            if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n            var query,\n              url = this,\n              host = url.host,\n              protocol = url.protocol;\n            if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n            var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? '//' : '');\n            if (url.username) {\n              result += url.username;\n              if (url.password) result += ':' + url.password;\n              result += '@';\n            } else if (url.password) {\n              result += ':' + url.password;\n              result += '@';\n            } else if (url.protocol !== 'file:' && isSpecial(url.protocol) && !host && url.pathname !== '/') {\n              //\n              // Add back the empty userinfo, otherwise the original invalid URL\n              // might be transformed into a valid one with `url.pathname` as host.\n              //\n              result += '@';\n            }\n\n            //\n            // Trailing colon is removed from `url.host` when it is parsed. If it still\n            // ends with a colon, then add back the trailing colon that was removed. This\n            // prevents an invalid URL from being transformed into a valid one.\n            //\n            if (host[host.length - 1] === ':' || port.test(url.hostname) && !url.port) {\n              host += ':';\n            }\n            result += host + url.pathname;\n            query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n            if (query) result += '?' !== query.charAt(0) ? '?' + query : query;\n            if (url.hash) result += url.hash;\n            return result;\n          }\n          Url.prototype = {\n            set: set,\n            toString: toString\n          };\n\n          //\n          // Expose the URL parser and some additional properties that might be useful for\n          // others or testing.\n          //\n          Url.extractProtocol = extractProtocol;\n          Url.location = lolcation;\n          Url.trimLeft = trimLeft;\n          Url.qs = qs;\n          module.exports = Url;\n        }).call(this);\n      }).call(this, typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"querystringify\": 58,\n      \"requires-port\": 59\n    }]\n  }, {}, [1])(1);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcz9lOGU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIHNvY2tqcy1jbGllbnQgdjEuNi4xIHwgaHR0cDovL3NvY2tqcy5vcmcgfCBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uIChmKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGYpO1xuICB9IGVsc2Uge1xuICAgIHZhciBnO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBnID0gd2luZG93O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZyA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBnID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgZyA9IHRoaXM7XG4gICAgfVxuICAgIGcuU29ja0pTID0gZigpO1xuICB9XG59KShmdW5jdGlvbiAoKSB7XG4gIHZhciBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0cztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiByKGUsIG4sIHQpIHtcbiAgICAgIGZ1bmN0aW9uIG8oaSwgZikge1xuICAgICAgICBpZiAoIW5baV0pIHtcbiAgICAgICAgICBpZiAoIWVbaV0pIHtcbiAgICAgICAgICAgIHZhciBjID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiByZXF1aXJlICYmIHJlcXVpcmU7XG4gICAgICAgICAgICBpZiAoIWYgJiYgYykgcmV0dXJuIGMoaSwgITApO1xuICAgICAgICAgICAgaWYgKHUpIHJldHVybiB1KGksICEwKTtcbiAgICAgICAgICAgIHZhciBhID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIGkgKyBcIidcIik7XG4gICAgICAgICAgICB0aHJvdyBhLmNvZGUgPSBcIk1PRFVMRV9OT1RfRk9VTkRcIiwgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHAgPSBuW2ldID0ge1xuICAgICAgICAgICAgZXhwb3J0czoge31cbiAgICAgICAgICB9O1xuICAgICAgICAgIGVbaV1bMF0uY2FsbChwLmV4cG9ydHMsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGVbaV1bMV1bcl07XG4gICAgICAgICAgICByZXR1cm4gbyhuIHx8IHIpO1xuICAgICAgICAgIH0sIHAsIHAuZXhwb3J0cywgciwgZSwgbiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5baV0uZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHJlcXVpcmUgJiYgcmVxdWlyZSwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSBvKHRbaV0pO1xuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9KCkoe1xuICAgIDE6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJykodHJhbnNwb3J0TGlzdCk7XG5cbiAgICAgICAgICAvLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuICAgICAgICAgIGlmICgnX3NvY2tqc19vbmxvYWQnIGluIGdsb2JhbCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG4gICAgfSwge1xuICAgICAgXCIuL21haW5cIjogMTQsXG4gICAgICBcIi4vdHJhbnNwb3J0LWxpc3RcIjogMTZcbiAgICB9XSxcbiAgICAyOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgICAgICBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcbiAgICAgIGZ1bmN0aW9uIENsb3NlRXZlbnQoKSB7XG4gICAgICAgIEV2ZW50LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdEV2ZW50KCdjbG9zZScsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMud2FzQ2xlYW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2RlID0gMDtcbiAgICAgICAgdGhpcy5yZWFzb24gPSAnJztcbiAgICAgIH1cbiAgICAgIGluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcbiAgICB9LCB7XG4gICAgICBcIi4vZXZlbnRcIjogNCxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAzOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgICAgICBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnR0YXJnZXQnKTtcbiAgICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICAgICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIGZpcmVkID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICAgICAgICBpZiAoIWZpcmVkKSB7XG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKHR5cGUsIGcpO1xuICAgICAgfTtcbiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG4gICAgICAgIGZvciAodmFyIGFpID0gMTsgYWkgPCBsOyBhaSsrKSB7XG4gICAgICAgICAgYXJnc1thaSAtIDFdID0gYXJndW1lbnRzW2FpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgICBtb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgfSwge1xuICAgICAgXCIuL2V2ZW50dGFyZ2V0XCI6IDUsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgNDogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgZnVuY3Rpb24gRXZlbnQoZXZlbnRUeXBlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgICAgIH1cbiAgICAgIEV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xuICAgICAgICB0aGlzLmJ1YmJsZXMgPSBjYW5CdWJibGU7XG4gICAgICAgIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gICAgICAgIHRoaXMudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIEV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIEV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbiAgICAgIEV2ZW50LkFUX1RBUkdFVCA9IDI7XG4gICAgICBFdmVudC5CVUJCTElOR19QSEFTRSA9IDM7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuICAgIH0sIHt9XSxcbiAgICA1OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAvKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gICAgICAgKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgfVxuICAgICAgRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgICAgICAvLyAjNFxuICAgICAgICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgICAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgICAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xuICAgICAgfTtcbiAgICAgIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgICAgICBpZiAoIWFycikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gYXJyLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnIuc2xpY2UoMCwgaWR4KS5jb25jYXQoYXJyLnNsaWNlKGlkeCArIDEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBFdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgdCA9IGV2ZW50LnR5cGU7XG4gICAgICAgIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgZG9lc24ndCBtYXRjaCB0aGUgcmVhbCBiZWhhdmlvcjsgcGVyIHNwZWMsIG9uZm9vIGdldFxuICAgICAgICAvLyB0aGVpciBwbGFjZSBpbiBsaW5lIGZyb20gdGhlIC9maXJzdC8gdGltZSB0aGV5J3JlIHNldCBmcm9tXG4gICAgICAgIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcbiAgICAgICAgLy8gc2V0LlxuICAgICAgICBpZiAodGhpc1snb24nICsgdF0pIHtcbiAgICAgICAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXG4gICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0XTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG4gICAgfSwge31dLFxuICAgIDY6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpO1xuICAgICAgZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgfVxuICAgICAgaW5oZXJpdHMoVHJhbnNwb3J0TWVzc2FnZUV2ZW50LCBFdmVudCk7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydE1lc3NhZ2VFdmVudDtcbiAgICB9LCB7XG4gICAgICBcIi4vZXZlbnRcIjogNCxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICA3OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpO1xuICAgICAgZnVuY3Rpb24gRmFjYWRlSlModHJhbnNwb3J0KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgICAgRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ2MnLCBKU09OLnN0cmluZ2lmeShbY29kZSwgcmVhc29uXSkpO1xuICAgICAgfTtcbiAgICAgIEZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgndCcsIGZyYW1lKTtcbiAgICAgIH07XG4gICAgICBGYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQuc2VuZChkYXRhKTtcbiAgICAgIH07XG4gICAgICBGYWNhZGVKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfTtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gRmFjYWRlSlM7XG4gICAgfSwge1xuICAgICAgXCIuL3V0aWxzL2lmcmFtZVwiOiA0N1xuICAgIH1dLFxuICAgIDg6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICB2YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpLFxuICAgICAgICAgICAgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKSxcbiAgICAgICAgICAgIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKSxcbiAgICAgICAgICAgIEluZm9JZnJhbWVSZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKSxcbiAgICAgICAgICAgIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKSxcbiAgICAgICAgICAgIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKTtcbiAgICAgICAgICB2YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmlmcmFtZS1ib290c3RyYXAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNwb3J0TWFwID0ge307XG4gICAgICAgICAgICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24gKGF0KSB7XG4gICAgICAgICAgICAgIGlmIChhdC5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRNYXBbYXQuZmFjYWRlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdID0gYXQuZmFjYWRlVHJhbnNwb3J0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gaGFyZC1jb2RlZCBmb3IgdGhlIGluZm8gaWZyYW1lXG4gICAgICAgICAgICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICAgICAgICAgICAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcbiAgICAgICAgICAgIHZhciBwYXJlbnRPcmlnaW47XG5cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgICAgICAgU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgICAgICAgICAgIHZhciBmYWNhZGU7XG4gICAgICAgICAgICAgIGlmcmFtZVV0aWxzLmN1cnJlbnRXaW5kb3dJZCA9IGxvYy5oYXNoLnNsaWNlKDEpO1xuICAgICAgICAgICAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5zb3VyY2UgIT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmVudE9yaWdpbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gIT09IHBhcmVudE9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWZyYW1lTWVzc2FnZSA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgcCA9IEpTT04ucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICsgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fCAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgKyAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgICAgICAgICAgICAvLyBTdGFydFxuICAgICAgICAgICAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB7XG4gICAgICAgIGVudjoge31cbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIFwiLi9mYWNhZGVcIjogNyxcbiAgICAgIFwiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOiAxMCxcbiAgICAgIFwiLi9sb2NhdGlvblwiOiAxMyxcbiAgICAgIFwiLi91dGlscy9ldmVudFwiOiA0NixcbiAgICAgIFwiLi91dGlscy9pZnJhbWVcIjogNDcsXG4gICAgICBcIi4vdXRpbHMvdXJsXCI6IDUyLFxuICAgICAgXCJkZWJ1Z1wiOiA1NVxuICAgIH1dLFxuICAgIDk6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICB2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgICAgICAgICAgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpO1xuICAgICAgICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1hamF4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEluZm9BamF4KHVybCwgQWpheE9iamVjdCkge1xuICAgICAgICAgICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcbiAgICAgICAgICAgIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24gKHN0YXR1cywgdGV4dCkge1xuICAgICAgICAgICAgICB2YXIgaW5mbywgcnR0O1xuICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICBydHQgPSArbmV3IERhdGUoKSAtIHQwO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0VXRpbHMuaXNPYmplY3QoaW5mbykpIHtcbiAgICAgICAgICAgICAgICAgIGluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgICAgICAgICAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaGVyaXRzKEluZm9BamF4LCBFdmVudEVtaXR0ZXIpO1xuICAgICAgICAgIEluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnhvLmNsb3NlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB7XG4gICAgICAgIGVudjoge31cbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIFwiLi91dGlscy9vYmplY3RcIjogNDksXG4gICAgICBcImRlYnVnXCI6IDU1LFxuICAgICAgXCJldmVudHNcIjogMyxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAxMDogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICAgICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxuICAgICAgICBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKSxcbiAgICAgICAgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpO1xuICAgICAgZnVuY3Rpb24gSW5mb1JlY2VpdmVySWZyYW1lKHRyYW5zVXJsKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgICAgICAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiAoaW5mbywgcnR0KSB7XG4gICAgICAgICAgc2VsZi5pciA9IG51bGw7XG4gICAgICAgICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTi5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpbmhlcml0cyhJbmZvUmVjZWl2ZXJJZnJhbWUsIEV2ZW50RW1pdHRlcik7XG4gICAgICBJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtaW5mby1yZWNlaXZlcic7XG4gICAgICBJbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pcikge1xuICAgICAgICAgIHRoaXMuaXIuY2xvc2UoKTtcbiAgICAgICAgICB0aGlzLmlyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfTtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVySWZyYW1lO1xuICAgIH0sIHtcbiAgICAgIFwiLi9pbmZvLWFqYXhcIjogOSxcbiAgICAgIFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOiAzNyxcbiAgICAgIFwiZXZlbnRzXCI6IDMsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgMTE6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MsIGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG4gICAgICAgICAgICBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKSxcbiAgICAgICAgICAgIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpLFxuICAgICAgICAgICAgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpO1xuICAgICAgICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1pZnJhbWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgaWZyID0gc2VsZi5pZnIgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KEluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lLCB1cmwsIGJhc2VVcmwpO1xuICAgICAgICAgICAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAobXNnKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBKU09OLnBhcnNlKG1zZyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBkWzBdLFxuICAgICAgICAgICAgICAgICAgICBydHQgPSBkWzFdO1xuICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICAgICAgICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaGVyaXRzKEluZm9JZnJhbWUsIEV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgSW5mb0lmcmFtZS5lbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBJbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlmcikge1xuICAgICAgICAgICAgICB0aGlzLmlmci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMuaWZyID0gbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywge1xuICAgICAgICBlbnY6IHt9XG4gICAgICB9LCB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcbiAgICB9LCB7XG4gICAgICBcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjogMTAsXG4gICAgICBcIi4vdHJhbnNwb3J0L2lmcmFtZVwiOiAyMixcbiAgICAgIFwiLi91dGlscy9ldmVudFwiOiA0NixcbiAgICAgIFwiZGVidWdcIjogNTUsXG4gICAgICBcImV2ZW50c1wiOiAzLFxuICAgICAgXCJpbmhlcml0c1wiOiA1N1xuICAgIH1dLFxuICAgIDEyOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChwcm9jZXNzKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgdmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICAgICAgICAgIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKSxcbiAgICAgICAgICAgIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKSxcbiAgICAgICAgICAgIFhIUkNvcnMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMnKSxcbiAgICAgICAgICAgIFhIUkxvY2FsID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpLFxuICAgICAgICAgICAgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpLFxuICAgICAgICAgICAgSW5mb0lmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUnKSxcbiAgICAgICAgICAgIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKTtcbiAgICAgICAgICB2YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tcmVjZWl2ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSW5mb1JlY2VpdmVyKGJhc2VVcmwsIHVybEluZm8pIHtcbiAgICAgICAgICAgIGRlYnVnKGJhc2VVcmwpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmhlcml0cyhJbmZvUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbiAgICAgICAgICAvLyBUT0RPIHRoaXMgaXMgY3VycmVudGx5IGlnbm9yaW5nIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSB0cmFuc3BvcnRzIGFuZCB0aGUgd2hpdGVsaXN0XG5cbiAgICAgICAgICBJbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24gKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIG1ldGhvZCBvZiBDT1JTIHN1cHBvcnQgKGlmIG5lZWRlZClcbiAgICAgICAgICAgIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbiAoYmFzZVVybCwgdXJsSW5mbykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaW5mbycpO1xuICAgICAgICAgICAgZGVidWcoJ2RvWGhyJywgdXJsKTtcbiAgICAgICAgICAgIHRoaXMueG8gPSBJbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyKGJhc2VVcmwsIHVybCwgdXJsSW5mbyk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICAgICAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIChpbmZvLCBydHQpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uICh3YXNDbGVhbikge1xuICAgICAgICAgICAgZGVidWcoJ19jbGVhbnVwJyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dFJlZiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICAgICAgICAgICAgdGhpcy54by5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy54byA9IG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBJbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBJbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgZW52OiB7fVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgXCIuL2luZm8tYWpheFwiOiA5LFxuICAgICAgXCIuL2luZm8taWZyYW1lXCI6IDExLFxuICAgICAgXCIuL3RyYW5zcG9ydC9zZW5kZXIveGRyXCI6IDM0LFxuICAgICAgXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnNcIjogMzUsXG4gICAgICBcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZVwiOiAzNixcbiAgICAgIFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOiAzNyxcbiAgICAgIFwiLi91dGlscy91cmxcIjogNTIsXG4gICAgICBcImRlYnVnXCI6IDU1LFxuICAgICAgXCJldmVudHNcIjogMyxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAxMzogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICAgICAgICAgICAgb3JpZ2luOiAnaHR0cDovL2xvY2FsaG9zdDo4MCcsXG4gICAgICAgICAgICBwcm90b2NvbDogJ2h0dHA6JyxcbiAgICAgICAgICAgIGhvc3Q6ICdsb2NhbGhvc3QnLFxuICAgICAgICAgICAgcG9ydDogODAsXG4gICAgICAgICAgICBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nLFxuICAgICAgICAgICAgaGFzaDogJydcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcbiAgICB9LCB7fV0sXG4gICAgMTQ6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MsIGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHJlcXVpcmUoJy4vc2hpbXMnKTtcbiAgICAgICAgICB2YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJyksXG4gICAgICAgICAgICBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICByYW5kb20gPSByZXF1aXJlKCcuL3V0aWxzL3JhbmRvbScpLFxuICAgICAgICAgICAgZXNjYXBlID0gcmVxdWlyZSgnLi91dGlscy9lc2NhcGUnKSxcbiAgICAgICAgICAgIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKSxcbiAgICAgICAgICAgIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JyksXG4gICAgICAgICAgICB0cmFuc3BvcnQgPSByZXF1aXJlKCcuL3V0aWxzL3RyYW5zcG9ydCcpLFxuICAgICAgICAgICAgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpLFxuICAgICAgICAgICAgYnJvd3NlciA9IHJlcXVpcmUoJy4vdXRpbHMvYnJvd3NlcicpLFxuICAgICAgICAgICAgbG9nID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKSxcbiAgICAgICAgICAgIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudCcpLFxuICAgICAgICAgICAgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50dGFyZ2V0JyksXG4gICAgICAgICAgICBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJyksXG4gICAgICAgICAgICBDbG9zZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9jbG9zZScpLFxuICAgICAgICAgICAgVHJhbnNwb3J0TWVzc2FnZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC90cmFucy1tZXNzYWdlJyksXG4gICAgICAgICAgICBJbmZvUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8tcmVjZWl2ZXInKTtcbiAgICAgICAgICB2YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50Om1haW4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRyYW5zcG9ydHM7XG5cbiAgICAgICAgICAvLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuICAgICAgICAgIGZ1bmN0aW9uIFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tKUykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ09OTkVDVElORztcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9ICcnO1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gICAgICAgICAgICAvLyBub24tc3RhbmRhcmQgZXh0ZW5zaW9uXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICAgICAgICAgICAgbG9nLndhcm4oXCIncHJvdG9jb2xzX3doaXRlbGlzdCcgaXMgREVQUkVDQVRFRC4gVXNlICd0cmFuc3BvcnRzJyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG4gICAgICAgICAgICB0aGlzLl90cmFuc3BvcnRPcHRpb25zID0gb3B0aW9ucy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCAwO1xuICAgICAgICAgICAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmRvbS5zdHJpbmcoc2Vzc2lvbklkKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lmIHNlc3Npb25JZCBpcyB1c2VkIGluIHRoZSBvcHRpb25zLCBpdCBuZWVkcyB0byBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXIgfHwgcmFuZG9tLm51bWJlclN0cmluZygxMDAwKTtcblxuICAgICAgICAgICAgLy8gU3RlcCAxIG9mIFdTIHNwZWMgLSBwYXJzZSBhbmQgdmFsaWRhdGUgdGhlIHVybC4gSXNzdWUgIzhcbiAgICAgICAgICAgIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCAnXCIgKyB1cmwgKyBcIicgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwOicgJiYgcGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgICAgIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxuICAgICAgICAgICAgaWYgKGxvYy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiYgIXNlY3VyZSkge1xuICAgICAgICAgICAgICAvLyBleGNlcHRpb24gaXMgMTI3LjAuMC4wLzggYW5kIDo6MSB1cmxzXG4gICAgICAgICAgICAgIGlmICghdXJsVXRpbHMuaXNMb29wYmFja0FkZHIocGFyc2VkVXJsLmhvc3RuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdXJpdHlFcnJvcjogQW4gaW5zZWN1cmUgU29ja0pTIGNvbm5lY3Rpb24gbWF5IG5vdCBiZSBpbml0aWF0ZWQgZnJvbSBhIHBhZ2UgbG9hZGVkIG92ZXIgSFRUUFMnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAgICAgICAgICAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XG4gICAgICAgICAgICBpZiAoIXByb3RvY29scykge1xuICAgICAgICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgICAgICAgICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RlcCA1IC0gY2hlY2sgcHJvdG9jb2xzIGFyZ3VtZW50XG4gICAgICAgICAgICB2YXIgc29ydGVkUHJvdG9jb2xzID0gcHJvdG9jb2xzLnNvcnQoKTtcbiAgICAgICAgICAgIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uIChwcm90bywgaSkge1xuICAgICAgICAgICAgICBpZiAoIXByb3RvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaSA8IHNvcnRlZFByb3RvY29scy5sZW5ndGggLSAxICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBkdXBsaWNhdGVkLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXG4gICAgICAgICAgICB2YXIgbyA9IHVybFV0aWxzLmdldE9yaWdpbihsb2MuaHJlZik7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaFxuICAgICAgICAgICAgcGFyc2VkVXJsLnNldCgncGF0aG5hbWUnLCBwYXJzZWRVcmwucGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCAnJykpO1xuXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICAgICAgICAgICAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgICAgICAgICAgIGRlYnVnKCd1c2luZyB1cmwnLCB0aGlzLnVybCk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAgICAgICAgICAgLy8gb2J0YWluIHNlcnZlciBpbmZvXG4gICAgICAgICAgICAvLyBodHRwOi8vc29ja2pzLmdpdGh1Yi5pby9zb2NranMtcHJvdG9jb2wvc29ja2pzLXByb3RvY29sLTAuMy4zLmh0bWwjc2VjdGlvbi0yNlxuICAgICAgICAgICAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICAgICAgICAgICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKCksXG4gICAgICAgICAgICAgIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKSxcbiAgICAgICAgICAgICAgc2FtZVNjaGVtZTogdXJsVXRpbHMuaXNTY2hlbWVFcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5faXIgPSBuZXcgSW5mb1JlY2VpdmVyKHRoaXMudXJsLCB0aGlzLl91cmxJbmZvKTtcbiAgICAgICAgICAgIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcbiAgICAgICAgICBmdW5jdGlvbiB1c2VyU2V0Q29kZShjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCBjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBTb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICAgICAgLy8gU3RlcCAxXG4gICAgICAgICAgICBpZiAoY29kZSAmJiAhdXNlclNldENvZGUoY29kZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkQWNjZXNzRXJyb3I6IEludmFsaWQgY29kZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAyLjQgc3RhdGVzIHRoZSBtYXggaXMgMTIzIGJ5dGVzLCBidXQgd2UgYXJlIGp1c3QgY2hlY2tpbmcgbGVuZ3RoXG4gICAgICAgICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5sZW5ndGggPiAxMjMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMy4xXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gICAgICAgICAgICB2YXIgd2FzQ2xlYW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24gfHwgJ05vcm1hbCBjbG9zdXJlJywgd2FzQ2xlYW4pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgU29ja0pTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBjdXJyZW50bHkgdHVybnMgb2JqZWN0cyBpbnRvIFtvYmplY3QgT2JqZWN0XVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG4gICAgICAgICAgU29ja0pTLkNPTk5FQ1RJTkcgPSAwO1xuICAgICAgICAgIFNvY2tKUy5PUEVOID0gMTtcbiAgICAgICAgICBTb2NrSlMuQ0xPU0lORyA9IDI7XG4gICAgICAgICAgU29ja0pTLkNMT1NFRCA9IDM7XG4gICAgICAgICAgU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbiAoaW5mbywgcnR0KSB7XG4gICAgICAgICAgICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgICAgICAgICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAgICAgICAgICAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXG4gICAgICAgICAgICB0aGlzLl9ydG8gPSB0aGlzLmNvdW50UlRPKHJ0dCk7XG4gICAgICAgICAgICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gICAgICAgICAgICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XG4gICAgICAgICAgICBpbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKGluZm8sIHRoaXMuX3VybEluZm8pO1xuICAgICAgICAgICAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXG4gICAgICAgICAgICB2YXIgZW5hYmxlZFRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzLmZpbHRlclRvRW5hYmxlZCh0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICAgICAgICAgICAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdCgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKTsgVHJhbnNwb3J0OyBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgICAgIGlmIChUcmFuc3BvcnQubmVlZEJvZHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5IHx8IHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScgJiYgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc3BvcnRzLnVuc2hpZnQoVHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCB0aGlzLl9jb25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICAgICAgICAgICAgdmFyIHRpbWVvdXRNcyA9IE1hdGgubWF4KHRoaXMuX3RpbWVvdXQsIHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzIHx8IDUwMDApO1xuICAgICAgICAgICAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dE1zKTtcbiAgICAgICAgICAgICAgZGVidWcoJ3VzaW5nIHRpbWVvdXQnLCB0aW1lb3V0TXMpO1xuICAgICAgICAgICAgICB2YXIgdHJhbnNwb3J0VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0aGlzLl90cmFuc1VybCwgJy8nICsgdGhpcy5fc2VydmVyICsgJy8nICsgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQoKSk7XG4gICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fdHJhbnNwb3J0T3B0aW9uc1tUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV07XG4gICAgICAgICAgICAgIGRlYnVnKCd0cmFuc3BvcnQgdXJsJywgdHJhbnNwb3J0VXJsKTtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIHRyYW5zcG9ydE9iai5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgIHRyYW5zcG9ydE9iai5vbmNlKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgICAgICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnRPYmo7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlKDIwMDAsICdBbGwgdHJhbnNwb3J0cyBmYWlsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoJ190cmFuc3BvcnRUaW1lb3V0Jyk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0Q2xvc2UoMjAwNywgJ1RyYW5zcG9ydCB0aW1lZCBvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICBkZWJ1ZygnX3RyYW5zcG9ydE1lc3NhZ2UnLCBtc2cpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICB0eXBlID0gbXNnLnNsaWNlKDAsIDEpLFxuICAgICAgICAgICAgICBjb250ZW50ID0gbXNnLnNsaWNlKDEpLFxuICAgICAgICAgICAgICBwYXlsb2FkO1xuXG4gICAgICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnaGVhcnRiZWF0JywgdGhpcy50cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBkZWJ1ZygnZW1wdHkgcGF5bG9hZCcsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnbWVzc2FnZScsIHNlbGYudHJhbnNwb3J0LCBwKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocCkpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICBkZWJ1ZygnbWVzc2FnZScsIHRoaXMudHJhbnNwb3J0LCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgICAgIGRlYnVnKCdfdHJhbnNwb3J0Q2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0KCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTb2NrSlMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoJ19vcGVuJywgdGhpcy5fdHJhbnNwb3J0ICYmIHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XG4gICAgICAgICAgICAgIGRlYnVnKCdjb25uZWN0ZWQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxuICAgICAgICAgICAgICAvLyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICB0aGlzLl9jbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgU29ja0pTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICAgICAgICAgICAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgICAgICAgICAgdmFyIGZvcmNlRmFpbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lyKSB7XG4gICAgICAgICAgICAgIGZvcmNlRmFpbCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuX2lyLmNsb3NlKCk7XG4gICAgICAgICAgICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuICAgICAgICAgICAgICBpZiAoZm9yY2VGYWlsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGUgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKTtcbiAgICAgICAgICAgICAgZS53YXNDbGVhbiA9IHdhc0NsZWFuIHx8IGZhbHNlO1xuICAgICAgICAgICAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XG4gICAgICAgICAgICAgIGUucmVhc29uID0gcmVhc29uO1xuICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgICAgICAgIHRoaXMub25tZXNzYWdlID0gdGhpcy5vbmNsb3NlID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgZGVidWcoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gU2VlOiBodHRwOi8vd3d3LmVyZy5hYmRuLmFjLnVrL35nZXJyaXQvZGNjcC9ub3Rlcy9jY2lkMi9ydG9fZXN0aW1hdG9yL1xuICAgICAgICAgIC8vIGFuZCBSRkMgMjk4OC5cbiAgICAgICAgICBTb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24gKHJ0dCkge1xuICAgICAgICAgICAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxuICAgICAgICAgICAgLy8gdHJhbnNwb3J0IHRoZSB0aW1lIG5lZWRlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uICh0aGUgdGltZSB0aGF0IHBhc3NcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIG9wZW5pbmcgb2YgdGhlIHRyYW5zcG9ydCB0byB0aGUgY2FsbCBvZiBgX2Rpc3BhdGNoT3BlbmApIGlzXG4gICAgICAgICAgICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXG4gICAgICAgICAgICAvLyBjYXVzZXMgc3B1cmlvdXMgdGltZW91dHMuIEZvciB0aGlzIHJlYXNvbiB3ZSBjYWxjdWxhdGUgYSB2YWx1ZSBzbGlnaHRseVxuICAgICAgICAgICAgLy8gbGFyZ2VyIHRoYW4gdGhhdCB1c2VkIGluIHRoZSBhcnRpY2xlLlxuICAgICAgICAgICAgaWYgKHJ0dCA+IDEwMCkge1xuICAgICAgICAgICAgICByZXR1cm4gNCAqIHJ0dDsgLy8gcnRvID4gNDAwbXNlY1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMzAwICsgcnR0OyAvLyAzMDBtc2VjIDwgcnRvIDw9IDQwMG1zZWNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICAgICAgICAgICAgdHJhbnNwb3J0cyA9IHRyYW5zcG9ydChhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgICAgICAgICAgIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gICAgICAgICAgICByZXR1cm4gU29ja0pTO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgZW52OiB7fVxuICAgICAgfSwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG4gICAgfSwge1xuICAgICAgXCIuL2V2ZW50L2Nsb3NlXCI6IDIsXG4gICAgICBcIi4vZXZlbnQvZXZlbnRcIjogNCxcbiAgICAgIFwiLi9ldmVudC9ldmVudHRhcmdldFwiOiA1LFxuICAgICAgXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjogNixcbiAgICAgIFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6IDgsXG4gICAgICBcIi4vaW5mby1yZWNlaXZlclwiOiAxMixcbiAgICAgIFwiLi9sb2NhdGlvblwiOiAxMyxcbiAgICAgIFwiLi9zaGltc1wiOiAxNSxcbiAgICAgIFwiLi91dGlscy9icm93c2VyXCI6IDQ0LFxuICAgICAgXCIuL3V0aWxzL2VzY2FwZVwiOiA0NSxcbiAgICAgIFwiLi91dGlscy9ldmVudFwiOiA0NixcbiAgICAgIFwiLi91dGlscy9sb2dcIjogNDgsXG4gICAgICBcIi4vdXRpbHMvb2JqZWN0XCI6IDQ5LFxuICAgICAgXCIuL3V0aWxzL3JhbmRvbVwiOiA1MCxcbiAgICAgIFwiLi91dGlscy90cmFuc3BvcnRcIjogNTEsXG4gICAgICBcIi4vdXRpbHMvdXJsXCI6IDUyLFxuICAgICAgXCIuL3ZlcnNpb25cIjogNTMsXG4gICAgICBcImRlYnVnXCI6IDU1LFxuICAgICAgXCJpbmhlcml0c1wiOiA1NyxcbiAgICAgIFwidXJsLXBhcnNlXCI6IDYwXG4gICAgfV0sXG4gICAgMTU6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgLyoganNjczogZGlzYWJsZSAqL1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAvLyBwdWxsZWQgc3BlY2lmaWMgc2hpbXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbiAgICAgIHZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbiAgICAgIHZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuICAgICAgdmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgICAgdmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG4gICAgICB2YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcbiAgICAgIHZhciBfdG9TdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgICB9O1xuICAgICAgdmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgIH07XG4gICAgICB2YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICAgICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgICAgfTtcbiAgICAgIHZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcblxuICAgICAgLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4gICAgICAvLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxuICAgICAgdmFyIGRlZmluZVByb3BlcnR5O1xuICAgICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiBuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiBuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0KG8pO1xuICAgICAgfTtcblxuICAgICAgLy9cbiAgICAgIC8vIFV0aWxcbiAgICAgIC8vID09PT09PVxuICAgICAgLy9cblxuICAgICAgLy8gRVM1IDkuNFxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS40XG4gICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXG5cbiAgICAgIGZ1bmN0aW9uIHRvSW50ZWdlcihudW0pIHtcbiAgICAgICAgdmFyIG4gPSArbnVtO1xuICAgICAgICBpZiAobiAhPT0gbikge1xuICAgICAgICAgIC8vIGlzTmFOXG4gICAgICAgICAgbiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAxIC8gMCAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgICAgIHJldHVybiB4ID4+PiAwO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgLy8gRnVuY3Rpb25cbiAgICAgIC8vID09PT09PT09XG4gICAgICAvL1xuXG4gICAgICAvLyBFUy01IDE1LjMuNC41XG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG4gICAgICBmdW5jdGlvbiBFbXB0eSgpIHt9XG4gICAgICBkZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgICAgICAgIC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgIC8vIEYgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgLy8gICBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAvLyAzLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAvLyAgIG1ldGhvZCBvZiB0YXJnZXQgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4xIFtbQ2FsbF1dXG4gICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgIC8vIDMuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAvLyAgIG9mIHRhcmdldCBwcm92aWRpbmcgYm91bmRUaGlzIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAgIC8vIDE3LiBTZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byB0aGUgdmFsdWVzXG4gICAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xuICAgICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcbiAgICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgICAgLy8gICBhcmd1bWVudHMgXCJjYWxsZXJcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLCBbW1NldF1dOlxuICAgICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgICAgLy8gMjEuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgICAgLy8gICBhbmQgZmFsc2UuXG5cbiAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcbiAgICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgICAgLy8gMjIuIFJldHVybiBGLlxuICAgICAgICAgIHJldHVybiBib3VuZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBBcnJheVxuICAgICAgLy8gPT09PT1cbiAgICAgIC8vXG5cbiAgICAgIC8vIEVTNSAxNS40LjMuMlxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbiAgICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXksIHtcbiAgICAgICAgaXNBcnJheTogaXNBcnJheVxuICAgICAgfSk7XG4gICAgICB2YXIgYm94ZWRTdHJpbmcgPSBPYmplY3QoJ2EnKTtcbiAgICAgIHZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcbiAgICAgIHZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgfSwgJ3gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xuICAgICAgfTtcbiAgICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmdW4gLyosIHRoaXNwKi8pIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgIGlmICghaXNGdW5jdGlvbihmdW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIFRPRE8gbWVzc2FnZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAvLyBjb250ZXh0LCBwcm9wZXJ0eSB2YWx1ZSwgcHJvcGVydHkga2V5LCB0aGlzQXJnIG9iamVjdFxuICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuICAgICAgLy8gRVM1IDE1LjQuNC4xNFxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG4gICAgICB2YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuICAgICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc291Z2h0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBTdHJpbmdcbiAgICAgIC8vID09PT09PVxuICAgICAgLy9cblxuICAgICAgLy8gRVM1IDE1LjUuNC4xNFxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbiAgICAgIC8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbiAgICAgIC8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4gICAgICAvLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbiAgICAgIC8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuICAgICAgLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuICAgICAgLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbiAgICAgIC8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuICAgICAgLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuICAgICAgLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbiAgICAgIC8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuICAgICAgLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbiAgICAgIHZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XG4gICAgICBpZiAoJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fCAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8ICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8ICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHwgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8ICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHZvaWQgMDsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICsgKHNlcGFyYXRvci5leHRlbmRlZCA/ICd4JyA6ICcnKSArIChcbiAgICAgICAgICAgICAgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICBzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpLFxuICAgICAgICAgICAgICAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICBzZXBhcmF0b3IyLFxuICAgICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgICAgbGFzdEluZGV4LFxuICAgICAgICAgICAgICBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yLnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdm9pZCAwID8gLTEgPj4+IDAgOlxuICAgICAgICAgICAgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIEFycmF5UHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIC8vIFtidWdmaXgsIGNocm9tZV1cbiAgICAgICAgLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbiAgICAgICAgLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXG4gICAgICAgIC8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbiAgICAgICAgLy8gZWxlbWVudHMuXG4gICAgICAgIC8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cbiAgICAgIH0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4gICAgICAvLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuICAgICAgLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuICAgICAgLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4gICAgICAvLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxuICAgICAgdmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xuICAgICAgdmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuICAgICAgZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAgICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwodGhpcywgc3RhcnQgPCAwID8gKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0IDogc3RhcnQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcbiAgICB9LCB7fV0sXG4gICAgMTY6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gW1xuICAgICAgLy8gc3RyZWFtaW5nIHRyYW5zcG9ydHNcbiAgICAgIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3dlYnNvY2tldCcpLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJyksIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcnKSwgcmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcblxuICAgICAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXG4gICAgICAsIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJyksIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJykpLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItcG9sbGluZycpLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpKSwgcmVxdWlyZSgnLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZycpXTtcbiAgICB9LCB7XG4gICAgICBcIi4vdHJhbnNwb3J0L2V2ZW50c291cmNlXCI6IDIwLFxuICAgICAgXCIuL3RyYW5zcG9ydC9odG1sZmlsZVwiOiAyMSxcbiAgICAgIFwiLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZ1wiOiAyMyxcbiAgICAgIFwiLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwXCI6IDI2LFxuICAgICAgXCIuL3RyYW5zcG9ydC93ZWJzb2NrZXRcIjogMzgsXG4gICAgICBcIi4vdHJhbnNwb3J0L3hkci1wb2xsaW5nXCI6IDM5LFxuICAgICAgXCIuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nXCI6IDQwLFxuICAgICAgXCIuL3RyYW5zcG9ydC94aHItcG9sbGluZ1wiOiA0MSxcbiAgICAgIFwiLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZ1wiOiA0MlxuICAgIH1dLFxuICAgIDE3OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChwcm9jZXNzLCBnbG9iYWwpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICB2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgICAgICAgICAgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpLFxuICAgICAgICAgICAgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKSxcbiAgICAgICAgICAgIFhIUiA9IGdsb2JhbC5YTUxIdHRwUmVxdWVzdDtcbiAgICAgICAgICB2YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJyb3dzZXI6eGhyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0WEhST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gICAgICAgICAgICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5oZXJpdHMoQWJzdHJhY3RYSFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy54aHIgPSBuZXcgWEhSKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy54aHIpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ25vIHhocicpO1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICdubyB4aHIgc3VwcG9ydCcpO1xuICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V2ZXJhbCBicm93c2VycyBjYWNoZSBQT1NUc1xuICAgICAgICAgICAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgK25ldyBEYXRlKCkpO1xuXG4gICAgICAgICAgICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgICAgICAgICAgIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICAgICAgICAgICAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWJ1ZygndW5sb2FkIGNsZWFudXAnKTtcbiAgICAgICAgICAgICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy54aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgICAgICAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBkZWJ1ZygneGhyIHRpbWVvdXQnKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBkZWJ1ZygnZXhjZXB0aW9uJywgZSk7XG4gICAgICAgICAgICAgIC8vIElFIHJhaXNlcyBhbiBleGNlcHRpb24gb24gd3JvbmcgcG9ydC5cbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKCFvcHRzIHx8ICFvcHRzLm5vQ3JlZGVudGlhbHMpICYmIEFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUykge1xuICAgICAgICAgICAgICBkZWJ1Zygnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgICAgICAgICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAgICAgICAgICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXG5cbiAgICAgICAgICAgICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzICYmIG9wdHMuaGVhZGVycykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHNlbGYueGhyO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0LCBzdGF0dXM7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3JlYWR5U3RhdGUnLCB4LnJlYWR5U3RhdGUpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoeC5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgZG9lcyByZXR1cm4gcmVhZHlzdGF0ZSA9PSAzIGZvciA0MDQgYW5zd2Vycy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwICYmIHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVidWcoJ2NodW5rJyk7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdjaHVuaycsIHN0YXR1cywgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJRSByZXR1cm5zIHRoaXMgZm9yIGEgYmFkIHBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM4Mzc3MCh2PXZzLjg1KS5hc3B4XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDEyMDA1IHx8IHN0YXR1cyA9PT0gMTIwMjkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIEFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uIChhYm9ydCkge1xuICAgICAgICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy54aHIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgICAgICAgICAgIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxuICAgICAgICAgICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBpZiAodGhpcy54aHIub250aW1lb3V0KSB7XG4gICAgICAgICAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGhyID0gbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIVhIUjtcbiAgICAgICAgICAvLyBvdmVycmlkZSBYTUxIdHRwUmVxdWVzdCBmb3IgSUU2LzdcbiAgICAgICAgICAvLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG4gICAgICAgICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgICAgICAgaWYgKCFBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkICYmIGF4byBpbiBnbG9iYWwpIHtcbiAgICAgICAgICAgIGRlYnVnKCdvdmVycmlkaW5nIHhtbGh0dHByZXF1ZXN0Jyk7XG4gICAgICAgICAgICBYSFIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbYXhvXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhbmV3IFhIUigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY29ycyA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhIUigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgICB9XG4gICAgICAgICAgQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTID0gY29ycztcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0WEhST2JqZWN0O1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB7XG4gICAgICAgIGVudjoge31cbiAgICAgIH0sIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHtcbiAgICAgIFwiLi4vLi4vdXRpbHMvZXZlbnRcIjogNDYsXG4gICAgICBcIi4uLy4uL3V0aWxzL3VybFwiOiA1MixcbiAgICAgIFwiZGVidWdcIjogNTUsXG4gICAgICBcImV2ZW50c1wiOiAzLFxuICAgICAgXCJpbmhlcml0c1wiOiA1N1xuICAgIH1dLFxuICAgIDE4OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG4gICAgfSwge31dLFxuICAgIDE5OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICB2YXIgRHJpdmVyID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuICAgICAgICAgIGlmIChEcml2ZXIpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gV2ViU29ja2V0QnJvd3NlckRyaXZlcih1cmwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEcml2ZXIodXJsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG4gICAgfSwge31dLFxuICAgIDIwOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgICAgICBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJyksXG4gICAgICAgIEV2ZW50U291cmNlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2V2ZW50c291cmNlJyksXG4gICAgICAgIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpLFxuICAgICAgICBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJyk7XG4gICAgICBmdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICAgICAgICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2V2ZW50c291cmNlJywgRXZlbnRTb3VyY2VSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG4gICAgICB9XG4gICAgICBpbmhlcml0cyhFdmVudFNvdXJjZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcbiAgICAgIEV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIUV2ZW50U291cmNlRHJpdmVyO1xuICAgICAgfTtcbiAgICAgIEV2ZW50U291cmNlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnZXZlbnRzb3VyY2UnO1xuICAgICAgRXZlbnRTb3VyY2VUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuICAgIH0sIHtcbiAgICAgIFwiLi9saWIvYWpheC1iYXNlZFwiOiAyNCxcbiAgICAgIFwiLi9yZWNlaXZlci9ldmVudHNvdXJjZVwiOiAyOSxcbiAgICAgIFwiLi9zZW5kZXIveGhyLWNvcnNcIjogMzUsXG4gICAgICBcImV2ZW50c291cmNlXCI6IDE4LFxuICAgICAgXCJpbmhlcml0c1wiOiA1N1xuICAgIH1dLFxuICAgIDIxOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgICAgICBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpLFxuICAgICAgICBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpLFxuICAgICAgICBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJyk7XG4gICAgICBmdW5jdGlvbiBIdG1sRmlsZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICAgICAgICBpZiAoIUh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgWEhSTG9jYWxPYmplY3QpO1xuICAgICAgfVxuICAgICAgaW5oZXJpdHMoSHRtbEZpbGVUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG4gICAgICBIdG1sRmlsZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgcmV0dXJuIEh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW47XG4gICAgICB9O1xuICAgICAgSHRtbEZpbGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdodG1sZmlsZSc7XG4gICAgICBIdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XG4gICAgfSwge1xuICAgICAgXCIuL2xpYi9hamF4LWJhc2VkXCI6IDI0LFxuICAgICAgXCIuL3JlY2VpdmVyL2h0bWxmaWxlXCI6IDMwLFxuICAgICAgXCIuL3NlbmRlci94aHItbG9jYWxcIjogMzcsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgMjI6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAvLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2VcbiAgICAgICAgICAvLyB0aGVtIHdvcmsgY3Jvc3MtZG9tYWluIHdlIHNoYWxsIHVzZSBpZnJhbWUsIHNlcnZlZCBmcm9tIHRoZVxuICAgICAgICAgIC8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXG4gICAgICAgICAgLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSB1c2luZyBwb3N0TWVzc2FnZSgpLiBJbiBJRSBpdCB3YXMgaW1wbGVtZW50ZWRcbiAgICAgICAgICAvLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuICAgICAgICAgIC8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XG4gICAgICAgICAgLy8gICAgaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuICAgICAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpLFxuICAgICAgICAgICAgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKSxcbiAgICAgICAgICAgIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvaWZyYW1lJyksXG4gICAgICAgICAgICBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKSxcbiAgICAgICAgICAgIHJhbmRvbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3JhbmRvbScpO1xuICAgICAgICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dHJhbnNwb3J0OmlmcmFtZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJZnJhbWVUcmFuc3BvcnQodHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCkge1xuICAgICAgICAgICAgaWYgKCFJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IHVybFV0aWxzLmdldE9yaWdpbihiYXNlVXJsKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICAgICAgICB0aGlzLnRyYW5zVXJsID0gdHJhbnNVcmw7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgICAgIHRoaXMud2luZG93SWQgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgICAgICAgICAgdmFyIGlmcmFtZVVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pZnJhbWUuaHRtbCcpICsgJyMnICsgdGhpcy53aW5kb3dJZDtcbiAgICAgICAgICAgIGRlYnVnKHRyYW5zcG9ydCwgdHJhbnNVcmwsIGlmcmFtZVVybCk7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZU9iaiA9IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVVcmwsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcbiAgICAgICAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdVbmFibGUgdG8gbG9hZCBhbiBpZnJhbWUgKCcgKyByICsgJyknKTtcbiAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5fbWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgICAgICAgICAgICBldmVudFV0aWxzLmRldGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xuICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gICAgICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoZS5vcmlnaW4sIHRoaXMub3JpZ2luKSkge1xuICAgICAgICAgICAgICBkZWJ1Zygnbm90IHNhbWUgb3JpZ2luJywgZS5vcmlnaW4sIHRoaXMub3JpZ2luKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTi5wYXJzZShlLmRhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgICAgICAgICAgICBkZWJ1ZygnbWlzbWF0Y2hlZCB3aW5kb3cgaWQnLCBpZnJhbWVNZXNzYWdlLndpbmRvd0lkLCB0aGlzLndpbmRvd0lkKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgdGhpcy5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgICAgICAgICAgICAgLy8gd2luZG93IGdsb2JhbCBkZXBlbmRlbmN5XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0TWVzc2FnZSgncycsIEpTT04uc3RyaW5naWZ5KFt2ZXJzaW9uLCB0aGlzLnRyYW5zcG9ydCwgdGhpcy50cmFuc1VybCwgdGhpcy5iYXNlVXJsXSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICB2YXIgY2RhdGE7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNkYXRhID0gSlNPTi5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjZGF0YVswXSwgY2RhdGFbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIElmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgZGVidWcoJ3Bvc3RNZXNzYWdlJywgdHlwZSwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgd2luZG93SWQ6IHRoaXMud2luZG93SWQsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEgfHwgJydcbiAgICAgICAgICAgIH0pLCB0aGlzLm9yaWdpbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBJZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBJZnJhbWVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUnO1xuICAgICAgICAgIElmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IElmcmFtZVRyYW5zcG9ydDtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywge1xuICAgICAgICBlbnY6IHt9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBcIi4uL3V0aWxzL2V2ZW50XCI6IDQ2LFxuICAgICAgXCIuLi91dGlscy9pZnJhbWVcIjogNDcsXG4gICAgICBcIi4uL3V0aWxzL3JhbmRvbVwiOiA1MCxcbiAgICAgIFwiLi4vdXRpbHMvdXJsXCI6IDUyLFxuICAgICAgXCIuLi92ZXJzaW9uXCI6IDUzLFxuICAgICAgXCJkZWJ1Z1wiOiA1NSxcbiAgICAgIFwiZXZlbnRzXCI6IDMsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgMjM6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIC8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXG4gICAgICAgICAgLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbiAgICAgICAgICAvLyBtZXNzYWdlIGNvdWxkIHVzZSB1cCB0byBvbmUgaHR0cCByZXF1ZXN0LiBCdXQgYXQgbGVhc3QgaXQgd29ya3MgYWxtb3N0XG4gICAgICAgICAgLy8gZXZlcnl3aGVyZS5cbiAgICAgICAgICAvLyBLbm93biBsaW1pdGF0aW9uczpcbiAgICAgICAgICAvLyAgIG8geW91IHdpbGwgZ2V0IGEgc3Bpbm5pbmcgY3Vyc29yXG4gICAgICAgICAgLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG4gICAgICAgICAgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICAgICAgICAgIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyLXJlY2VpdmVyJyksXG4gICAgICAgICAgICBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpLFxuICAgICAgICAgICAganNvbnBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlci9qc29ucCcpO1xuICAgICAgICAgIGZ1bmN0aW9uIEpzb25QVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gICAgICAgICAgICBpZiAoIUpzb25QVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsICcvanNvbnAnLCBqc29ucFNlbmRlciwgSnNvbnBSZWNlaXZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaGVyaXRzKEpzb25QVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG4gICAgICAgICAgSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEpzb25QVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnanNvbnAtcG9sbGluZyc7XG4gICAgICAgICAgSnNvblBUcmFuc3BvcnQucm91bmRUcmlwcyA9IDE7XG4gICAgICAgICAgSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gSnNvblBUcmFuc3BvcnQ7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHtcbiAgICAgIFwiLi9saWIvc2VuZGVyLXJlY2VpdmVyXCI6IDI4LFxuICAgICAgXCIuL3JlY2VpdmVyL2pzb25wXCI6IDMxLFxuICAgICAgXCIuL3NlbmRlci9qc29ucFwiOiAzMyxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAyNDogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpLFxuICAgICAgICAgICAgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3NlbmRlci1yZWNlaXZlcicpO1xuICAgICAgICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YWpheC1iYXNlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgdmFyIG9wdCA9IHt9O1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgb3B0LmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAnQ29udGVudC10eXBlJzogJ3RleHQvcGxhaW4nXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XG4gICAgICAgICAgICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgYWpheFVybCwgcGF5bG9hZCwgb3B0KTtcbiAgICAgICAgICAgICAgeG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIHhvID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAyMDAgJiYgc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ2Fib3J0Jyk7XG4gICAgICAgICAgICAgICAgeG8uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB4byA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gICAgICAgICAgICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCB1cmxTdWZmaXgsIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCksIFJlY2VpdmVyLCBBamF4T2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5oZXJpdHMoQWpheEJhc2VkVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgZW52OiB7fVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgXCIuLi8uLi91dGlscy91cmxcIjogNTIsXG4gICAgICBcIi4vc2VuZGVyLXJlY2VpdmVyXCI6IDI4LFxuICAgICAgXCJkZWJ1Z1wiOiA1NSxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAyNTogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gICAgICAgICAgdmFyIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpidWZmZXJlZC1zZW5kZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gQnVmZmVyZWRTZW5kZXIodXJsLCBzZW5kZXIpIHtcbiAgICAgICAgICAgIGRlYnVnKHVybCk7XG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5oZXJpdHMoQnVmZmVyZWRTZW5kZXIsIEV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VuZFNjaGVkdWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEZvciBwb2xsaW5nIHRyYW5zcG9ydHMgaW4gYSBzaXR1YXRpb24gd2hlbiBpbiB0aGUgbWVzc2FnZSBjYWxsYmFjayxcbiAgICAgICAgICAvLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4gICAgICAgICAgLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuICAgICAgICAgIC8vIHRpbWVvdXQgZHVlIHRvIHRoZSBsYWNrIG9mIHJlY2VpdmluZyBzb2NrZXQuIFRvIGF2b2lkIHRoYXQgd2UgZGVsYXlcbiAgICAgICAgICAvLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuICAgICAgICAgIC8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbiAgICAgICAgICAvLyBkb2VzIG5vdCBmaXggdGhlIGJpZyBwcm9ibGVtLCBidXQgaXQgZG9lcyBtYWtlIHRoZSB0ZXN0cyBnbyBtb3JlXG4gICAgICAgICAgLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG4gICAgICAgICAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZVdhaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1Zygnc2VuZFNjaGVkdWxlV2FpdCcpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHRyZWY7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWJ1Zygnc2VuZFN0b3AnKTtcbiAgICAgICAgICAgICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgICAgICAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZSgpO1xuICAgICAgICAgICAgfSwgMjUpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgIHRoaXMuc2VuZFN0b3AgPSB0aGlzLnNlbmRlcih0aGlzLnVybCwgcGF5bG9hZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUgfHwgMTAwNiwgJ1NlbmRpbmcgZXJyb3I6ICcgKyBlcnIpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZVdhaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIEJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdfY2xlYW51cCcpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VuZFN0b3ApIHtcbiAgICAgICAgICAgICAgdGhpcy5zZW5kU3RvcCgpO1xuICAgICAgICAgICAgICB0aGlzLnNlbmRTdG9wID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gQnVmZmVyZWRTZW5kZXI7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgZW52OiB7fVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgXCJkZWJ1Z1wiOiA1NSxcbiAgICAgIFwiZXZlbnRzXCI6IDMsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgMjY6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKSxcbiAgICAgICAgICAgIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0Jyk7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBJZnJhbWVXcmFwVHJhbnNwb3J0KHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gICAgICAgICAgICAgIElmcmFtZVRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0cmFuc1VybCwgYmFzZVVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmhlcml0cyhJZnJhbWVXcmFwVHJhbnNwb3J0LCBJZnJhbWVUcmFuc3BvcnQpO1xuICAgICAgICAgICAgSWZyYW1lV3JhcFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24gKHVybCwgaW5mbykge1xuICAgICAgICAgICAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaWZyYW1lSW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZCh7fSwgaW5mbyk7XG4gICAgICAgICAgICAgIGlmcmFtZUluZm8uc2FtZU9yaWdpbiA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgICAgICAgICAgSWZyYW1lV3JhcFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG4gICAgICAgICAgICBJZnJhbWVXcmFwVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSBJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyArIHRyYW5zcG9ydC5yb3VuZFRyaXBzIC0gMTsgLy8gaHRtbCwgamF2YXNjcmlwdCAoMikgKyB0cmFuc3BvcnQgLSBubyBDT1JTICgxKVxuXG4gICAgICAgICAgICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgICAgIHJldHVybiBJZnJhbWVXcmFwVHJhbnNwb3J0O1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHtcbiAgICAgIFwiLi4vLi4vdXRpbHMvb2JqZWN0XCI6IDQ5LFxuICAgICAgXCIuLi9pZnJhbWVcIjogMjIsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgMjc6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgICAgICAgICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuICAgICAgICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gICAgICAgICAgICBkZWJ1ZyhyZWNlaXZlVXJsKTtcbiAgICAgICAgICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlVXJsID0gcmVjZWl2ZVVybDtcbiAgICAgICAgICAgIHRoaXMuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgUG9sbGluZy5wcm90b3R5cGUuX3NjaGVkdWxlUmVjZWl2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnX3NjaGVkdWxlUmVjZWl2ZXInKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuICAgICAgICAgICAgcG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICAgICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICAgICAgICBkZWJ1ZygnY2xvc2UnLCBjb2RlLCByZWFzb24sIHNlbGYucG9sbElzQ2xvc2luZyk7XG4gICAgICAgICAgICAgIHNlbGYucG9sbCA9IHBvbGwgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoIXNlbGYucG9sbElzQ2xvc2luZykge1xuICAgICAgICAgICAgICAgIGlmIChyZWFzb24gPT09ICduZXR3b3JrJykge1xuICAgICAgICAgICAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSB8fCAxMDA2LCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnBvbGxJc0Nsb3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9sbCkge1xuICAgICAgICAgICAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywge1xuICAgICAgICBlbnY6IHt9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBcImRlYnVnXCI6IDU1LFxuICAgICAgXCJldmVudHNcIjogMyxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAyODogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpLFxuICAgICAgICAgICAgQnVmZmVyZWRTZW5kZXIgPSByZXF1aXJlKCcuL2J1ZmZlcmVkLXNlbmRlcicpLFxuICAgICAgICAgICAgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xuICAgICAgICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyLXJlY2VpdmVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFNlbmRlclJlY2VpdmVyKHRyYW5zVXJsLCB1cmxTdWZmaXgsIHNlbmRlckZ1bmMsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gICAgICAgICAgICBkZWJ1Zyhwb2xsVXJsKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuICAgICAgICAgICAgdGhpcy5wb2xsID0gbmV3IFBvbGxpbmcoUmVjZWl2ZXIsIHBvbGxVcmwsIEFqYXhPYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICBkZWJ1ZygncG9sbCBtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgICAgICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICAgICAgICBkZWJ1ZygncG9sbCBjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgICAgIHNlbGYucG9sbCA9IG51bGw7XG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5oZXJpdHMoU2VuZGVyUmVjZWl2ZXIsIEJ1ZmZlcmVkU2VuZGVyKTtcbiAgICAgICAgICBTZW5kZXJSZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBCdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGRlYnVnKCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gICAgICAgICAgICAgIHRoaXMucG9sbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB7XG4gICAgICAgIGVudjoge31cbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIFwiLi4vLi4vdXRpbHMvdXJsXCI6IDUyLFxuICAgICAgXCIuL2J1ZmZlcmVkLXNlbmRlclwiOiAyNSxcbiAgICAgIFwiLi9wb2xsaW5nXCI6IDI3LFxuICAgICAgXCJkZWJ1Z1wiOiA1NSxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAyOTogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG4gICAgICAgICAgICBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJyk7XG4gICAgICAgICAgdmFyIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpldmVudHNvdXJjZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBFdmVudFNvdXJjZVJlY2VpdmVyKHVybCkge1xuICAgICAgICAgICAgZGVidWcodXJsKTtcbiAgICAgICAgICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICAgICAgICAgICAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgICAgICAgICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkZWNvZGVVUkkoZS5kYXRhKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXMub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdlcnJvcicsIGVzLnJlYWR5U3RhdGUsIGUpO1xuICAgICAgICAgICAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgICAgICAgICAgIC8vIG9uIG5ldHdvcmsgZXJyb3IgaXQncyBDTE9TRUQgPSAyXG4gICAgICAgICAgICAgIHZhciByZWFzb24gPSBlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCc7XG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgICAgICAgICAgc2VsZi5fY2xvc2UocmVhc29uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBFdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICAgICAgICB2YXIgZXMgPSB0aGlzLmVzO1xuICAgICAgICAgICAgaWYgKGVzKSB7XG4gICAgICAgICAgICAgIGVzLm9ubWVzc2FnZSA9IGVzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICBlcy5jbG9zZSgpO1xuICAgICAgICAgICAgICB0aGlzLmVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIEV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgICAgICAgICAgIC8vIHdhaXRpbmcgZm9yIEVTIGNsZWFudXAuIFNlZTpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgICAgICAgICAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VSZWNlaXZlcjtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywge1xuICAgICAgICBlbnY6IHt9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBcImRlYnVnXCI6IDU1LFxuICAgICAgXCJldmVudHNcIjogMyxcbiAgICAgIFwiZXZlbnRzb3VyY2VcIjogMTgsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgMzA6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MsIGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpLFxuICAgICAgICAgICAgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKSxcbiAgICAgICAgICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpO1xuICAgICAgICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgICAgICAgICAgIGRlYnVnKHVybCk7XG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmcmFtZVV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcbiAgICAgICAgICAgIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICAgICAgICAgICAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZGVjb2RlVVJJQ29tcG9uZW50KGlmcmFtZVV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG4gICAgICAgICAgICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gICAgICAgICAgICB2YXIgY29uc3RydWN0RnVuYyA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID8gaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG4gICAgICAgICAgICBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdzdG9wJyk7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2Nsb3NlKCduZXR3b3JrJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmlmcmFtZU9iaiA9IGNvbnN0cnVjdEZ1bmModXJsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgICAgICAgICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgIHNlbGYuX2Nsb3NlKCdwZXJtYW5lbnQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuICAgICAgICAgIEh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoJ2Fib3J0Jyk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZSgndXNlcicpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgICAgICAgICAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBIdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG4gICAgICAgICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgICAgICAgaWYgKGF4byBpbiBnbG9iYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gISFuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgfHwgaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgZW52OiB7fVxuICAgICAgfSwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG4gICAgfSwge1xuICAgICAgXCIuLi8uLi91dGlscy9pZnJhbWVcIjogNDcsXG4gICAgICBcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOiA1MCxcbiAgICAgIFwiLi4vLi4vdXRpbHMvdXJsXCI6IDUyLFxuICAgICAgXCJkZWJ1Z1wiOiA1NSxcbiAgICAgIFwiZXZlbnRzXCI6IDMsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgMzE6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MsIGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpLFxuICAgICAgICAgICAgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJyksXG4gICAgICAgICAgICBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpLFxuICAgICAgICAgICAgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKSxcbiAgICAgICAgICAgIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICAgICAgICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgICAgICAgICB2YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmpzb25wJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEpzb25wUmVjZWl2ZXIodXJsKSB7XG4gICAgICAgICAgICBkZWJ1Zyh1cmwpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG4gICAgICAgICAgICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgICAgICAgICAgIHZhciB1cmxXaXRoSWQgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcbiAgICAgICAgICAgIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTY3JpcHQodXJsV2l0aElkKTtcblxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICAgICAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKHRpbWVvdXQpJykpO1xuICAgICAgICAgICAgfSwgSnNvbnBSZWNlaXZlci50aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5oZXJpdHMoSnNvbnBSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcbiAgICAgICAgICBKc29ucFJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdhYm9ydCcpO1xuICAgICAgICAgICAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xuICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdKU09OUCB1c2VyIGFib3J0ZWQgcmVhZCcpO1xuICAgICAgICAgICAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgICAgICAgICAgIHRoaXMuX2Fib3J0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBKc29ucFJlY2VpdmVyLnRpbWVvdXQgPSAzNTAwMDtcbiAgICAgICAgICBKc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCA9IDEwMDA7XG4gICAgICAgICAgSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NhbGxiYWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGRlYnVnKCdfY2FsbGJhY2snLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFib3J0aW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgZGVidWcoJ19hYm9ydCcsIGVycik7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLmFib3J0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoJ19jbGVhbnVwJyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NyaXB0Mikge1xuICAgICAgICAgICAgICB0aGlzLnNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdDIpO1xuICAgICAgICAgICAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgICAgICAgICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgeW91IGNhbid0IHJlYWxseSBhYm9ydCBzY3JpcHQgbG9hZGluZyBvZlxuICAgICAgICAgICAgICAvLyB0aGUgc2NyaXB0LlxuICAgICAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gc2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX3NjcmlwdEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3JUaW1lcikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25lcnJvciknKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICBkZWJ1ZygnX2NyZWF0ZVNjcmlwdCcsIHVybCk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICB2YXIgc2NyaXB0MjsgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cblxuICAgICAgICAgICAgc2NyaXB0LmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgICAgICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICAgICAgc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLl9zY3JpcHRFcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ29ubG9hZCcpO1xuICAgICAgICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25sb2FkKScpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgICAgICAgICAgIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgc2NyaXB0LnJlYWR5U3RhdGUpO1xuICAgICAgICAgICAgICBpZiAoL2xvYWRlZHxjbG9zZWQvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICAgICAgICAgICAgc2VsZi5sb2FkZWRPa2F5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSknKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gSUU6IGV2ZW50L2h0bWxGb3Ivb25jbGljayB0cmljay5cbiAgICAgICAgICAgIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAgICAgICAgICAgLy8gc2NyaXB0IGNvZGUgd2lsbCBiZSBpbnN0YWxsZWQgYXMgJ29uY2xpY2snIGhhbmRsZXIgZm9yIHRoZVxuICAgICAgICAgICAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gICAgICAgICAgICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAgICAgICAgICAgLy8gc2V0LiBGb3IgcmVmZXJlbmNlIHNlZTpcbiAgICAgICAgICAgIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gICAgICAgICAgICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAgICAgICAgICAgLy8gICBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvRHluYW1pY19TY3JpcHRfRXhlY3V0aW9uX09yZGVyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAgICAgICAgICAgLy8gdG8gJ3RydWUnLCBzbyB3ZSBtYXkgdXNlIGl0IHRvIGRldGVjdCBhIGdvb2QgYnJvd3NlcjpcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgICAgICAgICAgICBpZiAoIWJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gTmFpdmVseSBhc3N1bWUgd2UncmUgaW4gSUVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgICAgICAgICAgICBzY3JpcHQuZXZlbnQgPSAnb25jbGljayc7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE9wZXJhLCBzZWNvbmQgc3luYyBzY3JpcHQgaGFja1xuICAgICAgICAgICAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Mi50ZXh0ID0gXCJ0cnl7dmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXCIgKyBzY3JpcHQuaWQgKyBcIicpOyBpZihhKWEub25lcnJvcigpO31jYXRjaCh4KXt9O1wiO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5hc3luYyA9IHNjcmlwdDIuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKHNjcmlwdDIpIHtcbiAgICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gSnNvbnBSZWNlaXZlcjtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywge1xuICAgICAgICBlbnY6IHt9XG4gICAgICB9LCB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcbiAgICB9LCB7XG4gICAgICBcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjogNDQsXG4gICAgICBcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOiA0NyxcbiAgICAgIFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6IDUwLFxuICAgICAgXCIuLi8uLi91dGlscy91cmxcIjogNTIsXG4gICAgICBcImRlYnVnXCI6IDU1LFxuICAgICAgXCJldmVudHNcIjogMyxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAzMjogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gICAgICAgICAgdmFyIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XG4gICAgICAgICAgICBkZWJ1Zyh1cmwpO1xuICAgICAgICAgICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLnhvLm9uKCdjaHVuaycsIHRoaXMuX2NodW5rSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24gKHN0YXR1cywgdGV4dCkge1xuICAgICAgICAgICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgICAgICAgc2VsZi5fY2h1bmtIYW5kbGVyKHN0YXR1cywgdGV4dCk7XG4gICAgICAgICAgICAgIHNlbGYueG8gPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcbiAgICAgICAgICAgICAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgICAgICAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmhlcml0cyhYaHJSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcbiAgICAgICAgICBYaHJSZWNlaXZlci5wcm90b3R5cGUuX2NodW5rSGFuZGxlciA9IGZ1bmN0aW9uIChzdGF0dXMsIHRleHQpIHtcbiAgICAgICAgICAgIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IDIwMCB8fCAhdGV4dCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpZHggPSAtMTs7IHRoaXMuYnVmZmVyUG9zaXRpb24gKz0gaWR4ICsgMSkge1xuICAgICAgICAgICAgICB2YXIgYnVmID0gdGV4dC5zbGljZSh0aGlzLmJ1ZmZlclBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgaWR4ID0gYnVmLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgICAgICAgaWYgKG1zZykge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBYaHJSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBYaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnhvKSB7XG4gICAgICAgICAgICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgICAgICAgICAgICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAndXNlcicpO1xuICAgICAgICAgICAgICB0aGlzLnhvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gWGhyUmVjZWl2ZXI7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgZW52OiB7fVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgXCJkZWJ1Z1wiOiA1NSxcbiAgICAgIFwiZXZlbnRzXCI6IDMsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgMzM6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MsIGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKSxcbiAgICAgICAgICAgIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJyk7XG4gICAgICAgICAgdmFyIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZvcm0sIGFyZWE7XG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlSWZyYW1lKGlkKSB7XG4gICAgICAgICAgICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICAgICAgICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVGb3JtKCkge1xuICAgICAgICAgICAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcbiAgICAgICAgICAgIGZvcm0gPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgICAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgICAgIGZvcm0uZW5jdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcbiAgICAgICAgICAgIGFyZWEgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgZGVidWcodXJsLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGlmICghZm9ybSkge1xuICAgICAgICAgICAgICBjcmVhdGVGb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICAgICAgICAgICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICAgICAgICAgIGZvcm0uYWN0aW9uID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsVXRpbHMuYWRkUGF0aCh1cmwsICcvanNvbnBfc2VuZCcpLCAnaT0nICsgaWQpO1xuICAgICAgICAgICAgdmFyIGlmcmFtZSA9IGNyZWF0ZUlmcmFtZShpZCk7XG4gICAgICAgICAgICBpZnJhbWUuaWQgPSBpZDtcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXJlYS52YWx1ZSA9IHBheWxvYWQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIHNlcmlvdXNseSBicm9rZW4gYnJvd3NlcnMgZ2V0IGhlcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBkZWJ1ZygnY29tcGxldGVkJywgaWQsIGVycik7XG4gICAgICAgICAgICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgIC8vIE9wZXJhIG1pbmkgZG9lc24ndCBsaWtlIGlmIHdlIEdDIGlmcmFtZVxuICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcbiAgICAgICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICAgIGFyZWEudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBpZiB0aGUgaWZyYW1lIHN1Y2NlZWRlZCBvclxuICAgICAgICAgICAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWJ1Zygnb25lcnJvcicsIGlkKTtcbiAgICAgICAgICAgICAgY29tcGxldGVkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcbiAgICAgICAgICAgICAgY29tcGxldGVkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xuICAgICAgICAgICAgICBpZiAoaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdhYm9ydGVkJywgaWQpO1xuICAgICAgICAgICAgICBjb21wbGV0ZWQobmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB7XG4gICAgICAgIGVudjoge31cbiAgICAgIH0sIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHtcbiAgICAgIFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6IDUwLFxuICAgICAgXCIuLi8uLi91dGlscy91cmxcIjogNTIsXG4gICAgICBcImRlYnVnXCI6IDU1XG4gICAgfV0sXG4gICAgMzQ6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKHByb2Nlc3MsIGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG4gICAgICAgICAgICBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKSxcbiAgICAgICAgICAgIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJyksXG4gICAgICAgICAgICB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpO1xuICAgICAgICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlZmVyZW5jZXM6XG4gICAgICAgICAgLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4gICAgICAgICAgLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxuXG4gICAgICAgICAgZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuICAgICAgICAgIFhEUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBkZWJ1ZygnX3N0YXJ0Jyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgeGRyID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICAgICAgLy8gSUUgY2FjaGVzIGV2ZW4gUE9TVHNcbiAgICAgICAgICAgIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICtuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIHhkci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWJ1Zygnb25lcnJvcicpO1xuICAgICAgICAgICAgICBzZWxmLl9lcnJvcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdvbnRpbWVvdXQnKTtcbiAgICAgICAgICAgICAgc2VsZi5fZXJyb3IoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ3Byb2dyZXNzJywgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnY2h1bmsnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhkci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdsb2FkJyk7XG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy54ZHIgPSB4ZHI7XG4gICAgICAgICAgICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcbiAgICAgICAgICAgICAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMueGRyLnNlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBYRFJPYmplY3QucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBYRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24gKGFib3J0KSB7XG4gICAgICAgICAgICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcbiAgICAgICAgICAgIGlmICghdGhpcy54ZHIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgICAgICAgICAgIHRoaXMueGRyLm9udGltZW91dCA9IHRoaXMueGRyLm9uZXJyb3IgPSB0aGlzLnhkci5vbnByb2dyZXNzID0gdGhpcy54ZHIub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChhYm9ydCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMueGRyLmFib3J0KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gSUUgOC85IGlmIHRoZSByZXF1ZXN0IHRhcmdldCB1c2VzIHRoZSBzYW1lIHNjaGVtZSAtICM3OVxuICAgICAgICAgIFhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gWERST2JqZWN0O1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB7XG4gICAgICAgIGVudjoge31cbiAgICAgIH0sIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHtcbiAgICAgIFwiLi4vLi4vdXRpbHMvYnJvd3NlclwiOiA0NCxcbiAgICAgIFwiLi4vLi4vdXRpbHMvZXZlbnRcIjogNDYsXG4gICAgICBcIi4uLy4uL3V0aWxzL3VybFwiOiA1MixcbiAgICAgIFwiZGVidWdcIjogNTUsXG4gICAgICBcImV2ZW50c1wiOiAzLFxuICAgICAgXCJpbmhlcml0c1wiOiA1N1xuICAgIH1dLFxuICAgIDM1OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgICAgICBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJyk7XG4gICAgICBmdW5jdGlvbiBYSFJDb3JzT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gICAgICAgIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbiAgICAgIH1cbiAgICAgIGluaGVyaXRzKFhIUkNvcnNPYmplY3QsIFhockRyaXZlcik7XG4gICAgICBYSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBYSFJDb3JzT2JqZWN0O1xuICAgIH0sIHtcbiAgICAgIFwiLi4vZHJpdmVyL3hoclwiOiAxNyxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAzNjogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcixcbiAgICAgICAgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuICAgICAgZnVuY3Rpb24gWEhSRmFrZSggLyogbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMgKi9cbiAgICAgICkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnRvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICAgICAgICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgaW5oZXJpdHMoWEhSRmFrZSwgRXZlbnRFbWl0dGVyKTtcbiAgICAgIFhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50byk7XG4gICAgICB9O1xuICAgICAgWEhSRmFrZS50aW1lb3V0ID0gMjAwMDtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcbiAgICB9LCB7XG4gICAgICBcImV2ZW50c1wiOiAzLFxuICAgICAgXCJpbmhlcml0c1wiOiA1N1xuICAgIH1dLFxuICAgIDM3OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgICAgICBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJyk7XG4gICAgICBmdW5jdGlvbiBYSFJMb2NhbE9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCAvKiwgb3B0cyAqLykge1xuICAgICAgICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgICAgICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpbmhlcml0cyhYSFJMb2NhbE9iamVjdCwgWGhyRHJpdmVyKTtcbiAgICAgIFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gWEhSTG9jYWxPYmplY3Q7XG4gICAgfSwge1xuICAgICAgXCIuLi9kcml2ZXIveGhyXCI6IDE3LFxuICAgICAgXCJpbmhlcml0c1wiOiA1N1xuICAgIH1dLFxuICAgIDM4OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChwcm9jZXNzKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKSxcbiAgICAgICAgICAgIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJyksXG4gICAgICAgICAgICBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG4gICAgICAgICAgICBXZWJzb2NrZXREcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlci93ZWJzb2NrZXQnKTtcbiAgICAgICAgICB2YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OndlYnNvY2tldCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodHJhbnNVcmwsIGlnbm9yZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFXZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBkZWJ1ZygnY29uc3RydWN0b3InLCB0cmFuc1VybCk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgJy93ZWJzb2NrZXQnKTtcbiAgICAgICAgICAgIGlmICh1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwcycpIHtcbiAgICAgICAgICAgICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cmwgPSAnd3MnICsgdXJsLnNsaWNlKDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgICAgICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBkZWJ1ZygnbWVzc2FnZSBldmVudCcsIGUuZGF0YSk7XG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGUuZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gRmlyZWZveCBoYXMgYW4gaW50ZXJlc3RpbmcgYnVnLiBJZiBhIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzXG4gICAgICAgICAgICAvLyBjcmVhdGVkIGFmdGVyIG9udW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAgICAgICAgICAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cbiAgICAgICAgICAgIC8vIGxldCdzIG5vdCBvcGVuIHRoZSB3cyBjb25uZWN0aW9uIGF0IGFsbC4gU2VlOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XG4gICAgICAgICAgICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCd1bmxvYWQnKTtcbiAgICAgICAgICAgICAgc2VsZi53cy5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBkZWJ1ZygnY2xvc2UgZXZlbnQnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICAgICAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgICAgICAgICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ2Vycm9yIGV2ZW50JywgZSk7XG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuJyk7XG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcbiAgICAgICAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdbJyArIGRhdGEgKyAnXSc7XG4gICAgICAgICAgICBkZWJ1Zygnc2VuZCcsIG1zZyk7XG4gICAgICAgICAgICB0aGlzLndzLnNlbmQobXNnKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnY2xvc2UnKTtcbiAgICAgICAgICAgIHZhciB3cyA9IHRoaXMud3M7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICBpZiAod3MpIHtcbiAgICAgICAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgICAgICAgICAgIHZhciB3cyA9IHRoaXMud3M7XG4gICAgICAgICAgICBpZiAod3MpIHtcbiAgICAgICAgICAgICAgd3Mub25tZXNzYWdlID0gd3Mub25jbG9zZSA9IHdzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgICAgICAgICAgIHRoaXMudW5sb2FkUmVmID0gdGhpcy53cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcpO1xuICAgICAgICAgICAgcmV0dXJuICEhV2Vic29ja2V0RHJpdmVyO1xuICAgICAgICAgIH07XG4gICAgICAgICAgV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcblxuICAgICAgICAgIC8vIEluIHRoZW9yeSwgd3Mgc2hvdWxkIHJlcXVpcmUgMSByb3VuZCB0cmlwLiBCdXQgaW4gY2hyb21lLCB0aGlzIGlzXG4gICAgICAgICAgLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuICAgICAgICAgIC8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4gICAgICAgICAgLy8gYWJzb2x1dGUgbWludW11bS5cbiAgICAgICAgICBXZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgZW52OiB7fVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgXCIuLi91dGlscy9ldmVudFwiOiA0NixcbiAgICAgIFwiLi4vdXRpbHMvdXJsXCI6IDUyLFxuICAgICAgXCIuL2RyaXZlci93ZWJzb2NrZXRcIjogMTksXG4gICAgICBcImRlYnVnXCI6IDU1LFxuICAgICAgXCJldmVudHNcIjogMyxcbiAgICAgIFwiaW5oZXJpdHNcIjogNTdcbiAgICB9XSxcbiAgICAzOTogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICAgICAgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpLFxuICAgICAgICBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3hkci1zdHJlYW1pbmcnKSxcbiAgICAgICAgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpLFxuICAgICAgICBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKTtcbiAgICAgIGZ1bmN0aW9uIFhkclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgICAgICAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xuICAgICAgfVxuICAgICAgaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcbiAgICAgIFhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuICAgICAgWGRyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1wb2xsaW5nJztcbiAgICAgIFhkclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IFhkclBvbGxpbmdUcmFuc3BvcnQ7XG4gICAgfSwge1xuICAgICAgXCIuL2xpYi9hamF4LWJhc2VkXCI6IDI0LFxuICAgICAgXCIuL3JlY2VpdmVyL3hoclwiOiAzMixcbiAgICAgIFwiLi9zZW5kZXIveGRyXCI6IDM0LFxuICAgICAgXCIuL3hkci1zdHJlYW1pbmdcIjogNDAsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgNDA6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKSxcbiAgICAgICAgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpLFxuICAgICAgICBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKTtcblxuICAgICAgLy8gQWNjb3JkaW5nIHRvOlxuICAgICAgLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuICAgICAgLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuICAgICAgZnVuY3Rpb24gWGRyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gICAgICAgIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG4gICAgICB9XG4gICAgICBpbmhlcml0cyhYZHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG4gICAgICBYZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XG4gICAgICB9O1xuICAgICAgWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXN0cmVhbWluZyc7XG4gICAgICBYZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydDtcbiAgICB9LCB7XG4gICAgICBcIi4vbGliL2FqYXgtYmFzZWRcIjogMjQsXG4gICAgICBcIi4vcmVjZWl2ZXIveGhyXCI6IDMyLFxuICAgICAgXCIuL3NlbmRlci94ZHJcIjogMzQsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgNDE6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKSxcbiAgICAgICAgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpLFxuICAgICAgICBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKSxcbiAgICAgICAgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKTtcbiAgICAgIGZ1bmN0aW9uIFhoclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgICAgICAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG4gICAgICB9XG4gICAgICBpbmhlcml0cyhYaHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuICAgICAgWGhyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW4pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xuICAgICAgfTtcbiAgICAgIFhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XG4gICAgICBYaHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xuICAgIH0sIHtcbiAgICAgIFwiLi9saWIvYWpheC1iYXNlZFwiOiAyNCxcbiAgICAgIFwiLi9yZWNlaXZlci94aHJcIjogMzIsXG4gICAgICBcIi4vc2VuZGVyL3hoci1jb3JzXCI6IDM1LFxuICAgICAgXCIuL3NlbmRlci94aHItbG9jYWxcIjogMzcsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgNDI6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgICAgICAgICBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJyksXG4gICAgICAgICAgICBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJyksXG4gICAgICAgICAgICBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKSxcbiAgICAgICAgICAgIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJyksXG4gICAgICAgICAgICBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbHMvYnJvd3NlcicpO1xuICAgICAgICAgIGZ1bmN0aW9uIFhoclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICAgICAgICAgICAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmhlcml0cyhYaHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG4gICAgICAgICAgWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcGVyYSBkb2Vzbid0IHN1cHBvcnQgeGhyLXN0cmVhbWluZyAjNjBcbiAgICAgICAgICAgIC8vIEJ1dCBpdCBtaWdodCBiZSBhYmxlIHRvICM5MlxuICAgICAgICAgICAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBYaHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItc3RyZWFtaW5nJztcbiAgICAgICAgICBYaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4gICAgICAgICAgLy8gU2FmYXJpIGdldHMgY29uZnVzZWQgd2hlbiBhIHN0cmVhbWluZyBhamF4IHJlcXVlc3QgaXMgc3RhcnRlZFxuICAgICAgICAgIC8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cbiAgICAgICAgICAvLyBPbmx5IHJlcXVpcmUgYm9keSB3aGVuIHVzZWQgaW4gYSBicm93c2VyXG4gICAgICAgICAgWGhyU3RyZWFtaW5nVHJhbnNwb3J0Lm5lZWRCb2R5ID0gISFnbG9iYWwuZG9jdW1lbnQ7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBYaHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHtcbiAgICAgIFwiLi4vdXRpbHMvYnJvd3NlclwiOiA0NCxcbiAgICAgIFwiLi9saWIvYWpheC1iYXNlZFwiOiAyNCxcbiAgICAgIFwiLi9yZWNlaXZlci94aHJcIjogMzIsXG4gICAgICBcIi4vc2VuZGVyL3hoci1jb3JzXCI6IDM1LFxuICAgICAgXCIuL3NlbmRlci94aHItbG9jYWxcIjogMzcsXG4gICAgICBcImluaGVyaXRzXCI6IDU3XG4gICAgfV0sXG4gICAgNDM6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIGlmIChnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHt9XSxcbiAgICA0NDogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgICAgICBpc09wZXJhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzS29ucXVlcm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmIC9rb25xdWVyb3IvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xuICAgICAgICAgICAgLFxuICAgICAgICAgICAgaGFzRG9tYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgICAgICAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG4gICAgfSwge31dLFxuICAgIDQ1OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAvLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbiAgICAgIC8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXgsIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzXG4gICAgICB2YXIgZXh0cmFFc2NhcGFibGUgPSAvW1xceDAwLVxceDFmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZcXHUwMzAwLVxcdTAzMzNcXHUwMzNkLVxcdTAzNDZcXHUwMzRhLVxcdTAzNGNcXHUwMzUwLVxcdTAzNTJcXHUwMzU3LVxcdTAzNThcXHUwMzVjLVxcdTAzNjJcXHUwMzc0XFx1MDM3ZVxcdTAzODdcXHUwNTkxLVxcdTA1YWZcXHUwNWM0XFx1MDYxMC1cXHUwNjE3XFx1MDY1My1cXHUwNjU0XFx1MDY1Ny1cXHUwNjViXFx1MDY1ZC1cXHUwNjVlXFx1MDZkZi1cXHUwNmUyXFx1MDZlYi1cXHUwNmVjXFx1MDczMFxcdTA3MzItXFx1MDczM1xcdTA3MzUtXFx1MDczNlxcdTA3M2FcXHUwNzNkXFx1MDczZi1cXHUwNzQxXFx1MDc0M1xcdTA3NDVcXHUwNzQ3XFx1MDdlYi1cXHUwN2YxXFx1MDk1MVxcdTA5NTgtXFx1MDk1ZlxcdTA5ZGMtXFx1MDlkZFxcdTA5ZGZcXHUwYTMzXFx1MGEzNlxcdTBhNTktXFx1MGE1YlxcdTBhNWVcXHUwYjVjLVxcdTBiNWRcXHUwZTM4LVxcdTBlMzlcXHUwZjQzXFx1MGY0ZFxcdTBmNTJcXHUwZjU3XFx1MGY1Y1xcdTBmNjlcXHUwZjcyLVxcdTBmNzZcXHUwZjc4XFx1MGY4MC1cXHUwZjgzXFx1MGY5M1xcdTBmOWRcXHUwZmEyXFx1MGZhN1xcdTBmYWNcXHUwZmI5XFx1MTkzOS1cXHUxOTNhXFx1MWExN1xcdTFiNmJcXHUxY2RhLVxcdTFjZGJcXHUxZGMwLVxcdTFkY2ZcXHUxZGZjXFx1MWRmZVxcdTFmNzFcXHUxZjczXFx1MWY3NVxcdTFmNzdcXHUxZjc5XFx1MWY3YlxcdTFmN2RcXHUxZmJiXFx1MWZiZVxcdTFmYzlcXHUxZmNiXFx1MWZkM1xcdTFmZGJcXHUxZmUzXFx1MWZlYlxcdTFmZWUtXFx1MWZlZlxcdTFmZjlcXHUxZmZiXFx1MWZmZFxcdTIwMDAtXFx1MjAwMVxcdTIwZDAtXFx1MjBkMVxcdTIwZDQtXFx1MjBkN1xcdTIwZTctXFx1MjBlOVxcdTIxMjZcXHUyMTJhLVxcdTIxMmJcXHUyMzI5LVxcdTIzMmFcXHUyYWRjXFx1MzAyYi1cXHUzMDJjXFx1YWFiMi1cXHVhYWIzXFx1ZjkwMC1cXHVmYTBkXFx1ZmExMFxcdWZhMTJcXHVmYTE1LVxcdWZhMWVcXHVmYTIwXFx1ZmEyMlxcdWZhMjUtXFx1ZmEyNlxcdWZhMmEtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMWRcXHVmYjFmXFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmI0ZVxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgZXh0cmFMb29rdXA7XG5cbiAgICAgIC8vIFRoaXMgbWF5IGJlIHF1aXRlIHNsb3csIHNvIGxldCdzIGRlbGF5IHVudGlsIHVzZXIgYWN0dWFsbHkgdXNlcyBiYWRcbiAgICAgIC8vIGNoYXJhY3RlcnMuXG4gICAgICB2YXIgdW5yb2xsTG9va3VwID0gZnVuY3Rpb24gKGVzY2FwYWJsZSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHVucm9sbGVkID0ge307XG4gICAgICAgIHZhciBjID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NTUzNjsgaSsrKSB7XG4gICAgICAgICAgYy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHVucm9sbGVkW2FdID0gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9KTtcbiAgICAgICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB1bnJvbGxlZDtcbiAgICAgIH07XG5cbiAgICAgIC8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuICAgICAgLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4gICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbiAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBxdW90ZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgIHZhciBxdW90ZWQgPSBKU09OLnN0cmluZ2lmeShzdHJpbmcpO1xuXG4gICAgICAgICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxuICAgICAgICAgIGV4dHJhRXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgaWYgKCFleHRyYUVzY2FwYWJsZS50ZXN0KHF1b3RlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBxdW90ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZXh0cmFMb29rdXApIHtcbiAgICAgICAgICAgIGV4dHJhTG9va3VwID0gdW5yb2xsTG9va3VwKGV4dHJhRXNjYXBhYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhTG9va3VwW2FdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIHt9XSxcbiAgICA0NjogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgdmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tJyk7XG4gICAgICAgICAgdmFyIG9uVW5sb2FkID0ge30sXG4gICAgICAgICAgICBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgICAgICAgICAvLyBkZXRlY3QgZ29vZ2xlIGNocm9tZSBwYWNrYWdlZCBhcHBzIGJlY2F1c2UgdGhleSBkb24ndCBhbGxvdyB0aGUgJ3VubG9hZCcgZXZlbnRcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGlzQ2hyb21lUGFja2FnZWRBcHAgPSBnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWU7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgICAgICBhdHRhY2hFdmVudDogZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJRSBxdWlya3MuXG4gICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAgICAgICAgICAgLy8gdGhlIG1lc3NhZ2UgZ2V0cyBkZWxpdmVyZWQgb25seSB0byAnZG9jdW1lbnQnLCBub3QgJ3dpbmRvdycuXG4gICAgICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVubG9hZEFkZDogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIGlmIChpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHJlZiA9IHJhbmRvbS5zdHJpbmcoOCk7XG4gICAgICAgICAgICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgICAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5sb2FkRGVsOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgIGlmIChyZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyaWdnZXJVbmxvYWRDYWxsYmFja3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICAgICAgICAgICAgb25VbmxvYWRbcmVmXSgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdW5sb2FkVHJpZ2dlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuICAgICAgICAgIC8vIGNhbid0IHVzZSBgYmVmb3JldW5sb2FkYCBhcyBJRSBmaXJlcyBpdCBvbiBqYXZhc2NyaXB0OiBsaW5rcy5cbiAgICAgICAgICBpZiAoIWlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH0pLmNhbGwodGhpcywgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG4gICAgfSwge1xuICAgICAgXCIuL3JhbmRvbVwiOiA1MFxuICAgIH1dLFxuICAgIDQ3OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChwcm9jZXNzLCBnbG9iYWwpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICB2YXIgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vZXZlbnQnKSxcbiAgICAgICAgICAgIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKTtcbiAgICAgICAgICB2YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOmlmcmFtZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgICAgIFdQcmVmaXg6ICdfanAnLFxuICAgICAgICAgICAgY3VycmVudFdpbmRvd0lkOiBudWxsLFxuICAgICAgICAgICAgcG9sbHV0ZUdsb2JhbE5hbWVzcGFjZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIShtb2R1bGUuZXhwb3J0cy5XUHJlZml4IGluIGdsb2JhbCkpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLnBhcmVudC5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEgfHwgJydcbiAgICAgICAgICAgICAgICB9KSwgJyonKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnQ2Fubm90IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LicsIHR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbiAoaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgICAgICAgICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygndW5hdHRhY2gnKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgICAgICAgICAgLy8gRXhwbG9yZXIgaGFkIHByb2JsZW1zIHdpdGggdGhhdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICAgICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAgICAgICAgICAgLy8gd2l0aGluIGlmcmFtZS4gV2l0aG91dCB0aGUgdGltZW91dCBpdCBnb2VzIHN0cmFpZ2h0IHRvXG4gICAgICAgICAgICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ29uZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZhciBwb3N0ID0gZnVuY3Rpb24gKG1zZywgb3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgICAgICAgICAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICAgICAgICAgICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgICAgICAgICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xuICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgICAgICAgICAgICB9LCAxNTAwMCk7XG4gICAgICAgICAgICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc3Q6IHBvc3QsXG4gICAgICAgICAgICAgICAgY2xlYW51cDogY2xlYW51cCxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIGVzbGludCBuby11bmRlZjogXCJvZmZcIiwgbmV3LWNhcDogXCJvZmZcIiAqLyxcbiAgICAgICAgICAgIGNyZWF0ZUh0bWxmaWxlOiBmdW5jdGlvbiAoaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuICAgICAgICAgICAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICAgICAgICAgICAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgICAgICAgICAgICB2YXIgaWZyYW1lO1xuICAgICAgICAgICAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgICAgICAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgICAgICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICAgICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ29uZXJyb3InLCByKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIHBvc3QgPSBmdW5jdGlvbiAobXNnLCBvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBkb2Mub3BlbigpO1xuICAgICAgICAgICAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICsgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBnbG9iYWwuZG9jdW1lbnQuZG9tYWluICsgJ1wiOycgKyAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XG4gICAgICAgICAgICAgIGRvYy5jbG9zZSgpO1xuICAgICAgICAgICAgICBkb2MucGFyZW50V2luZG93W21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0gZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdO1xuICAgICAgICAgICAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgIGlmcmFtZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgICAgICAgICAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgICAgICAgICAgIH0sIDE1MDAwKTtcbiAgICAgICAgICAgICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zdDogcG9zdCxcbiAgICAgICAgICAgICAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgICAgICAgICAgICAgIGxvYWRlZDogdW5hdHRhY2hcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICAgICAgICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcbiAgICAgICAgICAgIC8vIGh1Z2UgZGVsYXksIG9yIG5vdCBhdCBhbGwuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gKHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICFicm93c2VyLmlzS29ucXVlcm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB7XG4gICAgICAgIGVudjoge31cbiAgICAgIH0sIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHtcbiAgICAgIFwiLi9icm93c2VyXCI6IDQ0LFxuICAgICAgXCIuL2V2ZW50XCI6IDQ2LFxuICAgICAgXCJkZWJ1Z1wiOiA1NVxuICAgIH1dLFxuICAgIDQ4OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICB2YXIgbG9nT2JqZWN0ID0ge307XG4gICAgICAgICAgWydsb2cnLCAnZGVidWcnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWxFeGlzdHM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ09iamVjdFtsZXZlbF0gPSBsZXZlbEV4aXN0cyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseShnbG9iYWwuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gOiBsZXZlbCA9PT0gJ2xvZycgPyBmdW5jdGlvbiAoKSB7fSA6IGxvZ09iamVjdC5sb2c7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBsb2dPYmplY3Q7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuICAgIH0sIHt9XSxcbiAgICA0OTogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgICAgICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICAgICAgICB9LFxuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNvdXJjZSwgcHJvcDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIHt9XSxcbiAgICA1MDogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4gICAgICAvLyBUaGlzIHN0cmluZyBoYXMgbGVuZ3RoIDMyLCBhIHBvd2VyIG9mIDIsIHNvIHRoZSBtb2R1bHVzIGRvZXNuJ3QgaW50cm9kdWNlIGFcbiAgICAgIC8vIGJpYXMuXG4gICAgICB2YXIgX3JhbmRvbVN0cmluZ0NoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1JztcbiAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbWF4ID0gX3JhbmRvbVN0cmluZ0NoYXJzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgYnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmV0LnB1c2goX3JhbmRvbVN0cmluZ0NoYXJzLnN1YnN0cihieXRlc1tpXSAlIG1heCwgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICAgICAgICB9LFxuICAgICAgICBudW1iZXI6IGZ1bmN0aW9uIChtYXgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyU3RyaW5nOiBmdW5jdGlvbiAobWF4KSB7XG4gICAgICAgICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcbiAgICAgICAgICB2YXIgcCA9IG5ldyBBcnJheSh0ICsgMSkuam9pbignMCcpO1xuICAgICAgICAgIHJldHVybiAocCArIHRoaXMubnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCB7XG4gICAgICBcImNyeXB0b1wiOiA0M1xuICAgIH1dLFxuICAgIDUxOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgKGZ1bmN0aW9uIChwcm9jZXNzKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgdmFyIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp0cmFuc3BvcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZmlsdGVyVG9FbmFibGVkOiBmdW5jdGlvbiAodHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc3BvcnRzID0ge1xuICAgICAgICAgICAgICAgICAgbWFpbjogW10sXG4gICAgICAgICAgICAgICAgICBmYWNhZGU6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc3BvcnRzV2hpdGVsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICAgICAgaWYgKCF0cmFucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCBmcm9tIHNlcnZlcicsICd3ZWJzb2NrZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydHNXaGl0ZWxpc3QubGVuZ3RoICYmIHRyYW5zcG9ydHNXaGl0ZWxpc3QuaW5kZXhPZih0cmFucy50cmFuc3BvcnROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ25vdCBpbiB3aGl0ZWxpc3QnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ2VuYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0cy5tYWluLnB1c2godHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0cy5mYWNhZGUucHVzaCh0cmFucy5mYWNhZGVUcmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB7XG4gICAgICAgIGVudjoge31cbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIFwiZGVidWdcIjogNTVcbiAgICB9XSxcbiAgICA1MjogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcbiAgICAgICAgICB2YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgICAgIGdldE9yaWdpbjogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICAgICAgICBpZiAocC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwb3J0ID0gcC5wb3J0O1xuICAgICAgICAgICAgICBpZiAoIXBvcnQpIHtcbiAgICAgICAgICAgICAgICBwb3J0ID0gcC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnNDQzJyA6ICc4MCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHAucHJvdG9jb2wgKyAnLy8nICsgcC5ob3N0bmFtZSArICc6JyArIHBvcnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuZ2V0T3JpZ2luKGEpID09PSB0aGlzLmdldE9yaWdpbihiKTtcbiAgICAgICAgICAgICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU2NoZW1lRXF1YWw6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgICAgICAgICAgIHZhciBxcyA9IHVybC5zcGxpdCgnPycpO1xuICAgICAgICAgICAgICByZXR1cm4gcXNbMF0gKyBwYXRoICsgKHFzWzFdID8gJz8nICsgcXNbMV0gOiAnJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyArIHEgOiAnJicgKyBxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0xvb3BiYWNrQWRkcjogZnVuY3Rpb24gKGFkZHIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC9eMTI3XFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pLnRlc3QoYWRkcikgfHwgL15cXFs6OjFcXF0kLy50ZXN0KGFkZHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgZW52OiB7fVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgXCJkZWJ1Z1wiOiA1NSxcbiAgICAgIFwidXJsLXBhcnNlXCI6IDYwXG4gICAgfV0sXG4gICAgNTM6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9ICcxLjYuMSc7XG4gICAgfSwge31dLFxuICAgIDU0OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgLyoqXG4gICAgICAgKiBIZWxwZXJzLlxuICAgICAgICovXG5cbiAgICAgIHZhciBzID0gMTAwMDtcbiAgICAgIHZhciBtID0gcyAqIDYwO1xuICAgICAgdmFyIGggPSBtICogNjA7XG4gICAgICB2YXIgZCA9IGggKiAyNDtcbiAgICAgIHZhciB3ID0gZCAqIDc7XG4gICAgICB2YXIgeSA9IGQgKiAzNjUuMjU7XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAgICAgICAqXG4gICAgICAgKiBPcHRpb25zOlxuICAgICAgICpcbiAgICAgICAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAgICAgICAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgKyBKU09OLnN0cmluZ2lmeSh2YWwpKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIGNhc2UgJ3lycyc6XG4gICAgICAgICAgY2FzZSAneXInOlxuICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgcmV0dXJuIG4gKiB5O1xuICAgICAgICAgIGNhc2UgJ3dlZWtzJzpcbiAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIHJldHVybiBuICogdztcbiAgICAgICAgICBjYXNlICdkYXlzJzpcbiAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgcmV0dXJuIG4gKiBkO1xuICAgICAgICAgIGNhc2UgJ2hvdXJzJzpcbiAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICBjYXNlICdocnMnOlxuICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHJldHVybiBuICogaDtcbiAgICAgICAgICBjYXNlICdtaW51dGVzJzpcbiAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgIGNhc2UgJ21pbnMnOlxuICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIG07XG4gICAgICAgICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICBjYXNlICdzZWNzJzpcbiAgICAgICAgICBjYXNlICdzZWMnOlxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmV0dXJuIG4gKiBzO1xuICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgIGNhc2UgJ21zZWNzJzpcbiAgICAgICAgICBjYXNlICdtc2VjJzpcbiAgICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gbXNcbiAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gICAgICAgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgICAgICAgaWYgKG1zQWJzID49IGQpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc0FicyA+PSBoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zQWJzID49IHMpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtcyArICdtcyc7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gICAgICAgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgICAgICAgaWYgKG1zQWJzID49IGQpIHtcbiAgICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc0FicyA+PSBoKSB7XG4gICAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zQWJzID49IG0pIHtcbiAgICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc0FicyA+PSBzKSB7XG4gICAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXMgKyAnIG1zJztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAgICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gICAgICAgIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xuICAgICAgfVxuICAgIH0sIHt9XSxcbiAgICA1NTogW2Z1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIChmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICAgICAgICBleHBvcnRzLnNhdmUgPSBzYXZlO1xuICAgICAgICAgIGV4cG9ydHMubG9hZCA9IGxvYWQ7XG4gICAgICAgICAgZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG4gICAgICAgICAgZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4gICAgICAgICAgZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcbiAgICAgICAgICAgIGxldCB3YXJuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ29sb3JzLlxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gICAgICAgICAgICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gICAgICAgICAgICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgICAgICAgZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAgICAgICAgICAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgICAgICAgICAgIC8vIGV4cGxpY2l0bHlcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHxcbiAgICAgICAgICAgIC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHxcbiAgICAgICAgICAgIC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgICAgICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8XG4gICAgICAgICAgICAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgICAgICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gICAgICAgICAgICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cbiAgICAgICAgICAgIC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gICAgICAgICAgICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgbGFzdEMgPSAwO1xuICAgICAgICAgICAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gJyVjJykge1xuICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgICAgICAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICAgICAgICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICAgKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gICAgICAgICAgICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAgICAgICAgICAgKiB0byBgY29uc29sZS5sb2dgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBleHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIFN3YWxsb3dcbiAgICAgICAgICAgICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gICAgICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgICAgICAgIGxldCByO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gU3dhbGxvd1xuICAgICAgICAgICAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICAgICAgICAgICAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgICAgICAgICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICAgICAgICAgICAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gICAgICAgICAgICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAgICAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAgICAgICAgICAgLy8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cbiAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIFN3YWxsb3dcbiAgICAgICAgICAgICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBmb3JtYXR0ZXJzXG4gICAgICAgICAgfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgZW52OiB7fVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgXCIuL2NvbW1vblwiOiA1NlxuICAgIH1dLFxuICAgIDU2OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gICAgICAgKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIHNldHVwKGVudikge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuICAgICAgICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gICAgICAgIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcbiAgICAgICAgY3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG4gICAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgICAgICAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcbiAgICAgICAgY3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgICAgIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICAgICAgICovXG5cbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICAgICAgICpcbiAgICAgICAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICAgICAgICovXG4gICAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2VcbiAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gICAgICAgICAgbGV0IGhhc2ggPSAwO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAgICAgICAqXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgICAgICAgIGxldCBwcmV2VGltZTtcbiAgICAgICAgICBsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuICAgICAgICAgIGxldCBuYW1lc3BhY2VzQ2FjaGU7XG4gICAgICAgICAgbGV0IGVuYWJsZWRDYWNoZTtcbiAgICAgICAgICBmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgICAgICAvLyBEaXNhYmxlZD9cbiAgICAgICAgICAgIGlmICghZGVidWcuZW5hYmxlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gZGVidWc7XG5cbiAgICAgICAgICAgIC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgICAgICAgICBjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgY29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICAgICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgICAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICAgICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICAgICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG4gICAgICAgICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICclJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgICAgICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG4gICAgICAgICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgICAgICAgIGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICAgICAgICBkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG4gICAgICAgICAgZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmFibGVPdmVycmlkZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcbiAgICAgICAgICAgICAgICBlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWRDYWNoZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IHYgPT4ge1xuICAgICAgICAgICAgICBlbmFibGVPdmVycmlkZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICAgICAgICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZWJ1ZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICBjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gICAgICAgICAgbmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG4gICAgICAgICAgcmV0dXJuIG5ld0RlYnVnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAgICAgICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgICAgICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcbiAgICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgICAgICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgY29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgICAgICAgIGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghc3BsaXRbaV0pIHtcbiAgICAgICAgICAgICAgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAgICAgICAqXG4gICAgICAgICogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICAgICAgICogQGFwaSBwdWJsaWNcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgICAgICBjb25zdCBuYW1lc3BhY2VzID0gWy4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksIC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXS5qb2luKCcsJyk7XG4gICAgICAgICAgY3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcbiAgICAgICAgICByZXR1cm4gbmFtZXNwYWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICAgICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICBsZXQgbGVuO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG4gICAgICAgICogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZ2V4cC50b1N0cmluZygpLnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKS5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIENvZXJjZSBgdmFsYC5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgICAgICAqIEByZXR1cm4ge01peGVkfVxuICAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cbiAgICAgICAgKiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWJ1ZztcbiAgICAgIH1cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4gICAgfSwge1xuICAgICAgXCJtc1wiOiA1NFxuICAgIH1dLFxuICAgIDU3OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgICAgICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgICAgICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgICAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgICAgICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge31dLFxuICAgIDU4OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgdW5kZWY7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICAgICAgICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gICAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEF0dGVtcHRzIHRvIGVuY29kZSBhIGdpdmVuIGlucHV0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGVuY29kZWQgc3RyaW5nLlxuICAgICAgICogQGFwaSBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICAgICAgICB2YXIgcGFyc2VyID0gLyhbXj0/Jl0rKT0/KFteJl0qKS9nLFxuICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgIHBhcnQ7XG4gICAgICAgIHdoaWxlIChwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKSxcbiAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAgICAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgICAgICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSW4gdGhlIGNhc2UgaWYgZmFpbGVkIGRlY29kaW5nLCB3ZSB3YW50IHRvIG9taXQgdGhlIGtleS92YWx1ZSBwYWlyc1xuICAgICAgICAgIC8vIGZyb20gdGhlIHJlc3VsdC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwgfHwga2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG4gICAgICAgIHZhciBwYWlycyA9IFtdLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGtleTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAgICAgICAvL1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEVkZ2UgY2FzZXMgd2hlcmUgd2UgYWN0dWFsbHkgd2FudCB0byBlbmNvZGUgdGhlIHZhbHVlIHRvIGFuIGVtcHR5XG4gICAgICAgICAgICAvLyBzdHJpbmcgaW5zdGVhZCBvZiB0aGUgc3RyaW5naWZpZWQgdmFsdWUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmIHx8IGlzTmFOKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xuICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGVuY29kZSB0aGUgc3RyaW5ncywgd2Ugc2hvdWxkIGJhaWwgb3V0IGFzIHdlIGRvbid0XG4gICAgICAgICAgICAvLyB3YW50IHRvIGFkZCBpbnZhbGlkIHN0cmluZ3MgdG8gdGhlIHF1ZXJ5LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcGFpcnMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuICAgICAgLy9cbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG4gICAgfSwge31dLFxuICAgIDU5OiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICAgICAgICpcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAgICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gICAgICAgIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgICAgICAgcG9ydCA9ICtwb3J0O1xuICAgICAgICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgICAgICAgIGNhc2UgJ2h0dHAnOlxuICAgICAgICAgIGNhc2UgJ3dzJzpcbiAgICAgICAgICAgIHJldHVybiBwb3J0ICE9PSA4MDtcbiAgICAgICAgICBjYXNlICdodHRwcyc6XG4gICAgICAgICAgY2FzZSAnd3NzJzpcbiAgICAgICAgICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG4gICAgICAgICAgY2FzZSAnZnRwJzpcbiAgICAgICAgICAgIHJldHVybiBwb3J0ICE9PSAyMTtcbiAgICAgICAgICBjYXNlICdnb3BoZXInOlxuICAgICAgICAgICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3J0ICE9PSAwO1xuICAgICAgfTtcbiAgICB9LCB7fV0sXG4gICAgNjA6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgIHZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKSxcbiAgICAgICAgICAgIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKSxcbiAgICAgICAgICAgIGNvbnRyb2xPcldoaXRlc3BhY2UgPSAvXltcXHgwMC1cXHgyMFxcdTAwYTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyOFxcdTIwMjlcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXSsvLFxuICAgICAgICAgICAgQ1JIVExGID0gL1tcXG5cXHJcXHRdL2csXG4gICAgICAgICAgICBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vLFxuICAgICAgICAgICAgcG9ydCA9IC86XFxkKyQvLFxuICAgICAgICAgICAgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFxcL10rKT8oW1xcU1xcc10qKS9pLFxuICAgICAgICAgICAgd2luZG93c0RyaXZlTGV0dGVyID0gL15bYS16QS1aXTovO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmVtb3ZlIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgd2hpdGVzcGFjZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYSBzdHJpbmcuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHN0ciBTdHJpbmcgdG8gdHJpbS5cbiAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIG5ldyBzdHJpbmcgcmVwcmVzZW50aW5nIGBzdHJgIHN0cmlwcGVkIG9mIGNvbnRyb2xcbiAgICAgICAgICAgKiAgICAgY2hhcmFjdGVycyBhbmQgd2hpdGVzcGFjZSBmcm9tIGl0cyBiZWdpbm5pbmcuXG4gICAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIChzdHIgPyBzdHIgOiAnJykudG9TdHJpbmcoKS5yZXBsYWNlKGNvbnRyb2xPcldoaXRlc3BhY2UsICcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gICAgICAgICAgICogYWJvdXQ6XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICAgICAgICAgICAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gICAgICAgICAgICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAgICAgICAgICAgKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gICAgICAgICAgICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBydWxlcyA9IFtbJyMnLCAnaGFzaCddLFxuICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgICAgICAgICBbJz8nLCAncXVlcnknXSxcbiAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gICAgICAgICAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcywgdXJsKSB7XG4gICAgICAgICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgIHJldHVybiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/IGFkZHJlc3MucmVwbGFjZSgvXFxcXC9nLCAnLycpIDogYWRkcmVzcztcbiAgICAgICAgICB9LCBbJy8nLCAncGF0aG5hbWUnXSxcbiAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gICAgICAgICAgWydAJywgJ2F1dGgnLCAxXSxcbiAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICAgICAgICAgIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSxcbiAgICAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICAgICAgICAgIFsvOihcXGQqKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sXG4gICAgICAgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICAgICAgICAgIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gLy8gU2V0IGxlZnQgb3Zlci5cbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICAgICAgICAgICAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAgICAgICAgICAgKiBvcmlnaW4uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIGlnbm9yZSA9IHtcbiAgICAgICAgICAgIGhhc2g6IDEsXG4gICAgICAgICAgICBxdWVyeTogMVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAgICAgICAgICAgKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAgICAgICAgICAgKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAgICAgICAgICAgKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gICAgICAgICAgICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAgICAgICAgICAgKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICAgICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsVmFyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSB3aW5kb3c7ZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IGdsb2JhbDtlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHNlbGY7ZWxzZSBnbG9iYWxWYXIgPSB7fTtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGdsb2JhbFZhci5sb2NhdGlvbiB8fCB7fTtcbiAgICAgICAgICAgIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcbiAgICAgICAgICAgIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge30sXG4gICAgICAgICAgICAgIHR5cGUgPSB0eXBlb2YgbG9jLFxuICAgICAgICAgICAgICBrZXk7XG4gICAgICAgICAgICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgICAgICAgICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENoZWNrIHdoZXRoZXIgYSBwcm90b2NvbCBzY2hlbWUgaXMgc3BlY2lhbC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBUaGUgcHJvdG9jb2wgc2NoZW1lIG9mIHRoZSBVUkxcbiAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb3RvY29sIHNjaGVtZSBpcyBzcGVjaWFsLCBlbHNlIGBmYWxzZWBcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzU3BlY2lhbChzY2hlbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWUgPT09ICdmaWxlOicgfHwgc2NoZW1lID09PSAnZnRwOicgfHwgc2NoZW1lID09PSAnaHR0cDonIHx8IHNjaGVtZSA9PT0gJ2h0dHBzOicgfHwgc2NoZW1lID09PSAnd3M6JyB8fCBzY2hlbWUgPT09ICd3c3M6JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAgICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb25cbiAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzLCBsb2NhdGlvbikge1xuICAgICAgICAgICAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZShDUkhUTEYsICcnKTtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gfHwge307XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgICAgICAgIHZhciBmb3J3YXJkU2xhc2hlcyA9ICEhbWF0Y2hbMl07XG4gICAgICAgICAgICB2YXIgb3RoZXJTbGFzaGVzID0gISFtYXRjaFszXTtcbiAgICAgICAgICAgIHZhciBzbGFzaGVzQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIHJlc3Q7XG4gICAgICAgICAgICBpZiAoZm9yd2FyZFNsYXNoZXMpIHtcbiAgICAgICAgICAgICAgaWYgKG90aGVyU2xhc2hlcykge1xuICAgICAgICAgICAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbNF07XG4gICAgICAgICAgICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbMl0ubGVuZ3RoICsgbWF0Y2hbM10ubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzRdO1xuICAgICAgICAgICAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzJdLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKG90aGVyU2xhc2hlcykge1xuICAgICAgICAgICAgICAgIHJlc3QgPSBtYXRjaFszXSArIG1hdGNoWzRdO1xuICAgICAgICAgICAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzNdLmxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN0ID0gbWF0Y2hbNF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgICAgICAgICAgICBpZiAoc2xhc2hlc0NvdW50ID49IDIpIHtcbiAgICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1NwZWNpYWwocHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSBtYXRjaFs0XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgaWYgKGZvcndhcmRTbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xhc2hlc0NvdW50ID49IDIgJiYgaXNTcGVjaWFsKGxvY2F0aW9uLnByb3RvY29sKSkge1xuICAgICAgICAgICAgICByZXN0ID0gbWF0Y2hbNF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgICAgICAgICAgIHNsYXNoZXM6IGZvcndhcmRTbGFzaGVzIHx8IGlzU3BlY2lhbChwcm90b2NvbCksXG4gICAgICAgICAgICAgIHNsYXNoZXNDb3VudDogc2xhc2hlc0NvdW50LFxuICAgICAgICAgICAgICByZXN0OiByZXN0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUgPT09ICcnKSByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSksXG4gICAgICAgICAgICAgIGkgPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgICAgbGFzdCA9IHBhdGhbaSAtIDFdLFxuICAgICAgICAgICAgICB1bnNoaWZ0ID0gZmFsc2UsXG4gICAgICAgICAgICAgIHVwID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgICAgICAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB1cCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHVwLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICAgICAgICAgICAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGguam9pbignLycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAgICAgICAgICAgKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gICAgICAgICAgICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICAgICAgICAgICAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IFtwYXJzZXJdIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG4gICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKENSSFRMRiwgJycpO1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUsXG4gICAgICAgICAgICAgIGV4dHJhY3RlZCxcbiAgICAgICAgICAgICAgcGFyc2UsXG4gICAgICAgICAgICAgIGluc3RydWN0aW9uLFxuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpLFxuICAgICAgICAgICAgICB0eXBlID0gdHlwZW9mIGxvY2F0aW9uLFxuICAgICAgICAgICAgICB1cmwgPSB0aGlzLFxuICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gICAgICAgICAgICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAgICAgICAgICAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgICAgICAgICAgIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgICAgICAgICAgIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgICAgICAgICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG4gICAgICAgICAgICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycsIGxvY2F0aW9uKTtcbiAgICAgICAgICAgIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gICAgICAgICAgICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gICAgICAgICAgICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gICAgICAgICAgICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAgICAgICAgICAgLy8gY29tcG9uZW50LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmIChleHRyYWN0ZWQucHJvdG9jb2wgPT09ICdmaWxlOicgJiYgKGV4dHJhY3RlZC5zbGFzaGVzQ291bnQgIT09IDIgfHwgd2luZG93c0RyaXZlTGV0dGVyLnRlc3QoYWRkcmVzcykpIHx8ICFleHRyYWN0ZWQuc2xhc2hlcyAmJiAoZXh0cmFjdGVkLnByb3RvY29sIHx8IGV4dHJhY3RlZC5zbGFzaGVzQ291bnQgPCAyIHx8ICFpc1NwZWNpYWwodXJsLnByb3RvY29sKSkpIHtcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBpbnN0cnVjdGlvbihhZGRyZXNzLCB1cmwpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAgICAgICAgICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuICAgICAgICAgICAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICAgICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlID09PSAnQCcgPyBhZGRyZXNzLmxhc3RJbmRleE9mKHBhcnNlKSA6IGFkZHJlc3MuaW5kZXhPZihwYXJzZSk7XG4gICAgICAgICAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnKTtcblxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgICAgICAgICAgIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgICAgICAgICAgIC8vIHBhcnNlci5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJyAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpKSB7XG4gICAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGEgLyBmb3IgcGF0aG5hbWUgaWYgbm9uZSBleGlzdHMuIFRoaXMgbm9ybWFsaXplcyB0aGUgVVJMXG4gICAgICAgICAgICAvLyB0byBhbHdheXMgaGF2ZSBhIC9cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgIHVybC5wYXRobmFtZSA9ICcvJyArIHVybC5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gICAgICAgICAgICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gICAgICAgICAgICBpZiAodXJsLmF1dGgpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSB1cmwuYXV0aC5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICAgICAgICB1cmwudXNlcm5hbWUgPSB1cmwuYXV0aC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwudXNlcm5hbWUpKTtcbiAgICAgICAgICAgICAgICB1cmwucGFzc3dvcmQgPSB1cmwuYXV0aC5zbGljZShpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnBhc3N3b3JkKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwuYXV0aCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVybC5hdXRoID0gdXJsLnBhc3N3b3JkID8gdXJsLnVzZXJuYW1lICsgJzonICsgdXJsLnBhc3N3b3JkIDogdXJsLnVzZXJuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdCA/IHVybC5wcm90b2NvbCArICcvLycgKyB1cmwuaG9zdCA6ICdudWxsJztcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAgICAgICAgICAgKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gICAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICAgICAgICAgICAqIEByZXR1cm5zIHtVUkx9IFVSTCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzO1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdwb3J0JzpcbiAgICAgICAgICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsgJzonICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICAgICAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicgKyB1cmwucG9ydDtcbiAgICAgICAgICAgICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdob3N0JzpcbiAgICAgICAgICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocG9ydC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgICAgICAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICAgICAgICAgICAgY2FzZSAnaGFzaCc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgICAgICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICd1c2VybmFtZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3Bhc3N3b3JkJzpcbiAgICAgICAgICAgICAgICB1cmxbcGFydF0gPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhdXRoJzpcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB2YWx1ZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gdmFsdWUuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwudXNlcm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IHZhbHVlLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC5wYXNzd29yZCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaW5zID0gcnVsZXNbaV07XG4gICAgICAgICAgICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybC5hdXRoID0gdXJsLnBhc3N3b3JkID8gdXJsLnVzZXJuYW1lICsgJzonICsgdXJsLnBhc3N3b3JkIDogdXJsLnVzZXJuYW1lO1xuICAgICAgICAgICAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdCA/IHVybC5wcm90b2NvbCArICcvLycgKyB1cmwuaG9zdCA6ICdudWxsJztcbiAgICAgICAgICAgIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gICAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICAgICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgICAgICAgICAgIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcbiAgICAgICAgICAgIHZhciBxdWVyeSxcbiAgICAgICAgICAgICAgdXJsID0gdGhpcyxcbiAgICAgICAgICAgICAgaG9zdCA9IHVybC5ob3N0LFxuICAgICAgICAgICAgICBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcbiAgICAgICAgICAgIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5wcm90b2NvbCAmJiB1cmwuc2xhc2hlcyB8fCBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/ICcvLycgOiAnJyk7XG4gICAgICAgICAgICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgICAgICAgICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicgKyB1cmwucGFzc3dvcmQ7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSAnQCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5wYXNzd29yZCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gJzonICsgdXJsLnBhc3N3b3JkO1xuICAgICAgICAgICAgICByZXN1bHQgKz0gJ0AnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1cmwucHJvdG9jb2wgIT09ICdmaWxlOicgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiYgIWhvc3QgJiYgdXJsLnBhdGhuYW1lICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gQWRkIGJhY2sgdGhlIGVtcHR5IHVzZXJpbmZvLCBvdGhlcndpc2UgdGhlIG9yaWdpbmFsIGludmFsaWQgVVJMXG4gICAgICAgICAgICAgIC8vIG1pZ2h0IGJlIHRyYW5zZm9ybWVkIGludG8gYSB2YWxpZCBvbmUgd2l0aCBgdXJsLnBhdGhuYW1lYCBhcyBob3N0LlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICByZXN1bHQgKz0gJ0AnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVHJhaWxpbmcgY29sb24gaXMgcmVtb3ZlZCBmcm9tIGB1cmwuaG9zdGAgd2hlbiBpdCBpcyBwYXJzZWQuIElmIGl0IHN0aWxsXG4gICAgICAgICAgICAvLyBlbmRzIHdpdGggYSBjb2xvbiwgdGhlbiBhZGQgYmFjayB0aGUgdHJhaWxpbmcgY29sb24gdGhhdCB3YXMgcmVtb3ZlZC4gVGhpc1xuICAgICAgICAgICAgLy8gcHJldmVudHMgYW4gaW52YWxpZCBVUkwgZnJvbSBiZWluZyB0cmFuc2Zvcm1lZCBpbnRvIGEgdmFsaWQgb25lLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGlmIChob3N0W2hvc3QubGVuZ3RoIC0gMV0gPT09ICc6JyB8fCBwb3J0LnRlc3QodXJsLmhvc3RuYW1lKSAmJiAhdXJsLnBvcnQpIHtcbiAgICAgICAgICAgICAgaG9zdCArPSAnOic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gaG9zdCArIHVybC5wYXRobmFtZTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgICAgICAgICAgIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nICsgcXVlcnkgOiBxdWVyeTtcbiAgICAgICAgICAgIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgVXJsLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIHNldDogc2V0LFxuICAgICAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3JcbiAgICAgICAgICAvLyBvdGhlcnMgb3IgdGVzdGluZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIFVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG4gICAgICAgICAgVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuICAgICAgICAgIFVybC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuICAgICAgICAgIFVybC5xcyA9IHFzO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gVXJsO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfSkuY2FsbCh0aGlzLCB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcbiAgICB9LCB7XG4gICAgICBcInF1ZXJ5c3RyaW5naWZ5XCI6IDU4LFxuICAgICAgXCJyZXF1aXJlcy1wb3J0XCI6IDU5XG4gICAgfV1cbiAgfSwge30sIFsxXSkoMSk7XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sockjs-client/dist/sockjs.js\n");

/***/ }),

/***/ "./node_modules/styled-components/dist/styled-components.browser.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/styled-components/dist/styled-components.browser.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ServerStyleSheet\": () => (/* binding */ Je),\n/* harmony export */   \"StyleSheetConsumer\": () => (/* binding */ le),\n/* harmony export */   \"StyleSheetContext\": () => (/* binding */ ue),\n/* harmony export */   \"StyleSheetManager\": () => (/* binding */ ye),\n/* harmony export */   \"ThemeConsumer\": () => (/* binding */ Le),\n/* harmony export */   \"ThemeContext\": () => (/* binding */ Ge),\n/* harmony export */   \"ThemeProvider\": () => (/* binding */ Fe),\n/* harmony export */   \"__PRIVATE__\": () => (/* binding */ Ke),\n/* harmony export */   \"createGlobalStyle\": () => (/* binding */ We),\n/* harmony export */   \"css\": () => (/* binding */ Ce),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"isStyledComponent\": () => (/* binding */ N),\n/* harmony export */   \"keyframes\": () => (/* binding */ Ue),\n/* harmony export */   \"useTheme\": () => (/* binding */ Ze),\n/* harmony export */   \"version\": () => (/* binding */ C),\n/* harmony export */   \"withTheme\": () => (/* binding */ Xe)\n/* harmony export */ });\n/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var shallowequal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shallowequal */ \"./node_modules/shallowequal/index.js\");\n/* harmony import */ var shallowequal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(shallowequal__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _emotion_stylis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/stylis */ \"./node_modules/@emotion/stylis/dist/stylis.browser.esm.js\");\n/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/unitless */ \"./node_modules/@emotion/unitless/dist/unitless.browser.esm.js\");\n/* harmony import */ var _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @emotion/is-prop-valid */ \"./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! hoist-non-react-statics */ \"./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\nfunction v() {\n  return (v = Object.assign || function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n    }\n    return e;\n  }).apply(this, arguments);\n}\nvar g = function (e, t) {\n    for (var n = [e[0]], r = 0, o = t.length; r < o; r += 1) n.push(t[r], e[r + 1]);\n    return n;\n  },\n  S = function (t) {\n    return null !== t && \"object\" == typeof t && \"[object Object]\" === (t.toString ? t.toString() : Object.prototype.toString.call(t)) && !(0,react_is__WEBPACK_IMPORTED_MODULE_0__.typeOf)(t);\n  },\n  w = Object.freeze([]),\n  E = Object.freeze({});\nfunction b(e) {\n  return \"function\" == typeof e;\n}\nfunction _(e) {\n  return  true && \"string\" == typeof e && e || e.displayName || e.name || \"Component\";\n}\nfunction N(e) {\n  return e && \"string\" == typeof e.styledComponentId;\n}\nvar A = \"undefined\" != typeof process && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || \"data-styled\",\n  C = \"5.3.6\",\n  I = \"undefined\" != typeof window && \"HTMLElement\" in window,\n  P = Boolean(\"boolean\" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : \"undefined\" != typeof process && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && \"\" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? \"false\" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : \"undefined\" != typeof process && void 0 !== process.env.SC_DISABLE_SPEEDY && \"\" !== process.env.SC_DISABLE_SPEEDY ? \"false\" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : \"production\" !== \"development\"),\n  O = {},\n  R =  true ? {\n    1: \"Cannot create styled-component for component: %s.\\n\\n\",\n    2: \"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\\n\\n- Are you trying to reuse it across renders?\\n- Are you accidentally calling collectStyles twice?\\n\\n\",\n    3: \"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\\n\\n\",\n    4: \"The `StyleSheetManager` expects a valid target or sheet prop!\\n\\n- Does this error occur on the client and is your target falsy?\\n- Does this error occur on the server and is the sheet falsy?\\n\\n\",\n    5: \"The clone method cannot be used on the client!\\n\\n- Are you running in a client-like environment on the server?\\n- Are you trying to run SSR on the client?\\n\\n\",\n    6: \"Trying to insert a new style tag, but the given Node is unmounted!\\n\\n- Are you using a custom target that isn't mounted?\\n- Does your document not have a valid head element?\\n- Have you accidentally removed a style tag manually?\\n\\n\",\n    7: 'ThemeProvider: Please return an object from your \"theme\" prop function, e.g.\\n\\n```js\\ntheme={() => ({})}\\n```\\n\\n',\n    8: 'ThemeProvider: Please make your \"theme\" prop an object.\\n\\n',\n    9: \"Missing document `<head>`\\n\\n\",\n    10: \"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\\n\\n\",\n    11: \"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\\n\\n\",\n    12: \"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\\\`\\\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\\n\\n\",\n    13: \"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\\n\\n\",\n    14: 'ThemeProvider: \"theme\" prop is required.\\n\\n',\n    15: \"A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\\n\\n```js\\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\\n```\\n\\n\",\n    16: \"Reached the limit of how many styled components may be created at group %s.\\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\\nas for instance in your render method then you may be running into this limitation.\\n\\n\",\n    17: \"CSSStyleSheet could not be found on HTMLStyleElement.\\nHas styled-components' style tag been unmounted or altered by another script?\\n\"\n  } : 0;\nfunction D() {\n  for (var e = arguments.length <= 0 ? void 0 : arguments[0], t = [], n = 1, r = arguments.length; n < r; n += 1) t.push(n < 0 || arguments.length <= n ? void 0 : arguments[n]);\n  return t.forEach(function (t) {\n    e = e.replace(/%[a-z]/, t);\n  }), e;\n}\nfunction j(e) {\n  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];\n  throw  false ? 0 : new Error(D.apply(void 0, [R[e]].concat(n)).trim());\n}\nvar T = function () {\n    function e(e) {\n      this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e;\n    }\n    var t = e.prototype;\n    return t.indexOfGroup = function (e) {\n      for (var t = 0, n = 0; n < e; n++) t += this.groupSizes[n];\n      return t;\n    }, t.insertRules = function (e, t) {\n      if (e >= this.groupSizes.length) {\n        for (var n = this.groupSizes, r = n.length, o = r; e >= o;) (o <<= 1) < 0 && j(16, \"\" + e);\n        this.groupSizes = new Uint32Array(o), this.groupSizes.set(n), this.length = o;\n        for (var s = r; s < o; s++) this.groupSizes[s] = 0;\n      }\n      for (var i = this.indexOfGroup(e + 1), a = 0, c = t.length; a < c; a++) this.tag.insertRule(i, t[a]) && (this.groupSizes[e]++, i++);\n    }, t.clearGroup = function (e) {\n      if (e < this.length) {\n        var t = this.groupSizes[e],\n          n = this.indexOfGroup(e),\n          r = n + t;\n        this.groupSizes[e] = 0;\n        for (var o = n; o < r; o++) this.tag.deleteRule(n);\n      }\n    }, t.getGroup = function (e) {\n      var t = \"\";\n      if (e >= this.length || 0 === this.groupSizes[e]) return t;\n      for (var n = this.groupSizes[e], r = this.indexOfGroup(e), o = r + n, s = r; s < o; s++) t += this.tag.getRule(s) + \"/*!sc*/\\n\";\n      return t;\n    }, e;\n  }(),\n  x = new Map(),\n  k = new Map(),\n  V = 1,\n  B = function (e) {\n    if (x.has(e)) return x.get(e);\n    for (; k.has(V);) V++;\n    var t = V++;\n    return  true && ((0 | t) < 0 || t > 1 << 30) && j(16, \"\" + t), x.set(e, t), k.set(t, e), t;\n  },\n  z = function (e) {\n    return k.get(e);\n  },\n  M = function (e, t) {\n    t >= V && (V = t + 1), x.set(e, t), k.set(t, e);\n  },\n  G = \"style[\" + A + '][data-styled-version=\"5.3.6\"]',\n  L = new RegExp(\"^\" + A + '\\\\.g(\\\\d+)\\\\[id=\"([\\\\w\\\\d-]+)\"\\\\].*?\"([^\"]*)'),\n  F = function (e, t, n) {\n    for (var r, o = n.split(\",\"), s = 0, i = o.length; s < i; s++) (r = o[s]) && e.registerName(t, r);\n  },\n  Y = function (e, t) {\n    for (var n = (t.textContent || \"\").split(\"/*!sc*/\\n\"), r = [], o = 0, s = n.length; o < s; o++) {\n      var i = n[o].trim();\n      if (i) {\n        var a = i.match(L);\n        if (a) {\n          var c = 0 | parseInt(a[1], 10),\n            u = a[2];\n          0 !== c && (M(u, c), F(e, u, a[3]), e.getTag().insertRules(c, r)), r.length = 0;\n        } else r.push(i);\n      }\n    }\n  },\n  q = function () {\n    return  true ? __webpack_require__.nc : 0;\n  },\n  H = function (e) {\n    var t = document.head,\n      n = e || t,\n      r = document.createElement(\"style\"),\n      o = function (e) {\n        for (var t = e.childNodes, n = t.length; n >= 0; n--) {\n          var r = t[n];\n          if (r && 1 === r.nodeType && r.hasAttribute(A)) return r;\n        }\n      }(n),\n      s = void 0 !== o ? o.nextSibling : null;\n    r.setAttribute(A, \"active\"), r.setAttribute(\"data-styled-version\", \"5.3.6\");\n    var i = q();\n    return i && r.setAttribute(\"nonce\", i), n.insertBefore(r, s), r;\n  },\n  $ = function () {\n    function e(e) {\n      var t = this.element = H(e);\n      t.appendChild(document.createTextNode(\"\")), this.sheet = function (e) {\n        if (e.sheet) return e.sheet;\n        for (var t = document.styleSheets, n = 0, r = t.length; n < r; n++) {\n          var o = t[n];\n          if (o.ownerNode === e) return o;\n        }\n        j(17);\n      }(t), this.length = 0;\n    }\n    var t = e.prototype;\n    return t.insertRule = function (e, t) {\n      try {\n        return this.sheet.insertRule(t, e), this.length++, !0;\n      } catch (e) {\n        return !1;\n      }\n    }, t.deleteRule = function (e) {\n      this.sheet.deleteRule(e), this.length--;\n    }, t.getRule = function (e) {\n      var t = this.sheet.cssRules[e];\n      return void 0 !== t && \"string\" == typeof t.cssText ? t.cssText : \"\";\n    }, e;\n  }(),\n  W = function () {\n    function e(e) {\n      var t = this.element = H(e);\n      this.nodes = t.childNodes, this.length = 0;\n    }\n    var t = e.prototype;\n    return t.insertRule = function (e, t) {\n      if (e <= this.length && e >= 0) {\n        var n = document.createTextNode(t),\n          r = this.nodes[e];\n        return this.element.insertBefore(n, r || null), this.length++, !0;\n      }\n      return !1;\n    }, t.deleteRule = function (e) {\n      this.element.removeChild(this.nodes[e]), this.length--;\n    }, t.getRule = function (e) {\n      return e < this.length ? this.nodes[e].textContent : \"\";\n    }, e;\n  }(),\n  U = function () {\n    function e(e) {\n      this.rules = [], this.length = 0;\n    }\n    var t = e.prototype;\n    return t.insertRule = function (e, t) {\n      return e <= this.length && (this.rules.splice(e, 0, t), this.length++, !0);\n    }, t.deleteRule = function (e) {\n      this.rules.splice(e, 1), this.length--;\n    }, t.getRule = function (e) {\n      return e < this.length ? this.rules[e] : \"\";\n    }, e;\n  }(),\n  J = I,\n  X = {\n    isServer: !I,\n    useCSSOMInjection: !P\n  },\n  Z = function () {\n    function e(e, t, n) {\n      void 0 === e && (e = E), void 0 === t && (t = {}), this.options = v({}, X, {}, e), this.gs = t, this.names = new Map(n), this.server = !!e.isServer, !this.server && I && J && (J = !1, function (e) {\n        for (var t = document.querySelectorAll(G), n = 0, r = t.length; n < r; n++) {\n          var o = t[n];\n          o && \"active\" !== o.getAttribute(A) && (Y(e, o), o.parentNode && o.parentNode.removeChild(o));\n        }\n      }(this));\n    }\n    e.registerId = function (e) {\n      return B(e);\n    };\n    var t = e.prototype;\n    return t.reconstructWithOptions = function (t, n) {\n      return void 0 === n && (n = !0), new e(v({}, this.options, {}, t), this.gs, n && this.names || void 0);\n    }, t.allocateGSInstance = function (e) {\n      return this.gs[e] = (this.gs[e] || 0) + 1;\n    }, t.getTag = function () {\n      return this.tag || (this.tag = (n = (t = this.options).isServer, r = t.useCSSOMInjection, o = t.target, e = n ? new U(o) : r ? new $(o) : new W(o), new T(e)));\n      var e, t, n, r, o;\n    }, t.hasNameForId = function (e, t) {\n      return this.names.has(e) && this.names.get(e).has(t);\n    }, t.registerName = function (e, t) {\n      if (B(e), this.names.has(e)) this.names.get(e).add(t);else {\n        var n = new Set();\n        n.add(t), this.names.set(e, n);\n      }\n    }, t.insertRules = function (e, t, n) {\n      this.registerName(e, t), this.getTag().insertRules(B(e), n);\n    }, t.clearNames = function (e) {\n      this.names.has(e) && this.names.get(e).clear();\n    }, t.clearRules = function (e) {\n      this.getTag().clearGroup(B(e)), this.clearNames(e);\n    }, t.clearTag = function () {\n      this.tag = void 0;\n    }, t.toString = function () {\n      return function (e) {\n        for (var t = e.getTag(), n = t.length, r = \"\", o = 0; o < n; o++) {\n          var s = z(o);\n          if (void 0 !== s) {\n            var i = e.names.get(s),\n              a = t.getGroup(o);\n            if (i && a && i.size) {\n              var c = A + \".g\" + o + '[id=\"' + s + '\"]',\n                u = \"\";\n              void 0 !== i && i.forEach(function (e) {\n                e.length > 0 && (u += e + \",\");\n              }), r += \"\" + a + c + '{content:\"' + u + '\"}/*!sc*/\\n';\n            }\n          }\n        }\n        return r;\n      }(this);\n    }, e;\n  }(),\n  K = /(a)(d)/gi,\n  Q = function (e) {\n    return String.fromCharCode(e + (e > 25 ? 39 : 97));\n  };\nfunction ee(e) {\n  var t,\n    n = \"\";\n  for (t = Math.abs(e); t > 52; t = t / 52 | 0) n = Q(t % 52) + n;\n  return (Q(t % 52) + n).replace(K, \"$1-$2\");\n}\nvar te = function (e, t) {\n    for (var n = t.length; n;) e = 33 * e ^ t.charCodeAt(--n);\n    return e;\n  },\n  ne = function (e) {\n    return te(5381, e);\n  };\nfunction re(e) {\n  for (var t = 0; t < e.length; t += 1) {\n    var n = e[t];\n    if (b(n) && !N(n)) return !1;\n  }\n  return !0;\n}\nvar oe = ne(\"5.3.6\"),\n  se = function () {\n    function e(e, t, n) {\n      this.rules = e, this.staticRulesId = \"\", this.isStatic =  false && 0, this.componentId = t, this.baseHash = te(oe, t), this.baseStyle = n, Z.registerId(t);\n    }\n    return e.prototype.generateAndInjectStyles = function (e, t, n) {\n      var r = this.componentId,\n        o = [];\n      if (this.baseStyle && o.push(this.baseStyle.generateAndInjectStyles(e, t, n)), this.isStatic && !n.hash) {\n        if (this.staticRulesId && t.hasNameForId(r, this.staticRulesId)) o.push(this.staticRulesId);else {\n          var s = Ne(this.rules, e, t, n).join(\"\"),\n            i = ee(te(this.baseHash, s) >>> 0);\n          if (!t.hasNameForId(r, i)) {\n            var a = n(s, \".\" + i, void 0, r);\n            t.insertRules(r, i, a);\n          }\n          o.push(i), this.staticRulesId = i;\n        }\n      } else {\n        for (var c = this.rules.length, u = te(this.baseHash, n.hash), l = \"\", d = 0; d < c; d++) {\n          var h = this.rules[d];\n          if (\"string\" == typeof h) l += h,  true && (u = te(u, h + d));else if (h) {\n            var p = Ne(h, e, t, n),\n              f = Array.isArray(p) ? p.join(\"\") : p;\n            u = te(u, f + d), l += f;\n          }\n        }\n        if (l) {\n          var m = ee(u >>> 0);\n          if (!t.hasNameForId(r, m)) {\n            var y = n(l, \".\" + m, void 0, r);\n            t.insertRules(r, m, y);\n          }\n          o.push(m);\n        }\n      }\n      return o.join(\" \");\n    }, e;\n  }(),\n  ie = /^\\s*\\/\\/.*$/gm,\n  ae = [\":\", \"[\", \".\", \"#\"];\nfunction ce(e) {\n  var t,\n    n,\n    r,\n    o,\n    s = void 0 === e ? E : e,\n    i = s.options,\n    a = void 0 === i ? E : i,\n    c = s.plugins,\n    u = void 0 === c ? w : c,\n    l = new _emotion_stylis__WEBPACK_IMPORTED_MODULE_3__[\"default\"](a),\n    d = [],\n    h = function (e) {\n      function t(t) {\n        if (t) try {\n          e(t + \"}\");\n        } catch (e) {}\n      }\n      return function (n, r, o, s, i, a, c, u, l, d) {\n        switch (n) {\n          case 1:\n            if (0 === l && 64 === r.charCodeAt(0)) return e(r + \";\"), \"\";\n            break;\n          case 2:\n            if (0 === u) return r + \"/*|*/\";\n            break;\n          case 3:\n            switch (u) {\n              case 102:\n              case 112:\n                return e(o[0] + r), \"\";\n              default:\n                return r + (0 === d ? \"/*|*/\" : \"\");\n            }\n          case -2:\n            r.split(\"/*|*/}\").forEach(t);\n        }\n      };\n    }(function (e) {\n      d.push(e);\n    }),\n    f = function (e, r, s) {\n      return 0 === r && -1 !== ae.indexOf(s[n.length]) || s.match(o) ? e : \".\" + t;\n    };\n  function m(e, s, i, a) {\n    void 0 === a && (a = \"&\");\n    var c = e.replace(ie, \"\"),\n      u = s && i ? i + \" \" + s + \" { \" + c + \" }\" : c;\n    return t = a, n = s, r = new RegExp(\"\\\\\" + n + \"\\\\b\", \"g\"), o = new RegExp(\"(\\\\\" + n + \"\\\\b){2,}\"), l(i || !s ? \"\" : s, u);\n  }\n  return l.use([].concat(u, [function (e, t, o) {\n    2 === e && o.length && o[0].lastIndexOf(n) > 0 && (o[0] = o[0].replace(r, f));\n  }, h, function (e) {\n    if (-2 === e) {\n      var t = d;\n      return d = [], t;\n    }\n  }])), m.hash = u.length ? u.reduce(function (e, t) {\n    return t.name || j(15), te(e, t.name);\n  }, 5381).toString() : \"\", m;\n}\nvar ue = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(),\n  le = ue.Consumer,\n  de = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(),\n  he = (de.Consumer, new Z()),\n  pe = ce();\nfunction fe() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ue) || he;\n}\nfunction me() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(de) || pe;\n}\nfunction ye(e) {\n  var t = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(e.stylisPlugins),\n    n = t[0],\n    s = t[1],\n    c = fe(),\n    u = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n      var t = c;\n      return e.sheet ? t = e.sheet : e.target && (t = t.reconstructWithOptions({\n        target: e.target\n      }, !1)), e.disableCSSOMInjection && (t = t.reconstructWithOptions({\n        useCSSOMInjection: !1\n      })), t;\n    }, [e.disableCSSOMInjection, e.sheet, e.target]),\n    l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n      return ce({\n        options: {\n          prefix: !e.disableVendorPrefixes\n        },\n        plugins: n\n      });\n    }, [e.disableVendorPrefixes, n]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    shallowequal__WEBPACK_IMPORTED_MODULE_2___default()(n, e.stylisPlugins) || s(e.stylisPlugins);\n  }, [e.stylisPlugins]), react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ue.Provider, {\n    value: u\n  }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(de.Provider, {\n    value: l\n  },  true ? react__WEBPACK_IMPORTED_MODULE_1___default().Children.only(e.children) : 0));\n}\nvar ve = function () {\n    function e(e, t) {\n      var n = this;\n      this.inject = function (e, t) {\n        void 0 === t && (t = pe);\n        var r = n.name + t.hash;\n        e.hasNameForId(n.id, r) || e.insertRules(n.id, r, t(n.rules, r, \"@keyframes\"));\n      }, this.toString = function () {\n        return j(12, String(n.name));\n      }, this.name = e, this.id = \"sc-keyframes-\" + e, this.rules = t;\n    }\n    return e.prototype.getName = function (e) {\n      return void 0 === e && (e = pe), this.name + e.hash;\n    }, e;\n  }(),\n  ge = /([A-Z])/,\n  Se = /([A-Z])/g,\n  we = /^ms-/,\n  Ee = function (e) {\n    return \"-\" + e.toLowerCase();\n  };\nfunction be(e) {\n  return ge.test(e) ? e.replace(Se, Ee).replace(we, \"-ms-\") : e;\n}\nvar _e = function (e) {\n  return null == e || !1 === e || \"\" === e;\n};\nfunction Ne(e, n, r, o) {\n  if (Array.isArray(e)) {\n    for (var s, i = [], a = 0, c = e.length; a < c; a += 1) \"\" !== (s = Ne(e[a], n, r, o)) && (Array.isArray(s) ? i.push.apply(i, s) : i.push(s));\n    return i;\n  }\n  if (_e(e)) return \"\";\n  if (N(e)) return \".\" + e.styledComponentId;\n  if (b(e)) {\n    if (\"function\" != typeof (l = e) || l.prototype && l.prototype.isReactComponent || !n) return e;\n    var u = e(n);\n    return  true && (0,react_is__WEBPACK_IMPORTED_MODULE_0__.isElement)(u) && console.warn(_(e) + \" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\"), Ne(u, n, r, o);\n  }\n  var l;\n  return e instanceof ve ? r ? (e.inject(r, o), e.getName(o)) : e : S(e) ? function e(t, n) {\n    var r,\n      o,\n      s = [];\n    for (var i in t) t.hasOwnProperty(i) && !_e(t[i]) && (Array.isArray(t[i]) && t[i].isCss || b(t[i]) ? s.push(be(i) + \":\", t[i], \";\") : S(t[i]) ? s.push.apply(s, e(t[i], i)) : s.push(be(i) + \": \" + (r = i, null == (o = t[i]) || \"boolean\" == typeof o || \"\" === o ? \"\" : \"number\" != typeof o || 0 === o || r in _emotion_unitless__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? String(o).trim() : o + \"px\") + \";\"));\n    return n ? [n + \" {\"].concat(s, [\"}\"]) : s;\n  }(e) : e.toString();\n}\nvar Ae = function (e) {\n  return Array.isArray(e) && (e.isCss = !0), e;\n};\nfunction Ce(e) {\n  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];\n  return b(e) || S(e) ? Ae(Ne(g(w, [e].concat(n)))) : 0 === n.length && 1 === e.length && \"string\" == typeof e[0] ? e : Ae(Ne(g(e, n)));\n}\nvar Ie = /invalid hook call/i,\n  Pe = new Set(),\n  Oe = function (e, t) {\n    if (true) {\n      var n = \"The component \" + e + (t ? ' with the id of \"' + t + '\"' : \"\") + \" has been created dynamically.\\nYou may see this warning because you've called styled inside another component.\\nTo resolve this only create new StyledComponents outside of any render method and function component.\",\n        r = console.error;\n      try {\n        var o = !0;\n        console.error = function (e) {\n          if (Ie.test(e)) o = !1, Pe.delete(n);else {\n            for (var t = arguments.length, s = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) s[i - 1] = arguments[i];\n            r.apply(void 0, [e].concat(s));\n          }\n        }, (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(), o && !Pe.has(n) && (console.warn(n), Pe.add(n));\n      } catch (e) {\n        Ie.test(e.message) && Pe.delete(n);\n      } finally {\n        console.error = r;\n      }\n    }\n  },\n  Re = function (e, t, n) {\n    return void 0 === n && (n = E), e.theme !== n.theme && e.theme || t || n.theme;\n  },\n  De = /[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~-]+/g,\n  je = /(^-|-$)/g;\nfunction Te(e) {\n  return e.replace(De, \"-\").replace(je, \"\");\n}\nvar xe = function (e) {\n  return ee(ne(e) >>> 0);\n};\nfunction ke(e) {\n  return \"string\" == typeof e && ( false || e.charAt(0) === e.charAt(0).toLowerCase());\n}\nvar Ve = function (e) {\n    return \"function\" == typeof e || \"object\" == typeof e && null !== e && !Array.isArray(e);\n  },\n  Be = function (e) {\n    return \"__proto__\" !== e && \"constructor\" !== e && \"prototype\" !== e;\n  };\nfunction ze(e, t, n) {\n  var r = e[n];\n  Ve(t) && Ve(r) ? Me(r, t) : e[n] = t;\n}\nfunction Me(e) {\n  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];\n  for (var o = 0, s = n; o < s.length; o++) {\n    var i = s[o];\n    if (Ve(i)) for (var a in i) Be(a) && ze(e, i[a], a);\n  }\n  return e;\n}\nvar Ge = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(),\n  Le = Ge.Consumer;\nfunction Fe(e) {\n  var t = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge),\n    n = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n      return function (e, t) {\n        if (!e) return j(14);\n        if (b(e)) {\n          var n = e(t);\n          return  false || null !== n && !Array.isArray(n) && \"object\" == typeof n ? n : j(7);\n        }\n        return Array.isArray(e) || \"object\" != typeof e ? j(8) : t ? v({}, t, {}, e) : e;\n      }(e.theme, t);\n    }, [e.theme, t]);\n  return e.children ? react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Ge.Provider, {\n    value: n\n  }, e.children) : null;\n}\nvar Ye = {};\nfunction qe(e, t, n) {\n  var o = N(e),\n    i = !ke(e),\n    a = t.attrs,\n    c = void 0 === a ? w : a,\n    d = t.componentId,\n    h = void 0 === d ? function (e, t) {\n      var n = \"string\" != typeof e ? \"sc\" : Te(e);\n      Ye[n] = (Ye[n] || 0) + 1;\n      var r = n + \"-\" + xe(\"5.3.6\" + n + Ye[n]);\n      return t ? t + \"-\" + r : r;\n    }(t.displayName, t.parentComponentId) : d,\n    p = t.displayName,\n    f = void 0 === p ? function (e) {\n      return ke(e) ? \"styled.\" + e : \"Styled(\" + _(e) + \")\";\n    }(e) : p,\n    g = t.displayName && t.componentId ? Te(t.displayName) + \"-\" + t.componentId : t.componentId || h,\n    S = o && e.attrs ? Array.prototype.concat(e.attrs, c).filter(Boolean) : c,\n    A = t.shouldForwardProp;\n  o && e.shouldForwardProp && (A = t.shouldForwardProp ? function (n, r, o) {\n    return e.shouldForwardProp(n, r, o) && t.shouldForwardProp(n, r, o);\n  } : e.shouldForwardProp);\n  var C,\n    I = new se(n, g, o ? e.componentStyle : void 0),\n    P = I.isStatic && 0 === c.length,\n    O = function (e, t) {\n      return function (e, t, n, r) {\n        var o = e.attrs,\n          i = e.componentStyle,\n          a = e.defaultProps,\n          c = e.foldedComponentIds,\n          d = e.shouldForwardProp,\n          h = e.styledComponentId,\n          p = e.target;\n         true && (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(h);\n        var f = function (e, t, n) {\n            void 0 === e && (e = E);\n            var r = v({}, t, {\n                theme: e\n              }),\n              o = {};\n            return n.forEach(function (e) {\n              var t,\n                n,\n                s,\n                i = e;\n              for (t in b(i) && (i = i(r)), i) r[t] = o[t] = \"className\" === t ? (n = o[t], s = i[t], n && s ? n + \" \" + s : n || s) : i[t];\n            }), [r, o];\n          }(Re(t, (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge), a) || E, t, o),\n          y = f[0],\n          g = f[1],\n          S = function (e, t, n, r) {\n            var o = fe(),\n              s = me(),\n              i = t ? e.generateAndInjectStyles(E, o, s) : e.generateAndInjectStyles(n, o, s);\n            return  true && (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(i),  true && !t && r && r(i), i;\n          }(i, r, y,  true ? e.warnTooManyClasses : 0),\n          w = n,\n          _ = g.$as || t.$as || g.as || t.as || p,\n          N = ke(_),\n          A = g !== t ? v({}, t, {}, g) : t,\n          C = {};\n        for (var I in A) \"$\" !== I[0] && \"as\" !== I && (\"forwardedAs\" === I ? C.as = A[I] : (d ? d(I, _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_5__[\"default\"], _) : !N || (0,_emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(I)) && (C[I] = A[I]));\n        return t.style && g.style !== t.style && (C.style = v({}, t.style, {}, g.style)), C.className = Array.prototype.concat(c, h, S !== h ? S : null, t.className, g.className).filter(Boolean).join(\" \"), C.ref = w, (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(_, C);\n      }(C, e, t, P);\n    };\n  return O.displayName = f, (C = react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(O)).attrs = S, C.componentStyle = I, C.displayName = f, C.shouldForwardProp = A, C.foldedComponentIds = o ? Array.prototype.concat(e.foldedComponentIds, e.styledComponentId) : w, C.styledComponentId = g, C.target = o ? e.target : e, C.withComponent = function (e) {\n    var r = t.componentId,\n      o = function (e, t) {\n        if (null == e) return {};\n        var n,\n          r,\n          o = {},\n          s = Object.keys(e);\n        for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) >= 0 || (o[n] = e[n]);\n        return o;\n      }(t, [\"componentId\"]),\n      s = r && r + \"-\" + (ke(e) ? e : Te(_(e)));\n    return qe(e, v({}, o, {\n      attrs: S,\n      componentId: s\n    }), n);\n  }, Object.defineProperty(C, \"defaultProps\", {\n    get: function () {\n      return this._foldedDefaultProps;\n    },\n    set: function (t) {\n      this._foldedDefaultProps = o ? Me({}, e.defaultProps, t) : t;\n    }\n  }),  true && (Oe(f, g), C.warnTooManyClasses = function (e, t) {\n    var n = {},\n      r = !1;\n    return function (o) {\n      if (!r && (n[o] = !0, Object.keys(n).length >= 200)) {\n        var s = t ? ' with the id of \"' + t + '\"' : \"\";\n        console.warn(\"Over 200 classes were generated for component \" + e + s + \".\\nConsider using the attrs method, together with a style object for frequently changed styles.\\nExample:\\n  const Component = styled.div.attrs(props => ({\\n    style: {\\n      background: props.background,\\n    },\\n  }))`width: 100%;`\\n\\n  <Component />\"), r = !0, n = {};\n      }\n    };\n  }(f, g)), C.toString = function () {\n    return \".\" + C.styledComponentId;\n  }, i && hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6___default()(C, e, {\n    attrs: !0,\n    componentStyle: !0,\n    displayName: !0,\n    foldedComponentIds: !0,\n    shouldForwardProp: !0,\n    styledComponentId: !0,\n    target: !0,\n    withComponent: !0\n  }), C;\n}\nvar He = function (e) {\n  return function e(t, r, o) {\n    if (void 0 === o && (o = E), !(0,react_is__WEBPACK_IMPORTED_MODULE_0__.isValidElementType)(r)) return j(1, String(r));\n    var s = function () {\n      return t(r, o, Ce.apply(void 0, arguments));\n    };\n    return s.withConfig = function (n) {\n      return e(t, r, v({}, o, {}, n));\n    }, s.attrs = function (n) {\n      return e(t, r, v({}, o, {\n        attrs: Array.prototype.concat(o.attrs, n).filter(Boolean)\n      }));\n    }, s;\n  }(qe, e);\n};\n[\"a\", \"abbr\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"bdi\", \"bdo\", \"big\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"img\", \"input\", \"ins\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"nav\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"small\", \"source\", \"span\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"circle\", \"clipPath\", \"defs\", \"ellipse\", \"foreignObject\", \"g\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"stop\", \"svg\", \"text\", \"textPath\", \"tspan\"].forEach(function (e) {\n  He[e] = He(e);\n});\nvar $e = function () {\n  function e(e, t) {\n    this.rules = e, this.componentId = t, this.isStatic = re(e), Z.registerId(this.componentId + 1);\n  }\n  var t = e.prototype;\n  return t.createStyles = function (e, t, n, r) {\n    var o = r(Ne(this.rules, t, n, r).join(\"\"), \"\"),\n      s = this.componentId + e;\n    n.insertRules(s, s, o);\n  }, t.removeStyles = function (e, t) {\n    t.clearRules(this.componentId + e);\n  }, t.renderStyles = function (e, t, n, r) {\n    e > 2 && Z.registerId(this.componentId + e), this.removeStyles(e, n), this.createStyles(e, t, n, r);\n  }, e;\n}();\nfunction We(e) {\n  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++) n[o - 1] = arguments[o];\n  var i = Ce.apply(void 0, [e].concat(n)),\n    a = \"sc-global-\" + xe(JSON.stringify(i)),\n    u = new $e(i, a);\n  function l(e) {\n    var t = fe(),\n      n = me(),\n      o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge),\n      l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(t.allocateGSInstance(a)).current;\n    return  true && react__WEBPACK_IMPORTED_MODULE_1___default().Children.count(e.children) && console.warn(\"The global style component \" + a + \" was given child JSX. createGlobalStyle does not render children.\"),  true && i.some(function (e) {\n      return \"string\" == typeof e && -1 !== e.indexOf(\"@import\");\n    }) && console.warn(\"Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app.\"), t.server && h(l, e, t, o, n), (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(function () {\n      if (!t.server) return h(l, e, t, o, n), function () {\n        return u.removeStyles(l, t);\n      };\n    }, [l, e, t, o, n]), null;\n  }\n  function h(e, t, n, r, o) {\n    if (u.isStatic) u.renderStyles(e, O, n, o);else {\n      var s = v({}, t, {\n        theme: Re(t, r, l.defaultProps)\n      });\n      u.renderStyles(e, s, n, o);\n    }\n  }\n  return  true && Oe(a), react__WEBPACK_IMPORTED_MODULE_1___default().memo(l);\n}\nfunction Ue(e) {\n   true && \"undefined\" != typeof navigator && \"ReactNative\" === navigator.product && console.warn(\"`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.\");\n  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];\n  var o = Ce.apply(void 0, [e].concat(n)).join(\"\"),\n    s = xe(o);\n  return new ve(s, o);\n}\nvar Je = function () {\n    function e() {\n      var e = this;\n      this._emitSheetCSS = function () {\n        var t = e.instance.toString();\n        if (!t) return \"\";\n        var n = q();\n        return \"<style \" + [n && 'nonce=\"' + n + '\"', A + '=\"true\"', 'data-styled-version=\"5.3.6\"'].filter(Boolean).join(\" \") + \">\" + t + \"</style>\";\n      }, this.getStyleTags = function () {\n        return e.sealed ? j(2) : e._emitSheetCSS();\n      }, this.getStyleElement = function () {\n        var t;\n        if (e.sealed) return j(2);\n        var n = ((t = {})[A] = \"\", t[\"data-styled-version\"] = \"5.3.6\", t.dangerouslySetInnerHTML = {\n            __html: e.instance.toString()\n          }, t),\n          o = q();\n        return o && (n.nonce = o), [react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"style\", v({}, n, {\n          key: \"sc-0-0\"\n        }))];\n      }, this.seal = function () {\n        e.sealed = !0;\n      }, this.instance = new Z({\n        isServer: !0\n      }), this.sealed = !1;\n    }\n    var t = e.prototype;\n    return t.collectStyles = function (e) {\n      return this.sealed ? j(2) : react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ye, {\n        sheet: this.instance\n      }, e);\n    }, t.interleaveWithNodeStream = function (e) {\n      return j(3);\n    }, e;\n  }(),\n  Xe = function (e) {\n    var t = react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(function (t, n) {\n      var o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge),\n        i = e.defaultProps,\n        a = Re(t, o, i);\n      return  true && void 0 === a && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class \"' + _(e) + '\"'), react__WEBPACK_IMPORTED_MODULE_1___default().createElement(e, v({}, t, {\n        theme: a,\n        ref: n\n      }));\n    });\n    return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6___default()(t, e), t.displayName = \"WithTheme(\" + _(e) + \")\", t;\n  },\n  Ze = function () {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge);\n  },\n  Ke = {\n    StyleSheet: Z,\n    masterSheet: he\n  };\n true && \"undefined\" != typeof navigator && \"ReactNative\" === navigator.product && console.warn(\"It looks like you've imported 'styled-components' on React Native.\\nPerhaps you're looking to import 'styled-components/native'?\\nRead more about this at https://www.styled-components.com/docs/basics#react-native\"),  true && \"undefined\" != typeof window && (window[\"__styled-components-init__\"] = window[\"__styled-components-init__\"] || 0, 1 === window[\"__styled-components-init__\"] && console.warn(\"It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\\n\\nSee https://s-c.sh/2BAXzed for more info.\"), window[\"__styled-components-init__\"] += 1);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (He);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvZGlzdC9zdHlsZWQtY29tcG9uZW50cy5icm93c2VyLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvZGlzdC9zdHlsZWQtY29tcG9uZW50cy5icm93c2VyLmVzbS5qcz80OTM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHR5cGVPZiBhcyBlLCBpc0VsZW1lbnQgYXMgdCwgaXNWYWxpZEVsZW1lbnRUeXBlIGFzIG4gfSBmcm9tIFwicmVhY3QtaXNcIjtcbmltcG9ydCByLCB7IHVzZVN0YXRlIGFzIG8sIHVzZUNvbnRleHQgYXMgcywgdXNlTWVtbyBhcyBpLCB1c2VFZmZlY3QgYXMgYSwgdXNlUmVmIGFzIGMsIGNyZWF0ZUVsZW1lbnQgYXMgdSwgdXNlRGVidWdWYWx1ZSBhcyBsLCB1c2VMYXlvdXRFZmZlY3QgYXMgZCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IGggZnJvbSBcInNoYWxsb3dlcXVhbFwiO1xuaW1wb3J0IHAgZnJvbSBcIkBlbW90aW9uL3N0eWxpc1wiO1xuaW1wb3J0IGYgZnJvbSBcIkBlbW90aW9uL3VuaXRsZXNzXCI7XG5pbXBvcnQgbSBmcm9tIFwiQGVtb3Rpb24vaXMtcHJvcC12YWxpZFwiO1xuaW1wb3J0IHkgZnJvbSBcImhvaXN0LW5vbi1yZWFjdC1zdGF0aWNzXCI7XG5mdW5jdGlvbiB2KCkge1xuICByZXR1cm4gKHYgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIChlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgciBpbiBuKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcikgJiYgKGVbcl0gPSBuW3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG52YXIgZyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgZm9yICh2YXIgbiA9IFtlWzBdXSwgciA9IDAsIG8gPSB0Lmxlbmd0aDsgciA8IG87IHIgKz0gMSkgbi5wdXNoKHRbcl0sIGVbciArIDFdKTtcbiAgICByZXR1cm4gbjtcbiAgfSxcbiAgUyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIG51bGwgIT09IHQgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiBcIltvYmplY3QgT2JqZWN0XVwiID09PSAodC50b1N0cmluZyA/IHQudG9TdHJpbmcoKSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkgJiYgIWUodCk7XG4gIH0sXG4gIHcgPSBPYmplY3QuZnJlZXplKFtdKSxcbiAgRSA9IE9iamVjdC5mcmVlemUoe30pO1xuZnVuY3Rpb24gYihlKSB7XG4gIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGU7XG59XG5mdW5jdGlvbiBfKGUpIHtcbiAgcmV0dXJuIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIGUgfHwgZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgXCJDb21wb25lbnRcIjtcbn1cbmZ1bmN0aW9uIE4oZSkge1xuICByZXR1cm4gZSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBlLnN0eWxlZENvbXBvbmVudElkO1xufVxudmFyIEEgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBwcm9jZXNzICYmIChwcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfQVRUUiB8fCBwcm9jZXNzLmVudi5TQ19BVFRSKSB8fCBcImRhdGEtc3R5bGVkXCIsXG4gIEMgPSBcIjUuMy42XCIsXG4gIEkgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgXCJIVE1MRWxlbWVudFwiIGluIHdpbmRvdyxcbiAgUCA9IEJvb2xlYW4oXCJib29sZWFuXCIgPT0gdHlwZW9mIFNDX0RJU0FCTEVfU1BFRURZID8gU0NfRElTQUJMRV9TUEVFRFkgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBwcm9jZXNzICYmIHZvaWQgMCAhPT0gcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0RJU0FCTEVfU1BFRURZICYmIFwiXCIgIT09IHByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWSA/IFwiZmFsc2VcIiAhPT0gcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0RJU0FCTEVfU1BFRURZICYmIHByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWSA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHByb2Nlc3MgJiYgdm9pZCAwICE9PSBwcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWSAmJiBcIlwiICE9PSBwcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWSA/IFwiZmFsc2VcIiAhPT0gcHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFkgJiYgcHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFkgOiBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpLFxuICBPID0ge30sXG4gIFIgPSBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB7XG4gICAgMTogXCJDYW5ub3QgY3JlYXRlIHN0eWxlZC1jb21wb25lbnQgZm9yIGNvbXBvbmVudDogJXMuXFxuXFxuXCIsXG4gICAgMjogXCJDYW4ndCBjb2xsZWN0IHN0eWxlcyBvbmNlIHlvdSd2ZSBjb25zdW1lZCBhIGBTZXJ2ZXJTdHlsZVNoZWV0YCdzIHN0eWxlcyEgYFNlcnZlclN0eWxlU2hlZXRgIGlzIGEgb25lIG9mZiBpbnN0YW5jZSBmb3IgZWFjaCBzZXJ2ZXItc2lkZSByZW5kZXIgY3ljbGUuXFxuXFxuLSBBcmUgeW91IHRyeWluZyB0byByZXVzZSBpdCBhY3Jvc3MgcmVuZGVycz9cXG4tIEFyZSB5b3UgYWNjaWRlbnRhbGx5IGNhbGxpbmcgY29sbGVjdFN0eWxlcyB0d2ljZT9cXG5cXG5cIixcbiAgICAzOiBcIlN0cmVhbWluZyBTU1IgaXMgb25seSBzdXBwb3J0ZWQgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50OyBQbGVhc2UgZG8gbm90IHRyeSB0byBjYWxsIHRoaXMgbWV0aG9kIGluIHRoZSBicm93c2VyLlxcblxcblwiLFxuICAgIDQ6IFwiVGhlIGBTdHlsZVNoZWV0TWFuYWdlcmAgZXhwZWN0cyBhIHZhbGlkIHRhcmdldCBvciBzaGVldCBwcm9wIVxcblxcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBjbGllbnQgYW5kIGlzIHlvdXIgdGFyZ2V0IGZhbHN5P1xcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBzZXJ2ZXIgYW5kIGlzIHRoZSBzaGVldCBmYWxzeT9cXG5cXG5cIixcbiAgICA1OiBcIlRoZSBjbG9uZSBtZXRob2QgY2Fubm90IGJlIHVzZWQgb24gdGhlIGNsaWVudCFcXG5cXG4tIEFyZSB5b3UgcnVubmluZyBpbiBhIGNsaWVudC1saWtlIGVudmlyb25tZW50IG9uIHRoZSBzZXJ2ZXI/XFxuLSBBcmUgeW91IHRyeWluZyB0byBydW4gU1NSIG9uIHRoZSBjbGllbnQ/XFxuXFxuXCIsXG4gICAgNjogXCJUcnlpbmcgdG8gaW5zZXJ0IGEgbmV3IHN0eWxlIHRhZywgYnV0IHRoZSBnaXZlbiBOb2RlIGlzIHVubW91bnRlZCFcXG5cXG4tIEFyZSB5b3UgdXNpbmcgYSBjdXN0b20gdGFyZ2V0IHRoYXQgaXNuJ3QgbW91bnRlZD9cXG4tIERvZXMgeW91ciBkb2N1bWVudCBub3QgaGF2ZSBhIHZhbGlkIGhlYWQgZWxlbWVudD9cXG4tIEhhdmUgeW91IGFjY2lkZW50YWxseSByZW1vdmVkIGEgc3R5bGUgdGFnIG1hbnVhbGx5P1xcblxcblwiLFxuICAgIDc6ICdUaGVtZVByb3ZpZGVyOiBQbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHlvdXIgXCJ0aGVtZVwiIHByb3AgZnVuY3Rpb24sIGUuZy5cXG5cXG5gYGBqc1xcbnRoZW1lPXsoKSA9PiAoe30pfVxcbmBgYFxcblxcbicsXG4gICAgODogJ1RoZW1lUHJvdmlkZXI6IFBsZWFzZSBtYWtlIHlvdXIgXCJ0aGVtZVwiIHByb3AgYW4gb2JqZWN0LlxcblxcbicsXG4gICAgOTogXCJNaXNzaW5nIGRvY3VtZW50IGA8aGVhZD5gXFxuXFxuXCIsXG4gICAgMTA6IFwiQ2Fubm90IGZpbmQgYSBTdHlsZVNoZWV0IGluc3RhbmNlLiBVc3VhbGx5IHRoaXMgaGFwcGVucyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29waWVzIG9mIHN0eWxlZC1jb21wb25lbnRzIGxvYWRlZCBhdCBvbmNlLiBDaGVjayBvdXQgdGhpcyBpc3N1ZSBmb3IgaG93IHRvIHRyb3VibGVzaG9vdCBhbmQgZml4IHRoZSBjb21tb24gY2FzZXMgd2hlcmUgdGhpcyBzaXR1YXRpb24gY2FuIGhhcHBlbjogaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3N0eWxlZC1jb21wb25lbnRzL2lzc3Vlcy8xOTQxI2lzc3VlY29tbWVudC00MTc4NjIwMjFcXG5cXG5cIixcbiAgICAxMTogXCJfVGhpcyBlcnJvciB3YXMgcmVwbGFjZWQgd2l0aCBhIGRldi10aW1lIHdhcm5pbmcsIGl0IHdpbGwgYmUgZGVsZXRlZCBmb3IgdjQgZmluYWwuXyBbY3JlYXRlR2xvYmFsU3R5bGVdIHJlY2VpdmVkIGNoaWxkcmVuIHdoaWNoIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBQbGVhc2UgdXNlIHRoZSBjb21wb25lbnQgd2l0aG91dCBwYXNzaW5nIGNoaWxkcmVuIGVsZW1lbnRzLlxcblxcblwiLFxuICAgIDEyOiBcIkl0IHNlZW1zIHlvdSBhcmUgaW50ZXJwb2xhdGluZyBhIGtleWZyYW1lIGRlY2xhcmF0aW9uICglcykgaW50byBhbiB1bnRhZ2dlZCBzdHJpbmcuIFRoaXMgd2FzIHN1cHBvcnRlZCBpbiBzdHlsZWQtY29tcG9uZW50cyB2MywgYnV0IGlzIG5vdCBsb25nZXIgc3VwcG9ydGVkIGluIHY0IGFzIGtleWZyYW1lcyBhcmUgbm93IGluamVjdGVkIG9uLWRlbWFuZC4gUGxlYXNlIHdyYXAgeW91ciBzdHJpbmcgaW4gdGhlIGNzc1xcXFxgXFxcXGAgaGVscGVyIHdoaWNoIGVuc3VyZXMgdGhlIHN0eWxlcyBhcmUgaW5qZWN0ZWQgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYXBpI2Nzc1xcblxcblwiLFxuICAgIDEzOiBcIiVzIGlzIG5vdCBhIHN0eWxlZCBjb21wb25lbnQgYW5kIGNhbm5vdCBiZSByZWZlcnJlZCB0byB2aWEgY29tcG9uZW50IHNlbGVjdG9yLiBTZWUgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYWR2YW5jZWQjcmVmZXJyaW5nLXRvLW90aGVyLWNvbXBvbmVudHMgZm9yIG1vcmUgZGV0YWlscy5cXG5cXG5cIixcbiAgICAxNDogJ1RoZW1lUHJvdmlkZXI6IFwidGhlbWVcIiBwcm9wIGlzIHJlcXVpcmVkLlxcblxcbicsXG4gICAgMTU6IFwiQSBzdHlsaXMgcGx1Z2luIGhhcyBiZWVuIHN1cHBsaWVkIHRoYXQgaXMgbm90IG5hbWVkLiBXZSBuZWVkIGEgbmFtZSBmb3IgZWFjaCBwbHVnaW4gdG8gYmUgYWJsZSB0byBwcmV2ZW50IHN0eWxpbmcgY29sbGlzaW9ucyBiZXR3ZWVuIGRpZmZlcmVudCBzdHlsaXMgY29uZmlndXJhdGlvbnMgd2l0aGluIHRoZSBzYW1lIGFwcC4gQmVmb3JlIHlvdSBwYXNzIHlvdXIgcGx1Z2luIHRvIGA8U3R5bGVTaGVldE1hbmFnZXIgc3R5bGlzUGx1Z2lucz17W119PmAsIHBsZWFzZSBtYWtlIHN1cmUgZWFjaCBwbHVnaW4gaXMgdW5pcXVlbHktbmFtZWQsIGUuZy5cXG5cXG5gYGBqc1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbXBvcnRlZFBsdWdpbiwgJ25hbWUnLCB7IHZhbHVlOiAnc29tZS11bmlxdWUtbmFtZScgfSk7XFxuYGBgXFxuXFxuXCIsXG4gICAgMTY6IFwiUmVhY2hlZCB0aGUgbGltaXQgb2YgaG93IG1hbnkgc3R5bGVkIGNvbXBvbmVudHMgbWF5IGJlIGNyZWF0ZWQgYXQgZ3JvdXAgJXMuXFxuWW91IG1heSBvbmx5IGNyZWF0ZSB1cCB0byAxLDA3Myw3NDEsODI0IGNvbXBvbmVudHMuIElmIHlvdSdyZSBjcmVhdGluZyBjb21wb25lbnRzIGR5bmFtaWNhbGx5LFxcbmFzIGZvciBpbnN0YW5jZSBpbiB5b3VyIHJlbmRlciBtZXRob2QgdGhlbiB5b3UgbWF5IGJlIHJ1bm5pbmcgaW50byB0aGlzIGxpbWl0YXRpb24uXFxuXFxuXCIsXG4gICAgMTc6IFwiQ1NTU3R5bGVTaGVldCBjb3VsZCBub3QgYmUgZm91bmQgb24gSFRNTFN0eWxlRWxlbWVudC5cXG5IYXMgc3R5bGVkLWNvbXBvbmVudHMnIHN0eWxlIHRhZyBiZWVuIHVubW91bnRlZCBvciBhbHRlcmVkIGJ5IGFub3RoZXIgc2NyaXB0P1xcblwiXG4gIH0gOiB7fTtcbmZ1bmN0aW9uIEQoKSB7XG4gIGZvciAodmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB2b2lkIDAgOiBhcmd1bWVudHNbMF0sIHQgPSBbXSwgbiA9IDEsIHIgPSBhcmd1bWVudHMubGVuZ3RoOyBuIDwgcjsgbiArPSAxKSB0LnB1c2gobiA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBuID8gdm9pZCAwIDogYXJndW1lbnRzW25dKTtcbiAgcmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIGUgPSBlLnJlcGxhY2UoLyVbYS16XS8sIHQpO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIGooZSkge1xuICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IG5ldyBBcnJheSh0ID4gMSA/IHQgLSAxIDogMCksIHIgPSAxOyByIDwgdDsgcisrKSBuW3IgLSAxXSA9IGFyZ3VtZW50c1tyXTtcbiAgdGhyb3cgXCJwcm9kdWN0aW9uXCIgPT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gbmV3IEVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQuIFNlZSBodHRwczovL2dpdC5pby9KVUlhRSNcIiArIGUgKyBcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIiArIChuLmxlbmd0aCA+IDAgPyBcIiBBcmdzOiBcIiArIG4uam9pbihcIiwgXCIpIDogXCJcIikpIDogbmV3IEVycm9yKEQuYXBwbHkodm9pZCAwLCBbUltlXV0uY29uY2F0KG4pKS50cmltKCkpO1xufVxudmFyIFQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICB0aGlzLmdyb3VwU2l6ZXMgPSBuZXcgVWludDMyQXJyYXkoNTEyKSwgdGhpcy5sZW5ndGggPSA1MTIsIHRoaXMudGFnID0gZTtcbiAgICB9XG4gICAgdmFyIHQgPSBlLnByb3RvdHlwZTtcbiAgICByZXR1cm4gdC5pbmRleE9mR3JvdXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZm9yICh2YXIgdCA9IDAsIG4gPSAwOyBuIDwgZTsgbisrKSB0ICs9IHRoaXMuZ3JvdXBTaXplc1tuXTtcbiAgICAgIHJldHVybiB0O1xuICAgIH0sIHQuaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgaWYgKGUgPj0gdGhpcy5ncm91cFNpemVzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBuID0gdGhpcy5ncm91cFNpemVzLCByID0gbi5sZW5ndGgsIG8gPSByOyBlID49IG87KSAobyA8PD0gMSkgPCAwICYmIGooMTYsIFwiXCIgKyBlKTtcbiAgICAgICAgdGhpcy5ncm91cFNpemVzID0gbmV3IFVpbnQzMkFycmF5KG8pLCB0aGlzLmdyb3VwU2l6ZXMuc2V0KG4pLCB0aGlzLmxlbmd0aCA9IG87XG4gICAgICAgIGZvciAodmFyIHMgPSByOyBzIDwgbzsgcysrKSB0aGlzLmdyb3VwU2l6ZXNbc10gPSAwO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaW5kZXhPZkdyb3VwKGUgKyAxKSwgYSA9IDAsIGMgPSB0Lmxlbmd0aDsgYSA8IGM7IGErKykgdGhpcy50YWcuaW5zZXJ0UnVsZShpLCB0W2FdKSAmJiAodGhpcy5ncm91cFNpemVzW2VdKyssIGkrKyk7XG4gICAgfSwgdC5jbGVhckdyb3VwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmdyb3VwU2l6ZXNbZV0sXG4gICAgICAgICAgbiA9IHRoaXMuaW5kZXhPZkdyb3VwKGUpLFxuICAgICAgICAgIHIgPSBuICsgdDtcbiAgICAgICAgdGhpcy5ncm91cFNpemVzW2VdID0gMDtcbiAgICAgICAgZm9yICh2YXIgbyA9IG47IG8gPCByOyBvKyspIHRoaXMudGFnLmRlbGV0ZVJ1bGUobik7XG4gICAgICB9XG4gICAgfSwgdC5nZXRHcm91cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdCA9IFwiXCI7XG4gICAgICBpZiAoZSA+PSB0aGlzLmxlbmd0aCB8fCAwID09PSB0aGlzLmdyb3VwU2l6ZXNbZV0pIHJldHVybiB0O1xuICAgICAgZm9yICh2YXIgbiA9IHRoaXMuZ3JvdXBTaXplc1tlXSwgciA9IHRoaXMuaW5kZXhPZkdyb3VwKGUpLCBvID0gciArIG4sIHMgPSByOyBzIDwgbzsgcysrKSB0ICs9IHRoaXMudGFnLmdldFJ1bGUocykgKyBcIi8qIXNjKi9cXG5cIjtcbiAgICAgIHJldHVybiB0O1xuICAgIH0sIGU7XG4gIH0oKSxcbiAgeCA9IG5ldyBNYXAoKSxcbiAgayA9IG5ldyBNYXAoKSxcbiAgViA9IDEsXG4gIEIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICh4LmhhcyhlKSkgcmV0dXJuIHguZ2V0KGUpO1xuICAgIGZvciAoOyBrLmhhcyhWKTspIFYrKztcbiAgICB2YXIgdCA9IFYrKztcbiAgICByZXR1cm4gXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmICgoMCB8IHQpIDwgMCB8fCB0ID4gMSA8PCAzMCkgJiYgaigxNiwgXCJcIiArIHQpLCB4LnNldChlLCB0KSwgay5zZXQodCwgZSksIHQ7XG4gIH0sXG4gIHogPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBrLmdldChlKTtcbiAgfSxcbiAgTSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgdCA+PSBWICYmIChWID0gdCArIDEpLCB4LnNldChlLCB0KSwgay5zZXQodCwgZSk7XG4gIH0sXG4gIEcgPSBcInN0eWxlW1wiICsgQSArICddW2RhdGEtc3R5bGVkLXZlcnNpb249XCI1LjMuNlwiXScsXG4gIEwgPSBuZXcgUmVnRXhwKFwiXlwiICsgQSArICdcXFxcLmcoXFxcXGQrKVxcXFxbaWQ9XCIoW1xcXFx3XFxcXGQtXSspXCJcXFxcXS4qP1wiKFteXCJdKiknKSxcbiAgRiA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgZm9yICh2YXIgciwgbyA9IG4uc3BsaXQoXCIsXCIpLCBzID0gMCwgaSA9IG8ubGVuZ3RoOyBzIDwgaTsgcysrKSAociA9IG9bc10pICYmIGUucmVnaXN0ZXJOYW1lKHQsIHIpO1xuICB9LFxuICBZID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICBmb3IgKHZhciBuID0gKHQudGV4dENvbnRlbnQgfHwgXCJcIikuc3BsaXQoXCIvKiFzYyovXFxuXCIpLCByID0gW10sIG8gPSAwLCBzID0gbi5sZW5ndGg7IG8gPCBzOyBvKyspIHtcbiAgICAgIHZhciBpID0gbltvXS50cmltKCk7XG4gICAgICBpZiAoaSkge1xuICAgICAgICB2YXIgYSA9IGkubWF0Y2goTCk7XG4gICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgdmFyIGMgPSAwIHwgcGFyc2VJbnQoYVsxXSwgMTApLFxuICAgICAgICAgICAgdSA9IGFbMl07XG4gICAgICAgICAgMCAhPT0gYyAmJiAoTSh1LCBjKSwgRihlLCB1LCBhWzNdKSwgZS5nZXRUYWcoKS5pbnNlcnRSdWxlcyhjLCByKSksIHIubGVuZ3RoID0gMDtcbiAgICAgICAgfSBlbHNlIHIucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuICB9LFxuICBIID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgdCA9IGRvY3VtZW50LmhlYWQsXG4gICAgICBuID0gZSB8fCB0LFxuICAgICAgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSxcbiAgICAgIG8gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmb3IgKHZhciB0ID0gZS5jaGlsZE5vZGVzLCBuID0gdC5sZW5ndGg7IG4gPj0gMDsgbi0tKSB7XG4gICAgICAgICAgdmFyIHIgPSB0W25dO1xuICAgICAgICAgIGlmIChyICYmIDEgPT09IHIubm9kZVR5cGUgJiYgci5oYXNBdHRyaWJ1dGUoQSkpIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICB9KG4pLFxuICAgICAgcyA9IHZvaWQgMCAhPT0gbyA/IG8ubmV4dFNpYmxpbmcgOiBudWxsO1xuICAgIHIuc2V0QXR0cmlidXRlKEEsIFwiYWN0aXZlXCIpLCByLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLXZlcnNpb25cIiwgXCI1LjMuNlwiKTtcbiAgICB2YXIgaSA9IHEoKTtcbiAgICByZXR1cm4gaSAmJiByLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIGkpLCBuLmluc2VydEJlZm9yZShyLCBzKSwgcjtcbiAgfSxcbiAgJCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5lbGVtZW50ID0gSChlKTtcbiAgICAgIHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIikpLCB0aGlzLnNoZWV0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuc2hlZXQpIHJldHVybiBlLnNoZWV0O1xuICAgICAgICBmb3IgKHZhciB0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHMsIG4gPSAwLCByID0gdC5sZW5ndGg7IG4gPCByOyBuKyspIHtcbiAgICAgICAgICB2YXIgbyA9IHRbbl07XG4gICAgICAgICAgaWYgKG8ub3duZXJOb2RlID09PSBlKSByZXR1cm4gbztcbiAgICAgICAgfVxuICAgICAgICBqKDE3KTtcbiAgICAgIH0odCksIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdmFyIHQgPSBlLnByb3RvdHlwZTtcbiAgICByZXR1cm4gdC5pbnNlcnRSdWxlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoZWV0Lmluc2VydFJ1bGUodCwgZSksIHRoaXMubGVuZ3RoKyssICEwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfSwgdC5kZWxldGVSdWxlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuc2hlZXQuZGVsZXRlUnVsZShlKSwgdGhpcy5sZW5ndGgtLTtcbiAgICB9LCB0LmdldFJ1bGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLnNoZWV0LmNzc1J1bGVzW2VdO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB0LmNzc1RleHQgPyB0LmNzc1RleHQgOiBcIlwiO1xuICAgIH0sIGU7XG4gIH0oKSxcbiAgVyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5lbGVtZW50ID0gSChlKTtcbiAgICAgIHRoaXMubm9kZXMgPSB0LmNoaWxkTm9kZXMsIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdmFyIHQgPSBlLnByb3RvdHlwZTtcbiAgICByZXR1cm4gdC5pbnNlcnRSdWxlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIGlmIChlIDw9IHRoaXMubGVuZ3RoICYmIGUgPj0gMCkge1xuICAgICAgICB2YXIgbiA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHQpLFxuICAgICAgICAgIHIgPSB0aGlzLm5vZGVzW2VdO1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZShuLCByIHx8IG51bGwpLCB0aGlzLmxlbmd0aCsrLCAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCB0LmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubm9kZXNbZV0pLCB0aGlzLmxlbmd0aC0tO1xuICAgIH0sIHQuZ2V0UnVsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZSA8IHRoaXMubGVuZ3RoID8gdGhpcy5ub2Rlc1tlXS50ZXh0Q29udGVudCA6IFwiXCI7XG4gICAgfSwgZTtcbiAgfSgpLFxuICBVID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgdGhpcy5ydWxlcyA9IFtdLCB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHZhciB0ID0gZS5wcm90b3R5cGU7XG4gICAgcmV0dXJuIHQuaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICByZXR1cm4gZSA8PSB0aGlzLmxlbmd0aCAmJiAodGhpcy5ydWxlcy5zcGxpY2UoZSwgMCwgdCksIHRoaXMubGVuZ3RoKyssICEwKTtcbiAgICB9LCB0LmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5ydWxlcy5zcGxpY2UoZSwgMSksIHRoaXMubGVuZ3RoLS07XG4gICAgfSwgdC5nZXRSdWxlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlIDwgdGhpcy5sZW5ndGggPyB0aGlzLnJ1bGVzW2VdIDogXCJcIjtcbiAgICB9LCBlO1xuICB9KCksXG4gIEogPSBJLFxuICBYID0ge1xuICAgIGlzU2VydmVyOiAhSSxcbiAgICB1c2VDU1NPTUluamVjdGlvbjogIVBcbiAgfSxcbiAgWiA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBlKGUsIHQsIG4pIHtcbiAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IEUpLCB2b2lkIDAgPT09IHQgJiYgKHQgPSB7fSksIHRoaXMub3B0aW9ucyA9IHYoe30sIFgsIHt9LCBlKSwgdGhpcy5ncyA9IHQsIHRoaXMubmFtZXMgPSBuZXcgTWFwKG4pLCB0aGlzLnNlcnZlciA9ICEhZS5pc1NlcnZlciwgIXRoaXMuc2VydmVyICYmIEkgJiYgSiAmJiAoSiA9ICExLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmb3IgKHZhciB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChHKSwgbiA9IDAsIHIgPSB0Lmxlbmd0aDsgbiA8IHI7IG4rKykge1xuICAgICAgICAgIHZhciBvID0gdFtuXTtcbiAgICAgICAgICBvICYmIFwiYWN0aXZlXCIgIT09IG8uZ2V0QXR0cmlidXRlKEEpICYmIChZKGUsIG8pLCBvLnBhcmVudE5vZGUgJiYgby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pKTtcbiAgICAgICAgfVxuICAgICAgfSh0aGlzKSk7XG4gICAgfVxuICAgIGUucmVnaXN0ZXJJZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gQihlKTtcbiAgICB9O1xuICAgIHZhciB0ID0gZS5wcm90b3R5cGU7XG4gICAgcmV0dXJuIHQucmVjb25zdHJ1Y3RXaXRoT3B0aW9ucyA9IGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBuICYmIChuID0gITApLCBuZXcgZSh2KHt9LCB0aGlzLm9wdGlvbnMsIHt9LCB0KSwgdGhpcy5ncywgbiAmJiB0aGlzLm5hbWVzIHx8IHZvaWQgMCk7XG4gICAgfSwgdC5hbGxvY2F0ZUdTSW5zdGFuY2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ3NbZV0gPSAodGhpcy5nc1tlXSB8fCAwKSArIDE7XG4gICAgfSwgdC5nZXRUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWcgfHwgKHRoaXMudGFnID0gKG4gPSAodCA9IHRoaXMub3B0aW9ucykuaXNTZXJ2ZXIsIHIgPSB0LnVzZUNTU09NSW5qZWN0aW9uLCBvID0gdC50YXJnZXQsIGUgPSBuID8gbmV3IFUobykgOiByID8gbmV3ICQobykgOiBuZXcgVyhvKSwgbmV3IFQoZSkpKTtcbiAgICAgIHZhciBlLCB0LCBuLCByLCBvO1xuICAgIH0sIHQuaGFzTmFtZUZvcklkID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWVzLmhhcyhlKSAmJiB0aGlzLm5hbWVzLmdldChlKS5oYXModCk7XG4gICAgfSwgdC5yZWdpc3Rlck5hbWUgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgaWYgKEIoZSksIHRoaXMubmFtZXMuaGFzKGUpKSB0aGlzLm5hbWVzLmdldChlKS5hZGQodCk7ZWxzZSB7XG4gICAgICAgIHZhciBuID0gbmV3IFNldCgpO1xuICAgICAgICBuLmFkZCh0KSwgdGhpcy5uYW1lcy5zZXQoZSwgbik7XG4gICAgICB9XG4gICAgfSwgdC5pbnNlcnRSdWxlcyA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTmFtZShlLCB0KSwgdGhpcy5nZXRUYWcoKS5pbnNlcnRSdWxlcyhCKGUpLCBuKTtcbiAgICB9LCB0LmNsZWFyTmFtZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5uYW1lcy5oYXMoZSkgJiYgdGhpcy5uYW1lcy5nZXQoZSkuY2xlYXIoKTtcbiAgICB9LCB0LmNsZWFyUnVsZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5nZXRUYWcoKS5jbGVhckdyb3VwKEIoZSkpLCB0aGlzLmNsZWFyTmFtZXMoZSk7XG4gICAgfSwgdC5jbGVhclRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudGFnID0gdm9pZCAwO1xuICAgIH0sIHQudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IGUuZ2V0VGFnKCksIG4gPSB0Lmxlbmd0aCwgciA9IFwiXCIsIG8gPSAwOyBvIDwgbjsgbysrKSB7XG4gICAgICAgICAgdmFyIHMgPSB6KG8pO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IHMpIHtcbiAgICAgICAgICAgIHZhciBpID0gZS5uYW1lcy5nZXQocyksXG4gICAgICAgICAgICAgIGEgPSB0LmdldEdyb3VwKG8pO1xuICAgICAgICAgICAgaWYgKGkgJiYgYSAmJiBpLnNpemUpIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSBBICsgXCIuZ1wiICsgbyArICdbaWQ9XCInICsgcyArICdcIl0nLFxuICAgICAgICAgICAgICAgIHUgPSBcIlwiO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IGkgJiYgaS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5sZW5ndGggPiAwICYmICh1ICs9IGUgKyBcIixcIik7XG4gICAgICAgICAgICAgIH0pLCByICs9IFwiXCIgKyBhICsgYyArICd7Y29udGVudDpcIicgKyB1ICsgJ1wifS8qIXNjKi9cXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0odGhpcyk7XG4gICAgfSwgZTtcbiAgfSgpLFxuICBLID0gLyhhKShkKS9naSxcbiAgUSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZSArIChlID4gMjUgPyAzOSA6IDk3KSk7XG4gIH07XG5mdW5jdGlvbiBlZShlKSB7XG4gIHZhciB0LFxuICAgIG4gPSBcIlwiO1xuICBmb3IgKHQgPSBNYXRoLmFicyhlKTsgdCA+IDUyOyB0ID0gdCAvIDUyIHwgMCkgbiA9IFEodCAlIDUyKSArIG47XG4gIHJldHVybiAoUSh0ICUgNTIpICsgbikucmVwbGFjZShLLCBcIiQxLSQyXCIpO1xufVxudmFyIHRlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICBmb3IgKHZhciBuID0gdC5sZW5ndGg7IG47KSBlID0gMzMgKiBlIF4gdC5jaGFyQ29kZUF0KC0tbik7XG4gICAgcmV0dXJuIGU7XG4gIH0sXG4gIG5lID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gdGUoNTM4MSwgZSk7XG4gIH07XG5mdW5jdGlvbiByZShlKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkge1xuICAgIHZhciBuID0gZVt0XTtcbiAgICBpZiAoYihuKSAmJiAhTihuKSkgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbnZhciBvZSA9IG5lKFwiNS4zLjZcIiksXG4gIHNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGUoZSwgdCwgbikge1xuICAgICAgdGhpcy5ydWxlcyA9IGUsIHRoaXMuc3RhdGljUnVsZXNJZCA9IFwiXCIsIHRoaXMuaXNTdGF0aWMgPSBcInByb2R1Y3Rpb25cIiA9PT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgKHZvaWQgMCA9PT0gbiB8fCBuLmlzU3RhdGljKSAmJiByZShlKSwgdGhpcy5jb21wb25lbnRJZCA9IHQsIHRoaXMuYmFzZUhhc2ggPSB0ZShvZSwgdCksIHRoaXMuYmFzZVN0eWxlID0gbiwgWi5yZWdpc3RlcklkKHQpO1xuICAgIH1cbiAgICByZXR1cm4gZS5wcm90b3R5cGUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgdmFyIHIgPSB0aGlzLmNvbXBvbmVudElkLFxuICAgICAgICBvID0gW107XG4gICAgICBpZiAodGhpcy5iYXNlU3R5bGUgJiYgby5wdXNoKHRoaXMuYmFzZVN0eWxlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKGUsIHQsIG4pKSwgdGhpcy5pc1N0YXRpYyAmJiAhbi5oYXNoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRpY1J1bGVzSWQgJiYgdC5oYXNOYW1lRm9ySWQociwgdGhpcy5zdGF0aWNSdWxlc0lkKSkgby5wdXNoKHRoaXMuc3RhdGljUnVsZXNJZCk7ZWxzZSB7XG4gICAgICAgICAgdmFyIHMgPSBOZSh0aGlzLnJ1bGVzLCBlLCB0LCBuKS5qb2luKFwiXCIpLFxuICAgICAgICAgICAgaSA9IGVlKHRlKHRoaXMuYmFzZUhhc2gsIHMpID4+PiAwKTtcbiAgICAgICAgICBpZiAoIXQuaGFzTmFtZUZvcklkKHIsIGkpKSB7XG4gICAgICAgICAgICB2YXIgYSA9IG4ocywgXCIuXCIgKyBpLCB2b2lkIDAsIHIpO1xuICAgICAgICAgICAgdC5pbnNlcnRSdWxlcyhyLCBpLCBhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgby5wdXNoKGkpLCB0aGlzLnN0YXRpY1J1bGVzSWQgPSBpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBjID0gdGhpcy5ydWxlcy5sZW5ndGgsIHUgPSB0ZSh0aGlzLmJhc2VIYXNoLCBuLmhhc2gpLCBsID0gXCJcIiwgZCA9IDA7IGQgPCBjOyBkKyspIHtcbiAgICAgICAgICB2YXIgaCA9IHRoaXMucnVsZXNbZF07XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGgpIGwgKz0gaCwgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmICh1ID0gdGUodSwgaCArIGQpKTtlbHNlIGlmIChoKSB7XG4gICAgICAgICAgICB2YXIgcCA9IE5lKGgsIGUsIHQsIG4pLFxuICAgICAgICAgICAgICBmID0gQXJyYXkuaXNBcnJheShwKSA/IHAuam9pbihcIlwiKSA6IHA7XG4gICAgICAgICAgICB1ID0gdGUodSwgZiArIGQpLCBsICs9IGY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgdmFyIG0gPSBlZSh1ID4+PiAwKTtcbiAgICAgICAgICBpZiAoIXQuaGFzTmFtZUZvcklkKHIsIG0pKSB7XG4gICAgICAgICAgICB2YXIgeSA9IG4obCwgXCIuXCIgKyBtLCB2b2lkIDAsIHIpO1xuICAgICAgICAgICAgdC5pbnNlcnRSdWxlcyhyLCBtLCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgby5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gby5qb2luKFwiIFwiKTtcbiAgICB9LCBlO1xuICB9KCksXG4gIGllID0gL15cXHMqXFwvXFwvLiokL2dtLFxuICBhZSA9IFtcIjpcIiwgXCJbXCIsIFwiLlwiLCBcIiNcIl07XG5mdW5jdGlvbiBjZShlKSB7XG4gIHZhciB0LFxuICAgIG4sXG4gICAgcixcbiAgICBvLFxuICAgIHMgPSB2b2lkIDAgPT09IGUgPyBFIDogZSxcbiAgICBpID0gcy5vcHRpb25zLFxuICAgIGEgPSB2b2lkIDAgPT09IGkgPyBFIDogaSxcbiAgICBjID0gcy5wbHVnaW5zLFxuICAgIHUgPSB2b2lkIDAgPT09IGMgPyB3IDogYyxcbiAgICBsID0gbmV3IHAoYSksXG4gICAgZCA9IFtdLFxuICAgIGggPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZnVuY3Rpb24gdCh0KSB7XG4gICAgICAgIGlmICh0KSB0cnkge1xuICAgICAgICAgIGUodCArIFwifVwiKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAobiwgciwgbywgcywgaSwgYSwgYywgdSwgbCwgZCkge1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAoMCA9PT0gbCAmJiA2NCA9PT0gci5jaGFyQ29kZUF0KDApKSByZXR1cm4gZShyICsgXCI7XCIpLCBcIlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKDAgPT09IHUpIHJldHVybiByICsgXCIvKnwqL1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3dpdGNoICh1KSB7XG4gICAgICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgICAgICBjYXNlIDExMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZShvWzBdICsgciksIFwiXCI7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgKyAoMCA9PT0gZCA/IFwiLyp8Ki9cIiA6IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgLTI6XG4gICAgICAgICAgICByLnNwbGl0KFwiLyp8Ki99XCIpLmZvckVhY2godCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfShmdW5jdGlvbiAoZSkge1xuICAgICAgZC5wdXNoKGUpO1xuICAgIH0pLFxuICAgIGYgPSBmdW5jdGlvbiAoZSwgciwgcykge1xuICAgICAgcmV0dXJuIDAgPT09IHIgJiYgLTEgIT09IGFlLmluZGV4T2Yoc1tuLmxlbmd0aF0pIHx8IHMubWF0Y2gobykgPyBlIDogXCIuXCIgKyB0O1xuICAgIH07XG4gIGZ1bmN0aW9uIG0oZSwgcywgaSwgYSkge1xuICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IFwiJlwiKTtcbiAgICB2YXIgYyA9IGUucmVwbGFjZShpZSwgXCJcIiksXG4gICAgICB1ID0gcyAmJiBpID8gaSArIFwiIFwiICsgcyArIFwiIHsgXCIgKyBjICsgXCIgfVwiIDogYztcbiAgICByZXR1cm4gdCA9IGEsIG4gPSBzLCByID0gbmV3IFJlZ0V4cChcIlxcXFxcIiArIG4gKyBcIlxcXFxiXCIsIFwiZ1wiKSwgbyA9IG5ldyBSZWdFeHAoXCIoXFxcXFwiICsgbiArIFwiXFxcXGIpezIsfVwiKSwgbChpIHx8ICFzID8gXCJcIiA6IHMsIHUpO1xuICB9XG4gIHJldHVybiBsLnVzZShbXS5jb25jYXQodSwgW2Z1bmN0aW9uIChlLCB0LCBvKSB7XG4gICAgMiA9PT0gZSAmJiBvLmxlbmd0aCAmJiBvWzBdLmxhc3RJbmRleE9mKG4pID4gMCAmJiAob1swXSA9IG9bMF0ucmVwbGFjZShyLCBmKSk7XG4gIH0sIGgsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKC0yID09PSBlKSB7XG4gICAgICB2YXIgdCA9IGQ7XG4gICAgICByZXR1cm4gZCA9IFtdLCB0O1xuICAgIH1cbiAgfV0pKSwgbS5oYXNoID0gdS5sZW5ndGggPyB1LnJlZHVjZShmdW5jdGlvbiAoZSwgdCkge1xuICAgIHJldHVybiB0Lm5hbWUgfHwgaigxNSksIHRlKGUsIHQubmFtZSk7XG4gIH0sIDUzODEpLnRvU3RyaW5nKCkgOiBcIlwiLCBtO1xufVxudmFyIHVlID0gci5jcmVhdGVDb250ZXh0KCksXG4gIGxlID0gdWUuQ29uc3VtZXIsXG4gIGRlID0gci5jcmVhdGVDb250ZXh0KCksXG4gIGhlID0gKGRlLkNvbnN1bWVyLCBuZXcgWigpKSxcbiAgcGUgPSBjZSgpO1xuZnVuY3Rpb24gZmUoKSB7XG4gIHJldHVybiBzKHVlKSB8fCBoZTtcbn1cbmZ1bmN0aW9uIG1lKCkge1xuICByZXR1cm4gcyhkZSkgfHwgcGU7XG59XG5mdW5jdGlvbiB5ZShlKSB7XG4gIHZhciB0ID0gbyhlLnN0eWxpc1BsdWdpbnMpLFxuICAgIG4gPSB0WzBdLFxuICAgIHMgPSB0WzFdLFxuICAgIGMgPSBmZSgpLFxuICAgIHUgPSBpKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gYztcbiAgICAgIHJldHVybiBlLnNoZWV0ID8gdCA9IGUuc2hlZXQgOiBlLnRhcmdldCAmJiAodCA9IHQucmVjb25zdHJ1Y3RXaXRoT3B0aW9ucyh7XG4gICAgICAgIHRhcmdldDogZS50YXJnZXRcbiAgICAgIH0sICExKSksIGUuZGlzYWJsZUNTU09NSW5qZWN0aW9uICYmICh0ID0gdC5yZWNvbnN0cnVjdFdpdGhPcHRpb25zKHtcbiAgICAgICAgdXNlQ1NTT01JbmplY3Rpb246ICExXG4gICAgICB9KSksIHQ7XG4gICAgfSwgW2UuZGlzYWJsZUNTU09NSW5qZWN0aW9uLCBlLnNoZWV0LCBlLnRhcmdldF0pLFxuICAgIGwgPSBpKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjZSh7XG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBwcmVmaXg6ICFlLmRpc2FibGVWZW5kb3JQcmVmaXhlc1xuICAgICAgICB9LFxuICAgICAgICBwbHVnaW5zOiBuXG4gICAgICB9KTtcbiAgICB9LCBbZS5kaXNhYmxlVmVuZG9yUHJlZml4ZXMsIG5dKTtcbiAgcmV0dXJuIGEoZnVuY3Rpb24gKCkge1xuICAgIGgobiwgZS5zdHlsaXNQbHVnaW5zKSB8fCBzKGUuc3R5bGlzUGx1Z2lucyk7XG4gIH0sIFtlLnN0eWxpc1BsdWdpbnNdKSwgci5jcmVhdGVFbGVtZW50KHVlLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHVcbiAgfSwgci5jcmVhdGVFbGVtZW50KGRlLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGxcbiAgfSwgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gci5DaGlsZHJlbi5vbmx5KGUuY2hpbGRyZW4pIDogZS5jaGlsZHJlbikpO1xufVxudmFyIHZlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGUoZSwgdCkge1xuICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgdGhpcy5pbmplY3QgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB2b2lkIDAgPT09IHQgJiYgKHQgPSBwZSk7XG4gICAgICAgIHZhciByID0gbi5uYW1lICsgdC5oYXNoO1xuICAgICAgICBlLmhhc05hbWVGb3JJZChuLmlkLCByKSB8fCBlLmluc2VydFJ1bGVzKG4uaWQsIHIsIHQobi5ydWxlcywgciwgXCJAa2V5ZnJhbWVzXCIpKTtcbiAgICAgIH0sIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBqKDEyLCBTdHJpbmcobi5uYW1lKSk7XG4gICAgICB9LCB0aGlzLm5hbWUgPSBlLCB0aGlzLmlkID0gXCJzYy1rZXlmcmFtZXMtXCIgKyBlLCB0aGlzLnJ1bGVzID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIGUucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHBlKSwgdGhpcy5uYW1lICsgZS5oYXNoO1xuICAgIH0sIGU7XG4gIH0oKSxcbiAgZ2UgPSAvKFtBLVpdKS8sXG4gIFNlID0gLyhbQS1aXSkvZyxcbiAgd2UgPSAvXm1zLS8sXG4gIEVlID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gXCItXCIgKyBlLnRvTG93ZXJDYXNlKCk7XG4gIH07XG5mdW5jdGlvbiBiZShlKSB7XG4gIHJldHVybiBnZS50ZXN0KGUpID8gZS5yZXBsYWNlKFNlLCBFZSkucmVwbGFjZSh3ZSwgXCItbXMtXCIpIDogZTtcbn1cbnZhciBfZSA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBudWxsID09IGUgfHwgITEgPT09IGUgfHwgXCJcIiA9PT0gZTtcbn07XG5mdW5jdGlvbiBOZShlLCBuLCByLCBvKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgZm9yICh2YXIgcywgaSA9IFtdLCBhID0gMCwgYyA9IGUubGVuZ3RoOyBhIDwgYzsgYSArPSAxKSBcIlwiICE9PSAocyA9IE5lKGVbYV0sIG4sIHIsIG8pKSAmJiAoQXJyYXkuaXNBcnJheShzKSA/IGkucHVzaC5hcHBseShpLCBzKSA6IGkucHVzaChzKSk7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgaWYgKF9lKGUpKSByZXR1cm4gXCJcIjtcbiAgaWYgKE4oZSkpIHJldHVybiBcIi5cIiArIGUuc3R5bGVkQ29tcG9uZW50SWQ7XG4gIGlmIChiKGUpKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgKGwgPSBlKSB8fCBsLnByb3RvdHlwZSAmJiBsLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50IHx8ICFuKSByZXR1cm4gZTtcbiAgICB2YXIgdSA9IGUobik7XG4gICAgcmV0dXJuIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB0KHUpICYmIGNvbnNvbGUud2FybihfKGUpICsgXCIgaXMgbm90IGEgc3R5bGVkIGNvbXBvbmVudCBhbmQgY2Fubm90IGJlIHJlZmVycmVkIHRvIHZpYSBjb21wb25lbnQgc2VsZWN0b3IuIFNlZSBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hZHZhbmNlZCNyZWZlcnJpbmctdG8tb3RoZXItY29tcG9uZW50cyBmb3IgbW9yZSBkZXRhaWxzLlwiKSwgTmUodSwgbiwgciwgbyk7XG4gIH1cbiAgdmFyIGw7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgdmUgPyByID8gKGUuaW5qZWN0KHIsIG8pLCBlLmdldE5hbWUobykpIDogZSA6IFMoZSkgPyBmdW5jdGlvbiBlKHQsIG4pIHtcbiAgICB2YXIgcixcbiAgICAgIG8sXG4gICAgICBzID0gW107XG4gICAgZm9yICh2YXIgaSBpbiB0KSB0Lmhhc093blByb3BlcnR5KGkpICYmICFfZSh0W2ldKSAmJiAoQXJyYXkuaXNBcnJheSh0W2ldKSAmJiB0W2ldLmlzQ3NzIHx8IGIodFtpXSkgPyBzLnB1c2goYmUoaSkgKyBcIjpcIiwgdFtpXSwgXCI7XCIpIDogUyh0W2ldKSA/IHMucHVzaC5hcHBseShzLCBlKHRbaV0sIGkpKSA6IHMucHVzaChiZShpKSArIFwiOiBcIiArIChyID0gaSwgbnVsbCA9PSAobyA9IHRbaV0pIHx8IFwiYm9vbGVhblwiID09IHR5cGVvZiBvIHx8IFwiXCIgPT09IG8gPyBcIlwiIDogXCJudW1iZXJcIiAhPSB0eXBlb2YgbyB8fCAwID09PSBvIHx8IHIgaW4gZiA/IFN0cmluZyhvKS50cmltKCkgOiBvICsgXCJweFwiKSArIFwiO1wiKSk7XG4gICAgcmV0dXJuIG4gPyBbbiArIFwiIHtcIl0uY29uY2F0KHMsIFtcIn1cIl0pIDogcztcbiAgfShlKSA6IGUudG9TdHJpbmcoKTtcbn1cbnZhciBBZSA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGUpICYmIChlLmlzQ3NzID0gITApLCBlO1xufTtcbmZ1bmN0aW9uIENlKGUpIHtcbiAgZm9yICh2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGgsIG4gPSBuZXcgQXJyYXkodCA+IDEgPyB0IC0gMSA6IDApLCByID0gMTsgciA8IHQ7IHIrKykgbltyIC0gMV0gPSBhcmd1bWVudHNbcl07XG4gIHJldHVybiBiKGUpIHx8IFMoZSkgPyBBZShOZShnKHcsIFtlXS5jb25jYXQobikpKSkgOiAwID09PSBuLmxlbmd0aCAmJiAxID09PSBlLmxlbmd0aCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBlWzBdID8gZSA6IEFlKE5lKGcoZSwgbikpKTtcbn1cbnZhciBJZSA9IC9pbnZhbGlkIGhvb2sgY2FsbC9pLFxuICBQZSA9IG5ldyBTZXQoKSxcbiAgT2UgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhciBuID0gXCJUaGUgY29tcG9uZW50IFwiICsgZSArICh0ID8gJyB3aXRoIHRoZSBpZCBvZiBcIicgKyB0ICsgJ1wiJyA6IFwiXCIpICsgXCIgaGFzIGJlZW4gY3JlYXRlZCBkeW5hbWljYWxseS5cXG5Zb3UgbWF5IHNlZSB0aGlzIHdhcm5pbmcgYmVjYXVzZSB5b3UndmUgY2FsbGVkIHN0eWxlZCBpbnNpZGUgYW5vdGhlciBjb21wb25lbnQuXFxuVG8gcmVzb2x2ZSB0aGlzIG9ubHkgY3JlYXRlIG5ldyBTdHlsZWRDb21wb25lbnRzIG91dHNpZGUgb2YgYW55IHJlbmRlciBtZXRob2QgYW5kIGZ1bmN0aW9uIGNvbXBvbmVudC5cIixcbiAgICAgICAgciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbyA9ICEwO1xuICAgICAgICBjb25zb2xlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoSWUudGVzdChlKSkgbyA9ICExLCBQZS5kZWxldGUobik7ZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgcyA9IG5ldyBBcnJheSh0ID4gMSA/IHQgLSAxIDogMCksIGkgPSAxOyBpIDwgdDsgaSsrKSBzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIHIuYXBwbHkodm9pZCAwLCBbZV0uY29uY2F0KHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGMoKSwgbyAmJiAhUGUuaGFzKG4pICYmIChjb25zb2xlLndhcm4obiksIFBlLmFkZChuKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEllLnRlc3QoZS5tZXNzYWdlKSAmJiBQZS5kZWxldGUobik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zb2xlLmVycm9yID0gcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFJlID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gdm9pZCAwID09PSBuICYmIChuID0gRSksIGUudGhlbWUgIT09IG4udGhlbWUgJiYgZS50aGVtZSB8fCB0IHx8IG4udGhlbWU7XG4gIH0sXG4gIERlID0gL1shXCIjJCUmJygpKissLi86Ozw9Pj9AW1xcXFxcXF1eYHt8fX4tXSsvZyxcbiAgamUgPSAvKF4tfC0kKS9nO1xuZnVuY3Rpb24gVGUoZSkge1xuICByZXR1cm4gZS5yZXBsYWNlKERlLCBcIi1cIikucmVwbGFjZShqZSwgXCJcIik7XG59XG52YXIgeGUgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZWUobmUoZSkgPj4+IDApO1xufTtcbmZ1bmN0aW9uIGtlKGUpIHtcbiAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgKFwicHJvZHVjdGlvblwiID09PSBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCBlLmNoYXJBdCgwKSA9PT0gZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSk7XG59XG52YXIgVmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgfHwgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBudWxsICE9PSBlICYmICFBcnJheS5pc0FycmF5KGUpO1xuICB9LFxuICBCZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIFwiX19wcm90b19fXCIgIT09IGUgJiYgXCJjb25zdHJ1Y3RvclwiICE9PSBlICYmIFwicHJvdG90eXBlXCIgIT09IGU7XG4gIH07XG5mdW5jdGlvbiB6ZShlLCB0LCBuKSB7XG4gIHZhciByID0gZVtuXTtcbiAgVmUodCkgJiYgVmUocikgPyBNZShyLCB0KSA6IGVbbl0gPSB0O1xufVxuZnVuY3Rpb24gTWUoZSkge1xuICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IG5ldyBBcnJheSh0ID4gMSA/IHQgLSAxIDogMCksIHIgPSAxOyByIDwgdDsgcisrKSBuW3IgLSAxXSA9IGFyZ3VtZW50c1tyXTtcbiAgZm9yICh2YXIgbyA9IDAsIHMgPSBuOyBvIDwgcy5sZW5ndGg7IG8rKykge1xuICAgIHZhciBpID0gc1tvXTtcbiAgICBpZiAoVmUoaSkpIGZvciAodmFyIGEgaW4gaSkgQmUoYSkgJiYgemUoZSwgaVthXSwgYSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG52YXIgR2UgPSByLmNyZWF0ZUNvbnRleHQoKSxcbiAgTGUgPSBHZS5Db25zdW1lcjtcbmZ1bmN0aW9uIEZlKGUpIHtcbiAgdmFyIHQgPSBzKEdlKSxcbiAgICBuID0gaShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgaWYgKCFlKSByZXR1cm4gaigxNCk7XG4gICAgICAgIGlmIChiKGUpKSB7XG4gICAgICAgICAgdmFyIG4gPSBlKHQpO1xuICAgICAgICAgIHJldHVybiBcInByb2R1Y3Rpb25cIiA9PT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgbnVsbCAhPT0gbiAmJiAhQXJyYXkuaXNBcnJheShuKSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBuID8gbiA6IGooNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSA/IGooOCkgOiB0ID8gdih7fSwgdCwge30sIGUpIDogZTtcbiAgICAgIH0oZS50aGVtZSwgdCk7XG4gICAgfSwgW2UudGhlbWUsIHRdKTtcbiAgcmV0dXJuIGUuY2hpbGRyZW4gPyByLmNyZWF0ZUVsZW1lbnQoR2UuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogblxuICB9LCBlLmNoaWxkcmVuKSA6IG51bGw7XG59XG52YXIgWWUgPSB7fTtcbmZ1bmN0aW9uIHFlKGUsIHQsIG4pIHtcbiAgdmFyIG8gPSBOKGUpLFxuICAgIGkgPSAha2UoZSksXG4gICAgYSA9IHQuYXR0cnMsXG4gICAgYyA9IHZvaWQgMCA9PT0gYSA/IHcgOiBhLFxuICAgIGQgPSB0LmNvbXBvbmVudElkLFxuICAgIGggPSB2b2lkIDAgPT09IGQgPyBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgdmFyIG4gPSBcInN0cmluZ1wiICE9IHR5cGVvZiBlID8gXCJzY1wiIDogVGUoZSk7XG4gICAgICBZZVtuXSA9IChZZVtuXSB8fCAwKSArIDE7XG4gICAgICB2YXIgciA9IG4gKyBcIi1cIiArIHhlKFwiNS4zLjZcIiArIG4gKyBZZVtuXSk7XG4gICAgICByZXR1cm4gdCA/IHQgKyBcIi1cIiArIHIgOiByO1xuICAgIH0odC5kaXNwbGF5TmFtZSwgdC5wYXJlbnRDb21wb25lbnRJZCkgOiBkLFxuICAgIHAgPSB0LmRpc3BsYXlOYW1lLFxuICAgIGYgPSB2b2lkIDAgPT09IHAgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGtlKGUpID8gXCJzdHlsZWQuXCIgKyBlIDogXCJTdHlsZWQoXCIgKyBfKGUpICsgXCIpXCI7XG4gICAgfShlKSA6IHAsXG4gICAgZyA9IHQuZGlzcGxheU5hbWUgJiYgdC5jb21wb25lbnRJZCA/IFRlKHQuZGlzcGxheU5hbWUpICsgXCItXCIgKyB0LmNvbXBvbmVudElkIDogdC5jb21wb25lbnRJZCB8fCBoLFxuICAgIFMgPSBvICYmIGUuYXR0cnMgPyBBcnJheS5wcm90b3R5cGUuY29uY2F0KGUuYXR0cnMsIGMpLmZpbHRlcihCb29sZWFuKSA6IGMsXG4gICAgQSA9IHQuc2hvdWxkRm9yd2FyZFByb3A7XG4gIG8gJiYgZS5zaG91bGRGb3J3YXJkUHJvcCAmJiAoQSA9IHQuc2hvdWxkRm9yd2FyZFByb3AgPyBmdW5jdGlvbiAobiwgciwgbykge1xuICAgIHJldHVybiBlLnNob3VsZEZvcndhcmRQcm9wKG4sIHIsIG8pICYmIHQuc2hvdWxkRm9yd2FyZFByb3Aobiwgciwgbyk7XG4gIH0gOiBlLnNob3VsZEZvcndhcmRQcm9wKTtcbiAgdmFyIEMsXG4gICAgSSA9IG5ldyBzZShuLCBnLCBvID8gZS5jb21wb25lbnRTdHlsZSA6IHZvaWQgMCksXG4gICAgUCA9IEkuaXNTdGF0aWMgJiYgMCA9PT0gYy5sZW5ndGgsXG4gICAgTyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgdmFyIG8gPSBlLmF0dHJzLFxuICAgICAgICAgIGkgPSBlLmNvbXBvbmVudFN0eWxlLFxuICAgICAgICAgIGEgPSBlLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgICBjID0gZS5mb2xkZWRDb21wb25lbnRJZHMsXG4gICAgICAgICAgZCA9IGUuc2hvdWxkRm9yd2FyZFByb3AsXG4gICAgICAgICAgaCA9IGUuc3R5bGVkQ29tcG9uZW50SWQsXG4gICAgICAgICAgcCA9IGUudGFyZ2V0O1xuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgbChoKTtcbiAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gRSk7XG4gICAgICAgICAgICB2YXIgciA9IHYoe30sIHQsIHtcbiAgICAgICAgICAgICAgICB0aGVtZTogZVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICB2YXIgdCxcbiAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgICAgaSA9IGU7XG4gICAgICAgICAgICAgIGZvciAodCBpbiBiKGkpICYmIChpID0gaShyKSksIGkpIHJbdF0gPSBvW3RdID0gXCJjbGFzc05hbWVcIiA9PT0gdCA/IChuID0gb1t0XSwgcyA9IGlbdF0sIG4gJiYgcyA/IG4gKyBcIiBcIiArIHMgOiBuIHx8IHMpIDogaVt0XTtcbiAgICAgICAgICAgIH0pLCBbciwgb107XG4gICAgICAgICAgfShSZSh0LCBzKEdlKSwgYSkgfHwgRSwgdCwgbyksXG4gICAgICAgICAgeSA9IGZbMF0sXG4gICAgICAgICAgZyA9IGZbMV0sXG4gICAgICAgICAgUyA9IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGZlKCksXG4gICAgICAgICAgICAgIHMgPSBtZSgpLFxuICAgICAgICAgICAgICBpID0gdCA/IGUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMoRSwgbywgcykgOiBlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKG4sIG8sIHMpO1xuICAgICAgICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiBsKGkpLCBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgIXQgJiYgciAmJiByKGkpLCBpO1xuICAgICAgICAgIH0oaSwgciwgeSwgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gZS53YXJuVG9vTWFueUNsYXNzZXMgOiB2b2lkIDApLFxuICAgICAgICAgIHcgPSBuLFxuICAgICAgICAgIF8gPSBnLiRhcyB8fCB0LiRhcyB8fCBnLmFzIHx8IHQuYXMgfHwgcCxcbiAgICAgICAgICBOID0ga2UoXyksXG4gICAgICAgICAgQSA9IGcgIT09IHQgPyB2KHt9LCB0LCB7fSwgZykgOiB0LFxuICAgICAgICAgIEMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgSSBpbiBBKSBcIiRcIiAhPT0gSVswXSAmJiBcImFzXCIgIT09IEkgJiYgKFwiZm9yd2FyZGVkQXNcIiA9PT0gSSA/IEMuYXMgPSBBW0ldIDogKGQgPyBkKEksIG0sIF8pIDogIU4gfHwgbShJKSkgJiYgKENbSV0gPSBBW0ldKSk7XG4gICAgICAgIHJldHVybiB0LnN0eWxlICYmIGcuc3R5bGUgIT09IHQuc3R5bGUgJiYgKEMuc3R5bGUgPSB2KHt9LCB0LnN0eWxlLCB7fSwgZy5zdHlsZSkpLCBDLmNsYXNzTmFtZSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoYywgaCwgUyAhPT0gaCA/IFMgOiBudWxsLCB0LmNsYXNzTmFtZSwgZy5jbGFzc05hbWUpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKSwgQy5yZWYgPSB3LCB1KF8sIEMpO1xuICAgICAgfShDLCBlLCB0LCBQKTtcbiAgICB9O1xuICByZXR1cm4gTy5kaXNwbGF5TmFtZSA9IGYsIChDID0gci5mb3J3YXJkUmVmKE8pKS5hdHRycyA9IFMsIEMuY29tcG9uZW50U3R5bGUgPSBJLCBDLmRpc3BsYXlOYW1lID0gZiwgQy5zaG91bGRGb3J3YXJkUHJvcCA9IEEsIEMuZm9sZGVkQ29tcG9uZW50SWRzID0gbyA/IEFycmF5LnByb3RvdHlwZS5jb25jYXQoZS5mb2xkZWRDb21wb25lbnRJZHMsIGUuc3R5bGVkQ29tcG9uZW50SWQpIDogdywgQy5zdHlsZWRDb21wb25lbnRJZCA9IGcsIEMudGFyZ2V0ID0gbyA/IGUudGFyZ2V0IDogZSwgQy53aXRoQ29tcG9uZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgciA9IHQuY29tcG9uZW50SWQsXG4gICAgICBvID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgaWYgKG51bGwgPT0gZSkgcmV0dXJuIHt9O1xuICAgICAgICB2YXIgbixcbiAgICAgICAgICByLFxuICAgICAgICAgIG8gPSB7fSxcbiAgICAgICAgICBzID0gT2JqZWN0LmtleXMoZSk7XG4gICAgICAgIGZvciAociA9IDA7IHIgPCBzLmxlbmd0aDsgcisrKSBuID0gc1tyXSwgdC5pbmRleE9mKG4pID49IDAgfHwgKG9bbl0gPSBlW25dKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9KHQsIFtcImNvbXBvbmVudElkXCJdKSxcbiAgICAgIHMgPSByICYmIHIgKyBcIi1cIiArIChrZShlKSA/IGUgOiBUZShfKGUpKSk7XG4gICAgcmV0dXJuIHFlKGUsIHYoe30sIG8sIHtcbiAgICAgIGF0dHJzOiBTLFxuICAgICAgY29tcG9uZW50SWQ6IHNcbiAgICB9KSwgbik7XG4gIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm9sZGVkRGVmYXVsdFByb3BzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fZm9sZGVkRGVmYXVsdFByb3BzID0gbyA/IE1lKHt9LCBlLmRlZmF1bHRQcm9wcywgdCkgOiB0O1xuICAgIH1cbiAgfSksIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiAoT2UoZiwgZyksIEMud2FyblRvb01hbnlDbGFzc2VzID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICB2YXIgbiA9IHt9LFxuICAgICAgciA9ICExO1xuICAgIHJldHVybiBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKCFyICYmIChuW29dID0gITAsIE9iamVjdC5rZXlzKG4pLmxlbmd0aCA+PSAyMDApKSB7XG4gICAgICAgIHZhciBzID0gdCA/ICcgd2l0aCB0aGUgaWQgb2YgXCInICsgdCArICdcIicgOiBcIlwiO1xuICAgICAgICBjb25zb2xlLndhcm4oXCJPdmVyIDIwMCBjbGFzc2VzIHdlcmUgZ2VuZXJhdGVkIGZvciBjb21wb25lbnQgXCIgKyBlICsgcyArIFwiLlxcbkNvbnNpZGVyIHVzaW5nIHRoZSBhdHRycyBtZXRob2QsIHRvZ2V0aGVyIHdpdGggYSBzdHlsZSBvYmplY3QgZm9yIGZyZXF1ZW50bHkgY2hhbmdlZCBzdHlsZXMuXFxuRXhhbXBsZTpcXG4gIGNvbnN0IENvbXBvbmVudCA9IHN0eWxlZC5kaXYuYXR0cnMocHJvcHMgPT4gKHtcXG4gICAgc3R5bGU6IHtcXG4gICAgICBiYWNrZ3JvdW5kOiBwcm9wcy5iYWNrZ3JvdW5kLFxcbiAgICB9LFxcbiAgfSkpYHdpZHRoOiAxMDAlO2BcXG5cXG4gIDxDb21wb25lbnQgLz5cIiksIHIgPSAhMCwgbiA9IHt9O1xuICAgICAgfVxuICAgIH07XG4gIH0oZiwgZykpLCBDLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIi5cIiArIEMuc3R5bGVkQ29tcG9uZW50SWQ7XG4gIH0sIGkgJiYgeShDLCBlLCB7XG4gICAgYXR0cnM6ICEwLFxuICAgIGNvbXBvbmVudFN0eWxlOiAhMCxcbiAgICBkaXNwbGF5TmFtZTogITAsXG4gICAgZm9sZGVkQ29tcG9uZW50SWRzOiAhMCxcbiAgICBzaG91bGRGb3J3YXJkUHJvcDogITAsXG4gICAgc3R5bGVkQ29tcG9uZW50SWQ6ICEwLFxuICAgIHRhcmdldDogITAsXG4gICAgd2l0aENvbXBvbmVudDogITBcbiAgfSksIEM7XG59XG52YXIgSGUgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZSh0LCByLCBvKSB7XG4gICAgaWYgKHZvaWQgMCA9PT0gbyAmJiAobyA9IEUpLCAhbihyKSkgcmV0dXJuIGooMSwgU3RyaW5nKHIpKTtcbiAgICB2YXIgcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0KHIsIG8sIENlLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gcy53aXRoQ29uZmlnID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBlKHQsIHIsIHYoe30sIG8sIHt9LCBuKSk7XG4gICAgfSwgcy5hdHRycyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gZSh0LCByLCB2KHt9LCBvLCB7XG4gICAgICAgIGF0dHJzOiBBcnJheS5wcm90b3R5cGUuY29uY2F0KG8uYXR0cnMsIG4pLmZpbHRlcihCb29sZWFuKVxuICAgICAgfSkpO1xuICAgIH0sIHM7XG4gIH0ocWUsIGUpO1xufTtcbltcImFcIiwgXCJhYmJyXCIsIFwiYWRkcmVzc1wiLCBcImFyZWFcIiwgXCJhcnRpY2xlXCIsIFwiYXNpZGVcIiwgXCJhdWRpb1wiLCBcImJcIiwgXCJiYXNlXCIsIFwiYmRpXCIsIFwiYmRvXCIsIFwiYmlnXCIsIFwiYmxvY2txdW90ZVwiLCBcImJvZHlcIiwgXCJiclwiLCBcImJ1dHRvblwiLCBcImNhbnZhc1wiLCBcImNhcHRpb25cIiwgXCJjaXRlXCIsIFwiY29kZVwiLCBcImNvbFwiLCBcImNvbGdyb3VwXCIsIFwiZGF0YVwiLCBcImRhdGFsaXN0XCIsIFwiZGRcIiwgXCJkZWxcIiwgXCJkZXRhaWxzXCIsIFwiZGZuXCIsIFwiZGlhbG9nXCIsIFwiZGl2XCIsIFwiZGxcIiwgXCJkdFwiLCBcImVtXCIsIFwiZW1iZWRcIiwgXCJmaWVsZHNldFwiLCBcImZpZ2NhcHRpb25cIiwgXCJmaWd1cmVcIiwgXCJmb290ZXJcIiwgXCJmb3JtXCIsIFwiaDFcIiwgXCJoMlwiLCBcImgzXCIsIFwiaDRcIiwgXCJoNVwiLCBcImg2XCIsIFwiaGVhZFwiLCBcImhlYWRlclwiLCBcImhncm91cFwiLCBcImhyXCIsIFwiaHRtbFwiLCBcImlcIiwgXCJpZnJhbWVcIiwgXCJpbWdcIiwgXCJpbnB1dFwiLCBcImluc1wiLCBcImtiZFwiLCBcImtleWdlblwiLCBcImxhYmVsXCIsIFwibGVnZW5kXCIsIFwibGlcIiwgXCJsaW5rXCIsIFwibWFpblwiLCBcIm1hcFwiLCBcIm1hcmtcIiwgXCJtYXJxdWVlXCIsIFwibWVudVwiLCBcIm1lbnVpdGVtXCIsIFwibWV0YVwiLCBcIm1ldGVyXCIsIFwibmF2XCIsIFwibm9zY3JpcHRcIiwgXCJvYmplY3RcIiwgXCJvbFwiLCBcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCIsIFwib3V0cHV0XCIsIFwicFwiLCBcInBhcmFtXCIsIFwicGljdHVyZVwiLCBcInByZVwiLCBcInByb2dyZXNzXCIsIFwicVwiLCBcInJwXCIsIFwicnRcIiwgXCJydWJ5XCIsIFwic1wiLCBcInNhbXBcIiwgXCJzY3JpcHRcIiwgXCJzZWN0aW9uXCIsIFwic2VsZWN0XCIsIFwic21hbGxcIiwgXCJzb3VyY2VcIiwgXCJzcGFuXCIsIFwic3Ryb25nXCIsIFwic3R5bGVcIiwgXCJzdWJcIiwgXCJzdW1tYXJ5XCIsIFwic3VwXCIsIFwidGFibGVcIiwgXCJ0Ym9keVwiLCBcInRkXCIsIFwidGV4dGFyZWFcIiwgXCJ0Zm9vdFwiLCBcInRoXCIsIFwidGhlYWRcIiwgXCJ0aW1lXCIsIFwidGl0bGVcIiwgXCJ0clwiLCBcInRyYWNrXCIsIFwidVwiLCBcInVsXCIsIFwidmFyXCIsIFwidmlkZW9cIiwgXCJ3YnJcIiwgXCJjaXJjbGVcIiwgXCJjbGlwUGF0aFwiLCBcImRlZnNcIiwgXCJlbGxpcHNlXCIsIFwiZm9yZWlnbk9iamVjdFwiLCBcImdcIiwgXCJpbWFnZVwiLCBcImxpbmVcIiwgXCJsaW5lYXJHcmFkaWVudFwiLCBcIm1hcmtlclwiLCBcIm1hc2tcIiwgXCJwYXRoXCIsIFwicGF0dGVyblwiLCBcInBvbHlnb25cIiwgXCJwb2x5bGluZVwiLCBcInJhZGlhbEdyYWRpZW50XCIsIFwicmVjdFwiLCBcInN0b3BcIiwgXCJzdmdcIiwgXCJ0ZXh0XCIsIFwidGV4dFBhdGhcIiwgXCJ0c3BhblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gIEhlW2VdID0gSGUoZSk7XG59KTtcbnZhciAkZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZShlLCB0KSB7XG4gICAgdGhpcy5ydWxlcyA9IGUsIHRoaXMuY29tcG9uZW50SWQgPSB0LCB0aGlzLmlzU3RhdGljID0gcmUoZSksIFoucmVnaXN0ZXJJZCh0aGlzLmNvbXBvbmVudElkICsgMSk7XG4gIH1cbiAgdmFyIHQgPSBlLnByb3RvdHlwZTtcbiAgcmV0dXJuIHQuY3JlYXRlU3R5bGVzID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICB2YXIgbyA9IHIoTmUodGhpcy5ydWxlcywgdCwgbiwgcikuam9pbihcIlwiKSwgXCJcIiksXG4gICAgICBzID0gdGhpcy5jb21wb25lbnRJZCArIGU7XG4gICAgbi5pbnNlcnRSdWxlcyhzLCBzLCBvKTtcbiAgfSwgdC5yZW1vdmVTdHlsZXMgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgIHQuY2xlYXJSdWxlcyh0aGlzLmNvbXBvbmVudElkICsgZSk7XG4gIH0sIHQucmVuZGVyU3R5bGVzID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICBlID4gMiAmJiBaLnJlZ2lzdGVySWQodGhpcy5jb21wb25lbnRJZCArIGUpLCB0aGlzLnJlbW92ZVN0eWxlcyhlLCBuKSwgdGhpcy5jcmVhdGVTdHlsZXMoZSwgdCwgbiwgcik7XG4gIH0sIGU7XG59KCk7XG5mdW5jdGlvbiBXZShlKSB7XG4gIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBuID0gbmV3IEFycmF5KHQgPiAxID8gdCAtIDEgOiAwKSwgbyA9IDE7IG8gPCB0OyBvKyspIG5bbyAtIDFdID0gYXJndW1lbnRzW29dO1xuICB2YXIgaSA9IENlLmFwcGx5KHZvaWQgMCwgW2VdLmNvbmNhdChuKSksXG4gICAgYSA9IFwic2MtZ2xvYmFsLVwiICsgeGUoSlNPTi5zdHJpbmdpZnkoaSkpLFxuICAgIHUgPSBuZXcgJGUoaSwgYSk7XG4gIGZ1bmN0aW9uIGwoZSkge1xuICAgIHZhciB0ID0gZmUoKSxcbiAgICAgIG4gPSBtZSgpLFxuICAgICAgbyA9IHMoR2UpLFxuICAgICAgbCA9IGModC5hbGxvY2F0ZUdTSW5zdGFuY2UoYSkpLmN1cnJlbnQ7XG4gICAgcmV0dXJuIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiByLkNoaWxkcmVuLmNvdW50KGUuY2hpbGRyZW4pICYmIGNvbnNvbGUud2FybihcIlRoZSBnbG9iYWwgc3R5bGUgY29tcG9uZW50IFwiICsgYSArIFwiIHdhcyBnaXZlbiBjaGlsZCBKU1guIGNyZWF0ZUdsb2JhbFN0eWxlIGRvZXMgbm90IHJlbmRlciBjaGlsZHJlbi5cIiksIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiBpLnNvbWUoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIC0xICE9PSBlLmluZGV4T2YoXCJAaW1wb3J0XCIpO1xuICAgIH0pICYmIGNvbnNvbGUud2FybihcIlBsZWFzZSBkbyBub3QgdXNlIEBpbXBvcnQgQ1NTIHN5bnRheCBpbiBjcmVhdGVHbG9iYWxTdHlsZSBhdCB0aGlzIHRpbWUsIGFzIHRoZSBDU1NPTSBBUElzIHdlIHVzZSBpbiBwcm9kdWN0aW9uIGRvIG5vdCBoYW5kbGUgaXQgd2VsbC4gSW5zdGVhZCwgd2UgcmVjb21tZW5kIHVzaW5nIGEgbGlicmFyeSBzdWNoIGFzIHJlYWN0LWhlbG1ldCB0byBpbmplY3QgYSB0eXBpY2FsIDxsaW5rPiBtZXRhIHRhZyB0byB0aGUgc3R5bGVzaGVldCwgb3Igc2ltcGx5IGVtYmVkZGluZyBpdCBtYW51YWxseSBpbiB5b3VyIGluZGV4Lmh0bWwgPGhlYWQ+IHNlY3Rpb24gZm9yIGEgc2ltcGxlciBhcHAuXCIpLCB0LnNlcnZlciAmJiBoKGwsIGUsIHQsIG8sIG4pLCBkKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdC5zZXJ2ZXIpIHJldHVybiBoKGwsIGUsIHQsIG8sIG4pLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1LnJlbW92ZVN0eWxlcyhsLCB0KTtcbiAgICAgIH07XG4gICAgfSwgW2wsIGUsIHQsIG8sIG5dKSwgbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBoKGUsIHQsIG4sIHIsIG8pIHtcbiAgICBpZiAodS5pc1N0YXRpYykgdS5yZW5kZXJTdHlsZXMoZSwgTywgbiwgbyk7ZWxzZSB7XG4gICAgICB2YXIgcyA9IHYoe30sIHQsIHtcbiAgICAgICAgdGhlbWU6IFJlKHQsIHIsIGwuZGVmYXVsdFByb3BzKVxuICAgICAgfSk7XG4gICAgICB1LnJlbmRlclN0eWxlcyhlLCBzLCBuLCBvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiBPZShhKSwgci5tZW1vKGwpO1xufVxuZnVuY3Rpb24gVWUoZSkge1xuICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIFwiUmVhY3ROYXRpdmVcIiA9PT0gbmF2aWdhdG9yLnByb2R1Y3QgJiYgY29uc29sZS53YXJuKFwiYGtleWZyYW1lc2AgY2Fubm90IGJlIHVzZWQgb24gUmVhY3ROYXRpdmUsIG9ubHkgb24gdGhlIHdlYi4gVG8gZG8gYW5pbWF0aW9uIGluIFJlYWN0TmF0aXZlIHBsZWFzZSB1c2UgQW5pbWF0ZWQuXCIpO1xuICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IG5ldyBBcnJheSh0ID4gMSA/IHQgLSAxIDogMCksIHIgPSAxOyByIDwgdDsgcisrKSBuW3IgLSAxXSA9IGFyZ3VtZW50c1tyXTtcbiAgdmFyIG8gPSBDZS5hcHBseSh2b2lkIDAsIFtlXS5jb25jYXQobikpLmpvaW4oXCJcIiksXG4gICAgcyA9IHhlKG8pO1xuICByZXR1cm4gbmV3IHZlKHMsIG8pO1xufVxudmFyIEplID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICB0aGlzLl9lbWl0U2hlZXRDU1MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gZS5pbnN0YW5jZS50b1N0cmluZygpO1xuICAgICAgICBpZiAoIXQpIHJldHVybiBcIlwiO1xuICAgICAgICB2YXIgbiA9IHEoKTtcbiAgICAgICAgcmV0dXJuIFwiPHN0eWxlIFwiICsgW24gJiYgJ25vbmNlPVwiJyArIG4gKyAnXCInLCBBICsgJz1cInRydWVcIicsICdkYXRhLXN0eWxlZC12ZXJzaW9uPVwiNS4zLjZcIiddLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKSArIFwiPlwiICsgdCArIFwiPC9zdHlsZT5cIjtcbiAgICAgIH0sIHRoaXMuZ2V0U3R5bGVUYWdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZS5zZWFsZWQgPyBqKDIpIDogZS5fZW1pdFNoZWV0Q1NTKCk7XG4gICAgICB9LCB0aGlzLmdldFN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGlmIChlLnNlYWxlZCkgcmV0dXJuIGooMik7XG4gICAgICAgIHZhciBuID0gKCh0ID0ge30pW0FdID0gXCJcIiwgdFtcImRhdGEtc3R5bGVkLXZlcnNpb25cIl0gPSBcIjUuMy42XCIsIHQuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7XG4gICAgICAgICAgICBfX2h0bWw6IGUuaW5zdGFuY2UudG9TdHJpbmcoKVxuICAgICAgICAgIH0sIHQpLFxuICAgICAgICAgIG8gPSBxKCk7XG4gICAgICAgIHJldHVybiBvICYmIChuLm5vbmNlID0gbyksIFtyLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB2KHt9LCBuLCB7XG4gICAgICAgICAga2V5OiBcInNjLTAtMFwiXG4gICAgICAgIH0pKV07XG4gICAgICB9LCB0aGlzLnNlYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGUuc2VhbGVkID0gITA7XG4gICAgICB9LCB0aGlzLmluc3RhbmNlID0gbmV3IFooe1xuICAgICAgICBpc1NlcnZlcjogITBcbiAgICAgIH0pLCB0aGlzLnNlYWxlZCA9ICExO1xuICAgIH1cbiAgICB2YXIgdCA9IGUucHJvdG90eXBlO1xuICAgIHJldHVybiB0LmNvbGxlY3RTdHlsZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VhbGVkID8gaigyKSA6IHIuY3JlYXRlRWxlbWVudCh5ZSwge1xuICAgICAgICBzaGVldDogdGhpcy5pbnN0YW5jZVxuICAgICAgfSwgZSk7XG4gICAgfSwgdC5pbnRlcmxlYXZlV2l0aE5vZGVTdHJlYW0gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGooMyk7XG4gICAgfSwgZTtcbiAgfSgpLFxuICBYZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHQgPSByLmZvcndhcmRSZWYoZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgIHZhciBvID0gcyhHZSksXG4gICAgICAgIGkgPSBlLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgYSA9IFJlKHQsIG8sIGkpO1xuICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB2b2lkIDAgPT09IGEgJiYgY29uc29sZS53YXJuKCdbd2l0aFRoZW1lXSBZb3UgYXJlIG5vdCB1c2luZyBhIFRoZW1lUHJvdmlkZXIgbm9yIHBhc3NpbmcgYSB0aGVtZSBwcm9wIG9yIGEgdGhlbWUgaW4gZGVmYXVsdFByb3BzIGluIGNvbXBvbmVudCBjbGFzcyBcIicgKyBfKGUpICsgJ1wiJyksIHIuY3JlYXRlRWxlbWVudChlLCB2KHt9LCB0LCB7XG4gICAgICAgIHRoZW1lOiBhLFxuICAgICAgICByZWY6IG5cbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4geSh0LCBlKSwgdC5kaXNwbGF5TmFtZSA9IFwiV2l0aFRoZW1lKFwiICsgXyhlKSArIFwiKVwiLCB0O1xuICB9LFxuICBaZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcyhHZSk7XG4gIH0sXG4gIEtlID0ge1xuICAgIFN0eWxlU2hlZXQ6IFosXG4gICAgbWFzdGVyU2hlZXQ6IGhlXG4gIH07XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIFwiUmVhY3ROYXRpdmVcIiA9PT0gbmF2aWdhdG9yLnByb2R1Y3QgJiYgY29uc29sZS53YXJuKFwiSXQgbG9va3MgbGlrZSB5b3UndmUgaW1wb3J0ZWQgJ3N0eWxlZC1jb21wb25lbnRzJyBvbiBSZWFjdCBOYXRpdmUuXFxuUGVyaGFwcyB5b3UncmUgbG9va2luZyB0byBpbXBvcnQgJ3N0eWxlZC1jb21wb25lbnRzL25hdGl2ZSc/XFxuUmVhZCBtb3JlIGFib3V0IHRoaXMgYXQgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYmFzaWNzI3JlYWN0LW5hdGl2ZVwiKSwgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIFwidGVzdFwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgKHdpbmRvd1tcIl9fc3R5bGVkLWNvbXBvbmVudHMtaW5pdF9fXCJdID0gd2luZG93W1wiX19zdHlsZWQtY29tcG9uZW50cy1pbml0X19cIl0gfHwgMCwgMSA9PT0gd2luZG93W1wiX19zdHlsZWQtY29tcG9uZW50cy1pbml0X19cIl0gJiYgY29uc29sZS53YXJuKFwiSXQgbG9va3MgbGlrZSB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgJ3N0eWxlZC1jb21wb25lbnRzJyBpbml0aWFsaXplZCBpbiB0aGlzIGFwcGxpY2F0aW9uLiBUaGlzIG1heSBjYXVzZSBkeW5hbWljIHN0eWxlcyB0byBub3QgcmVuZGVyIHByb3Blcmx5LCBlcnJvcnMgZHVyaW5nIHRoZSByZWh5ZHJhdGlvbiBwcm9jZXNzLCBhIG1pc3NpbmcgdGhlbWUgcHJvcCwgYW5kIG1ha2VzIHlvdXIgYXBwbGljYXRpb24gYmlnZ2VyIHdpdGhvdXQgZ29vZCByZWFzb24uXFxuXFxuU2VlIGh0dHBzOi8vcy1jLnNoLzJCQVh6ZWQgZm9yIG1vcmUgaW5mby5cIiksIHdpbmRvd1tcIl9fc3R5bGVkLWNvbXBvbmVudHMtaW5pdF9fXCJdICs9IDEpO1xuZXhwb3J0IGRlZmF1bHQgSGU7XG5leHBvcnQgeyBKZSBhcyBTZXJ2ZXJTdHlsZVNoZWV0LCBsZSBhcyBTdHlsZVNoZWV0Q29uc3VtZXIsIHVlIGFzIFN0eWxlU2hlZXRDb250ZXh0LCB5ZSBhcyBTdHlsZVNoZWV0TWFuYWdlciwgTGUgYXMgVGhlbWVDb25zdW1lciwgR2UgYXMgVGhlbWVDb250ZXh0LCBGZSBhcyBUaGVtZVByb3ZpZGVyLCBLZSBhcyBfX1BSSVZBVEVfXywgV2UgYXMgY3JlYXRlR2xvYmFsU3R5bGUsIENlIGFzIGNzcywgTiBhcyBpc1N0eWxlZENvbXBvbmVudCwgVWUgYXMga2V5ZnJhbWVzLCBaZSBhcyB1c2VUaGVtZSwgQyBhcyB2ZXJzaW9uLCBYZSBhcyB3aXRoVGhlbWUgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/styled-components/dist/styled-components.browser.esm.js\n");

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */\n;\n(function (root) {\n  /** Detect free variables */\n  var freeExports =  true && exports && !exports.nodeType && exports;\n  var freeModule =  true && module && !module.nodeType && module;\n  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n    root = freeGlobal;\n  }\n\n  /**\n   * The `punycode` object.\n   * @name punycode\n   * @type Object\n   */\n  var punycode,\n    /** Highest positive signed 32-bit float value */\n    maxInt = 2147483647,\n    // aka. 0x7FFFFFFF or 2^31-1\n\n    /** Bootstring parameters */\n    base = 36,\n    tMin = 1,\n    tMax = 26,\n    skew = 38,\n    damp = 700,\n    initialBias = 72,\n    initialN = 128,\n    // 0x80\n    delimiter = '-',\n    // '\\x2D'\n\n    /** Regular expressions */\n    regexPunycode = /^xn--/,\n    regexNonASCII = /[^\\x20-\\x7E]/,\n    // unprintable ASCII chars + non-ASCII chars\n    regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n    // RFC 3490 separators\n\n    /** Error messages */\n    errors = {\n      'overflow': 'Overflow: input needs wider integers to process',\n      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n      'invalid-input': 'Invalid input'\n    },\n    /** Convenience shortcuts */\n    baseMinusTMin = base - tMin,\n    floor = Math.floor,\n    stringFromCharCode = String.fromCharCode,\n    /** Temporary variable */\n    key;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A generic error utility function.\n   * @private\n   * @param {String} type The error type.\n   * @returns {Error} Throws a `RangeError` with the applicable error message.\n   */\n  function error(type) {\n    throw RangeError(errors[type]);\n  }\n\n  /**\n   * A generic `Array#map` utility function.\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} callback The function that gets called for every array\n   * item.\n   * @returns {Array} A new array of values returned by the callback function.\n   */\n  function map(array, fn) {\n    var length = array.length;\n    var result = [];\n    while (length--) {\n      result[length] = fn(array[length]);\n    }\n    return result;\n  }\n\n  /**\n   * A simple `Array#map`-like wrapper to work with domain name strings or email\n   * addresses.\n   * @private\n   * @param {String} domain The domain name or email address.\n   * @param {Function} callback The function that gets called for every\n   * character.\n   * @returns {Array} A new string of characters returned by the callback\n   * function.\n   */\n  function mapDomain(string, fn) {\n    var parts = string.split('@');\n    var result = '';\n    if (parts.length > 1) {\n      // In email addresses, only the domain name should be punycoded. Leave\n      // the local part (i.e. everything up to `@`) intact.\n      result = parts[0] + '@';\n      string = parts[1];\n    }\n    // Avoid `split(regex)` for IE8 compatibility. See #17.\n    string = string.replace(regexSeparators, '\\x2E');\n    var labels = string.split('.');\n    var encoded = map(labels, fn).join('.');\n    return result + encoded;\n  }\n\n  /**\n   * Creates an array containing the numeric code points of each Unicode\n   * character in the string. While JavaScript uses UCS-2 internally,\n   * this function will convert a pair of surrogate halves (each of which\n   * UCS-2 exposes as separate characters) into a single code point,\n   * matching UTF-16.\n   * @see `punycode.ucs2.encode`\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\n   * @memberOf punycode.ucs2\n   * @name decode\n   * @param {String} string The Unicode input string (UCS-2).\n   * @returns {Array} The new array of code points.\n   */\n  function ucs2decode(string) {\n    var output = [],\n      counter = 0,\n      length = string.length,\n      value,\n      extra;\n    while (counter < length) {\n      value = string.charCodeAt(counter++);\n      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n        // high surrogate, and there is a next character\n        extra = string.charCodeAt(counter++);\n        if ((extra & 0xFC00) == 0xDC00) {\n          // low surrogate\n          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n        } else {\n          // unmatched surrogate; only append this code unit, in case the next\n          // code unit is the high surrogate of a surrogate pair\n          output.push(value);\n          counter--;\n        }\n      } else {\n        output.push(value);\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Creates a string based on an array of numeric code points.\n   * @see `punycode.ucs2.decode`\n   * @memberOf punycode.ucs2\n   * @name encode\n   * @param {Array} codePoints The array of numeric code points.\n   * @returns {String} The new Unicode string (UCS-2).\n   */\n  function ucs2encode(array) {\n    return map(array, function (value) {\n      var output = '';\n      if (value > 0xFFFF) {\n        value -= 0x10000;\n        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n        value = 0xDC00 | value & 0x3FF;\n      }\n      output += stringFromCharCode(value);\n      return output;\n    }).join('');\n  }\n\n  /**\n   * Converts a basic code point into a digit/integer.\n   * @see `digitToBasic()`\n   * @private\n   * @param {Number} codePoint The basic numeric code point value.\n   * @returns {Number} The numeric value of a basic code point (for use in\n   * representing integers) in the range `0` to `base - 1`, or `base` if\n   * the code point does not represent a value.\n   */\n  function basicToDigit(codePoint) {\n    if (codePoint - 48 < 10) {\n      return codePoint - 22;\n    }\n    if (codePoint - 65 < 26) {\n      return codePoint - 65;\n    }\n    if (codePoint - 97 < 26) {\n      return codePoint - 97;\n    }\n    return base;\n  }\n\n  /**\n   * Converts a digit/integer into a basic code point.\n   * @see `basicToDigit()`\n   * @private\n   * @param {Number} digit The numeric value of a basic code point.\n   * @returns {Number} The basic code point whose value (when used for\n   * representing integers) is `digit`, which needs to be in the range\n   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n   * used; else, the lowercase form is used. The behavior is undefined\n   * if `flag` is non-zero and `digit` has no uppercase form.\n   */\n  function digitToBasic(digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n  }\n\n  /**\n   * Bias adaptation function as per section 3.4 of RFC 3492.\n   * http://tools.ietf.org/html/rfc3492#section-3.4\n   * @private\n   */\n  function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for /* no initialization */\n    (; delta > baseMinusTMin * tMax >> 1; k += base) {\n      delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n  }\n\n  /**\n   * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n   * symbols.\n   * @memberOf punycode\n   * @param {String} input The Punycode string of ASCII-only symbols.\n   * @returns {String} The resulting string of Unicode symbols.\n   */\n  function decode(input) {\n    // Don't use UCS-2\n    var output = [],\n      inputLength = input.length,\n      out,\n      i = 0,\n      n = initialN,\n      bias = initialBias,\n      basic,\n      j,\n      index,\n      oldi,\n      w,\n      k,\n      digit,\n      t,\n      /** Cached calculation results */\n      baseMinusT;\n\n    // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n\n    basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n      basic = 0;\n    }\n    for (j = 0; j < basic; ++j) {\n      // if it's not a basic code point\n      if (input.charCodeAt(j) >= 0x80) {\n        error('not-basic');\n      }\n      output.push(input.charCodeAt(j));\n    }\n\n    // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n\n    for /* no final expression */\n    (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n      // `index` is the index of the next character to be consumed.\n      // Decode a generalized variable-length integer into `delta`,\n      // which gets added to `i`. The overflow checking is easier\n      // if we increase `i` as we go, then subtract off its starting\n      // value at the end to obtain `delta`.\n      for /* no condition */\n      (oldi = i, w = 1, k = base;; k += base) {\n        if (index >= inputLength) {\n          error('invalid-input');\n        }\n        digit = basicToDigit(input.charCodeAt(index++));\n        if (digit >= base || digit > floor((maxInt - i) / w)) {\n          error('overflow');\n        }\n        i += digit * w;\n        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n        if (digit < t) {\n          break;\n        }\n        baseMinusT = base - t;\n        if (w > floor(maxInt / baseMinusT)) {\n          error('overflow');\n        }\n        w *= baseMinusT;\n      }\n      out = output.length + 1;\n      bias = adapt(i - oldi, out, oldi == 0);\n\n      // `i` was supposed to wrap around from `out` to `0`,\n      // incrementing `n` each time, so we'll fix that now:\n      if (floor(i / out) > maxInt - n) {\n        error('overflow');\n      }\n      n += floor(i / out);\n      i %= out;\n\n      // Insert `n` at position `i` of the output\n      output.splice(i++, 0, n);\n    }\n    return ucs2encode(output);\n  }\n\n  /**\n   * Converts a string of Unicode symbols (e.g. a domain name label) to a\n   * Punycode string of ASCII-only symbols.\n   * @memberOf punycode\n   * @param {String} input The string of Unicode symbols.\n   * @returns {String} The resulting Punycode string of ASCII-only symbols.\n   */\n  function encode(input) {\n    var n,\n      delta,\n      handledCPCount,\n      basicLength,\n      bias,\n      j,\n      m,\n      q,\n      k,\n      t,\n      currentValue,\n      output = [],\n      /** `inputLength` will hold the number of code points in `input`. */\n      inputLength,\n      /** Cached calculation results */\n      handledCPCountPlusOne,\n      baseMinusT,\n      qMinusT;\n\n    // Convert the input in UCS-2 to Unicode\n    input = ucs2decode(input);\n\n    // Cache the length\n    inputLength = input.length;\n\n    // Initialize the state\n    n = initialN;\n    delta = 0;\n    bias = initialBias;\n\n    // Handle the basic code points\n    for (j = 0; j < inputLength; ++j) {\n      currentValue = input[j];\n      if (currentValue < 0x80) {\n        output.push(stringFromCharCode(currentValue));\n      }\n    }\n    handledCPCount = basicLength = output.length;\n\n    // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n\n    // Finish the basic string - if it is not empty - with a delimiter\n    if (basicLength) {\n      output.push(delimiter);\n    }\n\n    // Main encoding loop:\n    while (handledCPCount < inputLength) {\n      // All non-basic code points < n have been handled already. Find the next\n      // larger one:\n      for (m = maxInt, j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue >= n && currentValue < m) {\n          m = currentValue;\n        }\n      }\n\n      // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n      // but guard against overflow\n      handledCPCountPlusOne = handledCPCount + 1;\n      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n        error('overflow');\n      }\n      delta += (m - n) * handledCPCountPlusOne;\n      n = m;\n      for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue < n && ++delta > maxInt) {\n          error('overflow');\n        }\n        if (currentValue == n) {\n          // Represent delta as a generalized variable-length integer\n          for /* no condition */\n          (q = delta, k = base;; k += base) {\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n            if (q < t) {\n              break;\n            }\n            qMinusT = q - t;\n            baseMinusT = base - t;\n            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n            q = floor(qMinusT / baseMinusT);\n          }\n          output.push(stringFromCharCode(digitToBasic(q, 0)));\n          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n          delta = 0;\n          ++handledCPCount;\n        }\n      }\n      ++delta;\n      ++n;\n    }\n    return output.join('');\n  }\n\n  /**\n   * Converts a Punycode string representing a domain name or an email address\n   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n   * it doesn't matter if you call it on a string that has already been\n   * converted to Unicode.\n   * @memberOf punycode\n   * @param {String} input The Punycoded domain name or email address to\n   * convert to Unicode.\n   * @returns {String} The Unicode representation of the given Punycode\n   * string.\n   */\n  function toUnicode(input) {\n    return mapDomain(input, function (string) {\n      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    });\n  }\n\n  /**\n   * Converts a Unicode string representing a domain name or an email address to\n   * Punycode. Only the non-ASCII parts of the domain name will be converted,\n   * i.e. it doesn't matter if you call it with a domain that's already in\n   * ASCII.\n   * @memberOf punycode\n   * @param {String} input The domain name or email address to convert, as a\n   * Unicode string.\n   * @returns {String} The Punycode representation of the given domain name or\n   * email address.\n   */\n  function toASCII(input) {\n    return mapDomain(input, function (string) {\n      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n    });\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Define the public API */\n  punycode = {\n    /**\n     * A string representing the current Punycode.js version number.\n     * @memberOf punycode\n     * @type String\n     */\n    'version': '1.3.2',\n    /**\n     * An object of methods to convert from JavaScript's internal character\n     * representation (UCS-2) to Unicode code points, and back.\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode\n     * @type Object\n     */\n    'ucs2': {\n      'decode': ucs2decode,\n      'encode': ucs2encode\n    },\n    'decode': decode,\n    'encode': encode,\n    'toASCII': toASCII,\n    'toUnicode': toUnicode\n  };\n\n  /** Expose `punycode` */\n  // Some AMD build optimizers, like r.js, check for specific condition patterns\n  // like the following:\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return punycode;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFjQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcz80N2FhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47XG4oZnVuY3Rpb24gKHJvb3QpIHtcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG4gIHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWwpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG4gICAqIEBuYW1lIHB1bnljb2RlXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cbiAgdmFyIHB1bnljb2RlLFxuICAgIC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cbiAgICBtYXhJbnQgPSAyMTQ3NDgzNjQ3LFxuICAgIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuICAgIC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cbiAgICBiYXNlID0gMzYsXG4gICAgdE1pbiA9IDEsXG4gICAgdE1heCA9IDI2LFxuICAgIHNrZXcgPSAzOCxcbiAgICBkYW1wID0gNzAwLFxuICAgIGluaXRpYWxCaWFzID0gNzIsXG4gICAgaW5pdGlhbE4gPSAxMjgsXG4gICAgLy8gMHg4MFxuICAgIGRlbGltaXRlciA9ICctJyxcbiAgICAvLyAnXFx4MkQnXG5cbiAgICAvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuICAgIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuICAgIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLFxuICAgIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG4gICAgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZyxcbiAgICAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cbiAgICAvKiogRXJyb3IgbWVzc2FnZXMgKi9cbiAgICBlcnJvcnMgPSB7XG4gICAgICAnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuICAgICAgJ25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcbiAgICAgICdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG4gICAgfSxcbiAgICAvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG4gICAgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuICAgIC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cbiAgICBrZXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAgICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICAgKi9cbiAgZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuICAgIHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG4gICAqIGl0ZW0uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG4gICAqIGFkZHJlc3Nlcy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gICAqIGNoYXJhY3Rlci5cbiAgICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcbiAgICogZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuICAgIHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuICAgICAgLy8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cbiAgICAgIHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuICAgICAgc3RyaW5nID0gcGFydHNbMV07XG4gICAgfVxuICAgIC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuICAgIHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcbiAgICB2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG4gICAgcmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICAgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gICAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gICAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICAgKiBtYXRjaGluZyBVVEYtMTYuXG4gICAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAgICogQG5hbWUgZGVjb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG4gICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgY291bnRlciA9IDAsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgdmFsdWUsXG4gICAgICBleHRyYTtcbiAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICBpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHtcbiAgICAgICAgICAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuICAgICAgICAgIC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gICAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICAgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICAgKiBAbmFtZSBlbmNvZGVcbiAgICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICAgKi9cbiAgZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuICAgIHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgaWYgKHZhbHVlID4gMHhGRkZGKSB7XG4gICAgICAgIHZhbHVlIC09IDB4MTAwMDA7XG4gICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgICB2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG4gICAgICB9XG4gICAgICBvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSkuam9pbignJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICAgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAgICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICAgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcbiAgICBpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gICAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICAgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICAgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcbiAgICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAgICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuICAgIC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG4gICAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG4gICAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICAgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgICB2YXIgayA9IDA7XG4gICAgZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcbiAgICBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG4gICAgZm9yIC8qIG5vIGluaXRpYWxpemF0aW9uICovXG4gICAgKDsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcbiAgICAgIGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAgICogc3ltYm9scy5cbiAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgKi9cbiAgZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gICAgLy8gRG9uJ3QgdXNlIFVDUy0yXG4gICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBvdXQsXG4gICAgICBpID0gMCxcbiAgICAgIG4gPSBpbml0aWFsTixcbiAgICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcbiAgICAgIGJhc2ljLFxuICAgICAgaixcbiAgICAgIGluZGV4LFxuICAgICAgb2xkaSxcbiAgICAgIHcsXG4gICAgICBrLFxuICAgICAgZGlnaXQsXG4gICAgICB0LFxuICAgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG4gICAgICBiYXNlTWludXNUO1xuXG4gICAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG4gICAgLy8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcbiAgICAvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuICAgIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcbiAgICBpZiAoYmFzaWMgPCAwKSB7XG4gICAgICBiYXNpYyA9IDA7XG4gICAgfVxuICAgIGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG4gICAgICAvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcbiAgICAgICAgZXJyb3IoJ25vdC1iYXNpYycpO1xuICAgICAgfVxuICAgICAgb3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG4gICAgfVxuXG4gICAgLy8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuICAgIC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cbiAgICBmb3IgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqL1xuICAgIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7KSB7XG4gICAgICAvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG4gICAgICAvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG4gICAgICAvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuICAgICAgLy8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcbiAgICAgIC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG4gICAgICBmb3IgLyogbm8gY29uZGl0aW9uICovXG4gICAgICAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTs7IGsgKz0gYmFzZSkge1xuICAgICAgICBpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICBlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuICAgICAgICBpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG4gICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSBkaWdpdCAqIHc7XG4gICAgICAgIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcbiAgICAgICAgaWYgKGRpZ2l0IDwgdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgaWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgICB9XG4gICAgICAgIHcgKj0gYmFzZU1pbnVzVDtcbiAgICAgIH1cbiAgICAgIG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuICAgICAgYmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cbiAgICAgIC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG4gICAgICAvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuICAgICAgaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgIH1cbiAgICAgIG4gKz0gZmxvb3IoaSAvIG91dCk7XG4gICAgICBpICU9IG91dDtcblxuICAgICAgLy8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuICAgICAgb3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuICAgIH1cbiAgICByZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gICAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAgICovXG4gIGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICAgIHZhciBuLFxuICAgICAgZGVsdGEsXG4gICAgICBoYW5kbGVkQ1BDb3VudCxcbiAgICAgIGJhc2ljTGVuZ3RoLFxuICAgICAgYmlhcyxcbiAgICAgIGosXG4gICAgICBtLFxuICAgICAgcSxcbiAgICAgIGssXG4gICAgICB0LFxuICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgb3V0cHV0ID0gW10sXG4gICAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuICAgICAgaW5wdXRMZW5ndGgsXG4gICAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cbiAgICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcbiAgICAgIGJhc2VNaW51c1QsXG4gICAgICBxTWludXNUO1xuXG4gICAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuICAgIGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cbiAgICAvLyBDYWNoZSB0aGUgbGVuZ3RoXG4gICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuICAgIG4gPSBpbml0aWFsTjtcbiAgICBkZWx0YSA9IDA7XG4gICAgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG4gICAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cbiAgICAvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcbiAgICAvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cbiAgICAvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcbiAgICBpZiAoYmFzaWNMZW5ndGgpIHtcbiAgICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG4gICAgfVxuXG4gICAgLy8gTWFpbiBlbmNvZGluZyBsb29wOlxuICAgIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG4gICAgICAvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG4gICAgICAvLyBsYXJnZXIgb25lOlxuICAgICAgZm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG4gICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG4gICAgICAvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuICAgICAgaWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcbiAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICB9XG4gICAgICBkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuICAgICAgbiA9IG07XG4gICAgICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuICAgICAgICAgIC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG4gICAgICAgICAgZm9yIC8qIG5vIGNvbmRpdGlvbiAqL1xuICAgICAgICAgIChxID0gZGVsdGEsIGsgPSBiYXNlOzsgayArPSBiYXNlKSB7XG4gICAgICAgICAgICB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG4gICAgICAgICAgICBpZiAocSA8IHQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgICBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcbiAgICAgICAgICAgIHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcbiAgICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICAgIGRlbHRhID0gMDtcbiAgICAgICAgICArK2hhbmRsZWRDUENvdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICArK2RlbHRhO1xuICAgICAgKytuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAgICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICAgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAgICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG4gICAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gICAqIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgIHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKSA/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBzdHJpbmc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gICAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICAgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAgICogQVNDSUkuXG4gICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICAgKiBVbmljb2RlIHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICAgKiBlbWFpbCBhZGRyZXNzLlxuICAgKi9cbiAgZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgIHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpIDogc3RyaW5nO1xuICAgIH0pO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuICBwdW55Y29kZSA9IHtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgJ3ZlcnNpb24nOiAnMS4zLjInLFxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICAgICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cbiAgICAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICAndWNzMic6IHtcbiAgICAgICdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuICAgICAgJ2VuY29kZSc6IHVjczJlbmNvZGVcbiAgICB9LFxuICAgICdkZWNvZGUnOiBkZWNvZGUsXG4gICAgJ2VuY29kZSc6IGVuY29kZSxcbiAgICAndG9BU0NJSSc6IHRvQVNDSUksXG4gICAgJ3RvVW5pY29kZSc6IHRvVW5pY29kZVxuICB9O1xuXG4gIC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcbiAgLy8gbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHB1bnljb2RlO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICBpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcbiAgICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG4gICAgICBmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cbiAgICAgIGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG4gICAgICAgIHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuICAgIHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcbiAgfVxufSkodGhpcyk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/url/node_modules/punycode/punycode.js\n");

/***/ }),

/***/ "./node_modules/url/node_modules/querystring/decode.js":
/*!*************************************************************!*\
  !*** ./node_modules/url/node_modules/querystring/decode.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nmodule.exports = function (qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n      idx = x.indexOf(eq),\n      kstr,\n      vstr,\n      k,\n      v;\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n  return obj;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9kZWNvZGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL3VybC9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzPzAxY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAga3N0cixcbiAgICAgIHZzdHIsXG4gICAgICBrLFxuICAgICAgdjtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/url/node_modules/querystring/decode.js\n");

/***/ }),

/***/ "./node_modules/url/node_modules/querystring/encode.js":
/*!*************************************************************!*\
  !*** ./node_modules/url/node_modules/querystring/encode.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function (v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n    case 'boolean':\n      return v ? 'true' : 'false';\n    case 'number':\n      return isFinite(v) ? v : '';\n    default:\n      return '';\n  }\n};\nmodule.exports = function (obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function (k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function (v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n  }\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanM/Y2E5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24gKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcbiAgfVxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/url/node_modules/querystring/encode.js\n");

/***/ }),

/***/ "./node_modules/url/node_modules/querystring/index.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/querystring/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.decode = exports.parse = __webpack_require__(/*! ./decode */ \"./node_modules/url/node_modules/querystring/decode.js\");\nexports.encode = exports.stringify = __webpack_require__(/*! ./encode */ \"./node_modules/url/node_modules/querystring/encode.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcz83YmM3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/url/node_modules/querystring/index.js\n");

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(/*! punycode */ \"./node_modules/url/node_modules/punycode/punycode.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/url/util.js\");\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\nexports.Url = Url;\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n  portPattern = /:[0-9]*$/,\n  // Special case for a simple path URL\n  simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n  // RFC 2396: characters reserved for delimiting URLs.\n  // We actually just auto-escape these.\n  delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n  // RFC 2396: characters not allowed for various reasons.\n  unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n  autoEscape = ['\\''].concat(unwise),\n  // Characters that are never ever allowed in a hostname.\n  // Note that any invalid chars are also handled, but these\n  // are the ones that are *expected* to be seen, so we fast-path\n  // them.\n  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n  hostEndingChars = ['/', '?', '#'],\n  hostnameMaxLen = 255,\n  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n  // protocols that can allow \"unsafe\" and \"unwise\" chars.\n  unsafeProtocol = {\n    'javascript': true,\n    'javascript:': true\n  },\n  // protocols that never have a hostname.\n  hostlessProtocol = {\n    'javascript': true,\n    'javascript:': true\n  },\n  // protocols that always contain a // bit.\n  slashedProtocol = {\n    'http': true,\n    'https': true,\n    'ftp': true,\n    'gopher': true,\n    'file': true,\n    'http:': true,\n    'https:': true,\n    'ftp:': true,\n    'gopher:': true,\n    'file:': true\n  },\n  querystring = __webpack_require__(/*! querystring */ \"./node_modules/url/node_modules/querystring/index.js\");\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n    uSplit = url.split(splitter),\n    slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) hostEnd = rest.length;\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1) continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\nUrl.prototype.format = function () {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n  var protocol = this.protocol || '',\n    pathname = this.pathname || '',\n    hash = this.hash || '',\n    host = false,\n    query = '';\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n  var search = this.search || query && '?' + query || '';\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n  pathname = pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n  return protocol + host + pathname + search + hash;\n};\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\nUrl.prototype.resolveObject = function (relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol') result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n    result.href = result.format();\n    return result;\n  }\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n    mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n    removeAllDots = mustEndAbs,\n    srcPath = result.pathname && result.pathname.split('/') || [],\n    relPath = relative.pathname && relative.pathname.split('/') || [],\n    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n    srcPath.push('');\n  }\n  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcz8xNjI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcbmV4cG9ydHMuVXJsID0gVXJsO1xuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcbiAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG4gIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG4gIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gIC8vIHRoZW0uXG4gIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gIHVuc2FmZVByb3RvY29sID0ge1xuICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gIH0sXG4gIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICB9LFxuICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICdodHRwJzogdHJ1ZSxcbiAgICAnaHR0cHMnOiB0cnVlLFxuICAgICdmdHAnOiB0cnVlLFxuICAgICdnb3BoZXInOiB0cnVlLFxuICAgICdmaWxlJzogdHJ1ZSxcbiAgICAnaHR0cDonOiB0cnVlLFxuICAgICdodHRwczonOiB0cnVlLFxuICAgICdmdHA6JzogdHJ1ZSxcbiAgICAnZ29waGVyOic6IHRydWUsXG4gICAgJ2ZpbGU6JzogdHJ1ZVxuICB9LFxuICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgIHNwbGl0dGVyID0gcXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykgPyAnPycgOiAnIycsXG4gICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJiAoc2xhc2hlcyB8fCBwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpIHtcbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSkgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiYgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgIGhvc3QgPSBmYWxzZSxcbiAgICBxdWVyeSA9ICcnO1xuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/IHRoaXMuaG9zdG5hbWUgOiAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMucXVlcnkgJiYgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJiBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgcXVlcnkgJiYgJz8nICsgcXVlcnkgfHwgJyc7XG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fCAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBpc1NvdXJjZUFicyA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsXG4gICAgaXNSZWxBYnMgPSByZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgIG11c3RFbmRBYnMgPSBpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fCByZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSxcbiAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7ZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJyA/IHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycgPyByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID8gcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgKyAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJyc7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJztcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOiBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/IHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgcmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGg7XG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgKyAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/url/url.js\n");

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  isString: function (arg) {\n    return typeof arg === 'string';\n  },\n  isObject: function (arg) {\n    return typeof arg === 'object' && arg !== null;\n  },\n  isNull: function (arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function (arg) {\n    return arg == null;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzPzIwZGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/url/util.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/BaseClient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/clients/BaseClient.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint-disable\n  no-unused-vars\n*/\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BaseClient() {\n    _classCallCheck(this, BaseClient);\n  }\n  _createClass(BaseClient, null, [{\n    key: \"getClientPath\",\n    value: function getClientPath(options) {\n      throw new Error('Client needs implementation');\n    }\n  }]);\n  return BaseClient;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL0Jhc2VDbGllbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L2NsaWVudHMvQmFzZUNsaWVudC5qcz9jMzEwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGVcbiAgbm8tdW51c2VkLXZhcnNcbiovXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUNsaWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNsaWVudCk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEJhc2VDbGllbnQsIG51bGwsIFt7XG4gICAga2V5OiBcImdldENsaWVudFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UGF0aChvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBuZWVkcyBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmFzZUNsaWVudDtcbn0oKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/clients/BaseClient.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js":
/*!************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/clients/SockJSClient.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-disable\n  no-unused-vars\n*/\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nvar SockJS = __webpack_require__(/*! sockjs-client/dist/sockjs */ \"./node_modules/sockjs-client/dist/sockjs.js\");\nvar BaseClient = __webpack_require__(/*! ./BaseClient */ \"./node_modules/webpack-dev-server/client/clients/BaseClient.js\");\nmodule.exports = /*#__PURE__*/function (_BaseClient) {\n  _inherits(SockJSClient, _BaseClient);\n  var _super = _createSuper(SockJSClient);\n  function SockJSClient(url) {\n    var _this;\n    _classCallCheck(this, SockJSClient);\n    _this = _super.call(this);\n    _this.sock = new SockJS(url);\n    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src\n      // are reorganized to have the same directory structure\n    };\n    return _this;\n  }\n  _createClass(SockJSClient, [{\n    key: \"onOpen\",\n    value: function onOpen(f) {\n      this.sock.onopen = f;\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(f) {\n      this.sock.onclose = f;\n    } // call f with the message string as the first argument\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(f) {\n      this.sock.onmessage = function (e) {\n        f(e.data);\n      };\n    }\n  }], [{\n    key: \"getClientPath\",\n    value: function getClientPath(options) {\n      return /*require.resolve*/(/*! ./SockJSClient */ \"./node_modules/webpack-dev-server/client/clients/SockJSClient.js\");\n    }\n  }]);\n  return SockJSClient;\n}(BaseClient);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1NvY2tKU0NsaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9Tb2NrSlNDbGllbnQuanM/MzUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgIHJlc3VsdDtcbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcbnZhciBCYXNlQ2xpZW50ID0gcmVxdWlyZSgnLi9CYXNlQ2xpZW50Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDbGllbnQpIHtcbiAgX2luaGVyaXRzKFNvY2tKU0NsaWVudCwgX0Jhc2VDbGllbnQpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNvY2tKU0NsaWVudCk7XG4gIGZ1bmN0aW9uIFNvY2tKU0NsaWVudCh1cmwpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tKU0NsaWVudCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5zb2NrID0gbmV3IFNvY2tKUyh1cmwpO1xuICAgIF90aGlzLnNvY2sub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsvLyBUT0RPOiB1c2UgbG9nZ2VyIHRvIGxvZyB0aGUgZXJyb3IgZXZlbnQgb25jZSBjbGllbnQgYW5kIGNsaWVudC1zcmNcbiAgICAgIC8vIGFyZSByZW9yZ2FuaXplZCB0byBoYXZlIHRoZSBzYW1lIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoU29ja0pTQ2xpZW50LCBbe1xuICAgIGtleTogXCJvbk9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25PcGVuKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbm9wZW4gPSBmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xvc2UoZikge1xuICAgICAgdGhpcy5zb2NrLm9uY2xvc2UgPSBmO1xuICAgIH0gLy8gY2FsbCBmIHdpdGggdGhlIG1lc3NhZ2Ugc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICB9LCB7XG4gICAga2V5OiBcIm9uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2UoZikge1xuICAgICAgdGhpcy5zb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGYoZS5kYXRhKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUoJy4vU29ja0pTQ2xpZW50Jyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTb2NrSlNDbGllbnQ7XG59KEJhc2VDbGllbnQpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/clients/SockJSClient.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/index.js?http://localhost:8080":
/*!*******************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/index.js?http://localhost:8080 ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("var __resourceQuery = \"?http://localhost:8080\";\n\n\n/* global __resourceQuery WorkerGlobalScope self */\n\n/* eslint prefer-destructuring: off */\nvar stripAnsi = __webpack_require__(/*! strip-ansi */ \"./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js\");\nvar socket = __webpack_require__(/*! ./socket */ \"./node_modules/webpack-dev-server/client/socket.js\");\nvar overlay = __webpack_require__(/*! ./overlay */ \"./node_modules/webpack-dev-server/client/overlay.js\");\nvar _require = __webpack_require__(/*! ./utils/log */ \"./node_modules/webpack-dev-server/client/utils/log.js\"),\n  log = _require.log,\n  setLogLevel = _require.setLogLevel;\nvar sendMessage = __webpack_require__(/*! ./utils/sendMessage */ \"./node_modules/webpack-dev-server/client/utils/sendMessage.js\");\nvar reloadApp = __webpack_require__(/*! ./utils/reloadApp */ \"./node_modules/webpack-dev-server/client/utils/reloadApp.js\");\nvar createSocketUrl = __webpack_require__(/*! ./utils/createSocketUrl */ \"./node_modules/webpack-dev-server/client/utils/createSocketUrl.js\");\nvar status = {\n  isUnloading: false,\n  currentHash: ''\n};\nvar options = {\n  hot: false,\n  hotReload: true,\n  liveReload: false,\n  initial: true,\n  useWarningOverlay: false,\n  useErrorOverlay: false,\n  useProgress: false\n};\nvar socketUrl = createSocketUrl(__resourceQuery);\nself.addEventListener('beforeunload', function () {\n  status.isUnloading = true;\n});\nif (typeof window !== 'undefined') {\n  var qs = window.location.search.toLowerCase();\n  options.hotReload = qs.indexOf('hotreload=false') === -1;\n}\nvar onSocketMessage = {\n  hot: function hot() {\n    options.hot = true;\n    log.info('[WDS] Hot Module Replacement enabled.');\n  },\n  liveReload: function liveReload() {\n    options.liveReload = true;\n    log.info('[WDS] Live Reloading enabled.');\n  },\n  invalid: function invalid() {\n    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\n\n    if (options.useWarningOverlay || options.useErrorOverlay) {\n      overlay.clear();\n    }\n    sendMessage('Invalid');\n  },\n  hash: function hash(_hash) {\n    status.currentHash = _hash;\n  },\n  'still-ok': function stillOk() {\n    log.info('[WDS] Nothing changed.');\n    if (options.useWarningOverlay || options.useErrorOverlay) {\n      overlay.clear();\n    }\n    sendMessage('StillOk');\n  },\n  'log-level': function logLevel(level) {\n    var hotCtx = __webpack_require__(\"./node_modules/webpack/hot sync ^\\\\.\\\\/log$\");\n    if (hotCtx.keys().indexOf('./log') !== -1) {\n      hotCtx('./log').setLogLevel(level);\n    }\n    setLogLevel(level);\n  },\n  overlay: function overlay(value) {\n    if (typeof document !== 'undefined') {\n      if (typeof value === 'boolean') {\n        options.useWarningOverlay = false;\n        options.useErrorOverlay = value;\n      } else if (value) {\n        options.useWarningOverlay = value.warnings;\n        options.useErrorOverlay = value.errors;\n      }\n    }\n  },\n  progress: function progress(_progress) {\n    if (typeof document !== 'undefined') {\n      options.useProgress = _progress;\n    }\n  },\n  'progress-update': function progressUpdate(data) {\n    if (options.useProgress) {\n      log.info(\"[WDS] \".concat(data.percent, \"% - \").concat(data.msg, \".\"));\n    }\n    sendMessage('Progress', data);\n  },\n  ok: function ok() {\n    sendMessage('Ok');\n    if (options.useWarningOverlay || options.useErrorOverlay) {\n      overlay.clear();\n    }\n    if (options.initial) {\n      return options.initial = false;\n    } // eslint-disable-line no-return-assign\n\n    reloadApp(options, status);\n  },\n  'content-changed': function contentChanged() {\n    log.info('[WDS] Content base changed. Reloading...');\n    self.location.reload();\n  },\n  warnings: function warnings(_warnings) {\n    log.warn('[WDS] Warnings while compiling.');\n    var strippedWarnings = _warnings.map(function (warning) {\n      return stripAnsi(warning);\n    });\n    sendMessage('Warnings', strippedWarnings);\n    for (var i = 0; i < strippedWarnings.length; i++) {\n      log.warn(strippedWarnings[i]);\n    }\n    if (options.useWarningOverlay) {\n      overlay.showMessage(_warnings);\n    }\n    if (options.initial) {\n      return options.initial = false;\n    } // eslint-disable-line no-return-assign\n\n    reloadApp(options, status);\n  },\n  errors: function errors(_errors) {\n    log.error('[WDS] Errors while compiling. Reload prevented.');\n    var strippedErrors = _errors.map(function (error) {\n      return stripAnsi(error);\n    });\n    sendMessage('Errors', strippedErrors);\n    for (var i = 0; i < strippedErrors.length; i++) {\n      log.error(strippedErrors[i]);\n    }\n    if (options.useErrorOverlay) {\n      overlay.showMessage(_errors);\n    }\n    options.initial = false;\n  },\n  error: function error(_error) {\n    log.error(_error);\n  },\n  close: function close() {\n    log.error('[WDS] Disconnected!');\n    sendMessage('Close');\n  }\n};\nsocket(socketUrl, onSocketMessage);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9pbmRleC5qcz9odHRwOi8vbG9jYWxob3N0OjgwODAuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9pbmRleC5qcz9jMzJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKSxcbiAgbG9nID0gX3JlcXVpcmUubG9nLFxuICBzZXRMb2dMZXZlbCA9IF9yZXF1aXJlLnNldExvZ0xldmVsO1xudmFyIHNlbmRNZXNzYWdlID0gcmVxdWlyZSgnLi91dGlscy9zZW5kTWVzc2FnZScpO1xudmFyIHJlbG9hZEFwcCA9IHJlcXVpcmUoJy4vdXRpbHMvcmVsb2FkQXBwJyk7XG52YXIgY3JlYXRlU29ja2V0VXJsID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVTb2NrZXRVcmwnKTtcbnZhciBzdGF0dXMgPSB7XG4gIGlzVW5sb2FkaW5nOiBmYWxzZSxcbiAgY3VycmVudEhhc2g6ICcnXG59O1xudmFyIG9wdGlvbnMgPSB7XG4gIGhvdDogZmFsc2UsXG4gIGhvdFJlbG9hZDogdHJ1ZSxcbiAgbGl2ZVJlbG9hZDogZmFsc2UsXG4gIGluaXRpYWw6IHRydWUsXG4gIHVzZVdhcm5pbmdPdmVybGF5OiBmYWxzZSxcbiAgdXNlRXJyb3JPdmVybGF5OiBmYWxzZSxcbiAgdXNlUHJvZ3Jlc3M6IGZhbHNlXG59O1xudmFyIHNvY2tldFVybCA9IGNyZWF0ZVNvY2tldFVybChfX3Jlc291cmNlUXVlcnkpO1xuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gIHN0YXR1cy5pc1VubG9hZGluZyA9IHRydWU7XG59KTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIG9wdGlvbnMuaG90UmVsb2FkID0gcXMuaW5kZXhPZignaG90cmVsb2FkPWZhbHNlJykgPT09IC0xO1xufVxudmFyIG9uU29ja2V0TWVzc2FnZSA9IHtcbiAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGxpdmVSZWxvYWQ6IGZ1bmN0aW9uIGxpdmVSZWxvYWQoKSB7XG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC4nKTtcbiAgfSxcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uJyk7IC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UoJ0ludmFsaWQnKTtcbiAgfSxcbiAgaGFzaDogZnVuY3Rpb24gaGFzaChfaGFzaCkge1xuICAgIHN0YXR1cy5jdXJyZW50SGFzaCA9IF9oYXNoO1xuICB9LFxuICAnc3RpbGwtb2snOiBmdW5jdGlvbiBzdGlsbE9rKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBOb3RoaW5nIGNoYW5nZWQuJyk7XG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UoJ1N0aWxsT2snKTtcbiAgfSxcbiAgJ2xvZy1sZXZlbCc6IGZ1bmN0aW9uIGxvZ0xldmVsKGxldmVsKSB7XG4gICAgdmFyIGhvdEN0eCA9IHJlcXVpcmUuY29udGV4dCgnd2VicGFjay9ob3QnLCBmYWxzZSwgL15cXC5cXC9sb2ckLyk7XG4gICAgaWYgKGhvdEN0eC5rZXlzKCkuaW5kZXhPZignLi9sb2cnKSAhPT0gLTEpIHtcbiAgICAgIGhvdEN0eCgnLi9sb2cnKS5zZXRMb2dMZXZlbChsZXZlbCk7XG4gICAgfVxuICAgIHNldExvZ0xldmVsKGxldmVsKTtcbiAgfSxcbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICBvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5ID0gdmFsdWUud2FybmluZ3M7XG4gICAgICAgIG9wdGlvbnMudXNlRXJyb3JPdmVybGF5ID0gdmFsdWUuZXJyb3JzO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKF9wcm9ncmVzcykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zLnVzZVByb2dyZXNzID0gX3Byb2dyZXNzO1xuICAgIH1cbiAgfSxcbiAgJ3Byb2dyZXNzLXVwZGF0ZSc6IGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKGRhdGEpIHtcbiAgICBpZiAob3B0aW9ucy51c2VQcm9ncmVzcykge1xuICAgICAgbG9nLmluZm8oXCJbV0RTXSBcIi5jb25jYXQoZGF0YS5wZXJjZW50LCBcIiUgLSBcIikuY29uY2F0KGRhdGEubXNnLCBcIi5cIikpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZSgnUHJvZ3Jlc3MnLCBkYXRhKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKCdPaycpO1xuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluaXRpYWwpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gICdjb250ZW50LWNoYW5nZWQnOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQ29udGVudCBiYXNlIGNoYW5nZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MpIHtcbiAgICBsb2cud2FybignW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLicpO1xuICAgIHZhciBzdHJpcHBlZFdhcm5pbmdzID0gX3dhcm5pbmdzLm1hcChmdW5jdGlvbiAod2FybmluZykge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaSh3YXJuaW5nKTtcbiAgICB9KTtcbiAgICBzZW5kTWVzc2FnZSgnV2FybmluZ3MnLCBzdHJpcHBlZFdhcm5pbmdzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfd2FybmluZ3MpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLicpO1xuICAgIHZhciBzdHJpcHBlZEVycm9ycyA9IF9lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaShlcnJvcik7XG4gICAgfSk7XG4gICAgc2VuZE1lc3NhZ2UoJ0Vycm9ycycsIHN0cmlwcGVkRXJyb3JzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cuZXJyb3Ioc3RyaXBwZWRFcnJvcnNbaV0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2hvd01lc3NhZ2UoX2Vycm9ycyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoX2Vycm9yKSB7XG4gICAgbG9nLmVycm9yKF9lcnJvcik7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIERpc2Nvbm5lY3RlZCEnKTtcbiAgICBzZW5kTWVzc2FnZSgnQ2xvc2UnKTtcbiAgfVxufTtcbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TWVzc2FnZSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/index.js?http://localhost:8080\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay.js":
/*!***********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)\n// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).\nvar ansiHTML = __webpack_require__(/*! ansi-html-community */ \"./node_modules/webpack-dev-server/node_modules/ansi-html-community/index.js\");\nvar _require = __webpack_require__(/*! html-entities */ \"./node_modules/html-entities/lib/index.js\"),\n  AllHtmlEntities = _require.AllHtmlEntities;\nvar entities = new AllHtmlEntities();\nvar colors = {\n  reset: ['transparent', 'transparent'],\n  black: '181818',\n  red: 'E36049',\n  green: 'B3CB74',\n  yellow: 'FFD080',\n  blue: '7CAFC2',\n  magenta: '7FACCA',\n  cyan: 'C3C2EF',\n  lightgrey: 'EBE7E3',\n  darkgrey: '6D7891'\n};\nvar overlayIframe = null;\nvar overlayDiv = null;\nvar lastOnOverlayDivReady = null;\nansiHTML.setColors(colors);\nfunction createOverlayIframe(onIframeLoad) {\n  var iframe = document.createElement('iframe');\n  iframe.id = 'webpack-dev-server-client-overlay';\n  iframe.src = 'about:blank';\n  iframe.style.position = 'fixed';\n  iframe.style.left = 0;\n  iframe.style.top = 0;\n  iframe.style.right = 0;\n  iframe.style.bottom = 0;\n  iframe.style.width = '100vw';\n  iframe.style.height = '100vh';\n  iframe.style.border = 'none';\n  iframe.style.zIndex = 9999999999;\n  iframe.onload = onIframeLoad;\n  return iframe;\n}\nfunction addOverlayDivTo(iframe) {\n  var div = iframe.contentDocument.createElement('div');\n  div.id = 'webpack-dev-server-client-overlay-div';\n  div.style.position = 'fixed';\n  div.style.boxSizing = 'border-box';\n  div.style.left = 0;\n  div.style.top = 0;\n  div.style.right = 0;\n  div.style.bottom = 0;\n  div.style.width = '100vw';\n  div.style.height = '100vh';\n  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\n  div.style.color = '#E8E8E8';\n  div.style.fontFamily = 'Menlo, Consolas, monospace';\n  div.style.fontSize = 'large';\n  div.style.padding = '2rem';\n  div.style.lineHeight = '1.2';\n  div.style.whiteSpace = 'pre-wrap';\n  div.style.overflow = 'auto';\n  iframe.contentDocument.body.appendChild(div);\n  return div;\n}\nfunction ensureOverlayDivExists(onOverlayDivReady) {\n  if (overlayDiv) {\n    // Everything is ready, call the callback right away.\n    onOverlayDivReady(overlayDiv);\n    return;\n  } // Creating an iframe may be asynchronous so we'll schedule the callback.\n  // In case of multiple calls, last callback wins.\n\n  lastOnOverlayDivReady = onOverlayDivReady;\n  if (overlayIframe) {\n    // We've already created it.\n    return;\n  } // Create iframe and, when it is ready, a div inside it.\n\n  overlayIframe = createOverlayIframe(function () {\n    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!\n\n    lastOnOverlayDivReady(overlayDiv);\n  }); // Zalgo alert: onIframeLoad() will be called either synchronously\n  // or asynchronously depending on the browser.\n  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.\n\n  document.body.appendChild(overlayIframe);\n} // Successful compilation.\n\nfunction clear() {\n  if (!overlayDiv) {\n    // It is not there in the first place.\n    return;\n  } // Clean up and reset internal state.\n\n  document.body.removeChild(overlayIframe);\n  overlayDiv = null;\n  overlayIframe = null;\n  lastOnOverlayDivReady = null;\n} // Compilation with errors (e.g. syntax error or missing modules).\n\nfunction showMessage(messages) {\n  ensureOverlayDivExists(function (div) {\n    // Make it look similar to our terminal.\n    div.innerHTML = \"<span style=\\\"color: #\".concat(colors.red, \"\\\">Failed to compile.</span><br><br>\").concat(ansiHTML(entities.encode(messages[0])));\n  });\n}\nmodule.exports = {\n  clear: clear,\n  showMessage: showMessage\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkuanM/MTE4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBlcnJvciBvdmVybGF5IGlzIGluc3BpcmVkIChhbmQgbW9zdGx5IGNvcGllZCkgZnJvbSBDcmVhdGUgUmVhY3QgQXBwIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcClcbi8vIFRoZXksIGluIHR1cm4sIGdvdCBpbnNwaXJlZCBieSB3ZWJwYWNrLWhvdC1taWRkbGV3YXJlIChodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmUpLlxudmFyIGFuc2lIVE1MID0gcmVxdWlyZSgnYW5zaS1odG1sLWNvbW11bml0eScpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnaHRtbC1lbnRpdGllcycpLFxuICBBbGxIdG1sRW50aXRpZXMgPSBfcmVxdWlyZS5BbGxIdG1sRW50aXRpZXM7XG52YXIgZW50aXRpZXMgPSBuZXcgQWxsSHRtbEVudGl0aWVzKCk7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogWyd0cmFuc3BhcmVudCcsICd0cmFuc3BhcmVudCddLFxuICBibGFjazogJzE4MTgxOCcsXG4gIHJlZDogJ0UzNjA0OScsXG4gIGdyZWVuOiAnQjNDQjc0JyxcbiAgeWVsbG93OiAnRkZEMDgwJyxcbiAgYmx1ZTogJzdDQUZDMicsXG4gIG1hZ2VudGE6ICc3RkFDQ0EnLFxuICBjeWFuOiAnQzNDMkVGJyxcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcbiAgZGFya2dyZXk6ICc2RDc4OTEnXG59O1xudmFyIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xudmFyIG92ZXJsYXlEaXYgPSBudWxsO1xudmFyIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG5hbnNpSFRNTC5zZXRDb2xvcnMoY29sb3JzKTtcbmZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXlJZnJhbWUob25JZnJhbWVMb2FkKSB7XG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgaWZyYW1lLmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheSc7XG4gIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBpZnJhbWUuc3R5bGUubGVmdCA9IDA7XG4gIGlmcmFtZS5zdHlsZS50b3AgPSAwO1xuICBpZnJhbWUuc3R5bGUucmlnaHQgPSAwO1xuICBpZnJhbWUuc3R5bGUuYm90dG9tID0gMDtcbiAgaWZyYW1lLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGlmcmFtZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gIGlmcmFtZS5zdHlsZS56SW5kZXggPSA5OTk5OTk5OTk5O1xuICBpZnJhbWUub25sb2FkID0gb25JZnJhbWVMb2FkO1xuICByZXR1cm4gaWZyYW1lO1xufVxuZnVuY3Rpb24gYWRkT3ZlcmxheURpdlRvKGlmcmFtZSkge1xuICB2YXIgZGl2ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheS1kaXYnO1xuICBkaXYuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICBkaXYuc3R5bGUubGVmdCA9IDA7XG4gIGRpdi5zdHlsZS50b3AgPSAwO1xuICBkaXYuc3R5bGUucmlnaHQgPSAwO1xuICBkaXYuc3R5bGUuYm90dG9tID0gMDtcbiAgZGl2LnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjg1KSc7XG4gIGRpdi5zdHlsZS5jb2xvciA9ICcjRThFOEU4JztcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAnbGFyZ2UnO1xuICBkaXYuc3R5bGUucGFkZGluZyA9ICcycmVtJztcbiAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAnMS4yJztcbiAgZGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICBkaXYuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICByZXR1cm4gZGl2O1xufVxuZnVuY3Rpb24gZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhvbk92ZXJsYXlEaXZSZWFkeSkge1xuICBpZiAob3ZlcmxheURpdikge1xuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgb25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0aW5nIGFuIGlmcmFtZSBtYXkgYmUgYXN5bmNocm9ub3VzIHNvIHdlJ2xsIHNjaGVkdWxlIHRoZSBjYWxsYmFjay5cbiAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBjYWxscywgbGFzdCBjYWxsYmFjayB3aW5zLlxuXG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG9uT3ZlcmxheURpdlJlYWR5O1xuICBpZiAob3ZlcmxheUlmcmFtZSkge1xuICAgIC8vIFdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBpdC5cbiAgICByZXR1cm47XG4gIH0gLy8gQ3JlYXRlIGlmcmFtZSBhbmQsIHdoZW4gaXQgaXMgcmVhZHksIGEgZGl2IGluc2lkZSBpdC5cblxuICBvdmVybGF5SWZyYW1lID0gY3JlYXRlT3ZlcmxheUlmcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgb3ZlcmxheURpdiA9IGFkZE92ZXJsYXlEaXZUbyhvdmVybGF5SWZyYW1lKTsgLy8gTm93IHdlIGNhbiB0YWxrIVxuXG4gICAgbGFzdE9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICB9KTsgLy8gWmFsZ28gYWxlcnQ6IG9uSWZyYW1lTG9hZCgpIHdpbGwgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5XG4gIC8vIG9yIGFzeW5jaHJvbm91c2x5IGRlcGVuZGluZyBvbiB0aGUgYnJvd3Nlci5cbiAgLy8gV2UgZGVsYXkgYWRkaW5nIGl0IHNvIGBvdmVybGF5SWZyYW1lYCBpcyBzZXQgd2hlbiBgb25JZnJhbWVMb2FkYCBmaXJlcy5cblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG92ZXJsYXlJZnJhbWUpO1xufSAvLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgaWYgKCFvdmVybGF5RGl2KSB7XG4gICAgLy8gSXQgaXMgbm90IHRoZXJlIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICByZXR1cm47XG4gIH0gLy8gQ2xlYW4gdXAgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlLlxuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG4gIG92ZXJsYXlEaXYgPSBudWxsO1xuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbn0gLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5cbmZ1bmN0aW9uIHNob3dNZXNzYWdlKG1lc3NhZ2VzKSB7XG4gIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMoZnVuY3Rpb24gKGRpdikge1xuICAgIC8vIE1ha2UgaXQgbG9vayBzaW1pbGFyIHRvIG91ciB0ZXJtaW5hbC5cbiAgICBkaXYuaW5uZXJIVE1MID0gXCI8c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNcIi5jb25jYXQoY29sb3JzLnJlZCwgXCJcXFwiPkZhaWxlZCB0byBjb21waWxlLjwvc3Bhbj48YnI+PGJyPlwiKS5jb25jYXQoYW5zaUhUTUwoZW50aXRpZXMuZW5jb2RlKG1lc3NhZ2VzWzBdKSkpO1xuICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjbGVhcjogY2xlYXIsXG4gIHNob3dNZXNzYWdlOiBzaG93TWVzc2FnZVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/socket.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var __webpack_dev_server_client__ = __webpack_require__(/*! ./node_modules/webpack-dev-server/client/clients/SockJSClient.js */ \"./node_modules/webpack-dev-server/client/clients/SockJSClient.js\");\n\n\n/* global __webpack_dev_server_client__ */\n\n/* eslint-disable\n  camelcase\n*/\n// this SockJSClient is here as a default fallback, in case inline mode\n// is off or the client is not injected. This will be switched to\n// WebsocketClient when it becomes the default\n// important: the path to SockJSClient here is made to work in the 'client'\n// directory, but is updated via the webpack compilation when compiled from\n// the 'client-src' directory\nvar Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ :\n// eslint-disable-next-line import/no-unresolved\n__webpack_require__(/*! ./clients/SockJSClient */ \"./node_modules/webpack-dev-server/client/clients/SockJSClient.js\");\nvar retries = 0;\nvar client = null;\nvar socket = function initSocket(url, handlers) {\n  client = new Client(url);\n  client.onOpen(function () {\n    retries = 0;\n  });\n  client.onClose(function () {\n    if (retries === 0) {\n      handlers.close();\n    } // Try to reconnect.\n\n    client = null; // After 10 retries stop trying, to prevent logspam.\n\n    if (retries <= 10) {\n      // Exponentially increase timeout to reconnect.\n      // Respectfully copied from the package `got`.\n      // eslint-disable-next-line no-mixed-operators, no-restricted-properties\n      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;\n      retries += 1;\n      setTimeout(function () {\n        socket(url, handlers);\n      }, retryInMs);\n    }\n  });\n  client.onMessage(function (data) {\n    var msg = JSON.parse(data);\n    if (handlers[msg.type]) {\n      handlers[msg.type](msg.data);\n    }\n  });\n};\nmodule.exports = socket;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qcz80YTRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICovXG5cbi8qIGVzbGludC1kaXNhYmxlXG4gIGNhbWVsY2FzZVxuKi9cbi8vIHRoaXMgU29ja0pTQ2xpZW50IGlzIGhlcmUgYXMgYSBkZWZhdWx0IGZhbGxiYWNrLCBpbiBjYXNlIGlubGluZSBtb2RlXG4vLyBpcyBvZmYgb3IgdGhlIGNsaWVudCBpcyBub3QgaW5qZWN0ZWQuIFRoaXMgd2lsbCBiZSBzd2l0Y2hlZCB0b1xuLy8gV2Vic29ja2V0Q2xpZW50IHdoZW4gaXQgYmVjb21lcyB0aGUgZGVmYXVsdFxuLy8gaW1wb3J0YW50OiB0aGUgcGF0aCB0byBTb2NrSlNDbGllbnQgaGVyZSBpcyBtYWRlIHRvIHdvcmsgaW4gdGhlICdjbGllbnQnXG4vLyBkaXJlY3RvcnksIGJ1dCBpcyB1cGRhdGVkIHZpYSB0aGUgd2VicGFjayBjb21waWxhdGlvbiB3aGVuIGNvbXBpbGVkIGZyb21cbi8vIHRoZSAnY2xpZW50LXNyYycgZGlyZWN0b3J5XG52YXIgQ2xpZW50ID0gdHlwZW9mIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fIDpcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxucmVxdWlyZSgnLi9jbGllbnRzL1NvY2tKU0NsaWVudCcpO1xudmFyIHJldHJpZXMgPSAwO1xudmFyIGNsaWVudCA9IG51bGw7XG52YXIgc29ja2V0ID0gZnVuY3Rpb24gaW5pdFNvY2tldCh1cmwsIGhhbmRsZXJzKSB7XG4gIGNsaWVudCA9IG5ldyBDbGllbnQodXJsKTtcbiAgY2xpZW50Lm9uT3BlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0cmllcyA9IDA7XG4gIH0pO1xuICBjbGllbnQub25DbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJldHJpZXMgPT09IDApIHtcbiAgICAgIGhhbmRsZXJzLmNsb3NlKCk7XG4gICAgfSAvLyBUcnkgdG8gcmVjb25uZWN0LlxuXG4gICAgY2xpZW50ID0gbnVsbDsgLy8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuXG4gICAgaWYgKHJldHJpZXMgPD0gMTApIHtcbiAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXG4gICAgICAvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcbiAgICAgIHZhciByZXRyeUluTXMgPSAxMDAwICogTWF0aC5wb3coMiwgcmV0cmllcykgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvY2tldCh1cmwsIGhhbmRsZXJzKTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9KTtcbiAgY2xpZW50Lm9uTWVzc2FnZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBtc2cgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIGlmIChoYW5kbGVyc1ttc2cudHlwZV0pIHtcbiAgICAgIGhhbmRsZXJzW21zZy50eXBlXShtc2cuZGF0YSk7XG4gICAgfVxuICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHNvY2tldDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/socket.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/createSocketUrl.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/createSocketUrl.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* global self */\nvar url = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\nvar getCurrentScriptSource = __webpack_require__(/*! ./getCurrentScriptSource */ \"./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js\");\nfunction createSocketUrl(resourceQuery, currentLocation) {\n  var urlParts;\n  if (typeof resourceQuery === 'string' && resourceQuery !== '') {\n    // If this bundle is inlined, use the resource query to get the correct url.\n    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`\n    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL\n    .substr(1) // replace first `&` with `?` to have a valid query string\n    .replace('&', '?'), true);\n  } else {\n    // Else, get the url from the <script> this file was called with.\n    var scriptHost = getCurrentScriptSource();\n    urlParts = url.parse(scriptHost || '/', true, true);\n  } // Use parameter to allow passing location in unit tests\n\n  if (typeof currentLocation === 'string' && currentLocation !== '') {\n    currentLocation = url.parse(currentLocation);\n  } else {\n    currentLocation = self.location;\n  }\n  return getSocketUrl(urlParts, currentLocation);\n}\n/*\n * Gets socket URL based on Script Source/Location\n * (scriptSrc: URL, location: URL) -> URL\n */\n\nfunction getSocketUrl(urlParts, loc) {\n  var auth = urlParts.auth,\n    query = urlParts.query;\n  var hostname = urlParts.hostname,\n    protocol = urlParts.protocol,\n    port = urlParts.port;\n  if (!port || port === '0') {\n    port = loc.port;\n  } // check ipv4 and ipv6 `all hostname`\n  // why do we need this check?\n  // hostname n/a for file protocol (example, when using electron, ionic)\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\n\n  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {\n    hostname = loc.hostname;\n  } // `hostname` can be empty when the script path is relative. In that case, specifying\n  // a protocol would result in an invalid URL.\n  // When https is used in the app, secure websockets are always necessary\n  // because the browser doesn't accept non-secure websockets.\n\n  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {\n    protocol = loc.protocol;\n  } // all of these sock url params are optionally passed in through\n  // resourceQuery, so we need to fall back to the default if\n  // they are not provided\n\n  var sockHost = query.sockHost || hostname;\n  var sockPath = query.sockPath || '/sockjs-node';\n  var sockPort = query.sockPort || port;\n  if (sockPort === 'location') {\n    sockPort = loc.port;\n  }\n  return url.format({\n    protocol: protocol,\n    auth: auth,\n    hostname: sockHost,\n    port: sockPort,\n    // If sockPath is provided it'll be passed in via the resourceQuery as a\n    // query param so it has to be parsed out of the querystring in order for the\n    // client to open the socket to the correct location.\n    pathname: sockPath\n  });\n}\nmodule.exports = createSocketUrl;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9jcmVhdGVTb2NrZXRVcmwuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2NyZWF0ZVNvY2tldFVybC5qcz81MDhlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIHNlbGYgKi9cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBnZXRDdXJyZW50U2NyaXB0U291cmNlID0gcmVxdWlyZSgnLi9nZXRDdXJyZW50U2NyaXB0U291cmNlJyk7XG5mdW5jdGlvbiBjcmVhdGVTb2NrZXRVcmwocmVzb3VyY2VRdWVyeSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciB1cmxQYXJ0cztcbiAgaWYgKHR5cGVvZiByZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiByZXNvdXJjZVF1ZXJ5ICE9PSAnJykge1xuICAgIC8vIElmIHRoaXMgYnVuZGxlIGlzIGlubGluZWQsIHVzZSB0aGUgcmVzb3VyY2UgcXVlcnkgdG8gZ2V0IHRoZSBjb3JyZWN0IHVybC5cbiAgICAvLyBmb3JtYXQgaXMgbGlrZSBgP2h0dHA6Ly8wLjAuMC4wOjgwOTYmc29ja1BvcnQ9ODA5NyZzb2NrSG9zdD1sb2NhbGhvc3RgXG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2UocmVzb3VyY2VRdWVyeSAvLyBzdHJpcCBsZWFkaW5nIGA/YCBmcm9tIHF1ZXJ5IHN0cmluZyB0byBnZXQgYSB2YWxpZCBVUkxcbiAgICAuc3Vic3RyKDEpIC8vIHJlcGxhY2UgZmlyc3QgYCZgIHdpdGggYD9gIHRvIGhhdmUgYSB2YWxpZCBxdWVyeSBzdHJpbmdcbiAgICAucmVwbGFjZSgnJicsICc/JyksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gICAgdmFyIHNjcmlwdEhvc3QgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlKCk7XG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2Uoc2NyaXB0SG9zdCB8fCAnLycsIHRydWUsIHRydWUpO1xuICB9IC8vIFVzZSBwYXJhbWV0ZXIgdG8gYWxsb3cgcGFzc2luZyBsb2NhdGlvbiBpbiB1bml0IHRlc3RzXG5cbiAgaWYgKHR5cGVvZiBjdXJyZW50TG9jYXRpb24gPT09ICdzdHJpbmcnICYmIGN1cnJlbnRMb2NhdGlvbiAhPT0gJycpIHtcbiAgICBjdXJyZW50TG9jYXRpb24gPSB1cmwucGFyc2UoY3VycmVudExvY2F0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50TG9jYXRpb24gPSBzZWxmLmxvY2F0aW9uO1xuICB9XG4gIHJldHVybiBnZXRTb2NrZXRVcmwodXJsUGFydHMsIGN1cnJlbnRMb2NhdGlvbik7XG59XG4vKlxuICogR2V0cyBzb2NrZXQgVVJMIGJhc2VkIG9uIFNjcmlwdCBTb3VyY2UvTG9jYXRpb25cbiAqIChzY3JpcHRTcmM6IFVSTCwgbG9jYXRpb246IFVSTCkgLT4gVVJMXG4gKi9cblxuZnVuY3Rpb24gZ2V0U29ja2V0VXJsKHVybFBhcnRzLCBsb2MpIHtcbiAgdmFyIGF1dGggPSB1cmxQYXJ0cy5hdXRoLFxuICAgIHF1ZXJ5ID0gdXJsUGFydHMucXVlcnk7XG4gIHZhciBob3N0bmFtZSA9IHVybFBhcnRzLmhvc3RuYW1lLFxuICAgIHByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2wsXG4gICAgcG9ydCA9IHVybFBhcnRzLnBvcnQ7XG4gIGlmICghcG9ydCB8fCBwb3J0ID09PSAnMCcpIHtcbiAgICBwb3J0ID0gbG9jLnBvcnQ7XG4gIH0gLy8gY2hlY2sgaXB2NCBhbmQgaXB2NiBgYWxsIGhvc3RuYW1lYFxuICAvLyB3aHkgZG8gd2UgbmVlZCB0aGlzIGNoZWNrP1xuICAvLyBob3N0bmFtZSBuL2EgZm9yIGZpbGUgcHJvdG9jb2wgKGV4YW1wbGUsIHdoZW4gdXNpbmcgZWxlY3Ryb24sIGlvbmljKVxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9wdWxsLzM4NFxuXG4gIGlmICgoaG9zdG5hbWUgPT09ICcwLjAuMC4wJyB8fCBob3N0bmFtZSA9PT0gJzo6JykgJiYgbG9jLmhvc3RuYW1lICYmIGxvYy5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IDApIHtcbiAgICBob3N0bmFtZSA9IGxvYy5ob3N0bmFtZTtcbiAgfSAvLyBgaG9zdG5hbWVgIGNhbiBiZSBlbXB0eSB3aGVuIHRoZSBzY3JpcHQgcGF0aCBpcyByZWxhdGl2ZS4gSW4gdGhhdCBjYXNlLCBzcGVjaWZ5aW5nXG4gIC8vIGEgcHJvdG9jb2wgd291bGQgcmVzdWx0IGluIGFuIGludmFsaWQgVVJMLlxuICAvLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYnNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3NhcnlcbiAgLy8gYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGFjY2VwdCBub24tc2VjdXJlIHdlYnNvY2tldHMuXG5cbiAgaWYgKGhvc3RuYW1lICYmIGhvc3RuYW1lICE9PSAnMTI3LjAuMC4xJyAmJiAobG9jLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCB1cmxQYXJ0cy5ob3N0bmFtZSA9PT0gJzAuMC4wLjAnKSkge1xuICAgIHByb3RvY29sID0gbG9jLnByb3RvY29sO1xuICB9IC8vIGFsbCBvZiB0aGVzZSBzb2NrIHVybCBwYXJhbXMgYXJlIG9wdGlvbmFsbHkgcGFzc2VkIGluIHRocm91Z2hcbiAgLy8gcmVzb3VyY2VRdWVyeSwgc28gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgaWZcbiAgLy8gdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cbiAgdmFyIHNvY2tIb3N0ID0gcXVlcnkuc29ja0hvc3QgfHwgaG9zdG5hbWU7XG4gIHZhciBzb2NrUGF0aCA9IHF1ZXJ5LnNvY2tQYXRoIHx8ICcvc29ja2pzLW5vZGUnO1xuICB2YXIgc29ja1BvcnQgPSBxdWVyeS5zb2NrUG9ydCB8fCBwb3J0O1xuICBpZiAoc29ja1BvcnQgPT09ICdsb2NhdGlvbicpIHtcbiAgICBzb2NrUG9ydCA9IGxvYy5wb3J0O1xuICB9XG4gIHJldHVybiB1cmwuZm9ybWF0KHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgYXV0aDogYXV0aCxcbiAgICBob3N0bmFtZTogc29ja0hvc3QsXG4gICAgcG9ydDogc29ja1BvcnQsXG4gICAgLy8gSWYgc29ja1BhdGggaXMgcHJvdmlkZWQgaXQnbGwgYmUgcGFzc2VkIGluIHZpYSB0aGUgcmVzb3VyY2VRdWVyeSBhcyBhXG4gICAgLy8gcXVlcnkgcGFyYW0gc28gaXQgaGFzIHRvIGJlIHBhcnNlZCBvdXQgb2YgdGhlIHF1ZXJ5c3RyaW5nIGluIG9yZGVyIGZvciB0aGVcbiAgICAvLyBjbGllbnQgdG8gb3BlbiB0aGUgc29ja2V0IHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICAgIHBhdGhuYW1lOiBzb2NrUGF0aFxuICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU29ja2V0VXJsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/createSocketUrl.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!********************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction getCurrentScriptSource() {\n  // `document.currentScript` is the most accurate way to find the current script,\n  // but is not supported in all browsers.\n  if (document.currentScript) {\n    return document.currentScript.getAttribute('src');\n  } // Fall back to getting all scripts in the document.\n\n  var scriptElements = document.scripts || [];\n  var currentScript = scriptElements[scriptElements.length - 1];\n  if (currentScript) {\n    return currentScript.getAttribute('src');\n  } // Fail as there was no script to use.\n\n  throw new Error('[WDS] Failed to get current script source.');\n}\nmodule.exports = getCurrentScriptSource;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzP2UwNGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXG5cbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcbiAgdmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1tzY3JpcHRFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgaWYgKGN1cnJlbnRTY3JpcHQpIHtcbiAgICByZXR1cm4gY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICB9IC8vIEZhaWwgYXMgdGhlcmUgd2FzIG5vIHNjcmlwdCB0byB1c2UuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdbV0RTXSBGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgc2NyaXB0IHNvdXJjZS4nKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/log.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar log = (__webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\").getLogger)('webpack-dev-server');\nvar INFO = 'info';\nvar WARN = 'warn';\nvar ERROR = 'error';\nvar DEBUG = 'debug';\nvar TRACE = 'trace';\nvar SILENT = 'silent'; // deprecated\n// TODO: remove these at major released\n// https://github.com/webpack/webpack-dev-server/pull/1825\n\nvar WARNING = 'warning';\nvar NONE = 'none'; // Set the default log level\n\nlog.setDefaultLevel(INFO);\nfunction setLogLevel(level) {\n  switch (level) {\n    case INFO:\n    case WARN:\n    case ERROR:\n    case DEBUG:\n    case TRACE:\n      log.setLevel(level);\n      break;\n    // deprecated\n\n    case WARNING:\n      // loglevel's warning name is different from webpack's\n      log.setLevel('warn');\n      break;\n    // deprecated\n\n    case NONE:\n    case SILENT:\n      log.disableAll();\n      break;\n    default:\n      log.error(\"[WDS] Unknown clientLogLevel '\".concat(level, \"'\"));\n  }\n}\nmodule.exports = {\n  log: log,\n  setLogLevel: setLogLevel\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9sb2cuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2xvZy5qcz9iM2MxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJykuZ2V0TG9nZ2VyKCd3ZWJwYWNrLWRldi1zZXJ2ZXInKTtcbnZhciBJTkZPID0gJ2luZm8nO1xudmFyIFdBUk4gPSAnd2Fybic7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIERFQlVHID0gJ2RlYnVnJztcbnZhciBUUkFDRSA9ICd0cmFjZSc7XG52YXIgU0lMRU5UID0gJ3NpbGVudCc7IC8vIGRlcHJlY2F0ZWRcbi8vIFRPRE86IHJlbW92ZSB0aGVzZSBhdCBtYWpvciByZWxlYXNlZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMTgyNVxuXG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcbnZhciBOT05FID0gJ25vbmUnOyAvLyBTZXQgdGhlIGRlZmF1bHQgbG9nIGxldmVsXG5cbmxvZy5zZXREZWZhdWx0TGV2ZWwoSU5GTyk7XG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSBJTkZPOlxuICAgIGNhc2UgV0FSTjpcbiAgICBjYXNlIEVSUk9SOlxuICAgIGNhc2UgREVCVUc6XG4gICAgY2FzZSBUUkFDRTpcbiAgICAgIGxvZy5zZXRMZXZlbChsZXZlbCk7XG4gICAgICBicmVhaztcbiAgICAvLyBkZXByZWNhdGVkXG5cbiAgICBjYXNlIFdBUk5JTkc6XG4gICAgICAvLyBsb2dsZXZlbCdzIHdhcm5pbmcgbmFtZSBpcyBkaWZmZXJlbnQgZnJvbSB3ZWJwYWNrJ3NcbiAgICAgIGxvZy5zZXRMZXZlbCgnd2FybicpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gZGVwcmVjYXRlZFxuXG4gICAgY2FzZSBOT05FOlxuICAgIGNhc2UgU0lMRU5UOlxuICAgICAgbG9nLmRpc2FibGVBbGwoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsb2cuZXJyb3IoXCJbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsICdcIi5jb25jYXQobGV2ZWwsIFwiJ1wiKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2c6IGxvZyxcbiAgc2V0TG9nTGV2ZWw6IHNldExvZ0xldmVsXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/log.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/reloadApp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/reloadApp.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* global WorkerGlobalScope self */\nvar _require = __webpack_require__(/*! ./log */ \"./node_modules/webpack-dev-server/client/utils/log.js\"),\n  log = _require.log;\nfunction reloadApp(_ref, _ref2) {\n  var hotReload = _ref.hotReload,\n    hot = _ref.hot,\n    liveReload = _ref.liveReload;\n  var isUnloading = _ref2.isUnloading,\n    currentHash = _ref2.currentHash;\n  if (isUnloading || !hotReload) {\n    return;\n  }\n  if (hot) {\n    log.info('[WDS] App hot update...');\n    var hotEmitter = __webpack_require__(/*! webpack/hot/emitter */ \"./node_modules/webpack/hot/emitter.js\");\n    hotEmitter.emit('webpackHotUpdate', currentHash);\n    if (typeof self !== 'undefined' && self.window) {\n      // broadcast update to window\n      self.postMessage(\"webpackHotUpdate\".concat(currentHash), '*');\n    }\n  } // allow refreshing the page only if liveReload isn't disabled\n  else if (liveReload) {\n    var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)\n\n    var intervalId = self.setInterval(function () {\n      if (rootWindow.location.protocol !== 'about:') {\n        // reload immediately if protocol is valid\n        applyReload(rootWindow, intervalId);\n      } else {\n        rootWindow = rootWindow.parent;\n        if (rootWindow.parent === rootWindow) {\n          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\n          applyReload(rootWindow, intervalId);\n        }\n      }\n    });\n  }\n  function applyReload(rootWindow, intervalId) {\n    clearInterval(intervalId);\n    log.info('[WDS] App updated. Reloading...');\n    rootWindow.location.reload();\n  }\n}\nmodule.exports = reloadApp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvcmVsb2FkQXBwLmpzPzU0NzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9sb2cnKSxcbiAgbG9nID0gX3JlcXVpcmUubG9nO1xuZnVuY3Rpb24gcmVsb2FkQXBwKF9yZWYsIF9yZWYyKSB7XG4gIHZhciBob3RSZWxvYWQgPSBfcmVmLmhvdFJlbG9hZCxcbiAgICBob3QgPSBfcmVmLmhvdCxcbiAgICBsaXZlUmVsb2FkID0gX3JlZi5saXZlUmVsb2FkO1xuICB2YXIgaXNVbmxvYWRpbmcgPSBfcmVmMi5pc1VubG9hZGluZyxcbiAgICBjdXJyZW50SGFzaCA9IF9yZWYyLmN1cnJlbnRIYXNoO1xuICBpZiAoaXNVbmxvYWRpbmcgfHwgIWhvdFJlbG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaG90KSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCBob3QgdXBkYXRlLi4uJyk7XG4gICAgdmFyIGhvdEVtaXR0ZXIgPSByZXF1aXJlKCd3ZWJwYWNrL2hvdC9lbWl0dGVyJyk7XG4gICAgaG90RW1pdHRlci5lbWl0KCd3ZWJwYWNrSG90VXBkYXRlJywgY3VycmVudEhhc2gpO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi53aW5kb3cpIHtcbiAgICAgIC8vIGJyb2FkY2FzdCB1cGRhdGUgdG8gd2luZG93XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKFwid2VicGFja0hvdFVwZGF0ZVwiLmNvbmNhdChjdXJyZW50SGFzaCksICcqJyk7XG4gICAgfVxuICB9IC8vIGFsbG93IHJlZnJlc2hpbmcgdGhlIHBhZ2Ugb25seSBpZiBsaXZlUmVsb2FkIGlzbid0IGRpc2FibGVkXG4gIGVsc2UgaWYgKGxpdmVSZWxvYWQpIHtcbiAgICB2YXIgcm9vdFdpbmRvdyA9IHNlbGY7IC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxuXG4gICAgdmFyIGludGVydmFsSWQgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyb290V2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAnYWJvdXQ6Jykge1xuICAgICAgICAvLyByZWxvYWQgaW1tZWRpYXRlbHkgaWYgcHJvdG9jb2wgaXMgdmFsaWRcbiAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290V2luZG93ID0gcm9vdFdpbmRvdy5wYXJlbnQ7XG4gICAgICAgIGlmIChyb290V2luZG93LnBhcmVudCA9PT0gcm9vdFdpbmRvdykge1xuICAgICAgICAgIC8vIGlmIHBhcmVudCBlcXVhbHMgY3VycmVudCB3aW5kb3cgd2UndmUgcmVhY2hlZCB0aGUgcm9vdCB3aGljaCB3b3VsZCBjb250aW51ZSBmb3JldmVyLCBzbyB0cmlnZ2VyIGEgcmVsb2FkIGFueXdheXNcbiAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgcm9vdFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSByZWxvYWRBcHA7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/reloadApp.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/sendMessage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/sendMessage.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* global __resourceQuery WorkerGlobalScope self */\n// Send messages to the outside, so plugins can consume it.\nfunction sendMsg(type, data) {\n  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {\n    self.postMessage({\n      type: \"webpack\".concat(type),\n      data: data\n    }, '*');\n  }\n}\nmodule.exports = sendMsg;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcz8yYTg5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG4vLyBTZW5kIG1lc3NhZ2VzIHRvIHRoZSBvdXRzaWRlLCBzbyBwbHVnaW5zIGNhbiBjb25zdW1lIGl0LlxuZnVuY3Rpb24gc2VuZE1zZyh0eXBlLCBkYXRhKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ3ZWJwYWNrXCIuY29uY2F0KHR5cGUpLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0sICcqJyk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc2VuZE1zZzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/sendMessage.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/node_modules/ansi-html-community/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/node_modules/ansi-html-community/index.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = ansiHTML;\n\n// Reference to https://github.com/sindresorhus/ansi-regex\nvar _regANSI = /(?:(?:\\u001b\\[)|\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\u001b[A-M]/;\nvar _defColors = {\n  reset: ['fff', '000'],\n  // [FOREGROUD_COLOR, BACKGROUND_COLOR]\n  black: '000',\n  red: 'ff0000',\n  green: '209805',\n  yellow: 'e8bf03',\n  blue: '0000ff',\n  magenta: 'ff00ff',\n  cyan: '00ffee',\n  lightgrey: 'f0f0f0',\n  darkgrey: '888'\n};\nvar _styles = {\n  30: 'black',\n  31: 'red',\n  32: 'green',\n  33: 'yellow',\n  34: 'blue',\n  35: 'magenta',\n  36: 'cyan',\n  37: 'lightgrey'\n};\nvar _openTags = {\n  '1': 'font-weight:bold',\n  // bold\n  '2': 'opacity:0.5',\n  // dim\n  '3': '<i>',\n  // italic\n  '4': '<u>',\n  // underscore\n  '8': 'display:none',\n  // hidden\n  '9': '<del>' // delete\n};\n\nvar _closeTags = {\n  '23': '</i>',\n  // reset italic\n  '24': '</u>',\n  // reset underscore\n  '29': '</del>' // reset delete\n};\n\n[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {\n  _closeTags[n] = '</span>';\n});\n\n/**\n * Converts text with ANSI color codes to HTML markup.\n * @param {String} text\n * @returns {*}\n */\nfunction ansiHTML(text) {\n  // Returns the text if the string has no ANSI escape code.\n  if (!_regANSI.test(text)) {\n    return text;\n  }\n\n  // Cache opened sequence.\n  var ansiCodes = [];\n  // Replace with markup.\n  var ret = text.replace(/\\033\\[(\\d+)m/g, function (match, seq) {\n    var ot = _openTags[seq];\n    if (ot) {\n      // If current sequence has been opened, close it.\n      if (!!~ansiCodes.indexOf(seq)) {\n        // eslint-disable-line no-extra-boolean-cast\n        ansiCodes.pop();\n        return '</span>';\n      }\n      // Open tag.\n      ansiCodes.push(seq);\n      return ot[0] === '<' ? ot : '<span style=\"' + ot + ';\">';\n    }\n    var ct = _closeTags[seq];\n    if (ct) {\n      // Pop sequence\n      ansiCodes.pop();\n      return ct;\n    }\n    return '';\n  });\n\n  // Make sure tags are closed.\n  var l = ansiCodes.length;\n  l > 0 && (ret += Array(l + 1).join('</span>'));\n  return ret;\n}\n\n/**\n * Customize colors.\n * @param {Object} colors reference to _defColors\n */\nansiHTML.setColors = function (colors) {\n  if (typeof colors !== 'object') {\n    throw new Error('`colors` parameter must be an Object.');\n  }\n  var _finalColors = {};\n  for (var key in _defColors) {\n    var hex = colors.hasOwnProperty(key) ? colors[key] : null;\n    if (!hex) {\n      _finalColors[key] = _defColors[key];\n      continue;\n    }\n    if ('reset' === key) {\n      if (typeof hex === 'string') {\n        hex = [hex];\n      }\n      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {\n        return typeof h !== 'string';\n      })) {\n        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000');\n      }\n      var defHexColor = _defColors[key];\n      if (!hex[0]) {\n        hex[0] = defHexColor[0];\n      }\n      if (hex.length === 1 || !hex[1]) {\n        hex = [hex[0]];\n        hex.push(defHexColor[1]);\n      }\n      hex = hex.slice(0, 2);\n    } else if (typeof hex !== 'string') {\n      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000');\n    }\n    _finalColors[key] = hex;\n  }\n  _setTags(_finalColors);\n};\n\n/**\n * Reset colors.\n */\nansiHTML.reset = function () {\n  _setTags(_defColors);\n};\n\n/**\n * Expose tags, including open and close.\n * @type {Object}\n */\nansiHTML.tags = {};\nif (Object.defineProperty) {\n  Object.defineProperty(ansiHTML.tags, 'open', {\n    get: function () {\n      return _openTags;\n    }\n  });\n  Object.defineProperty(ansiHTML.tags, 'close', {\n    get: function () {\n      return _closeTags;\n    }\n  });\n} else {\n  ansiHTML.tags.open = _openTags;\n  ansiHTML.tags.close = _closeTags;\n}\nfunction _setTags(colors) {\n  // reset all\n  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1];\n  // inverse\n  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0];\n  // dark grey\n  _openTags['90'] = 'color:#' + colors.darkgrey;\n  for (var code in _styles) {\n    var color = _styles[code];\n    var oriColor = colors[color] || '000';\n    _openTags[code] = 'color:#' + oriColor;\n    code = parseInt(code);\n    _openTags[(code + 10).toString()] = 'background:#' + oriColor;\n  }\n}\nansiHTML.reset();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwtY29tbXVuaXR5L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2Fuc2ktaHRtbC1jb21tdW5pdHkvaW5kZXguanM/MGQ0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUw7XG5cbi8vIFJlZmVyZW5jZSB0byBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2Fuc2ktcmVnZXhcbnZhciBfcmVnQU5TSSA9IC8oPzooPzpcXHUwMDFiXFxbKXxcXHUwMDliKSg/Oig/OlswLTldezEsM30pPyg/Oig/OjtbMC05XXswLDN9KSopP1tBLU18Zi1tXSl8XFx1MDAxYltBLU1dLztcbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sXG4gIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn07XG52YXIgX3N0eWxlcyA9IHtcbiAgMzA6ICdibGFjaycsXG4gIDMxOiAncmVkJyxcbiAgMzI6ICdncmVlbicsXG4gIDMzOiAneWVsbG93JyxcbiAgMzQ6ICdibHVlJyxcbiAgMzU6ICdtYWdlbnRhJyxcbiAgMzY6ICdjeWFuJyxcbiAgMzc6ICdsaWdodGdyZXknXG59O1xudmFyIF9vcGVuVGFncyA9IHtcbiAgJzEnOiAnZm9udC13ZWlnaHQ6Ym9sZCcsXG4gIC8vIGJvbGRcbiAgJzInOiAnb3BhY2l0eTowLjUnLFxuICAvLyBkaW1cbiAgJzMnOiAnPGk+JyxcbiAgLy8gaXRhbGljXG4gICc0JzogJzx1PicsXG4gIC8vIHVuZGVyc2NvcmVcbiAgJzgnOiAnZGlzcGxheTpub25lJyxcbiAgLy8gaGlkZGVuXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcbn07XG5cbnZhciBfY2xvc2VUYWdzID0ge1xuICAnMjMnOiAnPC9pPicsXG4gIC8vIHJlc2V0IGl0YWxpY1xuICAnMjQnOiAnPC91PicsXG4gIC8vIHJlc2V0IHVuZGVyc2NvcmVcbiAgJzI5JzogJzwvZGVsPicgLy8gcmVzZXQgZGVsZXRlXG59O1xuXG5bMCwgMjEsIDIyLCAyNywgMjgsIDM5LCA0OV0uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nO1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgdGV4dCB3aXRoIEFOU0kgY29sb3IgY29kZXMgdG8gSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGFuc2lIVE1MKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIC8vIENhY2hlIG9wZW5lZCBzZXF1ZW5jZS5cbiAgdmFyIGFuc2lDb2RlcyA9IFtdO1xuICAvLyBSZXBsYWNlIHdpdGggbWFya3VwLlxuICB2YXIgcmV0ID0gdGV4dC5yZXBsYWNlKC9cXDAzM1xcWyhcXGQrKW0vZywgZnVuY3Rpb24gKG1hdGNoLCBzZXEpIHtcbiAgICB2YXIgb3QgPSBfb3BlblRhZ3Nbc2VxXTtcbiAgICBpZiAob3QpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgc2VxdWVuY2UgaGFzIGJlZW4gb3BlbmVkLCBjbG9zZSBpdC5cbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgIGFuc2lDb2Rlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcbiAgICAgIH1cbiAgICAgIC8vIE9wZW4gdGFnLlxuICAgICAgYW5zaUNvZGVzLnB1c2goc2VxKTtcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPic7XG4gICAgfVxuICAgIHZhciBjdCA9IF9jbG9zZVRhZ3Nbc2VxXTtcbiAgICBpZiAoY3QpIHtcbiAgICAgIC8vIFBvcCBzZXF1ZW5jZVxuICAgICAgYW5zaUNvZGVzLnBvcCgpO1xuICAgICAgcmV0dXJuIGN0O1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aDtcbiAgbCA+IDAgJiYgKHJldCArPSBBcnJheShsICsgMSkuam9pbignPC9zcGFuPicpKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDdXN0b21pemUgY29sb3JzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyByZWZlcmVuY2UgdG8gX2RlZkNvbG9yc1xuICovXG5hbnNpSFRNTC5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gIGlmICh0eXBlb2YgY29sb3JzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignYGNvbG9yc2AgcGFyYW1ldGVyIG11c3QgYmUgYW4gT2JqZWN0LicpO1xuICB9XG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIF9kZWZDb2xvcnMpIHtcbiAgICB2YXIgaGV4ID0gY29sb3JzLmhhc093blByb3BlcnR5KGtleSkgPyBjb2xvcnNba2V5XSA6IG51bGw7XG4gICAgaWYgKCFoZXgpIHtcbiAgICAgIF9maW5hbENvbG9yc1trZXldID0gX2RlZkNvbG9yc1trZXldO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgncmVzZXQnID09PSBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBoZXggPSBbaGV4XTtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBoICE9PSAnc3RyaW5nJztcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKTtcbiAgICAgIH1cbiAgICAgIHZhciBkZWZIZXhDb2xvciA9IF9kZWZDb2xvcnNba2V5XTtcbiAgICAgIGlmICghaGV4WzBdKSB7XG4gICAgICAgIGhleFswXSA9IGRlZkhleENvbG9yWzBdO1xuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXTtcbiAgICAgICAgaGV4LnB1c2goZGVmSGV4Q29sb3JbMV0pO1xuICAgICAgfVxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpO1xuICAgIH1cbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleDtcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpO1xufTtcblxuLyoqXG4gKiBSZXNldCBjb2xvcnMuXG4gKi9cbmFuc2lIVE1MLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBfc2V0VGFncyhfZGVmQ29sb3JzKTtcbn07XG5cbi8qKlxuICogRXhwb3NlIHRhZ3MsIGluY2x1ZGluZyBvcGVuIGFuZCBjbG9zZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmFuc2lIVE1MLnRhZ3MgPSB7fTtcbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9vcGVuVGFncztcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ2Nsb3NlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9jbG9zZVRhZ3M7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGFuc2lIVE1MLnRhZ3Mub3BlbiA9IF9vcGVuVGFncztcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3M7XG59XG5mdW5jdGlvbiBfc2V0VGFncyhjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV07XG4gIC8vIGludmVyc2VcbiAgX29wZW5UYWdzWyc3J10gPSAnY29sb3I6IycgKyBjb2xvcnMucmVzZXRbMV0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMF07XG4gIC8vIGRhcmsgZ3JleVxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXk7XG4gIGZvciAodmFyIGNvZGUgaW4gX3N0eWxlcykge1xuICAgIHZhciBjb2xvciA9IF9zdHlsZXNbY29kZV07XG4gICAgdmFyIG9yaUNvbG9yID0gY29sb3JzW2NvbG9yXSB8fCAnMDAwJztcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvcjtcbiAgICBjb2RlID0gcGFyc2VJbnQoY29kZSk7XG4gICAgX29wZW5UYWdzWyhjb2RlICsgMTApLnRvU3RyaW5nKCldID0gJ2JhY2tncm91bmQ6IycgKyBvcmlDb2xvcjtcbiAgfVxufVxuYW5zaUhUTUwucmVzZXQoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/node_modules/ansi-html-community/index.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/node_modules/ansi-regex/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/node_modules/ansi-regex/index.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function () {\n  return /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcz9jMjQwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/node_modules/ansi-regex/index.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ansiRegex = __webpack_require__(/*! ansi-regex */ \"./node_modules/webpack-dev-server/node_modules/ansi-regex/index.js\")();\nmodule.exports = function (str) {\n  return typeof str === 'string' ? str.replace(ansiRegex, '') : str;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzP2RlNzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/dev-server.js":
/*!************************************************!*\
  !*** ./node_modules/webpack/hot/dev-server.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/* globals __webpack_hash__ */\nif (true) {\n  var lastHash;\n  var upToDate = function upToDate() {\n    return lastHash.indexOf(__webpack_require__.h()) >= 0;\n  };\n  var log = __webpack_require__(/*! ./log */ \"./node_modules/webpack/hot/log.js\");\n  var check = function check() {\n    module.hot.check(true).then(function (updatedModules) {\n      if (!updatedModules) {\n        log(\"warning\", \"[HMR] Cannot find update. \" + (typeof window !== \"undefined\" ? \"Need to do a full reload!\" : \"Please reload manually!\"));\n        log(\"warning\", \"[HMR] (Probably because of restarting the webpack-dev-server)\");\n        if (typeof window !== \"undefined\") {\n          window.location.reload();\n        }\n        return;\n      }\n      if (!upToDate()) {\n        check();\n      }\n      __webpack_require__(/*! ./log-apply-result */ \"./node_modules/webpack/hot/log-apply-result.js\")(updatedModules, updatedModules);\n      if (upToDate()) {\n        log(\"info\", \"[HMR] App is up to date.\");\n      }\n    }).catch(function (err) {\n      var status = module.hot.status();\n      if ([\"abort\", \"fail\"].indexOf(status) >= 0) {\n        log(\"warning\", \"[HMR] Cannot apply update. \" + (typeof window !== \"undefined\" ? \"Need to do a full reload!\" : \"Please reload manually!\"));\n        log(\"warning\", \"[HMR] \" + log.formatError(err));\n        if (typeof window !== \"undefined\") {\n          window.location.reload();\n        }\n      } else {\n        log(\"warning\", \"[HMR] Update failed: \" + log.formatError(err));\n      }\n    });\n  };\n  var hotEmitter = __webpack_require__(/*! ./emitter */ \"./node_modules/webpack/hot/emitter.js\");\n  hotEmitter.on(\"webpackHotUpdate\", function (currentHash) {\n    lastHash = currentHash;\n    if (!upToDate() && module.hot.status() === \"idle\") {\n      log(\"info\", \"[HMR] Checking for updates on the server...\");\n      check();\n    }\n  });\n  log(\"info\", \"[HMR] Waiting for update signal from WDS...\");\n} else {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZGV2LXNlcnZlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L2Rldi1zZXJ2ZXIuanM/N2Y1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLyogZ2xvYmFscyBfX3dlYnBhY2tfaGFzaF9fICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgbGFzdEhhc2g7XG4gIHZhciB1cFRvRGF0ZSA9IGZ1bmN0aW9uIHVwVG9EYXRlKCkge1xuICAgIHJldHVybiBsYXN0SGFzaC5pbmRleE9mKF9fd2VicGFja19oYXNoX18pID49IDA7XG4gIH07XG4gIHZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgIG1vZHVsZS5ob3QuY2hlY2sodHJ1ZSkudGhlbihmdW5jdGlvbiAodXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgIGlmICghdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIENhbm5vdCBmaW5kIHVwZGF0ZS4gXCIgKyAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IFwiTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiIDogXCJQbGVhc2UgcmVsb2FkIG1hbnVhbGx5IVwiKSk7XG4gICAgICAgIGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSAoUHJvYmFibHkgYmVjYXVzZSBvZiByZXN0YXJ0aW5nIHRoZSB3ZWJwYWNrLWRldi1zZXJ2ZXIpXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXVwVG9EYXRlKCkpIHtcbiAgICAgICAgY2hlY2soKTtcbiAgICAgIH1cbiAgICAgIHJlcXVpcmUoXCIuL2xvZy1hcHBseS1yZXN1bHRcIikodXBkYXRlZE1vZHVsZXMsIHVwZGF0ZWRNb2R1bGVzKTtcbiAgICAgIGlmICh1cFRvRGF0ZSgpKSB7XG4gICAgICAgIGxvZyhcImluZm9cIiwgXCJbSE1SXSBBcHAgaXMgdXAgdG8gZGF0ZS5cIik7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgdmFyIHN0YXR1cyA9IG1vZHVsZS5ob3Quc3RhdHVzKCk7XG4gICAgICBpZiAoW1wiYWJvcnRcIiwgXCJmYWlsXCJdLmluZGV4T2Yoc3RhdHVzKSA+PSAwKSB7XG4gICAgICAgIGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBDYW5ub3QgYXBwbHkgdXBkYXRlLiBcIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCJOZWVkIHRvIGRvIGEgZnVsbCByZWxvYWQhXCIgOiBcIlBsZWFzZSByZWxvYWQgbWFudWFsbHkhXCIpKTtcbiAgICAgICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIFwiICsgbG9nLmZvcm1hdEVycm9yKGVycikpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIFVwZGF0ZSBmYWlsZWQ6IFwiICsgbG9nLmZvcm1hdEVycm9yKGVycikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICB2YXIgaG90RW1pdHRlciA9IHJlcXVpcmUoXCIuL2VtaXR0ZXJcIik7XG4gIGhvdEVtaXR0ZXIub24oXCJ3ZWJwYWNrSG90VXBkYXRlXCIsIGZ1bmN0aW9uIChjdXJyZW50SGFzaCkge1xuICAgIGxhc3RIYXNoID0gY3VycmVudEhhc2g7XG4gICAgaWYgKCF1cFRvRGF0ZSgpICYmIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09IFwiaWRsZVwiKSB7XG4gICAgICBsb2coXCJpbmZvXCIsIFwiW0hNUl0gQ2hlY2tpbmcgZm9yIHVwZGF0ZXMgb24gdGhlIHNlcnZlci4uLlwiKTtcbiAgICAgIGNoZWNrKCk7XG4gICAgfVxuICB9KTtcbiAgbG9nKFwiaW5mb1wiLCBcIltITVJdIFdhaXRpbmcgZm9yIHVwZGF0ZSBzaWduYWwgZnJvbSBXRFMuLi5cIik7XG59IGVsc2Uge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJbSE1SXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGlzIGRpc2FibGVkLlwiKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/dev-server.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/emitter.js":
/*!*********************************************!*\
  !*** ./node_modules/webpack/hot/emitter.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nmodule.exports = new EventEmitter();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZW1pdHRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9lbWl0dGVyLmpzP2QwYjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/emitter.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/*!******************************************************!*\
  !*** ./node_modules/webpack/hot/log-apply-result.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function (updatedModules, renewedModules) {\n  var unacceptedModules = updatedModules.filter(function (moduleId) {\n    return renewedModules && renewedModules.indexOf(moduleId) < 0;\n  });\n  var log = __webpack_require__(/*! ./log */ \"./node_modules/webpack/hot/log.js\");\n  if (unacceptedModules.length > 0) {\n    log(\"warning\", \"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)\");\n    unacceptedModules.forEach(function (moduleId) {\n      log(\"warning\", \"[HMR]  - \" + moduleId);\n    });\n  }\n  if (!renewedModules || renewedModules.length === 0) {\n    log(\"info\", \"[HMR] Nothing hot updated.\");\n  } else {\n    log(\"info\", \"[HMR] Updated modules:\");\n    renewedModules.forEach(function (moduleId) {\n      if (typeof moduleId === \"string\" && moduleId.indexOf(\"!\") !== -1) {\n        var parts = moduleId.split(\"!\");\n        log.groupCollapsed(\"info\", \"[HMR]  - \" + parts.pop());\n        log(\"info\", \"[HMR]  - \" + moduleId);\n        log.groupEnd(\"info\");\n      } else {\n        log(\"info\", \"[HMR]  - \" + moduleId);\n      }\n    });\n    var numberIds = renewedModules.every(function (moduleId) {\n      return typeof moduleId === \"number\";\n    });\n    if (numberIds) log(\"info\", '[HMR] Consider using the optimization.moduleIds: \"named\" for module names.');\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLWFwcGx5LXJlc3VsdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9sb2ctYXBwbHktcmVzdWx0LmpzPzllNjEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcykge1xuICB2YXIgdW5hY2NlcHRlZE1vZHVsZXMgPSB1cGRhdGVkTW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG4gICAgcmV0dXJuIHJlbmV3ZWRNb2R1bGVzICYmIHJlbmV3ZWRNb2R1bGVzLmluZGV4T2YobW9kdWxlSWQpIDwgMDtcbiAgfSk7XG4gIHZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG4gIGlmICh1bmFjY2VwdGVkTW9kdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIFRoZSBmb2xsb3dpbmcgbW9kdWxlcyBjb3VsZG4ndCBiZSBob3QgdXBkYXRlZDogKFRoZXkgd291bGQgbmVlZCBhIGZ1bGwgcmVsb2FkISlcIik7XG4gICAgdW5hY2NlcHRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcbiAgICAgIGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXJlbmV3ZWRNb2R1bGVzIHx8IHJlbmV3ZWRNb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGxvZyhcImluZm9cIiwgXCJbSE1SXSBOb3RoaW5nIGhvdCB1cGRhdGVkLlwiKTtcbiAgfSBlbHNlIHtcbiAgICBsb2coXCJpbmZvXCIsIFwiW0hNUl0gVXBkYXRlZCBtb2R1bGVzOlwiKTtcbiAgICByZW5ld2VkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICAgICAgaWYgKHR5cGVvZiBtb2R1bGVJZCA9PT0gXCJzdHJpbmdcIiAmJiBtb2R1bGVJZC5pbmRleE9mKFwiIVwiKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gbW9kdWxlSWQuc3BsaXQoXCIhXCIpO1xuICAgICAgICBsb2cuZ3JvdXBDb2xsYXBzZWQoXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBwYXJ0cy5wb3AoKSk7XG4gICAgICAgIGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcbiAgICAgICAgbG9nLmdyb3VwRW5kKFwiaW5mb1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbnVtYmVySWRzID0gcmVuZXdlZE1vZHVsZXMuZXZlcnkoZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG1vZHVsZUlkID09PSBcIm51bWJlclwiO1xuICAgIH0pO1xuICAgIGlmIChudW1iZXJJZHMpIGxvZyhcImluZm9cIiwgJ1tITVJdIENvbnNpZGVyIHVzaW5nIHRoZSBvcHRpbWl6YXRpb24ubW9kdWxlSWRzOiBcIm5hbWVkXCIgZm9yIG1vZHVsZSBuYW1lcy4nKTtcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/log-apply-result.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!*****************************************!*\
  !*** ./node_modules/webpack/hot/log.js ***!
  \*****************************************/
/***/ ((module) => {

eval("var logLevel = \"info\";\nfunction dummy() {}\nfunction shouldLog(level) {\n  var shouldLog = logLevel === \"info\" && level === \"info\" || [\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\" || [\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\";\n  return shouldLog;\n}\nfunction logGroup(logFn) {\n  return function (level, msg) {\n    if (shouldLog(level)) {\n      logFn(msg);\n    }\n  };\n}\nmodule.exports = function (level, msg) {\n  if (shouldLog(level)) {\n    if (level === \"info\") {\n      console.log(msg);\n    } else if (level === \"warning\") {\n      console.warn(msg);\n    } else if (level === \"error\") {\n      console.error(msg);\n    }\n  }\n};\n\n/* eslint-disable node/no-unsupported-features/node-builtins */\nvar group = console.group || dummy;\nvar groupCollapsed = console.groupCollapsed || dummy;\nvar groupEnd = console.groupEnd || dummy;\n/* eslint-enable node/no-unsupported-features/node-builtins */\n\nmodule.exports.group = logGroup(group);\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\nmodule.exports.groupEnd = logGroup(groupEnd);\nmodule.exports.setLogLevel = function (level) {\n  logLevel = level;\n};\nmodule.exports.formatError = function (err) {\n  var message = err.message;\n  var stack = err.stack;\n  if (!stack) {\n    return message;\n  } else if (stack.indexOf(message) < 0) {\n    return message + \"\\n\" + stack;\n  } else {\n    return stack;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLmpzPzk0YTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XG5mdW5jdGlvbiBkdW1teSgpIHt9XG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcbiAgdmFyIHNob3VsZExvZyA9IGxvZ0xldmVsID09PSBcImluZm9cIiAmJiBsZXZlbCA9PT0gXCJpbmZvXCIgfHwgW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIgfHwgW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCI7XG4gIHJldHVybiBzaG91bGRMb2c7XG59XG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGxldmVsLCBtc2cpIHtcbiAgICBpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuICAgICAgbG9nRm4obXNnKTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnKSB7XG4gIGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG4gICAgaWYgKGxldmVsID09PSBcImluZm9cIikge1xuICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xuICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgfSBlbHNlIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XG52YXIgZ3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIHx8IGR1bW15O1xudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcbi8qIGVzbGludC1lbmFibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nR3JvdXAoZ3JvdXApO1xubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XG5tb2R1bGUuZXhwb3J0cy5ncm91cEVuZCA9IGxvZ0dyb3VwKGdyb3VwRW5kKTtcbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gIGxvZ0xldmVsID0gbGV2ZWw7XG59O1xubW9kdWxlLmV4cG9ydHMuZm9ybWF0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gIHZhciBzdGFjayA9IGVyci5zdGFjaztcbiAgaWYgKCFzdGFjaykge1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9IGVsc2UgaWYgKHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPCAwKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/log.js\n");

/***/ }),

/***/ "./src/Painter/index.ts":
/*!******************************!*\
  !*** ./src/Painter/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Painter = void 0;\r\nvar storage_1 = __webpack_require__(/*! lib/storage */ \"./src/lib/storage.ts\");\r\nvar paint_brush_png_1 = __importDefault(__webpack_require__(/*! images/paint-brush.png */ \"./src/images/paint-brush.png\"));\r\nvar Painter = /** @class */ (function () {\r\n    function Painter() {\r\n        this.$canvas = null;\r\n        this.ctx = null;\r\n        this.drawOn = storage_1.getDrawOn();\r\n        this.isDrawing = false;\r\n        this.strokeColor = \"red\";\r\n        this.thickness = 3;\r\n        this.paintBrush = true;\r\n        this.positions = [];\r\n        this.figures = storage_1.getFigures();\r\n        this.onDraw = null;\r\n        this.removeDrawEvent = function () { };\r\n    }\r\n    Painter.prototype.add = function (name, callback) {\r\n        var _this = this;\r\n        if (!this.$canvas)\r\n            return;\r\n        this.$canvas.addEventListener(name, callback);\r\n        return function () {\r\n            _this.$canvas.removeEventListener(name, callback);\r\n        };\r\n    };\r\n    Painter.prototype.drawStart = function (painterOption) {\r\n        if (!painterOption)\r\n            painterOption = { color: this.strokeColor, thickness: this.thickness };\r\n        this.isDrawing = true;\r\n        this.setOptions(painterOption);\r\n    };\r\n    Painter.prototype.draw = function (position, redraw) {\r\n        if (redraw === void 0) { redraw = false; }\r\n        if (!this.ctx)\r\n            return;\r\n        var drawX = position.x;\r\n        var drawY = position.y;\r\n        if (!this.isDrawing) {\r\n            this.ctx.beginPath();\r\n        }\r\n        else {\r\n            this.ctx.lineTo(drawX, drawY);\r\n            this.ctx.stroke();\r\n            if (this.onDraw)\r\n                this.onDraw({ x: drawX, y: drawY });\r\n        }\r\n        if (!redraw) {\r\n            this.positions.push(position);\r\n        }\r\n    };\r\n    Painter.prototype.drawEnd = function (redraw) {\r\n        if (redraw === void 0) { redraw = false; }\r\n        this.isDrawing = false;\r\n        this.ctx.beginPath();\r\n        if (!redraw) {\r\n            this.setFigures();\r\n        }\r\n    };\r\n    Painter.prototype.redraw = function () {\r\n        var _this = this;\r\n        for (var _i = 0, _a = this.figures; _i < _a.length; _i++) {\r\n            var figure = _a[_i];\r\n            this.drawStart(figure.painterOption);\r\n            figure.positions.forEach(function (position) {\r\n                _this.draw(position, true);\r\n            });\r\n            this.drawEnd(true);\r\n        }\r\n    };\r\n    Painter.prototype.setTarget = function (_a) {\r\n        var target = _a.target, onDraw = _a.onDraw;\r\n        if (!target)\r\n            return;\r\n        this.$canvas = target;\r\n        this.ctx = target.getContext(\"2d\");\r\n        this.setCursor();\r\n        this.addDrawEvent();\r\n        if (onDraw)\r\n            this.onDraw = onDraw;\r\n        if (this.drawOn && this.figures.length > 0)\r\n            this.redraw();\r\n    };\r\n    Painter.prototype.setOptions = function (_a) {\r\n        var color = _a.color, thickness = _a.thickness, paintBrush = _a.paintBrush;\r\n        if (!this.ctx)\r\n            return;\r\n        if (color) {\r\n            this.strokeColor = color;\r\n            this.ctx.strokeStyle = color;\r\n        }\r\n        if (thickness) {\r\n            this.thickness = thickness;\r\n            this.ctx.lineWidth = thickness;\r\n        }\r\n        if (paintBrush) {\r\n            this.paintBrush = paintBrush;\r\n            this.setCursor();\r\n        }\r\n    };\r\n    Painter.prototype.setCursor = function () {\r\n        if (this.paintBrush)\r\n            this.$canvas.style.cursor = \"url(\" + paint_brush_png_1.default + \"), auto\";\r\n    };\r\n    Painter.prototype.getFigures = function () {\r\n        this.figures = storage_1.getFigures();\r\n    };\r\n    Painter.prototype.setFigures = function () {\r\n        this.figures.push({\r\n            painterOption: { color: this.strokeColor, thickness: this.thickness },\r\n            positions: this.positions\r\n        });\r\n        storage_1.storage.set(\"figures\", this.figures);\r\n        this.positions = [];\r\n    };\r\n    Painter.prototype.addDrawEvent = function () {\r\n        var _this = this;\r\n        if (!this.$canvas)\r\n            return;\r\n        var handleMouseMove = function (e) {\r\n            var position = {\r\n                x: e.offsetX,\r\n                y: e.offsetY + (_this.paintBrush && 56)\r\n            };\r\n            _this.draw(position);\r\n        };\r\n        var handleTouchMove = function (e) {\r\n            if (e.target === _this.$canvas) {\r\n                e.preventDefault();\r\n            }\r\n            var rect = _this.$canvas.getBoundingClientRect();\r\n            var position = {\r\n                x: e.touches[0].clientX - rect.left,\r\n                y: e.touches[0].clientY - rect.top\r\n            };\r\n            _this.draw(position);\r\n        };\r\n        var canvasEvents = [\r\n            this.add(\"mousedown\", function () { return _this.drawStart(); }),\r\n            this.add(\"mousemove\", function (e) { return handleMouseMove(e); }),\r\n            this.add(\"mouseup\", function () { return _this.drawEnd(); }),\r\n            this.add(\"mouseleave\", function () { return _this.drawEnd(); }),\r\n            this.add(\"touchstart\", function () { return _this.drawStart(); }),\r\n            this.add(\"touchmove\", function (e) { return handleTouchMove(e); }),\r\n            this.add(\"touchend\", function () { return _this.drawEnd(); })\r\n        ];\r\n        this.removeDrawEvent = function () { return canvasEvents.forEach(function (off) { return off(); }); };\r\n    };\r\n    Painter.prototype.save = function () {\r\n        var image = this.$canvas.toDataURL(\"image/jpeg\");\r\n        var link = document.createElement(\"a\");\r\n        link.href = image;\r\n        link.download = \"your_paint\";\r\n        link.click();\r\n    };\r\n    Painter.prototype.clear = function () {\r\n        this.ctx.clearRect(0, 0, this.$canvas.clientWidth, this.$canvas.clientHeight);\r\n    };\r\n    Painter.prototype.destroy = function () {\r\n        this.removeDrawEvent();\r\n        storage_1.storage.remove(\"figures\");\r\n    };\r\n    return Painter;\r\n}());\r\nexports.Painter = Painter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUGFpbnRlci9pbmRleC50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL3NyYy9QYWludGVyL2luZGV4LnRzPzYyZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5QYWludGVyID0gdm9pZCAwO1xyXG52YXIgc3RvcmFnZV8xID0gcmVxdWlyZShcImxpYi9zdG9yYWdlXCIpO1xyXG52YXIgcGFpbnRfYnJ1c2hfcG5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImltYWdlcy9wYWludC1icnVzaC5wbmdcIikpO1xyXG52YXIgUGFpbnRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhaW50ZXIoKSB7XHJcbiAgICAgICAgdGhpcy4kY2FudmFzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kcmF3T24gPSBzdG9yYWdlXzEuZ2V0RHJhd09uKCk7XHJcbiAgICAgICAgdGhpcy5pc0RyYXdpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gXCJyZWRcIjtcclxuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IDM7XHJcbiAgICAgICAgdGhpcy5wYWludEJydXNoID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZmlndXJlcyA9IHN0b3JhZ2VfMS5nZXRGaWd1cmVzKCk7XHJcbiAgICAgICAgdGhpcy5vbkRyYXcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRHJhd0V2ZW50ID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgfVxyXG4gICAgUGFpbnRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuJGNhbnZhcylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuJGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy4kY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgUGFpbnRlci5wcm90b3R5cGUuZHJhd1N0YXJ0ID0gZnVuY3Rpb24gKHBhaW50ZXJPcHRpb24pIHtcclxuICAgICAgICBpZiAoIXBhaW50ZXJPcHRpb24pXHJcbiAgICAgICAgICAgIHBhaW50ZXJPcHRpb24gPSB7IGNvbG9yOiB0aGlzLnN0cm9rZUNvbG9yLCB0aGlja25lc3M6IHRoaXMudGhpY2tuZXNzIH07XHJcbiAgICAgICAgdGhpcy5pc0RyYXdpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhwYWludGVyT3B0aW9uKTtcclxuICAgIH07XHJcbiAgICBQYWludGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCByZWRyYXcpIHtcclxuICAgICAgICBpZiAocmVkcmF3ID09PSB2b2lkIDApIHsgcmVkcmF3ID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAoIXRoaXMuY3R4KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGRyYXdYID0gcG9zaXRpb24ueDtcclxuICAgICAgICB2YXIgZHJhd1kgPSBwb3NpdGlvbi55O1xyXG4gICAgICAgIGlmICghdGhpcy5pc0RyYXdpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lVG8oZHJhd1gsIGRyYXdZKTtcclxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRHJhdylcclxuICAgICAgICAgICAgICAgIHRoaXMub25EcmF3KHsgeDogZHJhd1gsIHk6IGRyYXdZIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJlZHJhdykge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGFpbnRlci5wcm90b3R5cGUuZHJhd0VuZCA9IGZ1bmN0aW9uIChyZWRyYXcpIHtcclxuICAgICAgICBpZiAocmVkcmF3ID09PSB2b2lkIDApIHsgcmVkcmF3ID0gZmFsc2U7IH1cclxuICAgICAgICB0aGlzLmlzRHJhd2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGlmICghcmVkcmF3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RmlndXJlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQYWludGVyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5maWd1cmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZmlndXJlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdTdGFydChmaWd1cmUucGFpbnRlck9wdGlvbik7XHJcbiAgICAgICAgICAgIGZpZ3VyZS5wb3NpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYXcocG9zaXRpb24sIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3RW5kKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQYWludGVyLnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0LCBvbkRyYXcgPSBfYS5vbkRyYXc7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLiRjYW52YXMgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5jdHggPSB0YXJnZXQuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKCk7XHJcbiAgICAgICAgdGhpcy5hZGREcmF3RXZlbnQoKTtcclxuICAgICAgICBpZiAob25EcmF3KVxyXG4gICAgICAgICAgICB0aGlzLm9uRHJhdyA9IG9uRHJhdztcclxuICAgICAgICBpZiAodGhpcy5kcmF3T24gJiYgdGhpcy5maWd1cmVzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICB9O1xyXG4gICAgUGFpbnRlci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBjb2xvciA9IF9hLmNvbG9yLCB0aGlja25lc3MgPSBfYS50aGlja25lc3MsIHBhaW50QnJ1c2ggPSBfYS5wYWludEJydXNoO1xyXG4gICAgICAgIGlmICghdGhpcy5jdHgpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHJva2VDb2xvciA9IGNvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpY2tuZXNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhpY2tuZXNzID0gdGhpY2tuZXNzO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB0aGlja25lc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYWludEJydXNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFpbnRCcnVzaCA9IHBhaW50QnJ1c2g7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBhaW50ZXIucHJvdG90eXBlLnNldEN1cnNvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5wYWludEJydXNoKVxyXG4gICAgICAgICAgICB0aGlzLiRjYW52YXMuc3R5bGUuY3Vyc29yID0gXCJ1cmwoXCIgKyBwYWludF9icnVzaF9wbmdfMS5kZWZhdWx0ICsgXCIpLCBhdXRvXCI7XHJcbiAgICB9O1xyXG4gICAgUGFpbnRlci5wcm90b3R5cGUuZ2V0RmlndXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmZpZ3VyZXMgPSBzdG9yYWdlXzEuZ2V0RmlndXJlcygpO1xyXG4gICAgfTtcclxuICAgIFBhaW50ZXIucHJvdG90eXBlLnNldEZpZ3VyZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5maWd1cmVzLnB1c2goe1xyXG4gICAgICAgICAgICBwYWludGVyT3B0aW9uOiB7IGNvbG9yOiB0aGlzLnN0cm9rZUNvbG9yLCB0aGlja25lc3M6IHRoaXMudGhpY2tuZXNzIH0sXHJcbiAgICAgICAgICAgIHBvc2l0aW9uczogdGhpcy5wb3NpdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdG9yYWdlXzEuc3RvcmFnZS5zZXQoXCJmaWd1cmVzXCIsIHRoaXMuZmlndXJlcyk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBbXTtcclxuICAgIH07XHJcbiAgICBQYWludGVyLnByb3RvdHlwZS5hZGREcmF3RXZlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuJGNhbnZhcylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBoYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBlLm9mZnNldFgsXHJcbiAgICAgICAgICAgICAgICB5OiBlLm9mZnNldFkgKyAoX3RoaXMucGFpbnRCcnVzaCAmJiA1NilcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuZHJhdyhwb3NpdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaGFuZGxlVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy4kY2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBfdGhpcy4kY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIHJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgIHk6IGUudG91Y2hlc1swXS5jbGllbnRZIC0gcmVjdC50b3BcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuZHJhdyhwb3NpdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgY2FudmFzRXZlbnRzID0gW1xyXG4gICAgICAgICAgICB0aGlzLmFkZChcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kcmF3U3RhcnQoKTsgfSksXHJcbiAgICAgICAgICAgIHRoaXMuYWRkKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBoYW5kbGVNb3VzZU1vdmUoZSk7IH0pLFxyXG4gICAgICAgICAgICB0aGlzLmFkZChcIm1vdXNldXBcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZHJhd0VuZCgpOyB9KSxcclxuICAgICAgICAgICAgdGhpcy5hZGQoXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRyYXdFbmQoKTsgfSksXHJcbiAgICAgICAgICAgIHRoaXMuYWRkKFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kcmF3U3RhcnQoKTsgfSksXHJcbiAgICAgICAgICAgIHRoaXMuYWRkKFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBoYW5kbGVUb3VjaE1vdmUoZSk7IH0pLFxyXG4gICAgICAgICAgICB0aGlzLmFkZChcInRvdWNoZW5kXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRyYXdFbmQoKTsgfSlcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRHJhd0V2ZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FudmFzRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG9mZikgeyByZXR1cm4gb2ZmKCk7IH0pOyB9O1xyXG4gICAgfTtcclxuICAgIFBhaW50ZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy4kY2FudmFzLnRvRGF0YVVSTChcImltYWdlL2pwZWdcIik7XHJcbiAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgICAgICBsaW5rLmhyZWYgPSBpbWFnZTtcclxuICAgICAgICBsaW5rLmRvd25sb2FkID0gXCJ5b3VyX3BhaW50XCI7XHJcbiAgICAgICAgbGluay5jbGljaygpO1xyXG4gICAgfTtcclxuICAgIFBhaW50ZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLiRjYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuJGNhbnZhcy5jbGllbnRIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIFBhaW50ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVEcmF3RXZlbnQoKTtcclxuICAgICAgICBzdG9yYWdlXzEuc3RvcmFnZS5yZW1vdmUoXCJmaWd1cmVzXCIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQYWludGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlBhaW50ZXIgPSBQYWludGVyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Painter/index.ts\n");

/***/ }),

/***/ "./src/Toolbar/ColorItem.tsx":
/*!***********************************!*\
  !*** ./src/Toolbar/ColorItem.tsx ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ColorItem = void 0;\r\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nvar styled_1 = __webpack_require__(/*! ./styled */ \"./src/Toolbar/styled.tsx\");\r\nvar ColorItem = function (_a) {\r\n    var painter = _a.painter, colors = _a.colors;\r\n    var _b = react_1.useState(typeof colors === \"string\" ? colors : colors[0]), currentColor = _b[0], setCurrentColor = _b[1];\r\n    var handleStrokeColor = function (color) {\r\n        setCurrentColor(color);\r\n    };\r\n    react_1.useEffect(function () {\r\n        console.log('currentColor', currentColor);\r\n        painter.setOptions({ color: currentColor });\r\n    }, [currentColor]);\r\n    return (typeof colors === \"string\" ?\r\n        react_1.default.createElement(styled_1.Round, { active: currentColor === colors, color: colors, onClick: function () { return handleStrokeColor(colors); }, key: colors })\r\n        : colors.map(function (color) {\r\n            return react_1.default.createElement(styled_1.Round, { active: currentColor === color, color: color, onClick: function () { return handleStrokeColor(color); }, key: color });\r\n        }));\r\n};\r\nexports.ColorItem = ColorItem;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9Db2xvckl0ZW0udHN4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vc3JjL1Rvb2xiYXIvQ29sb3JJdGVtLnRzeD9iYzNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNvbG9ySXRlbSA9IHZvaWQgMDtcclxudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIHN0eWxlZF8xID0gcmVxdWlyZShcIi4vc3R5bGVkXCIpO1xyXG52YXIgQ29sb3JJdGVtID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcGFpbnRlciA9IF9hLnBhaW50ZXIsIGNvbG9ycyA9IF9hLmNvbG9ycztcclxuICAgIHZhciBfYiA9IHJlYWN0XzEudXNlU3RhdGUodHlwZW9mIGNvbG9ycyA9PT0gXCJzdHJpbmdcIiA/IGNvbG9ycyA6IGNvbG9yc1swXSksIGN1cnJlbnRDb2xvciA9IF9iWzBdLCBzZXRDdXJyZW50Q29sb3IgPSBfYlsxXTtcclxuICAgIHZhciBoYW5kbGVTdHJva2VDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgIHNldEN1cnJlbnRDb2xvcihjb2xvcik7XHJcbiAgICB9O1xyXG4gICAgcmVhY3RfMS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdjdXJyZW50Q29sb3InLCBjdXJyZW50Q29sb3IpO1xyXG4gICAgICAgIHBhaW50ZXIuc2V0T3B0aW9ucyh7IGNvbG9yOiBjdXJyZW50Q29sb3IgfSk7XHJcbiAgICB9LCBbY3VycmVudENvbG9yXSk7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBjb2xvcnMgPT09IFwic3RyaW5nXCIgP1xyXG4gICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHN0eWxlZF8xLlJvdW5kLCB7IGFjdGl2ZTogY3VycmVudENvbG9yID09PSBjb2xvcnMsIGNvbG9yOiBjb2xvcnMsIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhbmRsZVN0cm9rZUNvbG9yKGNvbG9ycyk7IH0sIGtleTogY29sb3JzIH0pXHJcbiAgICAgICAgOiBjb2xvcnMubWFwKGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoc3R5bGVkXzEuUm91bmQsIHsgYWN0aXZlOiBjdXJyZW50Q29sb3IgPT09IGNvbG9yLCBjb2xvcjogY29sb3IsIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhbmRsZVN0cm9rZUNvbG9yKGNvbG9yKTsgfSwga2V5OiBjb2xvciB9KTtcclxuICAgICAgICB9KSk7XHJcbn07XHJcbmV4cG9ydHMuQ29sb3JJdGVtID0gQ29sb3JJdGVtO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Toolbar/ColorItem.tsx\n");

/***/ }),

/***/ "./src/Toolbar/ControlItem.tsx":
/*!*************************************!*\
  !*** ./src/Toolbar/ControlItem.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ControlItem = void 0;\r\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nvar styled_1 = __webpack_require__(/*! ./styled */ \"./src/Toolbar/styled.tsx\");\r\nvar ControlItem = function (_a) {\r\n    var title = _a.title, active = _a.active, disable = _a.disable, onClickItem = _a.onClickItem, _b = _a.onClick, onClick = _b === void 0 ? function () { return null; } : _b, children = _a.children;\r\n    return (react_1.default.createElement(styled_1.ItemWrapper, { title: title },\r\n        react_1.default.createElement(styled_1.Item, { active: active, disable: disable, onClick: function () {\r\n                if (onClickItem) {\r\n                    return onClickItem();\r\n                }\r\n                onClick();\r\n            }, role: \"button\" }, children)));\r\n};\r\nexports.ControlItem = ControlItem;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9Db250cm9sSXRlbS50c3guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vc3JjL1Rvb2xiYXIvQ29udHJvbEl0ZW0udHN4P2U3OTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Db250cm9sSXRlbSA9IHZvaWQgMDtcclxudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIHN0eWxlZF8xID0gcmVxdWlyZShcIi4vc3R5bGVkXCIpO1xyXG52YXIgQ29udHJvbEl0ZW0gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciB0aXRsZSA9IF9hLnRpdGxlLCBhY3RpdmUgPSBfYS5hY3RpdmUsIGRpc2FibGUgPSBfYS5kaXNhYmxlLCBvbkNsaWNrSXRlbSA9IF9hLm9uQ2xpY2tJdGVtLCBfYiA9IF9hLm9uQ2xpY2ssIG9uQ2xpY2sgPSBfYiA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSA6IF9iLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xyXG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChzdHlsZWRfMS5JdGVtV3JhcHBlciwgeyB0aXRsZTogdGl0bGUgfSxcclxuICAgICAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChzdHlsZWRfMS5JdGVtLCB7IGFjdGl2ZTogYWN0aXZlLCBkaXNhYmxlOiBkaXNhYmxlLCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob25DbGlja0l0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25DbGlja0l0ZW0oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9uQ2xpY2soKTtcclxuICAgICAgICAgICAgfSwgcm9sZTogXCJidXR0b25cIiB9LCBjaGlsZHJlbikpKTtcclxufTtcclxuZXhwb3J0cy5Db250cm9sSXRlbSA9IENvbnRyb2xJdGVtO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Toolbar/ControlItem.tsx\n");

/***/ }),

/***/ "./src/Toolbar/Icons/AllClear.tsx":
/*!****************************************!*\
  !*** ./src/Toolbar/Icons/AllClear.tsx ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nfunction AllClear(_a) {\r\n    var _b = _a.width, width = _b === void 0 ? \"16\" : _b, _c = _a.height, height = _c === void 0 ? \"16\" : _c, _d = _a.viewBox, viewBox = _d === void 0 ? \"0 0 16 16\" : _d, _e = _a.color, color = _e === void 0 ? \"#fff\" : _e;\r\n    return (react_1.default.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: width, height: height, viewBox: viewBox },\r\n        react_1.default.createElement(\"path\", { d: \"M14.398 3.273A7.719 7.719 0 008.215.227 7.712 7.712 0 003.5 1.824a7.775 7.775 0 00-1.332 1.301L1.824 1.16a.404.404 0 00-.46-.324L.327 1.02a.408.408 0 00-.258.164.396.396 0 00-.062.296l.824 4.668c.031.192.2.329.387.329.023 0 .047-.004.07-.008l4.672-.824a.395.395 0 00.32-.457l-.183-1.04a.4.4 0 00-.457-.32l-1.95.344c.274-.324.586-.617.93-.883A5.875 5.875 0 018.22 2.07c1.867 0 3.586.848 4.715 2.325a5.882 5.882 0 011.168 4.382 5.893 5.893 0 01-2.274 3.93 5.873 5.873 0 01-4.383 1.168 5.893 5.893 0 01-3.93-2.273A5.945 5.945 0 012.38 8.988a.395.395 0 00-.457-.32l-1.04.172a.4.4 0 00-.323.457 7.842 7.842 0 001.492 3.426 7.738 7.738 0 005.152 2.98 7.686 7.686 0 005.746-1.531 7.73 7.73 0 002.98-5.152 7.72 7.72 0 00-1.53-5.747zm0 0\", fill: color || \"#fff\" })));\r\n}\r\nexports[\"default\"] = AllClear;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9JY29ucy9BbGxDbGVhci50c3guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL3NyYy9Ub29sYmFyL0ljb25zL0FsbENsZWFyLnRzeD8xMWU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbmZ1bmN0aW9uIEFsbENsZWFyKF9hKSB7XHJcbiAgICB2YXIgX2IgPSBfYS53aWR0aCwgd2lkdGggPSBfYiA9PT0gdm9pZCAwID8gXCIxNlwiIDogX2IsIF9jID0gX2EuaGVpZ2h0LCBoZWlnaHQgPSBfYyA9PT0gdm9pZCAwID8gXCIxNlwiIDogX2MsIF9kID0gX2Eudmlld0JveCwgdmlld0JveCA9IF9kID09PSB2b2lkIDAgPyBcIjAgMCAxNiAxNlwiIDogX2QsIF9lID0gX2EuY29sb3IsIGNvbG9yID0gX2UgPT09IHZvaWQgMCA/IFwiI2ZmZlwiIDogX2U7XHJcbiAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdmlld0JveDogdmlld0JveCB9LFxyXG4gICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE0LjM5OCAzLjI3M0E3LjcxOSA3LjcxOSAwIDAwOC4yMTUuMjI3IDcuNzEyIDcuNzEyIDAgMDAzLjUgMS44MjRhNy43NzUgNy43NzUgMCAwMC0xLjMzMiAxLjMwMUwxLjgyNCAxLjE2YS40MDQuNDA0IDAgMDAtLjQ2LS4zMjRMLjMyNyAxLjAyYS40MDguNDA4IDAgMDAtLjI1OC4xNjQuMzk2LjM5NiAwIDAwLS4wNjIuMjk2bC44MjQgNC42NjhjLjAzMS4xOTIuMi4zMjkuMzg3LjMyOS4wMjMgMCAuMDQ3LS4wMDQuMDctLjAwOGw0LjY3Mi0uODI0YS4zOTUuMzk1IDAgMDAuMzItLjQ1N2wtLjE4My0xLjA0YS40LjQgMCAwMC0uNDU3LS4zMmwtMS45NS4zNDRjLjI3NC0uMzI0LjU4Ni0uNjE3LjkzLS44ODNBNS44NzUgNS44NzUgMCAwMTguMjIgMi4wN2MxLjg2NyAwIDMuNTg2Ljg0OCA0LjcxNSAyLjMyNWE1Ljg4MiA1Ljg4MiAwIDAxMS4xNjggNC4zODIgNS44OTMgNS44OTMgMCAwMS0yLjI3NCAzLjkzIDUuODczIDUuODczIDAgMDEtNC4zODMgMS4xNjggNS44OTMgNS44OTMgMCAwMS0zLjkzLTIuMjczQTUuOTQ1IDUuOTQ1IDAgMDEyLjM4IDguOTg4YS4zOTUuMzk1IDAgMDAtLjQ1Ny0uMzJsLTEuMDQuMTcyYS40LjQgMCAwMC0uMzIzLjQ1NyA3Ljg0MiA3Ljg0MiAwIDAwMS40OTIgMy40MjYgNy43MzggNy43MzggMCAwMDUuMTUyIDIuOTggNy42ODYgNy42ODYgMCAwMDUuNzQ2LTEuNTMxIDcuNzMgNy43MyAwIDAwMi45OC01LjE1MiA3LjcyIDcuNzIgMCAwMC0xLjUzLTUuNzQ3em0wIDBcIiwgZmlsbDogY29sb3IgfHwgXCIjZmZmXCIgfSkpKTtcclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBBbGxDbGVhcjtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Toolbar/Icons/AllClear.tsx\n");

/***/ }),

/***/ "./src/Toolbar/Icons/Icon.tsx":
/*!************************************!*\
  !*** ./src/Toolbar/Icons/Icon.tsx ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Icon = void 0;\r\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nvar AllClear_1 = __importDefault(__webpack_require__(/*! ./AllClear */ \"./src/Toolbar/Icons/AllClear.tsx\"));\r\nvar Save_1 = __importDefault(__webpack_require__(/*! ./Save */ \"./src/Toolbar/Icons/Save.tsx\"));\r\nvar Icon = function (_a) {\r\n    var iconName = _a.name;\r\n    switch (iconName) {\r\n        case \"allClear\":\r\n            return react_1.default.createElement(AllClear_1.default, null);\r\n        case \"save\":\r\n            return react_1.default.createElement(Save_1.default, null);\r\n        default:\r\n            return react_1.default.createElement(react_1.default.Fragment, null);\r\n    }\r\n};\r\nexports.Icon = Icon;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9JY29ucy9JY29uLnRzeC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vc3JjL1Rvb2xiYXIvSWNvbnMvSWNvbi50c3g/ZDJkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkljb24gPSB2b2lkIDA7XHJcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBBbGxDbGVhcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0FsbENsZWFyXCIpKTtcclxudmFyIFNhdmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9TYXZlXCIpKTtcclxudmFyIEljb24gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBpY29uTmFtZSA9IF9hLm5hbWU7XHJcbiAgICBzd2l0Y2ggKGljb25OYW1lKSB7XHJcbiAgICAgICAgY2FzZSBcImFsbENsZWFyXCI6XHJcbiAgICAgICAgICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChBbGxDbGVhcl8xLmRlZmF1bHQsIG51bGwpO1xyXG4gICAgICAgIGNhc2UgXCJzYXZlXCI6XHJcbiAgICAgICAgICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChTYXZlXzEuZGVmYXVsdCwgbnVsbCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHJlYWN0XzEuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCk7XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuSWNvbiA9IEljb247XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Toolbar/Icons/Icon.tsx\n");

/***/ }),

/***/ "./src/Toolbar/Icons/Save.tsx":
/*!************************************!*\
  !*** ./src/Toolbar/Icons/Save.tsx ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nfunction Save(_a) {\r\n    var _b = _a.width, width = _b === void 0 ? \"16\" : _b, _c = _a.height, height = _c === void 0 ? \"16\" : _c, _d = _a.viewBox, viewBox = _d === void 0 ? \"0 0 16 16\" : _d, _e = _a.color, color = _e === void 0 ? \"#fff\" : _e;\r\n    return (react_1.default.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: width, height: height, viewBox: viewBox },\r\n        react_1.default.createElement(\"g\", { fill: color || \"#fff\" },\r\n            react_1.default.createElement(\"path\", { d: \"M10.813 13.188H5.186a.47.47 0 00-.468.468c0 .258.21.469.468.469h5.625a.47.47 0 00.47-.469.47.47 0 00-.47-.469zm0 0M10.813 9.438H5.186a.47.47 0 00-.468.468c0 .258.21.469.468.469h5.625a.47.47 0 00.47-.469.47.47 0 00-.47-.469zm0 0M10.813 11.313H5.186a.47.47 0 00-.468.468c0 .258.21.469.468.469h5.625a.47.47 0 00.47-.469.47.47 0 00-.47-.469zm0 0M3.781 0h6.563v4.063H3.78zm0 0\" }),\r\n            react_1.default.createElement(\"path\", { d: \"M15.863 2.637l-2.5-2.5A.48.48 0 0013.031 0h-1.75v4.531a.47.47 0 01-.469.469h-7.5a.47.47 0 01-.468-.469V0H.469A.47.47 0 000 .469V15.53c0 .258.21.469.469.469H15.53a.47.47 0 00.469-.469V2.97a.48.48 0 00-.137-.332zM12.22 15.062H3.78V8.5h8.438zm0 0\" }))));\r\n}\r\nexports[\"default\"] = Save;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9JY29ucy9TYXZlLnRzeC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL3NyYy9Ub29sYmFyL0ljb25zL1NhdmUudHN4PzMwNDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxuZnVuY3Rpb24gU2F2ZShfYSkge1xyXG4gICAgdmFyIF9iID0gX2Eud2lkdGgsIHdpZHRoID0gX2IgPT09IHZvaWQgMCA/IFwiMTZcIiA6IF9iLCBfYyA9IF9hLmhlaWdodCwgaGVpZ2h0ID0gX2MgPT09IHZvaWQgMCA/IFwiMTZcIiA6IF9jLCBfZCA9IF9hLnZpZXdCb3gsIHZpZXdCb3ggPSBfZCA9PT0gdm9pZCAwID8gXCIwIDAgMTYgMTZcIiA6IF9kLCBfZSA9IF9hLmNvbG9yLCBjb2xvciA9IF9lID09PSB2b2lkIDAgPyBcIiNmZmZcIiA6IF9lO1xyXG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHZpZXdCb3g6IHZpZXdCb3ggfSxcclxuICAgICAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImdcIiwgeyBmaWxsOiBjb2xvciB8fCBcIiNmZmZcIiB9LFxyXG4gICAgICAgICAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xMC44MTMgMTMuMTg4SDUuMTg2YS40Ny40NyAwIDAwLS40NjguNDY4YzAgLjI1OC4yMS40NjkuNDY4LjQ2OWg1LjYyNWEuNDcuNDcgMCAwMC40Ny0uNDY5LjQ3LjQ3IDAgMDAtLjQ3LS40Njl6bTAgME0xMC44MTMgOS40MzhINS4xODZhLjQ3LjQ3IDAgMDAtLjQ2OC40NjhjMCAuMjU4LjIxLjQ2OS40NjguNDY5aDUuNjI1YS40Ny40NyAwIDAwLjQ3LS40NjkuNDcuNDcgMCAwMC0uNDctLjQ2OXptMCAwTTEwLjgxMyAxMS4zMTNINS4xODZhLjQ3LjQ3IDAgMDAtLjQ2OC40NjhjMCAuMjU4LjIxLjQ2OS40NjguNDY5aDUuNjI1YS40Ny40NyAwIDAwLjQ3LS40NjkuNDcuNDcgMCAwMC0uNDctLjQ2OXptMCAwTTMuNzgxIDBoNi41NjN2NC4wNjNIMy43OHptMCAwXCIgfSksXHJcbiAgICAgICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE1Ljg2MyAyLjYzN2wtMi41LTIuNUEuNDguNDggMCAwMDEzLjAzMSAwaC0xLjc1djQuNTMxYS40Ny40NyAwIDAxLS40NjkuNDY5aC03LjVhLjQ3LjQ3IDAgMDEtLjQ2OC0uNDY5VjBILjQ2OUEuNDcuNDcgMCAwMDAgLjQ2OVYxNS41M2MwIC4yNTguMjEuNDY5LjQ2OS40NjlIMTUuNTNhLjQ3LjQ3IDAgMDAuNDY5LS40NjlWMi45N2EuNDguNDggMCAwMC0uMTM3LS4zMzJ6TTEyLjIyIDE1LjA2MkgzLjc4VjguNWg4LjQzOHptMCAwXCIgfSkpKSk7XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gU2F2ZTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Toolbar/Icons/Save.tsx\n");

/***/ }),

/***/ "./src/Toolbar/Icons/index.tsx":
/*!*************************************!*\
  !*** ./src/Toolbar/Icons/index.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Save = exports.AllClear = void 0;\r\n__exportStar(__webpack_require__(/*! ./Icon */ \"./src/Toolbar/Icons/Icon.tsx\"), exports);\r\nvar AllClear_1 = __webpack_require__(/*! ./AllClear */ \"./src/Toolbar/Icons/AllClear.tsx\");\r\nObject.defineProperty(exports, \"AllClear\", ({ enumerable: true, get: function () { return __importDefault(AllClear_1).default; } }));\r\nvar Save_1 = __webpack_require__(/*! ./Save */ \"./src/Toolbar/Icons/Save.tsx\");\r\nObject.defineProperty(exports, \"Save\", ({ enumerable: true, get: function () { return __importDefault(Save_1).default; } }));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9JY29ucy9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL3NyYy9Ub29sYmFyL0ljb25zL2luZGV4LnRzeD8yZWQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcclxufTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlNhdmUgPSBleHBvcnRzLkFsbENsZWFyID0gdm9pZCAwO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSWNvblwiKSwgZXhwb3J0cyk7XHJcbnZhciBBbGxDbGVhcl8xID0gcmVxdWlyZShcIi4vQWxsQ2xlYXJcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFsbENsZWFyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQoQWxsQ2xlYXJfMSkuZGVmYXVsdDsgfSB9KTtcclxudmFyIFNhdmVfMSA9IHJlcXVpcmUoXCIuL1NhdmVcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNhdmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChTYXZlXzEpLmRlZmF1bHQ7IH0gfSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Toolbar/Icons/index.tsx\n");

/***/ }),

/***/ "./src/Toolbar/RangeItem.tsx":
/*!***********************************!*\
  !*** ./src/Toolbar/RangeItem.tsx ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RangeItem = void 0;\r\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nvar styled_1 = __webpack_require__(/*! ./styled */ \"./src/Toolbar/styled.tsx\");\r\nvar RangeItem = function (_a) {\r\n    var painter = _a.painter, minTickness = _a.minTickness, maxTickness = _a.maxTickness;\r\n    var rangeRef = react_1.useRef(null);\r\n    var handleThickness = function (e) {\r\n        var range = e.target.value;\r\n        painter.setOptions({ thickness: range });\r\n    };\r\n    react_1.useEffect(function () {\r\n        if (rangeRef.current)\r\n            rangeRef.current.addEventListener('input', handleThickness);\r\n        return function () {\r\n            rangeRef.current.removeEventListener('input', handleThickness);\r\n        };\r\n    }, [rangeRef]);\r\n    return (react_1.default.createElement(styled_1.Range, { ref: rangeRef, type: \"range\", min: minTickness, max: maxTickness, step: \"1\", defaultValue: (minTickness + maxTickness) / 2 }));\r\n};\r\nexports.RangeItem = RangeItem;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9SYW5nZUl0ZW0udHN4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vc3JjL1Rvb2xiYXIvUmFuZ2VJdGVtLnRzeD8wOTBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlJhbmdlSXRlbSA9IHZvaWQgMDtcclxudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIHN0eWxlZF8xID0gcmVxdWlyZShcIi4vc3R5bGVkXCIpO1xyXG52YXIgUmFuZ2VJdGVtID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcGFpbnRlciA9IF9hLnBhaW50ZXIsIG1pblRpY2tuZXNzID0gX2EubWluVGlja25lc3MsIG1heFRpY2tuZXNzID0gX2EubWF4VGlja25lc3M7XHJcbiAgICB2YXIgcmFuZ2VSZWYgPSByZWFjdF8xLnVzZVJlZihudWxsKTtcclxuICAgIHZhciBoYW5kbGVUaGlja25lc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciByYW5nZSA9IGUudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgIHBhaW50ZXIuc2V0T3B0aW9ucyh7IHRoaWNrbmVzczogcmFuZ2UgfSk7XHJcbiAgICB9O1xyXG4gICAgcmVhY3RfMS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChyYW5nZVJlZi5jdXJyZW50KVxyXG4gICAgICAgICAgICByYW5nZVJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgaGFuZGxlVGhpY2tuZXNzKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByYW5nZVJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgaGFuZGxlVGhpY2tuZXNzKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW3JhbmdlUmVmXSk7XHJcbiAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHN0eWxlZF8xLlJhbmdlLCB7IHJlZjogcmFuZ2VSZWYsIHR5cGU6IFwicmFuZ2VcIiwgbWluOiBtaW5UaWNrbmVzcywgbWF4OiBtYXhUaWNrbmVzcywgc3RlcDogXCIxXCIsIGRlZmF1bHRWYWx1ZTogKG1pblRpY2tuZXNzICsgbWF4VGlja25lc3MpIC8gMiB9KSk7XHJcbn07XHJcbmV4cG9ydHMuUmFuZ2VJdGVtID0gUmFuZ2VJdGVtO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Toolbar/RangeItem.tsx\n");

/***/ }),

/***/ "./src/Toolbar/Toolbar.tsx":
/*!*********************************!*\
  !*** ./src/Toolbar/Toolbar.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Toolbar = void 0;\r\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nvar color_1 = __webpack_require__(/*! ../lib/color */ \"./src/lib/color.ts\");\r\nvar ControlItem_1 = __webpack_require__(/*! ./ControlItem */ \"./src/Toolbar/ControlItem.tsx\");\r\nvar RangeItem_1 = __webpack_require__(/*! ./RangeItem */ \"./src/Toolbar/RangeItem.tsx\");\r\nvar ColorItem_1 = __webpack_require__(/*! ./ColorItem */ \"./src/Toolbar/ColorItem.tsx\");\r\nvar styled_1 = __webpack_require__(/*! ./styled */ \"./src/Toolbar/styled.tsx\");\r\nvar Icons_1 = __webpack_require__(/*! ./Icons */ \"./src/Toolbar/Icons/index.tsx\");\r\nvar Toolbar = function (_a) {\r\n    var painter = _a.painter, _b = _a.useThickness, useThickness = _b === void 0 ? true : _b, _c = _a.minTickness, minTickness = _c === void 0 ? 1 : _c, _d = _a.maxTickness, maxTickness = _d === void 0 ? 5 : _d, _e = _a.useColor, useColor = _e === void 0 ? true : _e, colors = _a.colors;\r\n    var handleAllClear = function () {\r\n        painter.clear();\r\n    };\r\n    var handleSave = function () {\r\n        painter.save();\r\n    };\r\n    return (react_1.default.createElement(react_1.default.Fragment, null,\r\n        react_1.default.createElement(styled_1.ControlBar, null,\r\n            useThickness && (react_1.default.createElement(react_1.default.Fragment, null,\r\n                react_1.default.createElement(RangeItem_1.RangeItem, { painter: painter, minTickness: minTickness, maxTickness: maxTickness }),\r\n                react_1.default.createElement(styled_1.Separator, null))),\r\n            useColor && (react_1.default.createElement(react_1.default.Fragment, null,\r\n                react_1.default.createElement(ColorItem_1.ColorItem, { painter: painter, colors: colors || color_1.paletteColor }),\r\n                react_1.default.createElement(styled_1.Separator, null))),\r\n            react_1.default.createElement(ControlItem_1.ControlItem, { title: \"All Clear\", onClickItem: handleAllClear },\r\n                react_1.default.createElement(Icons_1.Icon, { name: \"allClear\" })),\r\n            react_1.default.createElement(ControlItem_1.ControlItem, { title: \"Save\", onClickItem: handleSave },\r\n                react_1.default.createElement(Icons_1.Icon, { name: \"save\" })))));\r\n};\r\nexports.Toolbar = Toolbar;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9Ub29sYmFyLnRzeC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL3NyYy9Ub29sYmFyL1Rvb2xiYXIudHN4P2FlY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Ub29sYmFyID0gdm9pZCAwO1xyXG52YXIgcmVhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgY29sb3JfMSA9IHJlcXVpcmUoXCIuLi9saWIvY29sb3JcIik7XHJcbnZhciBDb250cm9sSXRlbV8xID0gcmVxdWlyZShcIi4vQ29udHJvbEl0ZW1cIik7XHJcbnZhciBSYW5nZUl0ZW1fMSA9IHJlcXVpcmUoXCIuL1JhbmdlSXRlbVwiKTtcclxudmFyIENvbG9ySXRlbV8xID0gcmVxdWlyZShcIi4vQ29sb3JJdGVtXCIpO1xyXG52YXIgc3R5bGVkXzEgPSByZXF1aXJlKFwiLi9zdHlsZWRcIik7XHJcbnZhciBJY29uc18xID0gcmVxdWlyZShcIi4vSWNvbnNcIik7XHJcbnZhciBUb29sYmFyID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcGFpbnRlciA9IF9hLnBhaW50ZXIsIF9iID0gX2EudXNlVGhpY2tuZXNzLCB1c2VUaGlja25lc3MgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IF9hLm1pblRpY2tuZXNzLCBtaW5UaWNrbmVzcyA9IF9jID09PSB2b2lkIDAgPyAxIDogX2MsIF9kID0gX2EubWF4VGlja25lc3MsIG1heFRpY2tuZXNzID0gX2QgPT09IHZvaWQgMCA/IDUgOiBfZCwgX2UgPSBfYS51c2VDb2xvciwgdXNlQ29sb3IgPSBfZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9lLCBjb2xvcnMgPSBfYS5jb2xvcnM7XHJcbiAgICB2YXIgaGFuZGxlQWxsQ2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcGFpbnRlci5jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIHZhciBoYW5kbGVTYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHBhaW50ZXIuc2F2ZSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHN0eWxlZF8xLkNvbnRyb2xCYXIsIG51bGwsXHJcbiAgICAgICAgICAgIHVzZVRoaWNrbmVzcyAmJiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmFuZ2VJdGVtXzEuUmFuZ2VJdGVtLCB7IHBhaW50ZXI6IHBhaW50ZXIsIG1pblRpY2tuZXNzOiBtaW5UaWNrbmVzcywgbWF4VGlja25lc3M6IG1heFRpY2tuZXNzIH0pLFxyXG4gICAgICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoc3R5bGVkXzEuU2VwYXJhdG9yLCBudWxsKSkpLFxyXG4gICAgICAgICAgICB1c2VDb2xvciAmJiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29sb3JJdGVtXzEuQ29sb3JJdGVtLCB7IHBhaW50ZXI6IHBhaW50ZXIsIGNvbG9yczogY29sb3JzIHx8IGNvbG9yXzEucGFsZXR0ZUNvbG9yIH0pLFxyXG4gICAgICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoc3R5bGVkXzEuU2VwYXJhdG9yLCBudWxsKSkpLFxyXG4gICAgICAgICAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb250cm9sSXRlbV8xLkNvbnRyb2xJdGVtLCB7IHRpdGxlOiBcIkFsbCBDbGVhclwiLCBvbkNsaWNrSXRlbTogaGFuZGxlQWxsQ2xlYXIgfSxcclxuICAgICAgICAgICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb25zXzEuSWNvbiwgeyBuYW1lOiBcImFsbENsZWFyXCIgfSkpLFxyXG4gICAgICAgICAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb250cm9sSXRlbV8xLkNvbnRyb2xJdGVtLCB7IHRpdGxlOiBcIlNhdmVcIiwgb25DbGlja0l0ZW06IGhhbmRsZVNhdmUgfSxcclxuICAgICAgICAgICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEljb25zXzEuSWNvbiwgeyBuYW1lOiBcInNhdmVcIiB9KSkpKSk7XHJcbn07XHJcbmV4cG9ydHMuVG9vbGJhciA9IFRvb2xiYXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Toolbar/Toolbar.tsx\n");

/***/ }),

/***/ "./src/Toolbar/index.tsx":
/*!*******************************!*\
  !*** ./src/Toolbar/index.tsx ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./Toolbar */ \"./src/Toolbar/Toolbar.tsx\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ControlItem */ \"./src/Toolbar/ControlItem.tsx\"), exports);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXNpbXBsZS1jYW52YXMvLi9zcmMvVG9vbGJhci9pbmRleC50c3g/MDZiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1Rvb2xiYXJcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29udHJvbEl0ZW1cIiksIGV4cG9ydHMpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Toolbar/index.tsx\n");

/***/ }),

/***/ "./src/Toolbar/styled.tsx":
/*!********************************!*\
  !*** ./src/Toolbar/styled.tsx ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Separator = exports.Round = exports.Range = exports.Item = exports.ItemWrapper = exports.ControlBar = void 0;\r\nvar styled_components_1 = __importStar(__webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\"));\r\nexports.ControlBar = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"\\n  position: fixed;\\n  top: 0;\\n  left: 50%;\\n  height: 50px;\\n  display: flex;\\n  align-items: center;\\n  padding: 0 10px;\\n  border-radius: 6px;\\n  box-shadow: 0 4px 6px 0 rgba(0, 0, 0, 0.2);\\n  border: solid 1px rgba(0, 0, 0, 0.2);\\n  background-color: rgba(0, 0, 0, 0.65);\\n  transform: translateX(-50%);\\n  box-sizing: border-box;\\n\"], [\"\\n  position: fixed;\\n  top: 0;\\n  left: 50%;\\n  height: 50px;\\n  display: flex;\\n  align-items: center;\\n  padding: 0 10px;\\n  border-radius: 6px;\\n  box-shadow: 0 4px 6px 0 rgba(0, 0, 0, 0.2);\\n  border: solid 1px rgba(0, 0, 0, 0.2);\\n  background-color: rgba(0, 0, 0, 0.65);\\n  transform: translateX(-50%);\\n  box-sizing: border-box;\\n\"])));\r\nexports.ItemWrapper = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject([\"\\n  position: relative;\\n\"], [\"\\n  position: relative;\\n\"])));\r\nexports.Item = styled_components_1.default.div(templateObject_4 || (templateObject_4 = __makeTemplateObject([\"\\n  position: relative;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  width: 32px;\\n  height: 32px;\\n  border-radius: 4px;\\n  box-sizing: border-box;\\n  cursor: pointer;\\n\\n  &:hover {\\n    border: solid 1px rgba(255, 255, 255, 0.2);\\n    background-color: rgba(0, 0, 0, 0.2);\\n  }\\n\\n  \", \"\\n\"], [\"\\n  position: relative;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  width: 32px;\\n  height: 32px;\\n  border-radius: 4px;\\n  box-sizing: border-box;\\n  cursor: pointer;\\n\\n  &:hover {\\n    border: solid 1px rgba(255, 255, 255, 0.2);\\n    background-color: rgba(0, 0, 0, 0.2);\\n  }\\n\\n  \",\r\n    \"\\n\"])), function (_a) {\r\n    var active = _a.active;\r\n    return active && styled_components_1.css(templateObject_3 || (templateObject_3 = __makeTemplateObject([\"\\n      border: solid 1px rgba(255, 255, 255, 0.3);\\n      background-color: rgba(0, 0, 0, 0.3);\\n\\n      &:hover {\\n        border: solid 1px rgba(255, 255, 255, 0.3);\\n        background-color: rgba(0, 0, 0, 0.35);\\n      }\\n    \"], [\"\\n      border: solid 1px rgba(255, 255, 255, 0.3);\\n      background-color: rgba(0, 0, 0, 0.3);\\n\\n      &:hover {\\n        border: solid 1px rgba(255, 255, 255, 0.3);\\n        background-color: rgba(0, 0, 0, 0.35);\\n      }\\n    \"])));\r\n});\r\nexports.Range = styled_components_1.default.input(templateObject_5 || (templateObject_5 = __makeTemplateObject([\"\\n  width: 100px;\\n  height: 20px;\\n\"], [\"\\n  width: 100px;\\n  height: 20px;\\n\"])));\r\nexports.Round = styled_components_1.default.span(templateObject_8 || (templateObject_8 = __makeTemplateObject([\"\\n  width: 20px;\\n  height: 20px;\\n  border: solid 1px rgba(0, 0, 0, 0.5);\\n  border-radius: 10px;\\n  margin-right: 6px;\\n\\n  &:last-child {\\n    margin-right: 0;\\n  }\\n\\n  \", \"\\n\\n  \", \"\\n\"], [\"\\n  width: 20px;\\n  height: 20px;\\n  border: solid 1px rgba(0, 0, 0, 0.5);\\n  border-radius: 10px;\\n  margin-right: 6px;\\n\\n  &:last-child {\\n    margin-right: 0;\\n  }\\n\\n  \",\r\n    \"\\n\\n  \",\r\n    \"\\n\"])), function (_a) {\r\n    var active = _a.active;\r\n    return active && styled_components_1.css(templateObject_6 || (templateObject_6 = __makeTemplateObject([\"\\n      border: 2px solid #f9f9f9;\\n    \"], [\"\\n      border: 2px solid #f9f9f9;\\n    \"])));\r\n}, function (_a) {\r\n    var color = _a.color;\r\n    return color && styled_components_1.css(templateObject_7 || (templateObject_7 = __makeTemplateObject([\"\\n      background: \", \";\\n    \"], [\"\\n      background: \", \";\\n    \"])), color);\r\n});\r\nexports.Separator = styled_components_1.default.div(templateObject_9 || (templateObject_9 = __makeTemplateObject([\"\\n  width: 1px;\\n  height: 50%;\\n  background-color: rgba(255, 255, 255, 0.2);\\n  margin: 0 10px;\\n\"], [\"\\n  width: 1px;\\n  height: 50%;\\n  background-color: rgba(255, 255, 255, 0.2);\\n  margin: 0 10px;\\n\"])));\r\nvar templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6, templateObject_7, templateObject_8, templateObject_9;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVG9vbGJhci9zdHlsZWQudHN4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktc2ltcGxlLWNhbnZhcy8uL3NyYy9Ub29sYmFyL3N0eWxlZC50c3g/NjRkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TZXBhcmF0b3IgPSBleHBvcnRzLlJvdW5kID0gZXhwb3J0cy5SYW5nZSA9IGV4cG9ydHMuSXRlbSA9IGV4cG9ydHMuSXRlbVdyYXBwZXIgPSBleHBvcnRzLkNvbnRyb2xCYXIgPSB2b2lkIDA7XHJcbnZhciBzdHlsZWRfY29tcG9uZW50c18xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzdHlsZWQtY29tcG9uZW50c1wiKSk7XHJcbmV4cG9ydHMuQ29udHJvbEJhciA9IHN0eWxlZF9jb21wb25lbnRzXzEuZGVmYXVsdC5kaXYodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogNTAlO1xcbiAgaGVpZ2h0OiA1MHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBwYWRkaW5nOiAwIDEwcHg7XFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICBib3gtc2hhZG93OiAwIDRweCA2cHggMCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICBib3JkZXI6IHNvbGlkIDFweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNjUpO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cIl0sIFtcIlxcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogNTAlO1xcbiAgaGVpZ2h0OiA1MHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBwYWRkaW5nOiAwIDEwcHg7XFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICBib3gtc2hhZG93OiAwIDRweCA2cHggMCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICBib3JkZXI6IHNvbGlkIDFweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNjUpO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cIl0pKSk7XHJcbmV4cG9ydHMuSXRlbVdyYXBwZXIgPSBzdHlsZWRfY29tcG9uZW50c18xLmRlZmF1bHQuZGl2KHRlbXBsYXRlT2JqZWN0XzIgfHwgKHRlbXBsYXRlT2JqZWN0XzIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG5cIl0sIFtcIlxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcblwiXSkpKTtcclxuZXhwb3J0cy5JdGVtID0gc3R5bGVkX2NvbXBvbmVudHNfMS5kZWZhdWx0LmRpdih0ZW1wbGF0ZU9iamVjdF80IHx8ICh0ZW1wbGF0ZU9iamVjdF80ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgd2lkdGg6IDMycHg7XFxuICBoZWlnaHQ6IDMycHg7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcblxcbiAgJjpob3ZlciB7XFxuICAgIGJvcmRlcjogc29saWQgMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgfVxcblxcbiAgXCIsIFwiXFxuXCJdLCBbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB3aWR0aDogMzJweDtcXG4gIGhlaWdodDogMzJweDtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuXFxuICAmOmhvdmVyIHtcXG4gICAgYm9yZGVyOiBzb2xpZCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICB9XFxuXFxuICBcIixcclxuICAgIFwiXFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGFjdGl2ZSA9IF9hLmFjdGl2ZTtcclxuICAgIHJldHVybiBhY3RpdmUgJiYgc3R5bGVkX2NvbXBvbmVudHNfMS5jc3ModGVtcGxhdGVPYmplY3RfMyB8fCAodGVtcGxhdGVPYmplY3RfMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIGJvcmRlcjogc29saWQgMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMyk7XFxuXFxuICAgICAgJjpob3ZlciB7XFxuICAgICAgICBib3JkZXI6IHNvbGlkIDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMzUpO1xcbiAgICAgIH1cXG4gICAgXCJdLCBbXCJcXG4gICAgICBib3JkZXI6IHNvbGlkIDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjMpO1xcblxcbiAgICAgICY6aG92ZXIge1xcbiAgICAgICAgYm9yZGVyOiBzb2xpZCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjM1KTtcXG4gICAgICB9XFxuICAgIFwiXSkpKTtcclxufSk7XHJcbmV4cG9ydHMuUmFuZ2UgPSBzdHlsZWRfY29tcG9uZW50c18xLmRlZmF1bHQuaW5wdXQodGVtcGxhdGVPYmplY3RfNSB8fCAodGVtcGxhdGVPYmplY3RfNSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgd2lkdGg6IDEwMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcblwiXSwgW1wiXFxuICB3aWR0aDogMTAwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuXCJdKSkpO1xyXG5leHBvcnRzLlJvdW5kID0gc3R5bGVkX2NvbXBvbmVudHNfMS5kZWZhdWx0LnNwYW4odGVtcGxhdGVPYmplY3RfOCB8fCAodGVtcGxhdGVPYmplY3RfOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBib3JkZXI6IHNvbGlkIDFweCByZ2JhKDAsIDAsIDAsIDAuNSk7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiA2cHg7XFxuXFxuICAmOmxhc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICBcIiwgXCJcXG5cXG4gIFwiLCBcIlxcblwiXSwgW1wiXFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIGJvcmRlcjogc29saWQgMXB4IHJnYmEoMCwgMCwgMCwgMC41KTtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDZweDtcXG5cXG4gICY6bGFzdC1jaGlsZCB7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIFwiLFxyXG4gICAgXCJcXG5cXG4gIFwiLFxyXG4gICAgXCJcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgYWN0aXZlID0gX2EuYWN0aXZlO1xyXG4gICAgcmV0dXJuIGFjdGl2ZSAmJiBzdHlsZWRfY29tcG9uZW50c18xLmNzcyh0ZW1wbGF0ZU9iamVjdF82IHx8ICh0ZW1wbGF0ZU9iamVjdF82ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgYm9yZGVyOiAycHggc29saWQgI2Y5ZjlmOTtcXG4gICAgXCJdLCBbXCJcXG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAjZjlmOWY5O1xcbiAgICBcIl0pKSk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGNvbG9yID0gX2EuY29sb3I7XHJcbiAgICByZXR1cm4gY29sb3IgJiYgc3R5bGVkX2NvbXBvbmVudHNfMS5jc3ModGVtcGxhdGVPYmplY3RfNyB8fCAodGVtcGxhdGVPYmplY3RfNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIGJhY2tncm91bmQ6IFwiLCBcIjtcXG4gICAgXCJdLCBbXCJcXG4gICAgICBiYWNrZ3JvdW5kOiBcIiwgXCI7XFxuICAgIFwiXSkpLCBjb2xvcik7XHJcbn0pO1xyXG5leHBvcnRzLlNlcGFyYXRvciA9IHN0eWxlZF9jb21wb25lbnRzXzEuZGVmYXVsdC5kaXYodGVtcGxhdGVPYmplY3RfOSB8fCAodGVtcGxhdGVPYmplY3RfOSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgd2lkdGg6IDFweDtcXG4gIGhlaWdodDogNTAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgbWFyZ2luOiAwIDEwcHg7XFxuXCJdLCBbXCJcXG4gIHdpZHRoOiAxcHg7XFxuICBoZWlnaHQ6IDUwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gIG1hcmdpbjogMCAxMHB4O1xcblwiXSkpKTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEsIHRlbXBsYXRlT2JqZWN0XzIsIHRlbXBsYXRlT2JqZWN0XzMsIHRlbXBsYXRlT2JqZWN0XzQsIHRlbXBsYXRlT2JqZWN0XzUsIHRlbXBsYXRlT2JqZWN0XzYsIHRlbXBsYXRlT2JqZWN0XzcsIHRlbXBsYXRlT2JqZWN0XzgsIHRlbXBsYXRlT2JqZWN0Xzk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Toolbar/styled.tsx\n");

/***/ }),

/***/ "./src/index.tsx":
/*!***********************!*\
  !*** ./src/index.tsx ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimpleToolbar = exports.SimpleCanvas = void 0;\r\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nvar events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\r\nvar Painter_1 = __webpack_require__(/*! ./Painter */ \"./src/Painter/index.ts\");\r\nvar Toolbar_1 = __webpack_require__(/*! ./Toolbar */ \"./src/Toolbar/index.tsx\");\r\nvar _painter = new Painter_1.Painter();\r\nvar _eventEmitter = new events_1.EventEmitter();\r\nvar SimpleCanvas = function (_a) {\r\n    var _b = _a.width, width = _b === void 0 ? 500 : _b, _c = _a.height, height = _c === void 0 ? 600 : _c, _d = _a.onDraw, onDraw = _d === void 0 ? function () { } : _d;\r\n    var canvasRef = react_1.useRef(null);\r\n    react_1.useEffect(function () {\r\n        if (canvasRef.current) {\r\n            _painter.setTarget({ target: canvasRef.current, onDraw: onDraw });\r\n            _eventEmitter.emit(\"setTarget\");\r\n        }\r\n    }, [canvasRef]);\r\n    return (react_1.default.createElement(\"canvas\", { id: \"my-simple-canvas\", ref: canvasRef, width: width, height: height, style: { border: \"1px solid gray\" } }));\r\n};\r\nexports.SimpleCanvas = SimpleCanvas;\r\nvar SimpleToolbar = function (props) {\r\n    var _a = react_1.useState(false), show = _a[0], setShow = _a[1];\r\n    react_1.useEffect(function () {\r\n        _eventEmitter.once(\"setTarget\", function () { return setShow(true); });\r\n        return function () {\r\n            _eventEmitter.off(\"setTarget\", function () { return setShow(true); });\r\n        };\r\n    }, []);\r\n    return show && react_1.default.createElement(Toolbar_1.Toolbar, __assign({ painter: _painter }, props));\r\n};\r\nexports.SimpleToolbar = SimpleToolbar;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHN4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vc3JjL2luZGV4LnRzeD9iZDdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXHJcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2ltcGxlVG9vbGJhciA9IGV4cG9ydHMuU2ltcGxlQ2FudmFzID0gdm9pZCAwO1xyXG52YXIgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xyXG52YXIgUGFpbnRlcl8xID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcclxudmFyIFRvb2xiYXJfMSA9IHJlcXVpcmUoXCIuL1Rvb2xiYXJcIik7XHJcbnZhciBfcGFpbnRlciA9IG5ldyBQYWludGVyXzEuUGFpbnRlcigpO1xyXG52YXIgX2V2ZW50RW1pdHRlciA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcclxudmFyIFNpbXBsZUNhbnZhcyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIF9iID0gX2Eud2lkdGgsIHdpZHRoID0gX2IgPT09IHZvaWQgMCA/IDUwMCA6IF9iLCBfYyA9IF9hLmhlaWdodCwgaGVpZ2h0ID0gX2MgPT09IHZvaWQgMCA/IDYwMCA6IF9jLCBfZCA9IF9hLm9uRHJhdywgb25EcmF3ID0gX2QgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHsgfSA6IF9kO1xyXG4gICAgdmFyIGNhbnZhc1JlZiA9IHJlYWN0XzEudXNlUmVmKG51bGwpO1xyXG4gICAgcmVhY3RfMS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjYW52YXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBfcGFpbnRlci5zZXRUYXJnZXQoeyB0YXJnZXQ6IGNhbnZhc1JlZi5jdXJyZW50LCBvbkRyYXc6IG9uRHJhdyB9KTtcclxuICAgICAgICAgICAgX2V2ZW50RW1pdHRlci5lbWl0KFwic2V0VGFyZ2V0XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtjYW52YXNSZWZdKTtcclxuICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwgeyBpZDogXCJteS1zaW1wbGUtY2FudmFzXCIsIHJlZjogY2FudmFzUmVmLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzdHlsZTogeyBib3JkZXI6IFwiMXB4IHNvbGlkIGdyYXlcIiB9IH0pKTtcclxufTtcclxuZXhwb3J0cy5TaW1wbGVDYW52YXMgPSBTaW1wbGVDYW52YXM7XHJcbnZhciBTaW1wbGVUb29sYmFyID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICB2YXIgX2EgPSByZWFjdF8xLnVzZVN0YXRlKGZhbHNlKSwgc2hvdyA9IF9hWzBdLCBzZXRTaG93ID0gX2FbMV07XHJcbiAgICByZWFjdF8xLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2V2ZW50RW1pdHRlci5vbmNlKFwic2V0VGFyZ2V0XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFNob3codHJ1ZSk7IH0pO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9ldmVudEVtaXR0ZXIub2ZmKFwic2V0VGFyZ2V0XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFNob3codHJ1ZSk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4gc2hvdyAmJiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChUb29sYmFyXzEuVG9vbGJhciwgX19hc3NpZ24oeyBwYWludGVyOiBfcGFpbnRlciB9LCBwcm9wcykpO1xyXG59O1xyXG5leHBvcnRzLlNpbXBsZVRvb2xiYXIgPSBTaW1wbGVUb29sYmFyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.tsx\n");

/***/ }),

/***/ "./src/lib/color.ts":
/*!**************************!*\
  !*** ./src/lib/color.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.paletteColor = exports.color = void 0;\r\nexports.color = {\r\n    white: \"#ffffff\",\r\n    black: \"#000000\",\r\n    gray70: \"#424242\",\r\n    gray65: \"#484848\",\r\n    gray50: \"#999999\",\r\n    gray40: \"#929291\",\r\n    green70: \"#22a622\",\r\n    green50: \"#55b955\",\r\n};\r\nexports.paletteColor = [\"#f03434\", \"#f9690e\", \"#ffff7e\", \"#29f1c3\", \"#22a7f0\", \"#9f5afd\", \"#8c14fc\"];\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL2NvbG9yLnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vc3JjL2xpYi9jb2xvci50cz85Zjg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMucGFsZXR0ZUNvbG9yID0gZXhwb3J0cy5jb2xvciA9IHZvaWQgMDtcclxuZXhwb3J0cy5jb2xvciA9IHtcclxuICAgIHdoaXRlOiBcIiNmZmZmZmZcIixcclxuICAgIGJsYWNrOiBcIiMwMDAwMDBcIixcclxuICAgIGdyYXk3MDogXCIjNDI0MjQyXCIsXHJcbiAgICBncmF5NjU6IFwiIzQ4NDg0OFwiLFxyXG4gICAgZ3JheTUwOiBcIiM5OTk5OTlcIixcclxuICAgIGdyYXk0MDogXCIjOTI5MjkxXCIsXHJcbiAgICBncmVlbjcwOiBcIiMyMmE2MjJcIixcclxuICAgIGdyZWVuNTA6IFwiIzU1Yjk1NVwiLFxyXG59O1xyXG5leHBvcnRzLnBhbGV0dGVDb2xvciA9IFtcIiNmMDM0MzRcIiwgXCIjZjk2OTBlXCIsIFwiI2ZmZmY3ZVwiLCBcIiMyOWYxYzNcIiwgXCIjMjJhN2YwXCIsIFwiIzlmNWFmZFwiLCBcIiM4YzE0ZmNcIl07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/lib/color.ts\n");

/***/ }),

/***/ "./src/lib/storage.ts":
/*!****************************!*\
  !*** ./src/lib/storage.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getFigures = exports.getDrawOn = exports.storage = void 0;\r\nvar ROOT_KEY = \"painter\";\r\nvar Storage = /** @class */ (function () {\r\n    function Storage() {\r\n        this._items = JSON.parse(sessionStorage.getItem(ROOT_KEY) || JSON.stringify({ log: [] }));\r\n    }\r\n    Storage.prototype.get = function (key) {\r\n        return this._items[key];\r\n    };\r\n    Storage.prototype.all = function () {\r\n        return this._items;\r\n    };\r\n    Storage.prototype.set = function (key, value) {\r\n        this._items[key] = value;\r\n        this._save();\r\n    };\r\n    Storage.prototype.remove = function (key) {\r\n        delete this._items[key];\r\n        this._save();\r\n    };\r\n    Storage.prototype._save = function () {\r\n        sessionStorage.setItem(ROOT_KEY, JSON.stringify(this._items));\r\n    };\r\n    Storage.prototype.clear = function () {\r\n        this._items = { log: [] };\r\n        this._save();\r\n    };\r\n    return Storage;\r\n}());\r\nexports.storage = new Storage();\r\nvar getDrawOn = function () {\r\n    return exports.storage.get(\"drawOn\") || false;\r\n};\r\nexports.getDrawOn = getDrawOn;\r\nvar getFigures = function () {\r\n    return exports.storage.get(\"figures\") || [];\r\n};\r\nexports.getFigures = getFigures;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL3N0b3JhZ2UudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vc3JjL2xpYi9zdG9yYWdlLnRzPzY0MDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5nZXRGaWd1cmVzID0gZXhwb3J0cy5nZXREcmF3T24gPSBleHBvcnRzLnN0b3JhZ2UgPSB2b2lkIDA7XHJcbnZhciBST09UX0tFWSA9IFwicGFpbnRlclwiO1xyXG52YXIgU3RvcmFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0b3JhZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSBKU09OLnBhcnNlKHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUk9PVF9LRVkpIHx8IEpTT04uc3RyaW5naWZ5KHsgbG9nOiBbXSB9KSk7XHJcbiAgICB9XHJcbiAgICBTdG9yYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW2tleV07XHJcbiAgICB9O1xyXG4gICAgU3RvcmFnZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcztcclxuICAgIH07XHJcbiAgICBTdG9yYWdlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2l0ZW1zW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9zYXZlKCk7XHJcbiAgICB9O1xyXG4gICAgU3RvcmFnZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pdGVtc1trZXldO1xyXG4gICAgICAgIHRoaXMuX3NhdmUoKTtcclxuICAgIH07XHJcbiAgICBTdG9yYWdlLnByb3RvdHlwZS5fc2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFJPT1RfS0VZLCBKU09OLnN0cmluZ2lmeSh0aGlzLl9pdGVtcykpO1xyXG4gICAgfTtcclxuICAgIFN0b3JhZ2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2l0ZW1zID0geyBsb2c6IFtdIH07XHJcbiAgICAgICAgdGhpcy5fc2F2ZSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdG9yYWdlO1xyXG59KCkpO1xyXG5leHBvcnRzLnN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xyXG52YXIgZ2V0RHJhd09uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGV4cG9ydHMuc3RvcmFnZS5nZXQoXCJkcmF3T25cIikgfHwgZmFsc2U7XHJcbn07XHJcbmV4cG9ydHMuZ2V0RHJhd09uID0gZ2V0RHJhd09uO1xyXG52YXIgZ2V0RmlndXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBleHBvcnRzLnN0b3JhZ2UuZ2V0KFwiZmlndXJlc1wiKSB8fCBbXTtcclxufTtcclxuZXhwb3J0cy5nZXRGaWd1cmVzID0gZ2V0RmlndXJlcztcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/storage.ts\n");

/***/ }),

/***/ "./src/images/paint-brush.png":
/*!************************************!*\
  !*** ./src/images/paint-brush.png ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAABuwAAAbsBOuzj4gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAatSURBVHic5Zp7bFvVHcc/P9/ra+fRR1KakocLzdIkTR/iNaSwRVoK0tgYsHViHUqnuiQTmjS6aRuigmolIhNsYkIjA23VOpg2YMShW2EIrS/aqlRDU0BjUBValo40y5o+YietnYfjsz+ykFzH13Hs69hJv//5fK/v+X2+Pvec63OvKKW4kuXIdAGZ1hUfgJ7pAmZL8vuzebjctTgoQIWPqXuWdMMVMgKk3X83btdJhH0o2kA/LS9ffBJA5vskKL5AI7CTyT92JAL9/aDrf5jXAYiv/7ugngbk08Zx+HAYNG1w3l4C4gs8CKoVK3gAFXHNywCkvX8H8DNTYzQ8gDhC824VkPbAEygeMjXGggfQ9afnzRwgILT5f4HIAybDCt7l+ru6r+zmeRGANONgVeDXCE0mwwreMN5XjZ61MA+WQfGhIf7nUbLJZFjDn6TRU60gAnP8Rkh24oTAywnDO/VPOOOpGYeHOTwC5A1cXPK3g3zFZFjCO3vQI+XKe+3g5OY5uQrIX3pyCeXuAbnNZFjP9ucZzqlUTUsHidKcGwHy6vkFDBmvg6ozGZbwzj6cC8uVd7E/1vnm1BwgLwYKGHLuTxxeG2B0pNoKHubQJSAvDVyFk33AdSbDCl7TgujGavXtkt54550TAcjuYDH66H6QGpOhlBX8IC5tndpc0jXdubM+APnjRQ+adgBkpclQCgKBGPCOYfLcN6qGqz9O5PxZHYDsDpSjaQeBa0yGNfwILvctquHq44n2kbWToLwyUM0oR0gU3uEYRXevV5uLO2bST1aOAPH1rQXHfqDIZFjBiyOCy/Ul5S0+OtO+sm4EiC9wIzgOkSi8wxHBpW9Q3pJ9yfSXVQFI+8AtwAGg0GRYwovC0DepLZ49yfaZNZeAtPnrEXkNyDMZ8eBd7iblLXkplX6zYgSIr/92RF4nUXgBXMb3lLfkt6n2nfEApM3/VVB7gByTYQUP4M7ZprxlrXb0n9EApL3/m4j4AMNkxIV3tyhvyU9tqyFT/wbF5/eC7CL6R4gP/5TaUvoDW+vIRADiC3wHeIbJe/YwHfxOtaX0frtrmfVLQNr9PwSeZSbwOTkvpAMeZjmAhmdf3Xf9QOeTU4x48C7Xn5W3ZNNUwx7N2n3Apl/+6di6y5/Urhk4DcC7+eVjRlx4Y6+6r+xr6axrVuaAza2736kJdl0//jmC4Cuq4928FdbwhnFUNXrqphr2Kq0BNIPj362v/LMqeKYm2hsOj7I3XMTRotqpXzSMDtXouSlthU1S2gL4hu+4sajng+MVof98JtoLh8OcPHGCwcEQPVX1HCn9woTpdH6gmpavSUtRMZSWAO7a2ZFbHDp1onzwv55obxw+FAqOFSAyEYLTOEWTp2ryg4t0y/ZV4MsvvL2wdPDkx5bwH07AAyilKP7wTW7oe6+PRZ7VswkPNq8Ct+/6a2HFwPmPPEPnl0R7n8IHg1O+py0uiiwdCVeoexi2s55EZFsAt/3mwLKaS+dOlA5dWBztxYPXFy1RXSs+X3bk4Q0X7aplJrIlgDt2HbxmzUD3+8XDffnRXlz4BQWqc+XNlce2beixo45klEQAzQbntLuAm0BuQElo66qC6sC/Qvmd3ZrpyLjw+YtU18rPXXds272nkqzdFs1sFbjw2GdRjudQrI5ln+7WeOMtN/2XJC68M28B3ZX1tW8+svFvSVdukxIP4NxPtgEtgBbvsOERwbfXyf6DHxGMBZ+TR1fVrV88vH3j3iTqtV2JLYO9LY8CjzMNPIChD7Gx7i3yc2IMe3cuXRW3fj1b4CGRAHpbHkVkR0JnU8Nw+R10AjzUOGqydJebM5XrvYd3bNydTKHpUvwAkoAncgmAsiW95OWOWbrhonvV+q2Hf3zv71IpNh2yDiAF+P83sq5S0JwG3TX1Dx/a3mDLJqbdih1AyvBjWlWh0VNd/8Sh7d96PJUi06mpq4BN8ACdwarWFWt/tTXFGtMq8wiwER5gRdHoU6kUNxuaGAE2w6Plh7j2tdzUS0yvxkaA3fAIaIU/Sr289EvU2cdshgecSztY3jYrW1qpygGcBWLsSkYpUXh92Xs4ytK+mWmXxuaACy3rGRUfEvVcflyJwIsGzrJdeJ5vsj4o+zQxCfY3FzKkPwg8wOTH1NPCO0Av6MS54H5KnkvqLY1Maup9wNnmIjStASV3okbquNyhT4UXcLiG0Ba+jfOqRyh+Zsbv5mSL4v8d7v3+MoZCtWjhlUTCy4lELiPuf5C38CiFP5/2JcS5oDn3srTdyvgbIpnWFR/A/wDVzEEKHSG/HwAAAABJRU5ErkJggg==\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW1hZ2VzL3BhaW50LWJydXNoLnBuZy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1zaW1wbGUtY2FudmFzLy4vc3JjL2ltYWdlcy9wYWludC1icnVzaC5wbmc/ZmRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRUFBQUFCQUNBWUFBQUNxYVhIZUFBQUFCSE5DU1ZRSUNBZ0lmQWhraUFBQUFBbHdTRmx6QUFBQnV3QUFBYnNCT3V6ajRnQUFBQmwwUlZoMFUyOW1kSGRoY21VQWQzZDNMbWx1YTNOallYQmxMbTl5WjV2dVBCb0FBQWF0U1VSQlZIaWM1WnA3YkZ2VkhjYy9QOS9yYStmUlIxS2Frb2NMemRJa1RSL2lOYVN3UlZvSzB0Z1lzSFZpSFVxbnVpUVRtalM2YVJ1aWdtb2xJaE5zWWtJakEyM1ZPcGcyWU1TaFcyRUlyUy9hcWxSRFUwQmpVQlZhbG80MHk1bytZaWV0bllmanN6K3lrRnpIMTNIczY5aEp2Ly81ZksvditYMitQdmVjNjNPdktLVzRrdVhJZEFHWjFoVWZnSjdwQW1aTDh2dXplYmpjdFRnb1FJV1BxWHVXZE1NVk1nS2szWDgzYnRkSmhIMG8ya0EvTFM5ZmZCSkE1dnNrS0w1QUk3Q1R5VDkySkFMOS9hRHJmNWpYQVlpdi83dWduZ2JrMDhaeCtIQVlORzF3M2w0QzRnczhDS29WSzNnQUZYSE55d0Nrdlg4SDhETlRZelE4Z0RoQzgyNFZrUGJBRXlnZU1qWEdnZ2ZROWFmbnpSd2dJTFQ1ZjRISUF5YkRDdDdsK3J1NnIrem1lUkdBTk9OZ1ZlRFhDRTBtd3dyZU1ONVhqWjYxTUErV1FmR2hJZjduVWJMSlpGakRuNlRSVTYwZ0FuUDhSa2gyNG9UQXl3bkRPL1ZQT09PcEdZZUhPVHdDNUExY1hQSzNnM3pGWkZqQ08zdlFJK1hLZSszZzVPWTV1UXJJWDNweUNlWHVBYm5OWkZqUDl1Y1p6cWxVVFVzSGlkS2NHd0h5NnZrRkRCbXZnNm96R1pid3pqNmNDOHVWZDdFLzF2bm0xQndnTHdZS0dITHVUeHhlRzJCMHBOb0tIdWJRSlNBdkRWeUZrMzNBZFNiRENsN1RndWpHYXZYdGt0NTQ1NTBUQWNqdVlESDY2SDZRR3BPaGxCWDhJQzV0bmRwYzBqWGR1Yk0rQVBualJRK2FkZ0JrcGNsUUNnS0JHUENPWWZMY042cUdxejlPNVB4WkhZRHNEcFNqYVFlQmEweUdOZndJTHZjdHF1SHE0NG4ya2JXVG9Md3lVTTBvUjBnVTN1RVlSWGV2VjV1TE8yYlNUMWFPQVBIMXJRWEhmcURJWkZqQml5T0N5L1VsNVMwK090TytzbTRFaUM5d0l6Z09rU2k4d3hIQnBXOVEzcEo5eWZTWFZRRkkrOEF0d0FHZzBHUll3b3ZDMERlcExaNDl5ZmFaTlplQXRQbnJFWGtOeURNWjhlQmQ3aWJsTFhrcGxYNnpZZ1NJci85MlJGNG5VWGdCWE1iM2xMZmt0Nm4ybmZFQXBNMy9WVkI3Z0J5VFlRVVA0TTdacHJ4bHJYYjBuOUVBcEwzL200ajRBTU5reElWM3R5aHZ5VTl0cXlGVC93YkY1L2VDN0NMNlI0Z1AvNVRhVXZvRFcrdklSQURpQzN3SGVJYkplL1l3SGZ4T3RhWDBmcnRybWZWTFFOcjlQd1NlWlNid09Ua3ZwQU1lWmptQWhtZGYzWGY5UU9lVFU0eDQ4QzdYbjVXM1pOTlV3eDdOMm4zQXBsLys2ZGk2eTUvVXJoazREY0M3K2VWalJseDRZNis2cit4cjZheHJWdWFBemEyNzM2a0pkbDAvL2ptQzRDdXE0OTI4RmRid2huRlVOWHJxcGhyMktxMEJOSVBqMzYydi9MTXFlS1ltMmhzT2o3STNYTVRSb3RxcFh6U01EdFhvdVNsdGhVMVMyZ0w0aHUrNHNham5nK01Wb2Y5OEp0b0xoOE9jUEhHQ3djRVFQVlgxSENuOXdvVHBkSDZnbXBhdlNVdFJNWlNXQU83YTJaRmJIRHAxb256d3Y1NW9ieHcrRkFxT0ZTQXlFWUxUT0VXVHAycnlnNHQweS9aVjRNc3Z2TDJ3ZFBEa3g1YndIMDdBQXlpbEtQN3dUVzdvZTYrUFJaN1Zzd2tQTnE4Q3QrLzZhMkhGd1BtUFBFUG5sMFI3bjhJSGcxTytweTB1aWl3ZENWZW9leGkyczU1RVpGc0F0LzNtd0xLYVMrZE9sQTVkV0J6dHhZUFhGeTFSWFNzK1gzYms0UTBYN2FwbEpySWxnRHQySGJ4bXpVRDMrOFhEZmZuUlhsejRCUVdxYytYTmxjZTJiZWl4bzQ1a2xFUUF6UWJudEx1QW0wQnVRRWxvNjZxQzZzQy9Rdm1kM1pycHlMancrWXRVMThyUFhYZHMyNzJua3F6ZEZzMXNGYmp3MkdkUmp1ZFFySTVsbis3V2VPTXROLzJYSkM2OE0yOEIzWlgxdFc4K3N2RnZTVmR1a3hJUDROeFB0Z0V0Z0JidnNPRVJ3YmZYeWY2REh4R01CWitUUjFmVnJWODh2SDNqM2lUcXRWMkpMWU85TFk4Q2p6TU5QSUNoRDdHeDdpM3ljMklNZTNjdVhSVzNmajFiNENHUkFIcGJIa1ZrUjBKblU4TncrUjEwQWp6VU9HcXlkSmViTTVYcnZZZDNiTnlkVEtIcFV2d0Frb0FuY2dtQXNpVzk1T1dPV2JyaG9udlYrcTJIZjN6djcxSXBOaDJ5RGlBRitQODNzcTVTMEp3RzNUWDFEeC9hM21ETEpxYmRpaDFBeXZCaldsV2gwVk5kLzhTaDdkOTZQSlVpMDZtcHE0Qk44QUNkd2FyV0ZXdC90VFhGR3RNcTh3aXdFUjVnUmRIb1U2a1VOeHVhR0FFMnc2UGxoN2oydGR6VVMweXZ4a2FBM2ZBSWFJVS9TcjI4OUV2VTJjZHNoZ2VjU3p0WTNqWXJXMXFweWdHY0JXTHNTa1lwVVhoOTJYczR5dEsrbVdtWHh1YUFDeTNyR1JVZkV2VmNmbHlKd0lzR3pySmRlSjV2c2o0byt6UXhDZlkzRnpLa1B3Zzh3T1RIMU5QQ08wQXY2TVM1NEg1S25rdnFMWTFNYXVwOXdObm1JalN0QVNWM29rYnF1TnloVDRVWGNMaUcwQmEramZPcVJ5aCtac2J2NW1TTDR2OGQ3djMrTW9aQ3RXamhsVVRDeTRsRUxpUHVmNUMzOENpRlA1LzJKY1M1b0RuM3NyVGR5dmdiSXBuV0ZSL0Evd0RWekVFS0hTRy9Id0FBQUFCSlJVNUVya0pnZ2c9PVwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/images/paint-brush.png\n");

/***/ }),

/***/ "./node_modules/webpack/hot sync ^\\.\\/log$":
/*!***************************************************************!*\
  !*** ./node_modules/webpack/hot/ sync nonrecursive ^\.\/log$ ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./log": "./node_modules/webpack/hot/log.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/webpack/hot sync ^\\.\\/log$";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("476b8fe6cdd465cf6c4c")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "my-simple-canvas:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			};
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							},
/******/ 							[])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdatemy_simple_canvas"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./index.js");
/******/ 	__webpack_require__("./node_modules/webpack-dev-server/client/index.js?http://localhost:8080");
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/webpack/hot/dev-server.js");
/******/ 	
/******/ })()
;